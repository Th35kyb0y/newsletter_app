{"ast":null,"code":"/**\n * TinyMCE version 6.0.2 (2022-04-27)\n */\n(function () {\n  'use strict';\n\n  var typeOf$1 = function (x) {\n    if (x === null) {\n      return 'null';\n    }\n\n    if (x === undefined) {\n      return 'undefined';\n    }\n\n    var t = typeof x;\n\n    if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {\n      return 'array';\n    }\n\n    if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {\n      return 'string';\n    }\n\n    return t;\n  };\n\n  var isEquatableType = function (x) {\n    return ['undefined', 'boolean', 'number', 'string', 'function', 'xml', 'null'].indexOf(x) !== -1;\n  };\n\n  var sort$1 = function (xs, compareFn) {\n    var clone = Array.prototype.slice.call(xs);\n    return clone.sort(compareFn);\n  };\n\n  var contramap = function (eqa, f) {\n    return eq$2(function (x, y) {\n      return eqa.eq(f(x), f(y));\n    });\n  };\n\n  var eq$2 = function (f) {\n    return {\n      eq: f\n    };\n  };\n\n  var tripleEq = eq$2(function (x, y) {\n    return x === y;\n  });\n  var eqString = tripleEq;\n\n  var eqArray = function (eqa) {\n    return eq$2(function (x, y) {\n      if (x.length !== y.length) {\n        return false;\n      }\n\n      var len = x.length;\n\n      for (var i = 0; i < len; i++) {\n        if (!eqa.eq(x[i], y[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  };\n\n  var eqSortedArray = function (eqa, compareFn) {\n    return contramap(eqArray(eqa), function (xs) {\n      return sort$1(xs, compareFn);\n    });\n  };\n\n  var eqRecord = function (eqa) {\n    return eq$2(function (x, y) {\n      var kx = Object.keys(x);\n      var ky = Object.keys(y);\n\n      if (!eqSortedArray(eqString).eq(kx, ky)) {\n        return false;\n      }\n\n      var len = kx.length;\n\n      for (var i = 0; i < len; i++) {\n        var q = kx[i];\n\n        if (!eqa.eq(x[q], y[q])) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  };\n\n  var eqAny = eq$2(function (x, y) {\n    if (x === y) {\n      return true;\n    }\n\n    var tx = typeOf$1(x);\n    var ty = typeOf$1(y);\n\n    if (tx !== ty) {\n      return false;\n    }\n\n    if (isEquatableType(tx)) {\n      return x === y;\n    } else if (tx === 'array') {\n      return eqArray(eqAny).eq(x, y);\n    } else if (tx === 'object') {\n      return eqRecord(eqAny).eq(x, y);\n    }\n\n    return false;\n  });\n  const getPrototypeOf$1 = Object.getPrototypeOf;\n\n  const hasProto = (v, constructor, predicate) => {\n    var _a;\n\n    if (predicate(v, constructor.prototype)) {\n      return true;\n    } else {\n      return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n    }\n  };\n\n  const typeOf = x => {\n    const t = typeof x;\n\n    if (x === null) {\n      return 'null';\n    } else if (t === 'object' && Array.isArray(x)) {\n      return 'array';\n    } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n      return 'string';\n    } else {\n      return t;\n    }\n  };\n\n  const isType$1 = type => value => typeOf(value) === type;\n\n  const isSimpleType = type => value => typeof value === type;\n\n  const eq$1 = t => a => t === a;\n\n  const is$4 = (value, constructor) => isObject(value) && hasProto(value, constructor, (o, proto) => getPrototypeOf$1(o) === proto);\n\n  const isString = isType$1('string');\n  const isObject = isType$1('object');\n\n  const isPlainObject = value => is$4(value, Object);\n\n  const isArray$1 = isType$1('array');\n  const isNull = eq$1(null);\n  const isBoolean = isSimpleType('boolean');\n  const isUndefined = eq$1(undefined);\n\n  const isNullable = a => a === null || a === undefined;\n\n  const isNonNullable = a => !isNullable(a);\n\n  const isFunction = isSimpleType('function');\n  const isNumber = isSimpleType('number');\n\n  const isArrayOf = (value, pred) => {\n    if (isArray$1(value)) {\n      for (let i = 0, len = value.length; i < len; ++i) {\n        if (!pred(value[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  const noop = () => {};\n\n  const compose = (fa, fb) => {\n    return function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return fa(fb.apply(null, args));\n    };\n  };\n\n  const compose1 = (fbc, fab) => a => fbc(fab(a));\n\n  const constant = value => {\n    return () => {\n      return value;\n    };\n  };\n\n  const identity = x => {\n    return x;\n  };\n\n  const tripleEquals = (a, b) => {\n    return a === b;\n  };\n\n  function curry(fn) {\n    for (var _len4 = arguments.length, initialArgs = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      initialArgs[_key4 - 1] = arguments[_key4];\n    }\n\n    return function () {\n      for (var _len5 = arguments.length, restArgs = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        restArgs[_key5] = arguments[_key5];\n      }\n\n      const all = initialArgs.concat(restArgs);\n      return fn.apply(null, all);\n    };\n  }\n\n  const not = f => t => !f(t);\n\n  const die = msg => {\n    return () => {\n      throw new Error(msg);\n    };\n  };\n\n  const apply$1 = f => {\n    return f();\n  };\n\n  const call = f => {\n    f();\n  };\n\n  const never = constant(false);\n  const always = constant(true);\n\n  class Optional {\n    constructor(tag, value) {\n      this.tag = tag;\n      this.value = value;\n    }\n\n    static some(value) {\n      return new Optional(true, value);\n    }\n\n    static none() {\n      return Optional.singletonNone;\n    }\n\n    fold(onNone, onSome) {\n      if (this.tag) {\n        return onSome(this.value);\n      } else {\n        return onNone();\n      }\n    }\n\n    isSome() {\n      return this.tag;\n    }\n\n    isNone() {\n      return !this.tag;\n    }\n\n    map(mapper) {\n      if (this.tag) {\n        return Optional.some(mapper(this.value));\n      } else {\n        return Optional.none();\n      }\n    }\n\n    bind(binder) {\n      if (this.tag) {\n        return binder(this.value);\n      } else {\n        return Optional.none();\n      }\n    }\n\n    exists(predicate) {\n      return this.tag && predicate(this.value);\n    }\n\n    forall(predicate) {\n      return !this.tag || predicate(this.value);\n    }\n\n    filter(predicate) {\n      if (!this.tag || predicate(this.value)) {\n        return this;\n      } else {\n        return Optional.none();\n      }\n    }\n\n    getOr(replacement) {\n      return this.tag ? this.value : replacement;\n    }\n\n    or(replacement) {\n      return this.tag ? this : replacement;\n    }\n\n    getOrThunk(thunk) {\n      return this.tag ? this.value : thunk();\n    }\n\n    orThunk(thunk) {\n      return this.tag ? this : thunk();\n    }\n\n    getOrDie(message) {\n      if (!this.tag) {\n        throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n      } else {\n        return this.value;\n      }\n    }\n\n    static from(value) {\n      return isNonNullable(value) ? Optional.some(value) : Optional.none();\n    }\n\n    getOrNull() {\n      return this.tag ? this.value : null;\n    }\n\n    getOrUndefined() {\n      return this.value;\n    }\n\n    each(worker) {\n      if (this.tag) {\n        worker(this.value);\n      }\n    }\n\n    toArray() {\n      return this.tag ? [this.value] : [];\n    }\n\n    toString() {\n      return this.tag ? `some(${this.value})` : 'none()';\n    }\n\n  }\n\n  Optional.singletonNone = new Optional(false);\n  const nativeSlice = Array.prototype.slice;\n  const nativeIndexOf = Array.prototype.indexOf;\n  const nativePush = Array.prototype.push;\n\n  const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n\n  const indexOf$1 = (xs, x) => {\n    const r = rawIndexOf(xs, x);\n    return r === -1 ? Optional.none() : Optional.some(r);\n  };\n\n  const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;\n\n  const exists = (xs, pred) => {\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n\n      if (pred(x, i)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  const map$3 = (xs, f) => {\n    const len = xs.length;\n    const r = new Array(len);\n\n    for (let i = 0; i < len; i++) {\n      const x = xs[i];\n      r[i] = f(x, i);\n    }\n\n    return r;\n  };\n\n  const each$g = (xs, f) => {\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n      f(x, i);\n    }\n  };\n\n  const eachr = (xs, f) => {\n    for (let i = xs.length - 1; i >= 0; i--) {\n      const x = xs[i];\n      f(x, i);\n    }\n  };\n\n  const partition$2 = (xs, pred) => {\n    const pass = [];\n    const fail = [];\n\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n      const arr = pred(x, i) ? pass : fail;\n      arr.push(x);\n    }\n\n    return {\n      pass,\n      fail\n    };\n  };\n\n  const filter$6 = (xs, pred) => {\n    const r = [];\n\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n\n      if (pred(x, i)) {\n        r.push(x);\n      }\n    }\n\n    return r;\n  };\n\n  const foldr = (xs, f, acc) => {\n    eachr(xs, (x, i) => {\n      acc = f(acc, x, i);\n    });\n    return acc;\n  };\n\n  const foldl = (xs, f, acc) => {\n    each$g(xs, (x, i) => {\n      acc = f(acc, x, i);\n    });\n    return acc;\n  };\n\n  const findUntil$1 = (xs, pred, until) => {\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n\n      if (pred(x, i)) {\n        return Optional.some(x);\n      } else if (until(x, i)) {\n        break;\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const find$2 = (xs, pred) => {\n    return findUntil$1(xs, pred, never);\n  };\n\n  const findIndex$2 = (xs, pred) => {\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n\n      if (pred(x, i)) {\n        return Optional.some(i);\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const flatten = xs => {\n    const r = [];\n\n    for (let i = 0, len = xs.length; i < len; ++i) {\n      if (!isArray$1(xs[i])) {\n        throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n      }\n\n      nativePush.apply(r, xs[i]);\n    }\n\n    return r;\n  };\n\n  const bind$3 = (xs, f) => flatten(map$3(xs, f));\n\n  const forall = (xs, pred) => {\n    for (let i = 0, len = xs.length; i < len; ++i) {\n      const x = xs[i];\n\n      if (pred(x, i) !== true) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  const reverse = xs => {\n    const r = nativeSlice.call(xs, 0);\n    r.reverse();\n    return r;\n  };\n\n  const difference = (a1, a2) => filter$6(a1, x => !contains$2(a2, x));\n\n  const mapToObject = (xs, f) => {\n    const r = {};\n\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n      r[String(x)] = f(x, i);\n    }\n\n    return r;\n  };\n\n  const sort = (xs, comparator) => {\n    const copy = nativeSlice.call(xs, 0);\n    copy.sort(comparator);\n    return copy;\n  };\n\n  const get$b = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n\n  const head = xs => get$b(xs, 0);\n\n  const last$3 = xs => get$b(xs, xs.length - 1);\n\n  const from = isFunction(Array.from) ? Array.from : x => nativeSlice.call(x);\n\n  const findMap = (arr, f) => {\n    for (let i = 0; i < arr.length; i++) {\n      const r = f(arr[i], i);\n\n      if (r.isSome()) {\n        return r;\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const unique$1 = (xs, comparator) => {\n    const r = [];\n    const isDuplicated = isFunction(comparator) ? x => exists(r, i => comparator(i, x)) : x => contains$2(r, x);\n\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n\n      if (!isDuplicated(x)) {\n        r.push(x);\n      }\n    }\n\n    return r;\n  };\n\n  const keys = Object.keys;\n  const hasOwnProperty$2 = Object.hasOwnProperty;\n\n  const each$f = (obj, f) => {\n    const props = keys(obj);\n\n    for (let k = 0, len = props.length; k < len; k++) {\n      const i = props[k];\n      const x = obj[i];\n      f(x, i);\n    }\n  };\n\n  const map$2 = (obj, f) => {\n    return tupleMap(obj, (x, i) => ({\n      k: i,\n      v: f(x, i)\n    }));\n  };\n\n  const tupleMap = (obj, f) => {\n    const r = {};\n    each$f(obj, (x, i) => {\n      const tuple = f(x, i);\n      r[tuple.k] = tuple.v;\n    });\n    return r;\n  };\n\n  const objAcc = r => (x, i) => {\n    r[i] = x;\n  };\n\n  const internalFilter = (obj, pred, onTrue, onFalse) => {\n    const r = {};\n    each$f(obj, (x, i) => {\n      (pred(x, i) ? onTrue : onFalse)(x, i);\n    });\n    return r;\n  };\n\n  const bifilter = (obj, pred) => {\n    const t = {};\n    const f = {};\n    internalFilter(obj, pred, objAcc(t), objAcc(f));\n    return {\n      t,\n      f\n    };\n  };\n\n  const filter$5 = (obj, pred) => {\n    const t = {};\n    internalFilter(obj, pred, objAcc(t), noop);\n    return t;\n  };\n\n  const mapToArray = (obj, f) => {\n    const r = [];\n    each$f(obj, (value, name) => {\n      r.push(f(value, name));\n    });\n    return r;\n  };\n\n  const values = obj => {\n    return mapToArray(obj, identity);\n  };\n\n  const get$a = (obj, key) => {\n    return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();\n  };\n\n  const has$2 = (obj, key) => hasOwnProperty$2.call(obj, key);\n\n  const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;\n\n  const equal$1 = function (a1, a2) {\n    let eq = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : eqAny;\n    return eqRecord(eq).eq(a1, a2);\n  };\n\n  const stringArray = a => {\n    const all = {};\n    each$g(a, key => {\n      all[key] = {};\n    });\n    return keys(all);\n  };\n\n  const isArray = Array.isArray;\n\n  const toArray$1 = obj => {\n    if (!isArray(obj)) {\n      const array = [];\n\n      for (let i = 0, l = obj.length; i < l; i++) {\n        array[i] = obj[i];\n      }\n\n      return array;\n    } else {\n      return obj;\n    }\n  };\n\n  const each$e = (o, cb, s) => {\n    let n, l;\n\n    if (!o) {\n      return false;\n    }\n\n    s = s || o;\n\n    if (o.length !== undefined) {\n      for (n = 0, l = o.length; n < l; n++) {\n        if (cb.call(s, o[n], n, o) === false) {\n          return false;\n        }\n      }\n    } else {\n      for (n in o) {\n        if (has$2(o, n)) {\n          if (cb.call(s, o[n], n, o) === false) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  const map$1 = (array, callback) => {\n    const out = [];\n    each$e(array, (item, index) => {\n      out.push(callback(item, index, array));\n    });\n    return out;\n  };\n\n  const filter$4 = (a, f) => {\n    const o = [];\n    each$e(a, (v, index) => {\n      if (!f || f(v, index, a)) {\n        o.push(v);\n      }\n    });\n    return o;\n  };\n\n  const indexOf = (a, v) => {\n    if (a) {\n      for (let i = 0, l = a.length; i < l; i++) {\n        if (a[i] === v) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  };\n\n  const reduce = (collection, iteratee, accumulator, thisArg) => {\n    let acc = isUndefined(accumulator) ? collection[0] : accumulator;\n\n    for (let i = 0; i < collection.length; i++) {\n      acc = iteratee.call(thisArg, acc, collection[i], i);\n    }\n\n    return acc;\n  };\n\n  const findIndex$1 = (array, predicate, thisArg) => {\n    let i, l;\n\n    for (i = 0, l = array.length; i < l; i++) {\n      if (predicate.call(thisArg, array[i], i, array)) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  const last$2 = collection => collection[collection.length - 1];\n\n  const cached = f => {\n    let called = false;\n    let r;\n    return function () {\n      if (!called) {\n        called = true;\n\n        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n          args[_key6] = arguments[_key6];\n        }\n\n        r = f.apply(null, args);\n      }\n\n      return r;\n    };\n  };\n\n  const DeviceType = (os, browser, userAgent, mediaMatch) => {\n    const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;\n    const isiPhone = os.isiOS() && !isiPad;\n    const isMobile = os.isiOS() || os.isAndroid();\n    const isTouch = isMobile || mediaMatch('(pointer:coarse)');\n    const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');\n    const isPhone = isiPhone || isMobile && !isTablet;\n    const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;\n    const isDesktop = !isPhone && !isTablet && !iOSwebview;\n    return {\n      isiPad: constant(isiPad),\n      isiPhone: constant(isiPhone),\n      isTablet: constant(isTablet),\n      isPhone: constant(isPhone),\n      isTouch: constant(isTouch),\n      isAndroid: os.isAndroid,\n      isiOS: os.isiOS,\n      isWebView: constant(iOSwebview),\n      isDesktop: constant(isDesktop)\n    };\n  };\n\n  const firstMatch = (regexes, s) => {\n    for (let i = 0; i < regexes.length; i++) {\n      const x = regexes[i];\n\n      if (x.test(s)) {\n        return x;\n      }\n    }\n\n    return undefined;\n  };\n\n  const find$1 = (regexes, agent) => {\n    const r = firstMatch(regexes, agent);\n\n    if (!r) {\n      return {\n        major: 0,\n        minor: 0\n      };\n    }\n\n    const group = i => {\n      return Number(agent.replace(r, '$' + i));\n    };\n\n    return nu$3(group(1), group(2));\n  };\n\n  const detect$5 = (versionRegexes, agent) => {\n    const cleanedAgent = String(agent).toLowerCase();\n\n    if (versionRegexes.length === 0) {\n      return unknown$2();\n    }\n\n    return find$1(versionRegexes, cleanedAgent);\n  };\n\n  const unknown$2 = () => {\n    return nu$3(0, 0);\n  };\n\n  const nu$3 = (major, minor) => {\n    return {\n      major,\n      minor\n    };\n  };\n\n  const Version = {\n    nu: nu$3,\n    detect: detect$5,\n    unknown: unknown$2\n  };\n\n  const detectBrowser$1 = (browsers, userAgentData) => {\n    return findMap(userAgentData.brands, uaBrand => {\n      const lcBrand = uaBrand.brand.toLowerCase();\n      return find$2(browsers, browser => {\n        var _a;\n\n        return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());\n      }).map(info => ({\n        current: info.name,\n        version: Version.nu(parseInt(uaBrand.version, 10), 0)\n      }));\n    });\n  };\n\n  const detect$4 = (candidates, userAgent) => {\n    const agent = String(userAgent).toLowerCase();\n    return find$2(candidates, candidate => {\n      return candidate.search(agent);\n    });\n  };\n\n  const detectBrowser = (browsers, userAgent) => {\n    return detect$4(browsers, userAgent).map(browser => {\n      const version = Version.detect(browser.versionRegexes, userAgent);\n      return {\n        current: browser.name,\n        version\n      };\n    });\n  };\n\n  const detectOs = (oses, userAgent) => {\n    return detect$4(oses, userAgent).map(os => {\n      const version = Version.detect(os.versionRegexes, userAgent);\n      return {\n        current: os.name,\n        version\n      };\n    });\n  };\n\n  const removeFromStart = (str, numChars) => {\n    return str.substring(numChars);\n  };\n\n  const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;\n\n  const removeLeading = (str, prefix) => {\n    return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;\n  };\n\n  const contains$1 = (str, substr) => {\n    return str.indexOf(substr) !== -1;\n  };\n\n  const startsWith = (str, prefix) => {\n    return checkRange(str, prefix, 0);\n  };\n\n  const endsWith = (str, suffix) => {\n    return checkRange(str, suffix, str.length - suffix.length);\n  };\n\n  const blank = r => s => s.replace(r, '');\n\n  const trim$3 = blank(/^\\s+|\\s+$/g);\n  const lTrim = blank(/^\\s+/g);\n  const rTrim = blank(/\\s+$/g);\n\n  const isNotEmpty = s => s.length > 0;\n\n  const isEmpty$3 = s => !isNotEmpty(s);\n\n  const repeat = (s, count) => count <= 0 ? '' : new Array(count + 1).join(s);\n\n  const toInt = function (value) {\n    let radix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    const num = parseInt(value, radix);\n    return isNaN(num) ? Optional.none() : Optional.some(num);\n  };\n\n  const normalVersionRegex = /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/;\n\n  const checkContains = target => {\n    return uastring => {\n      return contains$1(uastring, target);\n    };\n  };\n\n  const browsers = [{\n    name: 'Edge',\n    versionRegexes: [/.*?edge\\/ ?([0-9]+)\\.([0-9]+)$/],\n    search: uastring => {\n      return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');\n    }\n  }, {\n    name: 'Chromium',\n    brand: 'Chromium',\n    versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/, normalVersionRegex],\n    search: uastring => {\n      return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');\n    }\n  }, {\n    name: 'IE',\n    versionRegexes: [/.*?msie\\ ?([0-9]+)\\.([0-9]+).*/, /.*?rv:([0-9]+)\\.([0-9]+).*/],\n    search: uastring => {\n      return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');\n    }\n  }, {\n    name: 'Opera',\n    versionRegexes: [normalVersionRegex, /.*?opera\\/([0-9]+)\\.([0-9]+).*/],\n    search: checkContains('opera')\n  }, {\n    name: 'Firefox',\n    versionRegexes: [/.*?firefox\\/\\ ?([0-9]+)\\.([0-9]+).*/],\n    search: checkContains('firefox')\n  }, {\n    name: 'Safari',\n    versionRegexes: [normalVersionRegex, /.*?cpu os ([0-9]+)_([0-9]+).*/],\n    search: uastring => {\n      return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');\n    }\n  }];\n  const oses = [{\n    name: 'Windows',\n    search: checkContains('win'),\n    versionRegexes: [/.*?windows\\ nt\\ ?([0-9]+)\\.([0-9]+).*/]\n  }, {\n    name: 'iOS',\n    search: uastring => {\n      return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');\n    },\n    versionRegexes: [/.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]\n  }, {\n    name: 'Android',\n    search: checkContains('android'),\n    versionRegexes: [/.*?android\\ ?([0-9]+)\\.([0-9]+).*/]\n  }, {\n    name: 'macOS',\n    search: checkContains('mac os x'),\n    versionRegexes: [/.*?mac\\ os\\ x\\ ?([0-9]+)_([0-9]+).*/]\n  }, {\n    name: 'Linux',\n    search: checkContains('linux'),\n    versionRegexes: []\n  }, {\n    name: 'Solaris',\n    search: checkContains('sunos'),\n    versionRegexes: []\n  }, {\n    name: 'FreeBSD',\n    search: checkContains('freebsd'),\n    versionRegexes: []\n  }, {\n    name: 'ChromeOS',\n    search: checkContains('cros'),\n    versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/]\n  }];\n  const PlatformInfo = {\n    browsers: constant(browsers),\n    oses: constant(oses)\n  };\n  const edge = 'Edge';\n  const chromium = 'Chromium';\n  const ie = 'IE';\n  const opera = 'Opera';\n  const firefox = 'Firefox';\n  const safari = 'Safari';\n\n  const unknown$1 = () => {\n    return nu$2({\n      current: undefined,\n      version: Version.unknown()\n    });\n  };\n\n  const nu$2 = info => {\n    const current = info.current;\n    const version = info.version;\n\n    const isBrowser = name => () => current === name;\n\n    return {\n      current,\n      version,\n      isEdge: isBrowser(edge),\n      isChromium: isBrowser(chromium),\n      isIE: isBrowser(ie),\n      isOpera: isBrowser(opera),\n      isFirefox: isBrowser(firefox),\n      isSafari: isBrowser(safari)\n    };\n  };\n\n  const Browser = {\n    unknown: unknown$1,\n    nu: nu$2,\n    edge: constant(edge),\n    chromium: constant(chromium),\n    ie: constant(ie),\n    opera: constant(opera),\n    firefox: constant(firefox),\n    safari: constant(safari)\n  };\n  const windows = 'Windows';\n  const ios = 'iOS';\n  const android = 'Android';\n  const linux = 'Linux';\n  const macos = 'macOS';\n  const solaris = 'Solaris';\n  const freebsd = 'FreeBSD';\n  const chromeos = 'ChromeOS';\n\n  const unknown = () => {\n    return nu$1({\n      current: undefined,\n      version: Version.unknown()\n    });\n  };\n\n  const nu$1 = info => {\n    const current = info.current;\n    const version = info.version;\n\n    const isOS = name => () => current === name;\n\n    return {\n      current,\n      version,\n      isWindows: isOS(windows),\n      isiOS: isOS(ios),\n      isAndroid: isOS(android),\n      isMacOS: isOS(macos),\n      isLinux: isOS(linux),\n      isSolaris: isOS(solaris),\n      isFreeBSD: isOS(freebsd),\n      isChromeOS: isOS(chromeos)\n    };\n  };\n\n  const OperatingSystem = {\n    unknown,\n    nu: nu$1,\n    windows: constant(windows),\n    ios: constant(ios),\n    android: constant(android),\n    linux: constant(linux),\n    macos: constant(macos),\n    solaris: constant(solaris),\n    freebsd: constant(freebsd),\n    chromeos: constant(chromeos)\n  };\n\n  const detect$3 = (userAgent, userAgentDataOpt, mediaMatch) => {\n    const browsers = PlatformInfo.browsers();\n    const oses = PlatformInfo.oses();\n    const browser = userAgentDataOpt.bind(userAgentData => detectBrowser$1(browsers, userAgentData)).orThunk(() => detectBrowser(browsers, userAgent)).fold(Browser.unknown, Browser.nu);\n    const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);\n    const deviceType = DeviceType(os, browser, userAgent, mediaMatch);\n    return {\n      browser,\n      os,\n      deviceType\n    };\n  };\n\n  const PlatformDetection = {\n    detect: detect$3\n  };\n\n  const mediaMatch = query => window.matchMedia(query).matches;\n\n  let platform$2 = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));\n\n  const detect$2 = () => platform$2();\n\n  const userAgent = navigator.userAgent;\n  const platform$1 = detect$2();\n  const browser$1 = platform$1.browser;\n  const os = platform$1.os;\n  const deviceType = platform$1.deviceType;\n  const windowsPhone = userAgent.indexOf('Windows Phone') !== -1;\n  const Env = {\n    transparentSrc: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',\n    documentMode: browser$1.isIE() ? document.documentMode || 7 : 10,\n    cacheSuffix: null,\n    container: null,\n    canHaveCSP: !browser$1.isIE(),\n    windowsPhone,\n    browser: {\n      current: browser$1.current,\n      version: browser$1.version,\n      isChromium: browser$1.isChromium,\n      isEdge: browser$1.isEdge,\n      isFirefox: browser$1.isFirefox,\n      isIE: browser$1.isIE,\n      isOpera: browser$1.isOpera,\n      isSafari: browser$1.isSafari\n    },\n    os: {\n      current: os.current,\n      version: os.version,\n      isAndroid: os.isAndroid,\n      isChromeOS: os.isChromeOS,\n      isFreeBSD: os.isFreeBSD,\n      isiOS: os.isiOS,\n      isLinux: os.isLinux,\n      isMacOS: os.isMacOS,\n      isSolaris: os.isSolaris,\n      isWindows: os.isWindows\n    },\n    deviceType: {\n      isDesktop: deviceType.isDesktop,\n      isiPad: deviceType.isiPad,\n      isiPhone: deviceType.isiPhone,\n      isPhone: deviceType.isPhone,\n      isTablet: deviceType.isTablet,\n      isTouch: deviceType.isTouch,\n      isWebView: deviceType.isWebView\n    }\n  };\n  const whiteSpaceRegExp$1 = /^\\s*|\\s*$/g;\n\n  const trim$2 = str => {\n    return str === null || str === undefined ? '' : ('' + str).replace(whiteSpaceRegExp$1, '');\n  };\n\n  const is$3 = (obj, type) => {\n    if (!type) {\n      return obj !== undefined;\n    }\n\n    if (type === 'array' && isArray(obj)) {\n      return true;\n    }\n\n    return typeof obj === type;\n  };\n\n  const makeMap$4 = (items, delim, map) => {\n    let i;\n    items = items || [];\n    delim = delim || ',';\n\n    if (typeof items === 'string') {\n      items = items.split(delim);\n    }\n\n    map = map || {};\n    i = items.length;\n\n    while (i--) {\n      map[items[i]] = {};\n    }\n\n    return map;\n  };\n\n  const hasOwnProperty$1 = has$2;\n\n  const extend$3 = function (obj) {\n    for (let i = 0; i < (arguments.length <= 1 ? 0 : arguments.length - 1); i++) {\n      const ext = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];\n\n      for (const name in ext) {\n        if (has$2(ext, name)) {\n          const value = ext[name];\n\n          if (value !== undefined) {\n            obj[name] = value;\n          }\n        }\n      }\n    }\n\n    return obj;\n  };\n\n  const walk$4 = function (o, f, n, s) {\n    s = s || this;\n\n    if (o) {\n      if (n) {\n        o = o[n];\n      }\n\n      each$e(o, (o, i) => {\n        if (f.call(s, o, i, n) === false) {\n          return false;\n        }\n\n        walk$4(o, f, n, s);\n      });\n    }\n  };\n\n  const resolve$2 = (n, o) => {\n    let i, l;\n    o = o || window;\n    n = n.split('.');\n\n    for (i = 0, l = n.length; i < l; i++) {\n      o = o[n[i]];\n\n      if (!o) {\n        break;\n      }\n    }\n\n    return o;\n  };\n\n  const explode$3 = (s, d) => {\n    if (!s || is$3(s, 'array')) {\n      return s;\n    }\n\n    return map$1(s.split(d || ','), trim$2);\n  };\n\n  const _addCacheSuffix = url => {\n    const cacheSuffix = Env.cacheSuffix;\n\n    if (cacheSuffix) {\n      url += (url.indexOf('?') === -1 ? '?' : '&') + cacheSuffix;\n    }\n\n    return url;\n  };\n\n  const Tools = {\n    trim: trim$2,\n    isArray: isArray,\n    is: is$3,\n    toArray: toArray$1,\n    makeMap: makeMap$4,\n    each: each$e,\n    map: map$1,\n    grep: filter$4,\n    inArray: indexOf,\n    hasOwn: hasOwnProperty$1,\n    extend: extend$3,\n    walk: walk$4,\n    resolve: resolve$2,\n    explode: explode$3,\n    _addCacheSuffix\n  };\n\n  const is$2 = function (lhs, rhs) {\n    let comparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : tripleEquals;\n    return lhs.exists(left => comparator(left, rhs));\n  };\n\n  const cat = arr => {\n    const r = [];\n\n    const push = x => {\n      r.push(x);\n    };\n\n    for (let i = 0; i < arr.length; i++) {\n      arr[i].each(push);\n    }\n\n    return r;\n  };\n\n  const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\n\n  const lift3 = (oa, ob, oc, f) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();\n\n  const someIf = (b, a) => b ? Optional.some(a) : Optional.none();\n\n  typeof window !== 'undefined' ? window : Function('return this;')();\n  const COMMENT = 8;\n  const DOCUMENT = 9;\n  const DOCUMENT_FRAGMENT = 11;\n  const ELEMENT = 1;\n  const TEXT = 3;\n\n  const name = element => {\n    const r = element.dom.nodeName;\n    return r.toLowerCase();\n  };\n\n  const type$1 = element => element.dom.nodeType;\n\n  const isType = t => element => type$1(element) === t;\n\n  const isComment$1 = element => type$1(element) === COMMENT || name(element) === '#comment';\n\n  const isElement$7 = isType(ELEMENT);\n  const isText$9 = isType(TEXT);\n  const isDocument$2 = isType(DOCUMENT);\n  const isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);\n\n  const isTag = tag => e => isElement$7(e) && name(e) === tag;\n\n  const rawSet = (dom, key, value) => {\n    if (isString(value) || isBoolean(value) || isNumber(value)) {\n      dom.setAttribute(key, value + '');\n    } else {\n      console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n      throw new Error('Attribute value was not simple');\n    }\n  };\n\n  const set$2 = (element, key, value) => {\n    rawSet(element.dom, key, value);\n  };\n\n  const setAll$1 = (element, attrs) => {\n    const dom = element.dom;\n    each$f(attrs, (v, k) => {\n      rawSet(dom, k, v);\n    });\n  };\n\n  const get$9 = (element, key) => {\n    const v = element.dom.getAttribute(key);\n    return v === null ? undefined : v;\n  };\n\n  const getOpt = (element, key) => Optional.from(get$9(element, key));\n\n  const has$1 = (element, key) => {\n    const dom = element.dom;\n    return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;\n  };\n\n  const remove$a = (element, key) => {\n    element.dom.removeAttribute(key);\n  };\n\n  const hasNone = element => {\n    const attrs = element.dom.attributes;\n    return attrs === undefined || attrs === null || attrs.length === 0;\n  };\n\n  const clone$4 = element => foldl(element.dom.attributes, (acc, attr) => {\n    acc[attr.name] = attr.value;\n    return acc;\n  }, {});\n\n  const read$4 = (element, attr) => {\n    const value = get$9(element, attr);\n    return value === undefined || value === '' ? [] : value.split(' ');\n  };\n\n  const add$4 = (element, attr, id) => {\n    const old = read$4(element, attr);\n    const nu = old.concat([id]);\n    set$2(element, attr, nu.join(' '));\n    return true;\n  };\n\n  const remove$9 = (element, attr, id) => {\n    const nu = filter$6(read$4(element, attr), v => v !== id);\n\n    if (nu.length > 0) {\n      set$2(element, attr, nu.join(' '));\n    } else {\n      remove$a(element, attr);\n    }\n\n    return false;\n  };\n\n  const supports = element => element.dom.classList !== undefined;\n\n  const get$8 = element => read$4(element, 'class');\n\n  const add$3 = (element, clazz) => add$4(element, 'class', clazz);\n\n  const remove$8 = (element, clazz) => remove$9(element, 'class', clazz);\n\n  const toggle$2 = (element, clazz) => {\n    if (contains$2(get$8(element), clazz)) {\n      return remove$8(element, clazz);\n    } else {\n      return add$3(element, clazz);\n    }\n  };\n\n  const add$2 = (element, clazz) => {\n    if (supports(element)) {\n      element.dom.classList.add(clazz);\n    } else {\n      add$3(element, clazz);\n    }\n  };\n\n  const cleanClass = element => {\n    const classList = supports(element) ? element.dom.classList : get$8(element);\n\n    if (classList.length === 0) {\n      remove$a(element, 'class');\n    }\n  };\n\n  const remove$7 = (element, clazz) => {\n    if (supports(element)) {\n      const classList = element.dom.classList;\n      classList.remove(clazz);\n    } else {\n      remove$8(element, clazz);\n    }\n\n    cleanClass(element);\n  };\n\n  const toggle$1 = (element, clazz) => {\n    const result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$2(element, clazz);\n    cleanClass(element);\n    return result;\n  };\n\n  const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);\n\n  const isSupported$1 = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n  const fromHtml$1 = (html, scope) => {\n    const doc = scope || document;\n    const div = doc.createElement('div');\n    div.innerHTML = html;\n\n    if (!div.hasChildNodes() || div.childNodes.length > 1) {\n      const message = 'HTML does not have a single root node';\n      console.error(message, html);\n      throw new Error(message);\n    }\n\n    return fromDom$2(div.childNodes[0]);\n  };\n\n  const fromTag = (tag, scope) => {\n    const doc = scope || document;\n    const node = doc.createElement(tag);\n    return fromDom$2(node);\n  };\n\n  const fromText = (text, scope) => {\n    const doc = scope || document;\n    const node = doc.createTextNode(text);\n    return fromDom$2(node);\n  };\n\n  const fromDom$2 = node => {\n    if (node === null || node === undefined) {\n      throw new Error('Node cannot be null or undefined');\n    }\n\n    return {\n      dom: node\n    };\n  };\n\n  const fromPoint$2 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$2);\n\n  const SugarElement = {\n    fromHtml: fromHtml$1,\n    fromTag,\n    fromText,\n    fromDom: fromDom$2,\n    fromPoint: fromPoint$2\n  };\n\n  const toArray = (target, f) => {\n    const r = [];\n\n    const recurse = e => {\n      r.push(e);\n      return f(e);\n    };\n\n    let cur = f(target);\n\n    do {\n      cur = cur.bind(recurse);\n    } while (cur.isSome());\n\n    return r;\n  };\n\n  const is$1 = (element, selector) => {\n    const dom = element.dom;\n\n    if (dom.nodeType !== ELEMENT) {\n      return false;\n    } else {\n      const elem = dom;\n\n      if (elem.matches !== undefined) {\n        return elem.matches(selector);\n      } else if (elem.msMatchesSelector !== undefined) {\n        return elem.msMatchesSelector(selector);\n      } else if (elem.webkitMatchesSelector !== undefined) {\n        return elem.webkitMatchesSelector(selector);\n      } else if (elem.mozMatchesSelector !== undefined) {\n        return elem.mozMatchesSelector(selector);\n      } else {\n        throw new Error('Browser lacks native selectors');\n      }\n    }\n  };\n\n  const bypassSelector = dom => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;\n\n  const all = (selector, scope) => {\n    const base = scope === undefined ? document : scope.dom;\n    return bypassSelector(base) ? [] : map$3(base.querySelectorAll(selector), SugarElement.fromDom);\n  };\n\n  const one = (selector, scope) => {\n    const base = scope === undefined ? document : scope.dom;\n    return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);\n  };\n\n  const eq = (e1, e2) => e1.dom === e2.dom;\n\n  const contains = (e1, e2) => {\n    const d1 = e1.dom;\n    const d2 = e2.dom;\n    return d1 === d2 ? false : d1.contains(d2);\n  };\n\n  const owner$1 = element => SugarElement.fromDom(element.dom.ownerDocument);\n\n  const documentOrOwner = dos => isDocument$2(dos) ? dos : owner$1(dos);\n\n  const documentElement = element => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);\n\n  const defaultView = element => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);\n\n  const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n\n  const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\n\n  const parents$1 = (element, isRoot) => {\n    const stop = isFunction(isRoot) ? isRoot : never;\n    let dom = element.dom;\n    const ret = [];\n\n    while (dom.parentNode !== null && dom.parentNode !== undefined) {\n      const rawParent = dom.parentNode;\n      const p = SugarElement.fromDom(rawParent);\n      ret.push(p);\n\n      if (stop(p) === true) {\n        break;\n      } else {\n        dom = rawParent;\n      }\n    }\n\n    return ret;\n  };\n\n  const siblings = element => {\n    const filterSelf = elements => filter$6(elements, x => !eq(element, x));\n\n    return parent(element).map(children).map(filterSelf).getOr([]);\n  };\n\n  const prevSibling = element => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);\n\n  const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n\n  const prevSiblings = element => reverse(toArray(element, prevSibling));\n\n  const nextSiblings = element => toArray(element, nextSibling);\n\n  const children = element => map$3(element.dom.childNodes, SugarElement.fromDom);\n\n  const child$1 = (element, index) => {\n    const cs = element.dom.childNodes;\n    return Optional.from(cs[index]).map(SugarElement.fromDom);\n  };\n\n  const firstChild = element => child$1(element, 0);\n\n  const lastChild = element => child$1(element, element.dom.childNodes.length - 1);\n\n  const childNodesCount = element => element.dom.childNodes.length;\n\n  const getHead = doc => {\n    const b = doc.dom.head;\n\n    if (b === null || b === undefined) {\n      throw new Error('Head is not available yet');\n    }\n\n    return SugarElement.fromDom(b);\n  };\n\n  const isShadowRoot = dos => isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);\n\n  const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);\n  const isSupported = constant(supported);\n  const getRootNode = supported ? e => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;\n\n  const getStyleContainer = dos => isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));\n\n  const getShadowRoot = e => {\n    const r = getRootNode(e);\n    return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n  };\n\n  const getShadowHost = e => SugarElement.fromDom(e.dom.host);\n\n  const getOriginalEventTarget = event => {\n    if (isSupported() && isNonNullable(event.target)) {\n      const el = SugarElement.fromDom(event.target);\n\n      if (isElement$7(el) && isOpenShadowHost(el)) {\n        if (event.composed && event.composedPath) {\n          const composedPath = event.composedPath();\n\n          if (composedPath) {\n            return head(composedPath);\n          }\n        }\n      }\n    }\n\n    return Optional.from(event.target);\n  };\n\n  const isOpenShadowHost = element => isNonNullable(element.dom.shadowRoot);\n\n  const inBody = element => {\n    const dom = isText$9(element) ? element.dom.parentNode : element.dom;\n\n    if (dom === undefined || dom === null || dom.ownerDocument === null) {\n      return false;\n    }\n\n    const doc = dom.ownerDocument;\n    return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n  };\n\n  const internalSet = (dom, property, value) => {\n    if (!isString(value)) {\n      console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n      throw new Error('CSS value must be a string: ' + value);\n    }\n\n    if (isSupported$1(dom)) {\n      dom.style.setProperty(property, value);\n    }\n  };\n\n  const internalRemove = (dom, property) => {\n    if (isSupported$1(dom)) {\n      dom.style.removeProperty(property);\n    }\n  };\n\n  const set$1 = (element, property, value) => {\n    const dom = element.dom;\n    internalSet(dom, property, value);\n  };\n\n  const setAll = (element, css) => {\n    const dom = element.dom;\n    each$f(css, (v, k) => {\n      internalSet(dom, k, v);\n    });\n  };\n\n  const get$7 = (element, property) => {\n    const dom = element.dom;\n    const styles = window.getComputedStyle(dom);\n    const r = styles.getPropertyValue(property);\n    return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;\n  };\n\n  const getUnsafeProperty = (dom, property) => isSupported$1(dom) ? dom.style.getPropertyValue(property) : '';\n\n  const getRaw$1 = (element, property) => {\n    const dom = element.dom;\n    const raw = getUnsafeProperty(dom, property);\n    return Optional.from(raw).filter(r => r.length > 0);\n  };\n\n  const getAllRaw = element => {\n    const css = {};\n    const dom = element.dom;\n\n    if (isSupported$1(dom)) {\n      for (let i = 0; i < dom.style.length; i++) {\n        const ruleName = dom.style.item(i);\n        css[ruleName] = dom.style[ruleName];\n      }\n    }\n\n    return css;\n  };\n\n  const remove$6 = (element, property) => {\n    const dom = element.dom;\n    internalRemove(dom, property);\n\n    if (is$2(getOpt(element, 'style').map(trim$3), '')) {\n      remove$a(element, 'style');\n    }\n  };\n\n  const reflow = e => e.dom.offsetWidth;\n\n  const before$3 = (marker, element) => {\n    const parent$1 = parent(marker);\n    parent$1.each(v => {\n      v.dom.insertBefore(element.dom, marker.dom);\n    });\n  };\n\n  const after$4 = (marker, element) => {\n    const sibling = nextSibling(marker);\n    sibling.fold(() => {\n      const parent$1 = parent(marker);\n      parent$1.each(v => {\n        append$1(v, element);\n      });\n    }, v => {\n      before$3(v, element);\n    });\n  };\n\n  const prepend = (parent, element) => {\n    const firstChild$1 = firstChild(parent);\n    firstChild$1.fold(() => {\n      append$1(parent, element);\n    }, v => {\n      parent.dom.insertBefore(element.dom, v.dom);\n    });\n  };\n\n  const append$1 = (parent, element) => {\n    parent.dom.appendChild(element.dom);\n  };\n\n  const wrap$2 = (element, wrapper) => {\n    before$3(element, wrapper);\n    append$1(wrapper, element);\n  };\n\n  const after$3 = (marker, elements) => {\n    each$g(elements, (x, i) => {\n      const e = i === 0 ? marker : elements[i - 1];\n      after$4(e, x);\n    });\n  };\n\n  const append = (parent, elements) => {\n    each$g(elements, x => {\n      append$1(parent, x);\n    });\n  };\n\n  const empty = element => {\n    element.dom.textContent = '';\n    each$g(children(element), rogue => {\n      remove$5(rogue);\n    });\n  };\n\n  const remove$5 = element => {\n    const dom = element.dom;\n\n    if (dom.parentNode !== null) {\n      dom.parentNode.removeChild(dom);\n    }\n  };\n\n  const unwrap = wrapper => {\n    const children$1 = children(wrapper);\n\n    if (children$1.length > 0) {\n      after$3(wrapper, children$1);\n    }\n\n    remove$5(wrapper);\n  };\n\n  const fromHtml = (html, scope) => {\n    const doc = scope || document;\n    const div = doc.createElement('div');\n    div.innerHTML = html;\n    return children(SugarElement.fromDom(div));\n  };\n\n  const fromDom$1 = nodes => map$3(nodes, SugarElement.fromDom);\n\n  const get$6 = element => element.dom.innerHTML;\n\n  const set = (element, content) => {\n    const owner = owner$1(element);\n    const docDom = owner.dom;\n    const fragment = SugarElement.fromDom(docDom.createDocumentFragment());\n    const contentElements = fromHtml(content, docDom);\n    append(fragment, contentElements);\n    empty(element);\n    append$1(element, fragment);\n  };\n\n  const getOuter = element => {\n    const container = SugarElement.fromTag('div');\n    const clone = SugarElement.fromDom(element.dom.cloneNode(true));\n    append$1(container, clone);\n    return get$6(container);\n  };\n\n  const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({\n    target,\n    x,\n    y,\n    stop,\n    prevent,\n    kill,\n    raw\n  });\n\n  const fromRawEvent = rawEvent => {\n    const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));\n\n    const stop = () => rawEvent.stopPropagation();\n\n    const prevent = () => rawEvent.preventDefault();\n\n    const kill = compose(prevent, stop);\n    return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);\n  };\n\n  const handle$1 = (filter, handler) => rawEvent => {\n    if (filter(rawEvent)) {\n      handler(fromRawEvent(rawEvent));\n    }\n  };\n\n  const binder = (element, event, filter, handler, useCapture) => {\n    const wrapped = handle$1(filter, handler);\n    element.dom.addEventListener(event, wrapped, useCapture);\n    return {\n      unbind: curry(unbind, element, event, wrapped, useCapture)\n    };\n  };\n\n  const bind$2 = (element, event, filter, handler) => binder(element, event, filter, handler, false);\n\n  const unbind = (element, event, handler, useCapture) => {\n    element.dom.removeEventListener(event, handler, useCapture);\n  };\n\n  const r = (left, top) => {\n    const translate = (x, y) => r(left + x, top + y);\n\n    return {\n      left,\n      top,\n      translate\n    };\n  };\n\n  const SugarPosition = r;\n\n  const boxPosition = dom => {\n    const box = dom.getBoundingClientRect();\n    return SugarPosition(box.left, box.top);\n  };\n\n  const firstDefinedOrZero = (a, b) => {\n    if (a !== undefined) {\n      return a;\n    } else {\n      return b !== undefined ? b : 0;\n    }\n  };\n\n  const absolute = element => {\n    const doc = element.dom.ownerDocument;\n    const body = doc.body;\n    const win = doc.defaultView;\n    const html = doc.documentElement;\n\n    if (body === element.dom) {\n      return SugarPosition(body.offsetLeft, body.offsetTop);\n    }\n\n    const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);\n    const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);\n    const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);\n    const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);\n    return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);\n  };\n\n  const viewport = element => {\n    const dom = element.dom;\n    const doc = dom.ownerDocument;\n    const body = doc.body;\n\n    if (body === dom) {\n      return SugarPosition(body.offsetLeft, body.offsetTop);\n    }\n\n    if (!inBody(element)) {\n      return SugarPosition(0, 0);\n    }\n\n    return boxPosition(dom);\n  };\n\n  const get$5 = _DOC => {\n    const doc = _DOC !== undefined ? _DOC.dom : document;\n    const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;\n    const y = doc.body.scrollTop || doc.documentElement.scrollTop;\n    return SugarPosition(x, y);\n  };\n\n  const to = (x, y, _DOC) => {\n    const doc = _DOC !== undefined ? _DOC.dom : document;\n    const win = doc.defaultView;\n\n    if (win) {\n      win.scrollTo(x, y);\n    }\n  };\n\n  const intoView = (element, alignToTop) => {\n    const isSafari = detect$2().browser.isSafari();\n\n    if (isSafari && isFunction(element.dom.scrollIntoViewIfNeeded)) {\n      element.dom.scrollIntoViewIfNeeded(false);\n    } else {\n      element.dom.scrollIntoView(alignToTop);\n    }\n  };\n\n  const get$4 = _win => {\n    const win = _win === undefined ? window : _win;\n\n    if (detect$2().browser.isFirefox()) {\n      return Optional.none();\n    } else {\n      return Optional.from(win.visualViewport);\n    }\n  };\n\n  const bounds = (x, y, width, height) => ({\n    x,\n    y,\n    width,\n    height,\n    right: x + width,\n    bottom: y + height\n  });\n\n  const getBounds = _win => {\n    const win = _win === undefined ? window : _win;\n    const doc = win.document;\n    const scroll = get$5(SugarElement.fromDom(doc));\n    return get$4(win).fold(() => {\n      const html = win.document.documentElement;\n      const width = html.clientWidth;\n      const height = html.clientHeight;\n      return bounds(scroll.left, scroll.top, width, height);\n    }, visualViewport => bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));\n  };\n\n  const isNodeType = type => {\n    return node => {\n      return !!node && node.nodeType === type;\n    };\n  };\n\n  const isRestrictedNode = node => !!node && !Object.getPrototypeOf(node);\n\n  const isElement$6 = isNodeType(1);\n\n  const matchNodeNames = names => {\n    const lowercasedNames = names.map(s => s.toLowerCase());\n    return node => {\n      if (node && node.nodeName) {\n        const nodeName = node.nodeName.toLowerCase();\n        return contains$2(lowercasedNames, nodeName);\n      }\n\n      return false;\n    };\n  };\n\n  const matchStyleValues = (name, values) => {\n    const items = values.toLowerCase().split(' ');\n    return node => {\n      if (isElement$6(node)) {\n        for (let i = 0; i < items.length; i++) {\n          const computed = node.ownerDocument.defaultView.getComputedStyle(node, null);\n          const cssValue = computed ? computed.getPropertyValue(name) : null;\n\n          if (cssValue === items[i]) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    };\n  };\n\n  const hasAttribute = attrName => {\n    return node => {\n      return isElement$6(node) && node.hasAttribute(attrName);\n    };\n  };\n\n  const hasAttributeValue = (attrName, attrValue) => {\n    return node => {\n      return isElement$6(node) && node.getAttribute(attrName) === attrValue;\n    };\n  };\n\n  const isBogus$2 = node => isElement$6(node) && node.hasAttribute('data-mce-bogus');\n\n  const isBogusAll$1 = node => isElement$6(node) && node.getAttribute('data-mce-bogus') === 'all';\n\n  const isTable$3 = node => isElement$6(node) && node.tagName === 'TABLE';\n\n  const hasContentEditableState = value => {\n    return node => {\n      if (isElement$6(node)) {\n        if (node.contentEditable === value) {\n          return true;\n        }\n\n        if (node.getAttribute('data-mce-contenteditable') === value) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n  };\n\n  const isTextareaOrInput = matchNodeNames(['textarea', 'input']);\n  const isText$8 = isNodeType(3);\n  const isCData = isNodeType(4);\n  const isPi = isNodeType(7);\n  const isComment = isNodeType(8);\n  const isDocument$1 = isNodeType(9);\n  const isDocumentFragment = isNodeType(11);\n  const isBr$5 = matchNodeNames(['br']);\n  const isImg = matchNodeNames(['img']);\n  const isContentEditableTrue$4 = hasContentEditableState('true');\n  const isContentEditableFalse$a = hasContentEditableState('false');\n  const isTableCell$5 = matchNodeNames(['td', 'th']);\n  const isMedia$2 = matchNodeNames(['video', 'audio', 'object', 'embed']);\n  const browser = detect$2().browser;\n\n  const firstElement = nodes => find$2(nodes, isElement$7);\n\n  const getTableCaptionDeltaY = elm => {\n    if (browser.isFirefox() && name(elm) === 'table') {\n      return firstElement(children(elm)).filter(elm => {\n        return name(elm) === 'caption';\n      }).bind(caption => {\n        return firstElement(nextSiblings(caption)).map(body => {\n          const bodyTop = body.dom.offsetTop;\n          const captionTop = caption.dom.offsetTop;\n          const captionHeight = caption.dom.offsetHeight;\n          return bodyTop <= captionTop ? -captionHeight : 0;\n        });\n      }).getOr(0);\n    } else {\n      return 0;\n    }\n  };\n\n  const hasChild = (elm, child) => elm.children && contains$2(elm.children, child);\n\n  const getPos = (body, elm, rootElm) => {\n    let x = 0,\n        y = 0;\n    const doc = body.ownerDocument;\n    rootElm = rootElm ? rootElm : body;\n\n    if (elm) {\n      if (rootElm === body && elm.getBoundingClientRect && get$7(SugarElement.fromDom(body), 'position') === 'static') {\n        const pos = elm.getBoundingClientRect();\n        x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;\n        y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;\n        return {\n          x,\n          y\n        };\n      }\n\n      let offsetParent = elm;\n\n      while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\n        const castOffsetParent = offsetParent;\n        x += castOffsetParent.offsetLeft || 0;\n        y += castOffsetParent.offsetTop || 0;\n        offsetParent = castOffsetParent.offsetParent;\n      }\n\n      offsetParent = elm.parentNode;\n\n      while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\n        x -= offsetParent.scrollLeft || 0;\n        y -= offsetParent.scrollTop || 0;\n        offsetParent = offsetParent.parentNode;\n      }\n\n      y += getTableCaptionDeltaY(SugarElement.fromDom(elm));\n    }\n\n    return {\n      x,\n      y\n    };\n  };\n\n  var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n    if (is(scope, a)) {\n      return Optional.some(scope);\n    } else if (isFunction(isRoot) && isRoot(scope)) {\n      return Optional.none();\n    } else {\n      return ancestor(scope, a, isRoot);\n    }\n  };\n\n  const ancestor$3 = (scope, predicate, isRoot) => {\n    let element = scope.dom;\n    const stop = isFunction(isRoot) ? isRoot : never;\n\n    while (element.parentNode) {\n      element = element.parentNode;\n      const el = SugarElement.fromDom(element);\n\n      if (predicate(el)) {\n        return Optional.some(el);\n      } else if (stop(el)) {\n        break;\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const closest$4 = (scope, predicate, isRoot) => {\n    const is = (s, test) => test(s);\n\n    return ClosestOrAncestor(is, ancestor$3, scope, predicate, isRoot);\n  };\n\n  const sibling$1 = (scope, predicate) => {\n    const element = scope.dom;\n\n    if (!element.parentNode) {\n      return Optional.none();\n    }\n\n    return child(SugarElement.fromDom(element.parentNode), x => !eq(scope, x) && predicate(x));\n  };\n\n  const child = (scope, predicate) => {\n    const pred = node => predicate(SugarElement.fromDom(node));\n\n    const result = find$2(scope.dom.childNodes, pred);\n    return result.map(SugarElement.fromDom);\n  };\n\n  const descendant$1 = (scope, predicate) => {\n    const descend = node => {\n      for (let i = 0; i < node.childNodes.length; i++) {\n        const child = SugarElement.fromDom(node.childNodes[i]);\n\n        if (predicate(child)) {\n          return Optional.some(child);\n        }\n\n        const res = descend(node.childNodes[i]);\n\n        if (res.isSome()) {\n          return res;\n        }\n      }\n\n      return Optional.none();\n    };\n\n    return descend(scope.dom);\n  };\n\n  const ancestor$2 = (scope, selector, isRoot) => ancestor$3(scope, e => is$1(e, selector), isRoot);\n\n  const descendant = (scope, selector) => one(selector, scope);\n\n  const closest$3 = (scope, selector, isRoot) => {\n    const is = (element, selector) => is$1(element, selector);\n\n    return ClosestOrAncestor(is, ancestor$2, scope, selector, isRoot);\n  };\n\n  const StyleSheetLoader = function (documentOrShadowRoot) {\n    let settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let idCount = 0;\n    const loadedStates = {};\n    const edos = SugarElement.fromDom(documentOrShadowRoot);\n    const doc = documentOrOwner(edos);\n    const maxLoadTime = settings.maxLoadTime || 5000;\n\n    const _setReferrerPolicy = referrerPolicy => {\n      settings.referrerPolicy = referrerPolicy;\n    };\n\n    const addStyle = element => {\n      append$1(getStyleContainer(edos), element);\n    };\n\n    const removeStyle = id => {\n      const styleContainer = getStyleContainer(edos);\n      descendant(styleContainer, '#' + id).each(remove$5);\n    };\n\n    const getOrCreateState = url => get$a(loadedStates, url).getOrThunk(() => ({\n      id: 'mce-u' + idCount++,\n      passed: [],\n      failed: [],\n      count: 0\n    }));\n\n    const load = url => new Promise((success, failure) => {\n      let link;\n\n      const urlWithSuffix = Tools._addCacheSuffix(url);\n\n      const state = getOrCreateState(urlWithSuffix);\n      loadedStates[urlWithSuffix] = state;\n      state.count++;\n\n      const resolve = (callbacks, status) => {\n        each$g(callbacks, call);\n        state.status = status;\n        state.passed = [];\n        state.failed = [];\n\n        if (link) {\n          link.onload = null;\n          link.onerror = null;\n          link = null;\n        }\n      };\n\n      const passed = () => resolve(state.passed, 2);\n\n      const failed = () => resolve(state.failed, 3);\n\n      const wait = (testCallback, waitCallback) => {\n        if (!testCallback()) {\n          if (Date.now() - startTime < maxLoadTime) {\n            setTimeout(waitCallback);\n          } else {\n            failed();\n          }\n        }\n      };\n\n      const waitForWebKitLinkLoaded = () => {\n        wait(() => {\n          const styleSheets = documentOrShadowRoot.styleSheets;\n          let i = styleSheets.length;\n\n          while (i--) {\n            const styleSheet = styleSheets[i];\n            const owner = styleSheet.ownerNode;\n\n            if (owner && owner.id === link.id) {\n              passed();\n              return true;\n            }\n          }\n\n          return false;\n        }, waitForWebKitLinkLoaded);\n      };\n\n      if (success) {\n        state.passed.push(success);\n      }\n\n      if (failure) {\n        state.failed.push(failure);\n      }\n\n      if (state.status === 1) {\n        return;\n      }\n\n      if (state.status === 2) {\n        passed();\n        return;\n      }\n\n      if (state.status === 3) {\n        failed();\n        return;\n      }\n\n      state.status = 1;\n      const linkElem = SugarElement.fromTag('link', doc.dom);\n      setAll$1(linkElem, {\n        rel: 'stylesheet',\n        type: 'text/css',\n        id: state.id\n      });\n      const startTime = Date.now();\n\n      if (settings.contentCssCors) {\n        set$2(linkElem, 'crossOrigin', 'anonymous');\n      }\n\n      if (settings.referrerPolicy) {\n        set$2(linkElem, 'referrerpolicy', settings.referrerPolicy);\n      }\n\n      link = linkElem.dom;\n      link.onload = waitForWebKitLinkLoaded;\n      link.onerror = failed;\n      addStyle(linkElem);\n      set$2(linkElem, 'href', urlWithSuffix);\n    });\n\n    const loadAll = urls => {\n      const loadedUrls = Promise.allSettled(map$3(urls, url => load(url).then(constant(url))));\n      return loadedUrls.then(results => {\n        const parts = partition$2(results, r => r.status === 'fulfilled');\n\n        if (parts.fail.length > 0) {\n          return Promise.reject(map$3(parts.fail, result => result.reason));\n        } else {\n          return map$3(parts.pass, result => result.value);\n        }\n      });\n    };\n\n    const unload = url => {\n      const urlWithSuffix = Tools._addCacheSuffix(url);\n\n      get$a(loadedStates, urlWithSuffix).each(state => {\n        const count = --state.count;\n\n        if (count === 0) {\n          delete loadedStates[urlWithSuffix];\n          removeStyle(state.id);\n        }\n      });\n    };\n\n    const unloadAll = urls => {\n      each$g(urls, url => {\n        unload(url);\n      });\n    };\n\n    return {\n      load,\n      loadAll,\n      unload,\n      unloadAll,\n      _setReferrerPolicy\n    };\n  };\n\n  const create$c = () => {\n    const map = new WeakMap();\n\n    const forElement = (referenceElement, settings) => {\n      const root = getRootNode(referenceElement);\n      const rootDom = root.dom;\n      return Optional.from(map.get(rootDom)).getOrThunk(() => {\n        const sl = StyleSheetLoader(rootDom, settings);\n        map.set(rootDom, sl);\n        return sl;\n      });\n    };\n\n    return {\n      forElement\n    };\n  };\n\n  const instance = create$c();\n\n  class DomTreeWalker {\n    constructor(startNode, rootNode) {\n      this.node = startNode;\n      this.rootNode = rootNode;\n      this.current = this.current.bind(this);\n      this.next = this.next.bind(this);\n      this.prev = this.prev.bind(this);\n      this.prev2 = this.prev2.bind(this);\n    }\n\n    current() {\n      return this.node;\n    }\n\n    next(shallow) {\n      this.node = this.findSibling(this.node, 'firstChild', 'nextSibling', shallow);\n      return this.node;\n    }\n\n    prev(shallow) {\n      this.node = this.findSibling(this.node, 'lastChild', 'previousSibling', shallow);\n      return this.node;\n    }\n\n    prev2(shallow) {\n      this.node = this.findPreviousNode(this.node, 'lastChild', 'previousSibling', shallow);\n      return this.node;\n    }\n\n    findSibling(node, startName, siblingName, shallow) {\n      let sibling, parent;\n\n      if (node) {\n        if (!shallow && node[startName]) {\n          return node[startName];\n        }\n\n        if (node !== this.rootNode) {\n          sibling = node[siblingName];\n\n          if (sibling) {\n            return sibling;\n          }\n\n          for (parent = node.parentNode; parent && parent !== this.rootNode; parent = parent.parentNode) {\n            sibling = parent[siblingName];\n\n            if (sibling) {\n              return sibling;\n            }\n          }\n        }\n      }\n    }\n\n    findPreviousNode(node, startName, siblingName, shallow) {\n      let sibling, parent, child;\n\n      if (node) {\n        sibling = node[siblingName];\n\n        if (this.rootNode && sibling === this.rootNode) {\n          return;\n        }\n\n        if (sibling) {\n          if (!shallow) {\n            for (child = sibling[startName]; child; child = child[startName]) {\n              if (!child[startName]) {\n                return child;\n              }\n            }\n          }\n\n          return sibling;\n        }\n\n        parent = node.parentNode;\n\n        if (parent && parent !== this.rootNode) {\n          return parent;\n        }\n      }\n    }\n\n  }\n\n  const blocks = ['article', 'aside', 'details', 'div', 'dt', 'figcaption', 'footer', 'form', 'fieldset', 'header', 'hgroup', 'html', 'main', 'nav', 'section', 'summary', 'body', 'p', 'dl', 'multicol', 'dd', 'figure', 'address', 'center', 'blockquote', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'listing', 'xmp', 'pre', 'plaintext', 'menu', 'dir', 'ul', 'ol', 'li', 'hr', 'table', 'tbody', 'thead', 'tfoot', 'th', 'tr', 'td', 'caption'];\n  const tableCells = ['td', 'th'];\n  const tableSections = ['thead', 'tbody', 'tfoot'];\n  const textBlocks = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'div', 'address', 'pre', 'form', 'blockquote', 'center', 'dir', 'fieldset', 'header', 'footer', 'article', 'section', 'hgroup', 'aside', 'nav', 'figure'];\n  const headings = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];\n  const listItems$1 = ['li', 'dd', 'dt'];\n  const lists = ['ul', 'ol', 'dl'];\n  const wsElements = ['pre', 'script', 'textarea', 'style'];\n\n  const lazyLookup = items => {\n    let lookup;\n    return node => {\n      lookup = lookup ? lookup : mapToObject(items, always);\n      return has$2(lookup, name(node));\n    };\n  };\n\n  const isHeading = lazyLookup(headings);\n  const isBlock$2 = lazyLookup(blocks);\n\n  const isTable$2 = node => name(node) === 'table';\n\n  const isInline$1 = node => isElement$7(node) && !isBlock$2(node);\n\n  const isBr$4 = node => isElement$7(node) && name(node) === 'br';\n\n  const isTextBlock$2 = lazyLookup(textBlocks);\n  const isList = lazyLookup(lists);\n  const isListItem = lazyLookup(listItems$1);\n  const isTableSection = lazyLookup(tableSections);\n  const isTableCell$4 = lazyLookup(tableCells);\n  const isWsPreserveElement = lazyLookup(wsElements);\n\n  const ancestor$1 = (scope, selector, isRoot) => ancestor$2(scope, selector, isRoot).isSome();\n\n  const zeroWidth = '\\uFEFF';\n  const nbsp = '\\xA0';\n\n  const isZwsp$1 = char => char === zeroWidth;\n\n  const removeZwsp = s => s.replace(/\\uFEFF/g, '');\n\n  const ZWSP$1 = zeroWidth;\n  const isZwsp = isZwsp$1;\n  const trim$1 = removeZwsp;\n  const isElement$5 = isElement$6;\n  const isText$7 = isText$8;\n\n  const isCaretContainerBlock$1 = node => {\n    if (isText$7(node)) {\n      node = node.parentNode;\n    }\n\n    return isElement$5(node) && node.hasAttribute('data-mce-caret');\n  };\n\n  const isCaretContainerInline = node => isText$7(node) && isZwsp(node.data);\n\n  const isCaretContainer$2 = node => isCaretContainerBlock$1(node) || isCaretContainerInline(node);\n\n  const hasContent = node => node.firstChild !== node.lastChild || !isBr$5(node.firstChild);\n\n  const insertInline$1 = (node, before) => {\n    const doc = node.ownerDocument;\n    const textNode = doc.createTextNode(ZWSP$1);\n    const parentNode = node.parentNode;\n\n    if (!before) {\n      const sibling = node.nextSibling;\n\n      if (isText$7(sibling)) {\n        if (isCaretContainer$2(sibling)) {\n          return sibling;\n        }\n\n        if (startsWithCaretContainer$1(sibling)) {\n          sibling.splitText(1);\n          return sibling;\n        }\n      }\n\n      if (node.nextSibling) {\n        parentNode.insertBefore(textNode, node.nextSibling);\n      } else {\n        parentNode.appendChild(textNode);\n      }\n    } else {\n      const sibling = node.previousSibling;\n\n      if (isText$7(sibling)) {\n        if (isCaretContainer$2(sibling)) {\n          return sibling;\n        }\n\n        if (endsWithCaretContainer$1(sibling)) {\n          return sibling.splitText(sibling.data.length - 1);\n        }\n      }\n\n      parentNode.insertBefore(textNode, node);\n    }\n\n    return textNode;\n  };\n\n  const isBeforeInline = pos => {\n    const container = pos.container();\n\n    if (!isText$8(container)) {\n      return false;\n    }\n\n    return container.data.charAt(pos.offset()) === ZWSP$1 || pos.isAtStart() && isCaretContainerInline(container.previousSibling);\n  };\n\n  const isAfterInline = pos => {\n    const container = pos.container();\n\n    if (!isText$8(container)) {\n      return false;\n    }\n\n    return container.data.charAt(pos.offset() - 1) === ZWSP$1 || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);\n  };\n\n  const createBogusBr = () => {\n    const br = document.createElement('br');\n    br.setAttribute('data-mce-bogus', '1');\n    return br;\n  };\n\n  const insertBlock = (blockName, node, before) => {\n    const doc = node.ownerDocument;\n    const blockNode = doc.createElement(blockName);\n    blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');\n    blockNode.setAttribute('data-mce-bogus', 'all');\n    blockNode.appendChild(createBogusBr());\n    const parentNode = node.parentNode;\n\n    if (!before) {\n      if (node.nextSibling) {\n        parentNode.insertBefore(blockNode, node.nextSibling);\n      } else {\n        parentNode.appendChild(blockNode);\n      }\n    } else {\n      parentNode.insertBefore(blockNode, node);\n    }\n\n    return blockNode;\n  };\n\n  const startsWithCaretContainer$1 = node => isText$7(node) && node.data[0] === ZWSP$1;\n\n  const endsWithCaretContainer$1 = node => isText$7(node) && node.data[node.data.length - 1] === ZWSP$1;\n\n  const trimBogusBr = elm => {\n    const brs = elm.getElementsByTagName('br');\n    const lastBr = brs[brs.length - 1];\n\n    if (isBogus$2(lastBr)) {\n      lastBr.parentNode.removeChild(lastBr);\n    }\n  };\n\n  const showCaretContainerBlock = caretContainer => {\n    if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {\n      trimBogusBr(caretContainer);\n      caretContainer.removeAttribute('data-mce-caret');\n      caretContainer.removeAttribute('data-mce-bogus');\n      caretContainer.removeAttribute('style');\n      caretContainer.removeAttribute('data-mce-style');\n      caretContainer.removeAttribute('_moz_abspos');\n      return caretContainer;\n    }\n\n    return null;\n  };\n\n  const isRangeInCaretContainerBlock = range => isCaretContainerBlock$1(range.startContainer);\n\n  const isContentEditableTrue$3 = isContentEditableTrue$4;\n  const isContentEditableFalse$9 = isContentEditableFalse$a;\n  const isBr$3 = isBr$5;\n  const isText$6 = isText$8;\n  const isInvalidTextElement = matchNodeNames(['script', 'style', 'textarea']);\n  const isAtomicInline = matchNodeNames(['img', 'input', 'textarea', 'hr', 'iframe', 'video', 'audio', 'object', 'embed']);\n  const isTable$1 = matchNodeNames(['table']);\n  const isCaretContainer$1 = isCaretContainer$2;\n\n  const isCaretCandidate$3 = node => {\n    if (isCaretContainer$1(node)) {\n      return false;\n    }\n\n    if (isText$6(node)) {\n      return !isInvalidTextElement(node.parentNode);\n    }\n\n    return isAtomicInline(node) || isBr$3(node) || isTable$1(node) || isNonUiContentEditableFalse(node);\n  };\n\n  const isUnselectable = node => isElement$6(node) && node.getAttribute('unselectable') === 'true';\n\n  const isNonUiContentEditableFalse = node => isUnselectable(node) === false && isContentEditableFalse$9(node);\n\n  const isInEditable = (node, root) => {\n    for (node = node.parentNode; node && node !== root; node = node.parentNode) {\n      if (isNonUiContentEditableFalse(node)) {\n        return false;\n      }\n\n      if (isContentEditableTrue$3(node)) {\n        return true;\n      }\n    }\n\n    return true;\n  };\n\n  const isAtomicContentEditableFalse = node => {\n    if (!isNonUiContentEditableFalse(node)) {\n      return false;\n    }\n\n    return foldl(from(node.getElementsByTagName('*')), (result, elm) => {\n      return result || isContentEditableTrue$3(elm);\n    }, false) !== true;\n  };\n\n  const isAtomic$1 = node => isAtomicInline(node) || isAtomicContentEditableFalse(node);\n\n  const isEditableCaretCandidate$1 = (node, root) => isCaretCandidate$3(node) && isInEditable(node, root);\n\n  const whiteSpaceRegExp = /^[ \\t\\r\\n]*$/;\n\n  const isWhitespaceText = text => whiteSpaceRegExp.test(text);\n\n  const isCollapsibleWhitespace$1 = c => ' \\f\\t\\x0B'.indexOf(c) !== -1;\n\n  const isNewLineChar = c => c === '\\n' || c === '\\r';\n\n  const isNewline = (text, idx) => idx < text.length && idx >= 0 ? isNewLineChar(text[idx]) : false;\n\n  const normalize$4 = function (text) {\n    let tabSpaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n    let isStartOfContent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let isEndOfContent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    const tabSpace = repeat(' ', tabSpaces);\n    const normalizedText = text.replace(/\\t/g, tabSpace);\n    const result = foldl(normalizedText, (acc, c) => {\n      if (isCollapsibleWhitespace$1(c) || c === nbsp) {\n        if (acc.pcIsSpace || acc.str === '' && isStartOfContent || acc.str.length === normalizedText.length - 1 && isEndOfContent || isNewline(normalizedText, acc.str.length + 1)) {\n          return {\n            pcIsSpace: false,\n            str: acc.str + nbsp\n          };\n        } else {\n          return {\n            pcIsSpace: true,\n            str: acc.str + ' '\n          };\n        }\n      } else {\n        return {\n          pcIsSpace: isNewLineChar(c),\n          str: acc.str + c\n        };\n      }\n    }, {\n      pcIsSpace: false,\n      str: ''\n    });\n    return result.str;\n  };\n\n  const hasWhitespacePreserveParent = (node, rootNode) => {\n    const rootElement = SugarElement.fromDom(rootNode);\n    const startNode = SugarElement.fromDom(node);\n    return ancestor$1(startNode, 'pre,code', curry(eq, rootElement));\n  };\n\n  const isWhitespace$1 = (node, rootNode) => {\n    return isText$8(node) && isWhitespaceText(node.data) && hasWhitespacePreserveParent(node, rootNode) === false;\n  };\n\n  const isNamedAnchor = node => {\n    return isElement$6(node) && node.nodeName === 'A' && !node.hasAttribute('href') && (node.hasAttribute('name') || node.hasAttribute('id'));\n  };\n\n  const isContent$1 = (node, rootNode) => {\n    return isCaretCandidate$3(node) && isWhitespace$1(node, rootNode) === false || isNamedAnchor(node) || isBookmark(node);\n  };\n\n  const isBookmark = hasAttribute('data-mce-bookmark');\n  const isBogus$1 = hasAttribute('data-mce-bogus');\n  const isBogusAll = hasAttributeValue('data-mce-bogus', 'all');\n\n  const isEmptyNode = (targetNode, skipBogus) => {\n    let brCount = 0;\n\n    if (isContent$1(targetNode, targetNode)) {\n      return false;\n    } else {\n      let node = targetNode.firstChild;\n\n      if (!node) {\n        return true;\n      }\n\n      const walker = new DomTreeWalker(node, targetNode);\n\n      do {\n        if (skipBogus) {\n          if (isBogusAll(node)) {\n            node = walker.next(true);\n            continue;\n          }\n\n          if (isBogus$1(node)) {\n            node = walker.next();\n            continue;\n          }\n        }\n\n        if (isBr$5(node)) {\n          brCount++;\n          node = walker.next();\n          continue;\n        }\n\n        if (isContent$1(node, targetNode)) {\n          return false;\n        }\n\n        node = walker.next();\n      } while (node);\n\n      return brCount <= 1;\n    }\n  };\n\n  const isEmpty$2 = function (elm) {\n    let skipBogus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return isEmptyNode(elm.dom, skipBogus);\n  };\n\n  const isSpan = node => node.nodeName.toLowerCase() === 'span';\n\n  const isInlineContent = (node, root) => isNonNullable(node) && (isContent$1(node, root) || isInline$1(SugarElement.fromDom(node)));\n\n  const surroundedByInlineContent = (node, root) => {\n    const prev = new DomTreeWalker(node, root).prev(false);\n    const next = new DomTreeWalker(node, root).next(false);\n    const prevIsInline = isUndefined(prev) || isInlineContent(prev, root);\n    const nextIsInline = isUndefined(next) || isInlineContent(next, root);\n    return prevIsInline && nextIsInline;\n  };\n\n  const isBookmarkNode$2 = node => isSpan(node) && node.getAttribute('data-mce-type') === 'bookmark';\n\n  const isKeepTextNode = (node, root) => isText$8(node) && node.data.length > 0 && surroundedByInlineContent(node, root);\n\n  const isKeepElement = node => isElement$6(node) ? node.childNodes.length > 0 : false;\n\n  const isDocument = node => isDocumentFragment(node) || isDocument$1(node);\n\n  const trimNode = (dom, node, root) => {\n    const rootNode = root || node;\n\n    if (isElement$6(node) && isBookmarkNode$2(node)) {\n      return node;\n    }\n\n    const children = node.childNodes;\n\n    for (let i = children.length - 1; i >= 0; i--) {\n      trimNode(dom, children[i], rootNode);\n    }\n\n    if (isElement$6(node)) {\n      const currentChildren = node.childNodes;\n\n      if (currentChildren.length === 1 && isBookmarkNode$2(currentChildren[0])) {\n        node.parentNode.insertBefore(currentChildren[0], node);\n      }\n    }\n\n    if (!isDocument(node) && !isContent$1(node, rootNode) && !isKeepElement(node) && !isKeepTextNode(node, rootNode)) {\n      dom.remove(node);\n    }\n\n    return node;\n  };\n\n  const makeMap$3 = Tools.makeMap;\n  const attrsCharsRegExp = /[&<>\\\"\\u0060\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n  const textCharsRegExp = /[<>&\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n  const rawCharsRegExp = /[<>&\\\"\\']/g;\n  const entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;\n  const asciiMap = {\n    128: '\\u20AC',\n    130: '\\u201A',\n    131: '\\u0192',\n    132: '\\u201E',\n    133: '\\u2026',\n    134: '\\u2020',\n    135: '\\u2021',\n    136: '\\u02c6',\n    137: '\\u2030',\n    138: '\\u0160',\n    139: '\\u2039',\n    140: '\\u0152',\n    142: '\\u017d',\n    145: '\\u2018',\n    146: '\\u2019',\n    147: '\\u201C',\n    148: '\\u201D',\n    149: '\\u2022',\n    150: '\\u2013',\n    151: '\\u2014',\n    152: '\\u02DC',\n    153: '\\u2122',\n    154: '\\u0161',\n    155: '\\u203A',\n    156: '\\u0153',\n    158: '\\u017e',\n    159: '\\u0178'\n  };\n  const baseEntities = {\n    '\"': '&quot;',\n    '\\'': '&#39;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '&': '&amp;',\n    '`': '&#96;'\n  };\n  const reverseEntities = {\n    '&lt;': '<',\n    '&gt;': '>',\n    '&amp;': '&',\n    '&quot;': '\"',\n    '&apos;': `'`\n  };\n\n  const nativeDecode = text => {\n    const elm = SugarElement.fromTag('div').dom;\n    elm.innerHTML = text;\n    return elm.textContent || elm.innerText || text;\n  };\n\n  const buildEntitiesLookup = (items, radix) => {\n    let i, chr, entity;\n    const lookup = {};\n\n    if (items) {\n      items = items.split(',');\n      radix = radix || 10;\n\n      for (i = 0; i < items.length; i += 2) {\n        chr = String.fromCharCode(parseInt(items[i], radix));\n\n        if (!baseEntities[chr]) {\n          entity = '&' + items[i + 1] + ';';\n          lookup[chr] = entity;\n          lookup[entity] = chr;\n        }\n      }\n\n      return lookup;\n    }\n  };\n\n  const namedEntities = buildEntitiesLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' + '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' + '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' + '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' + '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' + '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' + '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' + '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' + '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' + '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' + 'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' + 'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' + 't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' + 'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' + 'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' + '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' + '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' + '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' + '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' + '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' + 'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' + 'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' + 'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' + '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' + '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);\n\n  const encodeRaw = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n    return baseEntities[chr] || chr;\n  });\n\n  const encodeAllRaw = text => ('' + text).replace(rawCharsRegExp, chr => {\n    return baseEntities[chr] || chr;\n  });\n\n  const encodeNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n    if (chr.length > 1) {\n      return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\n    }\n\n    return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';\n  });\n\n  const encodeNamed = (text, attr, entities) => {\n    entities = entities || namedEntities;\n    return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n      return baseEntities[chr] || entities[chr] || chr;\n    });\n  };\n\n  const getEncodeFunc = (name, entities) => {\n    const entitiesMap = buildEntitiesLookup(entities) || namedEntities;\n\n    const encodeNamedAndNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n      if (baseEntities[chr] !== undefined) {\n        return baseEntities[chr];\n      }\n\n      if (entitiesMap[chr] !== undefined) {\n        return entitiesMap[chr];\n      }\n\n      if (chr.length > 1) {\n        return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\n      }\n\n      return '&#' + chr.charCodeAt(0) + ';';\n    });\n\n    const encodeCustomNamed = (text, attr) => {\n      return encodeNamed(text, attr, entitiesMap);\n    };\n\n    const nameMap = makeMap$3(name.replace(/\\+/g, ','));\n\n    if (nameMap.named && nameMap.numeric) {\n      return encodeNamedAndNumeric;\n    }\n\n    if (nameMap.named) {\n      if (entities) {\n        return encodeCustomNamed;\n      }\n\n      return encodeNamed;\n    }\n\n    if (nameMap.numeric) {\n      return encodeNumeric;\n    }\n\n    return encodeRaw;\n  };\n\n  const decode = text => text.replace(entityRegExp, (all, numeric) => {\n    if (numeric) {\n      if (numeric.charAt(0).toLowerCase() === 'x') {\n        numeric = parseInt(numeric.substr(1), 16);\n      } else {\n        numeric = parseInt(numeric, 10);\n      }\n\n      if (numeric > 65535) {\n        numeric -= 65536;\n        return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));\n      }\n\n      return asciiMap[numeric] || String.fromCharCode(numeric);\n    }\n\n    return reverseEntities[all] || namedEntities[all] || nativeDecode(all);\n  });\n\n  const Entities = {\n    encodeRaw,\n    encodeAllRaw,\n    encodeNumeric,\n    encodeNamed,\n    getEncodeFunc,\n    decode\n  };\n  const mapCache = {},\n        dummyObj = {};\n  const makeMap$2 = Tools.makeMap,\n        each$d = Tools.each,\n        extend$2 = Tools.extend,\n        explode$2 = Tools.explode,\n        inArray = Tools.inArray;\n\n  const split$1 = (items, delim) => {\n    items = Tools.trim(items);\n    return items ? items.split(delim || ' ') : [];\n  };\n\n  const compileSchema = type => {\n    const schema = {};\n    let globalAttributes, blockContent;\n    let phrasingContent, flowContent, html4BlockContent, html4PhrasingContent;\n\n    const add = function (name) {\n      let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      let children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      const childNames = split$1(children);\n      const names = split$1(name);\n      let ni = names.length;\n\n      while (ni--) {\n        const attributesOrder = split$1([globalAttributes, attributes].join(' '));\n        schema[names[ni]] = {\n          attributes: mapToObject(attributesOrder, () => ({})),\n          attributesOrder,\n          children: mapToObject(childNames, constant(dummyObj))\n        };\n      }\n    };\n\n    const addAttrs = (name, attributes) => {\n      const names = split$1(name);\n      const attrs = split$1(attributes);\n      let ni = names.length;\n\n      while (ni--) {\n        const schemaItem = schema[names[ni]];\n\n        for (let i = 0, l = attrs.length; i < l; i++) {\n          schemaItem.attributes[attrs[i]] = {};\n          schemaItem.attributesOrder.push(attrs[i]);\n        }\n      }\n    };\n\n    if (mapCache[type]) {\n      return mapCache[type];\n    }\n\n    globalAttributes = 'id accesskey class dir lang style tabindex title role';\n    blockContent = 'address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul';\n    phrasingContent = 'a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd ' + 'label map noscript object q s samp script select small span strong sub sup ' + 'textarea u var #text #comment';\n\n    if (type !== 'html4') {\n      globalAttributes += ' contenteditable contextmenu draggable dropzone ' + 'hidden spellcheck translate';\n      blockContent += ' article aside details dialog figure main header footer hgroup section nav';\n      phrasingContent += ' audio canvas command datalist mark meter output picture ' + 'progress time wbr video ruby bdi keygen';\n    }\n\n    if (type !== 'html5-strict') {\n      globalAttributes += ' xml:lang';\n      html4PhrasingContent = 'acronym applet basefont big font strike tt';\n      phrasingContent = [phrasingContent, html4PhrasingContent].join(' ');\n      each$d(split$1(html4PhrasingContent), name => {\n        add(name, '', phrasingContent);\n      });\n      html4BlockContent = 'center dir isindex noframes';\n      blockContent = [blockContent, html4BlockContent].join(' ');\n      flowContent = [blockContent, phrasingContent].join(' ');\n      each$d(split$1(html4BlockContent), name => {\n        add(name, '', flowContent);\n      });\n    }\n\n    flowContent = flowContent || [blockContent, phrasingContent].join(' ');\n    add('html', 'manifest', 'head body');\n    add('head', '', 'base command link meta noscript script style title');\n    add('title hr noscript br');\n    add('base', 'href target');\n    add('link', 'href rel media hreflang type sizes hreflang');\n    add('meta', 'name http-equiv content charset');\n    add('style', 'media type scoped');\n    add('script', 'src async defer type charset');\n    add('body', 'onafterprint onbeforeprint onbeforeunload onblur onerror onfocus ' + 'onhashchange onload onmessage onoffline ononline onpagehide onpageshow ' + 'onpopstate onresize onscroll onstorage onunload', flowContent);\n    add('address dt dd div caption', '', flowContent);\n    add('h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn', '', phrasingContent);\n    add('blockquote', 'cite', flowContent);\n    add('ol', 'reversed start type', 'li');\n    add('ul', '', 'li');\n    add('li', 'value', flowContent);\n    add('dl', '', 'dt dd');\n    add('a', 'href target rel media hreflang type', phrasingContent);\n    add('q', 'cite', phrasingContent);\n    add('ins del', 'cite datetime', flowContent);\n    add('img', 'src sizes srcset alt usemap ismap width height');\n    add('iframe', 'src name width height', flowContent);\n    add('embed', 'src type width height');\n    add('object', 'data type typemustmatch name usemap form width height', [flowContent, 'param'].join(' '));\n    add('param', 'name value');\n    add('map', 'name', [flowContent, 'area'].join(' '));\n    add('area', 'alt coords shape href target rel media hreflang type');\n    add('table', 'border', 'caption colgroup thead tfoot tbody tr' + (type === 'html4' ? ' col' : ''));\n    add('colgroup', 'span', 'col');\n    add('col', 'span');\n    add('tbody thead tfoot', '', 'tr');\n    add('tr', '', 'td th');\n    add('td', 'colspan rowspan headers', flowContent);\n    add('th', 'colspan rowspan headers scope abbr', flowContent);\n    add('form', 'accept-charset action autocomplete enctype method name novalidate target', flowContent);\n    add('fieldset', 'disabled form name', [flowContent, 'legend'].join(' '));\n    add('label', 'form for', phrasingContent);\n    add('input', 'accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate ' + 'formtarget height list max maxlength min multiple name pattern readonly required size src step type value width');\n    add('button', 'disabled form formaction formenctype formmethod formnovalidate formtarget name type value', type === 'html4' ? flowContent : phrasingContent);\n    add('select', 'disabled form multiple name required size', 'option optgroup');\n    add('optgroup', 'disabled label', 'option');\n    add('option', 'disabled label selected value');\n    add('textarea', 'cols dirname disabled form maxlength name readonly required rows wrap');\n    add('menu', 'type label', [flowContent, 'li'].join(' '));\n    add('noscript', '', flowContent);\n\n    if (type !== 'html4') {\n      add('wbr');\n      add('ruby', '', [phrasingContent, 'rt rp'].join(' '));\n      add('figcaption', '', flowContent);\n      add('mark rt rp summary bdi', '', phrasingContent);\n      add('canvas', 'width height', flowContent);\n      add('video', 'src crossorigin poster preload autoplay mediagroup loop ' + 'muted controls width height buffered', [flowContent, 'track source'].join(' '));\n      add('audio', 'src crossorigin preload autoplay mediagroup loop muted controls ' + 'buffered volume', [flowContent, 'track source'].join(' '));\n      add('picture', '', 'img source');\n      add('source', 'src srcset type media sizes');\n      add('track', 'kind src srclang label default');\n      add('datalist', '', [phrasingContent, 'option'].join(' '));\n      add('article section nav aside main header footer', '', flowContent);\n      add('hgroup', '', 'h1 h2 h3 h4 h5 h6');\n      add('figure', '', [flowContent, 'figcaption'].join(' '));\n      add('time', 'datetime', phrasingContent);\n      add('dialog', 'open', flowContent);\n      add('command', 'type label icon disabled checked radiogroup command');\n      add('output', 'for form name', phrasingContent);\n      add('progress', 'value max', phrasingContent);\n      add('meter', 'value min max low high optimum', phrasingContent);\n      add('details', 'open', [flowContent, 'summary'].join(' '));\n      add('keygen', 'autofocus challenge disabled form keytype name');\n    }\n\n    if (type !== 'html5-strict') {\n      addAttrs('script', 'language xml:space');\n      addAttrs('style', 'xml:space');\n      addAttrs('object', 'declare classid code codebase codetype archive standby align border hspace vspace');\n      addAttrs('embed', 'align name hspace vspace');\n      addAttrs('param', 'valuetype type');\n      addAttrs('a', 'charset name rev shape coords');\n      addAttrs('br', 'clear');\n      addAttrs('applet', 'codebase archive code object alt name width height align hspace vspace');\n      addAttrs('img', 'name longdesc align border hspace vspace');\n      addAttrs('iframe', 'longdesc frameborder marginwidth marginheight scrolling align');\n      addAttrs('font basefont', 'size color face');\n      addAttrs('input', 'usemap align');\n      addAttrs('select');\n      addAttrs('textarea');\n      addAttrs('h1 h2 h3 h4 h5 h6 div p legend caption', 'align');\n      addAttrs('ul', 'type compact');\n      addAttrs('li', 'type');\n      addAttrs('ol dl menu dir', 'compact');\n      addAttrs('pre', 'width xml:space');\n      addAttrs('hr', 'align noshade size width');\n      addAttrs('isindex', 'prompt');\n      addAttrs('table', 'summary width frame rules cellspacing cellpadding align bgcolor');\n      addAttrs('col', 'width align char charoff valign');\n      addAttrs('colgroup', 'width align char charoff valign');\n      addAttrs('thead', 'align char charoff valign');\n      addAttrs('tr', 'align char charoff valign bgcolor');\n      addAttrs('th', 'axis align char charoff valign nowrap bgcolor width height');\n      addAttrs('form', 'accept');\n      addAttrs('td', 'abbr axis scope align char charoff valign nowrap bgcolor width height');\n      addAttrs('tfoot', 'align char charoff valign');\n      addAttrs('tbody', 'align char charoff valign');\n      addAttrs('area', 'nohref');\n      addAttrs('body', 'background bgcolor text link vlink alink');\n    }\n\n    if (type !== 'html4') {\n      addAttrs('input button select textarea', 'autofocus');\n      addAttrs('input textarea', 'placeholder');\n      addAttrs('a', 'download');\n      addAttrs('link script img', 'crossorigin');\n      addAttrs('img', 'loading');\n      addAttrs('iframe', 'sandbox seamless allowfullscreen loading');\n    }\n\n    if (type !== 'html4') {\n      each$g([schema.video, schema.audio], item => {\n        delete item.children.audio;\n        delete item.children.video;\n      });\n    }\n\n    each$d(split$1('a form meter progress dfn'), name => {\n      if (schema[name]) {\n        delete schema[name].children[name];\n      }\n    });\n    delete schema.caption.children.table;\n    delete schema.script;\n    mapCache[type] = schema;\n    return schema;\n  };\n\n  const compileElementMap = (value, mode) => {\n    let styles;\n\n    if (value) {\n      styles = {};\n\n      if (typeof value === 'string') {\n        value = {\n          '*': value\n        };\n      }\n\n      each$d(value, (value, key) => {\n        styles[key] = styles[key.toUpperCase()] = mode === 'map' ? makeMap$2(value, /[, ]/) : explode$2(value, /[, ]/);\n      });\n    }\n\n    return styles;\n  };\n\n  const Schema = settings => {\n    var _a;\n\n    const elements = {};\n    const children = {};\n    let patternElements = [];\n    const customElementsMap = {},\n          specialElements = {};\n\n    const createLookupTable = (option, defaultValue, extendWith) => {\n      let value = settings[option];\n\n      if (!value) {\n        value = mapCache[option];\n\n        if (!value) {\n          value = makeMap$2(defaultValue, ' ', makeMap$2(defaultValue.toUpperCase(), ' '));\n          value = extend$2(value, extendWith);\n          mapCache[option] = value;\n        }\n      } else {\n        value = makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));\n      }\n\n      return value;\n    };\n\n    settings = settings || {};\n    const schemaType = (_a = settings.schema) !== null && _a !== void 0 ? _a : 'html5';\n    const schemaItems = compileSchema(schemaType);\n\n    if (settings.verify_html === false) {\n      settings.valid_elements = '*[*]';\n    }\n\n    const validStyles = compileElementMap(settings.valid_styles);\n    const invalidStyles = compileElementMap(settings.invalid_styles, 'map');\n    const validClasses = compileElementMap(settings.valid_classes, 'map');\n    const whitespaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object code');\n    const selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');\n    const voidElementsMap = createLookupTable('void_elements', 'area base basefont br col frame hr img input isindex link ' + 'meta param embed source wbr track');\n    const boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' + 'noshade nowrap readonly selected autoplay loop controls allowfullscreen');\n    const nonEmptyOrMoveCaretBeforeOnEnter = 'td th iframe video audio object script code';\n    const nonEmptyElementsMap = createLookupTable('non_empty_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' pre', voidElementsMap);\n    const moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' table', voidElementsMap);\n    const textBlockElementsMap = createLookupTable('text_block_elements', 'h1 h2 h3 h4 h5 h6 p div address pre form ' + 'blockquote center dir fieldset header footer article section hgroup aside main nav figure');\n    const blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' + 'th tr td li ol ul caption dl dt dd noscript menu isindex option ' + 'datalist select optgroup figcaption details summary', textBlockElementsMap);\n    const textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font strike u var cite ' + 'dfn code mark q sup sub samp');\n    each$d('script noscript iframe noframes noembed title style textarea xmp plaintext'.split(' '), name => {\n      specialElements[name] = new RegExp('</' + name + '[^>]*>', 'gi');\n    });\n\n    const patternToRegExp = str => new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');\n\n    const addValidElements = validElements => {\n      let ei, el, ai, al, matches, element, attr, attrData, elementName, attrName, attrType, attributes, attributesOrder, prefix, outputName, globalAttributes, globalAttributesOrder, value;\n      const elementRuleRegExp = /^([#+\\-])?([^\\[!\\/]+)(?:\\/([^\\[!]+))?(?:(!?)\\[([^\\]]+)])?$/,\n            attrRuleRegExp = /^([!\\-])?(\\w+[\\\\:]:\\w+|[^=~<]+)?(?:([=~<])(.*))?$/,\n            hasPatternsRegExp = /[*?+]/;\n\n      if (validElements) {\n        const validElementsArr = split$1(validElements, ',');\n\n        if (elements['@']) {\n          globalAttributes = elements['@'].attributes;\n          globalAttributesOrder = elements['@'].attributesOrder;\n        }\n\n        for (ei = 0, el = validElementsArr.length; ei < el; ei++) {\n          matches = elementRuleRegExp.exec(validElementsArr[ei]);\n\n          if (matches) {\n            prefix = matches[1];\n            elementName = matches[2];\n            outputName = matches[3];\n            attrData = matches[5];\n            attributes = {};\n            attributesOrder = [];\n            element = {\n              attributes,\n              attributesOrder\n            };\n\n            if (prefix === '#') {\n              element.paddEmpty = true;\n            }\n\n            if (prefix === '-') {\n              element.removeEmpty = true;\n            }\n\n            if (matches[4] === '!') {\n              element.removeEmptyAttrs = true;\n            }\n\n            if (globalAttributes) {\n              each$f(globalAttributes, (value, key) => {\n                attributes[key] = value;\n              });\n              attributesOrder.push.apply(attributesOrder, globalAttributesOrder);\n            }\n\n            if (attrData) {\n              attrData = split$1(attrData, '|');\n\n              for (ai = 0, al = attrData.length; ai < al; ai++) {\n                matches = attrRuleRegExp.exec(attrData[ai]);\n\n                if (matches) {\n                  attr = {};\n                  attrType = matches[1];\n                  attrName = matches[2].replace(/[\\\\:]:/g, ':');\n                  prefix = matches[3];\n                  value = matches[4];\n\n                  if (attrType === '!') {\n                    element.attributesRequired = element.attributesRequired || [];\n                    element.attributesRequired.push(attrName);\n                    attr.required = true;\n                  }\n\n                  if (attrType === '-') {\n                    delete attributes[attrName];\n                    attributesOrder.splice(inArray(attributesOrder, attrName), 1);\n                    continue;\n                  }\n\n                  if (prefix) {\n                    if (prefix === '=') {\n                      element.attributesDefault = element.attributesDefault || [];\n                      element.attributesDefault.push({\n                        name: attrName,\n                        value\n                      });\n                      attr.defaultValue = value;\n                    }\n\n                    if (prefix === '~') {\n                      element.attributesForced = element.attributesForced || [];\n                      element.attributesForced.push({\n                        name: attrName,\n                        value\n                      });\n                      attr.forcedValue = value;\n                    }\n\n                    if (prefix === '<') {\n                      attr.validValues = makeMap$2(value, '?');\n                    }\n                  }\n\n                  if (hasPatternsRegExp.test(attrName)) {\n                    element.attributePatterns = element.attributePatterns || [];\n                    attr.pattern = patternToRegExp(attrName);\n                    element.attributePatterns.push(attr);\n                  } else {\n                    if (!attributes[attrName]) {\n                      attributesOrder.push(attrName);\n                    }\n\n                    attributes[attrName] = attr;\n                  }\n                }\n              }\n            }\n\n            if (!globalAttributes && elementName === '@') {\n              globalAttributes = attributes;\n              globalAttributesOrder = attributesOrder;\n            }\n\n            if (outputName) {\n              element.outputName = elementName;\n              elements[outputName] = element;\n            }\n\n            if (hasPatternsRegExp.test(elementName)) {\n              element.pattern = patternToRegExp(elementName);\n              patternElements.push(element);\n            } else {\n              elements[elementName] = element;\n            }\n          }\n        }\n      }\n    };\n\n    const setValidElements = validElements => {\n      patternElements = [];\n      each$g(keys(elements), name => {\n        delete elements[name];\n      });\n      addValidElements(validElements);\n      each$d(schemaItems, (element, name) => {\n        children[name] = element.children;\n      });\n    };\n\n    const addCustomElements = customElements => {\n      const customElementRegExp = /^(~)?(.+)$/;\n\n      if (customElements) {\n        mapCache.text_block_elements = mapCache.block_elements = null;\n        each$d(split$1(customElements, ','), rule => {\n          const matches = customElementRegExp.exec(rule),\n                inline = matches[1] === '~',\n                cloneName = inline ? 'span' : 'div',\n                name = matches[2];\n          children[name] = children[cloneName];\n          customElementsMap[name] = cloneName;\n\n          if (!inline) {\n            blockElementsMap[name.toUpperCase()] = {};\n            blockElementsMap[name] = {};\n          }\n\n          if (!elements[name]) {\n            let customRule = elements[cloneName];\n            customRule = extend$2({}, customRule);\n            delete customRule.removeEmptyAttrs;\n            delete customRule.removeEmpty;\n            elements[name] = customRule;\n          }\n\n          each$d(children, (element, elmName) => {\n            if (element[cloneName]) {\n              children[elmName] = element = extend$2({}, children[elmName]);\n              element[name] = element[cloneName];\n            }\n          });\n        });\n      }\n    };\n\n    const addValidChildren = validChildren => {\n      const childRuleRegExp = /^([+\\-]?)([A-Za-z0-9_\\-.\\u00b7\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u037d\\u037f-\\u1fff\\u200c-\\u200d\\u203f-\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]+)\\[([^\\]]+)]$/;\n      mapCache[schemaType] = null;\n\n      if (validChildren) {\n        each$d(split$1(validChildren, ','), rule => {\n          const matches = childRuleRegExp.exec(rule);\n          let parent, prefix;\n\n          if (matches) {\n            prefix = matches[1];\n\n            if (prefix) {\n              parent = children[matches[2]];\n            } else {\n              parent = children[matches[2]] = {\n                '#comment': {}\n              };\n            }\n\n            parent = children[matches[2]];\n            each$d(split$1(matches[3], '|'), child => {\n              if (prefix === '-') {\n                delete parent[child];\n              } else {\n                parent[child] = {};\n              }\n            });\n          }\n        });\n      }\n    };\n\n    const getElementRule = name => {\n      let element = elements[name],\n          i;\n\n      if (element) {\n        return element;\n      }\n\n      i = patternElements.length;\n\n      while (i--) {\n        element = patternElements[i];\n\n        if (element.pattern.test(name)) {\n          return element;\n        }\n      }\n    };\n\n    if (!settings.valid_elements) {\n      each$d(schemaItems, (element, name) => {\n        elements[name] = {\n          attributes: element.attributes,\n          attributesOrder: element.attributesOrder\n        };\n        children[name] = element.children;\n      });\n      each$d(split$1('strong/b em/i'), item => {\n        const items = split$1(item, '/');\n        elements[items[1]].outputName = items[0];\n      });\n      each$d(split$1('ol ul sub sup blockquote span font a table tbody strong em b i'), name => {\n        if (elements[name]) {\n          elements[name].removeEmpty = true;\n        }\n      });\n      each$d(split$1('p h1 h2 h3 h4 h5 h6 th td pre div address caption li'), name => {\n        elements[name].paddEmpty = true;\n      });\n      each$d(split$1('span'), name => {\n        elements[name].removeEmptyAttrs = true;\n      });\n    } else {\n      setValidElements(settings.valid_elements);\n    }\n\n    addCustomElements(settings.custom_elements);\n    addValidChildren(settings.valid_children);\n    addValidElements(settings.extended_valid_elements);\n    addValidChildren('+ol[ul|ol],+ul[ul|ol]');\n    each$d({\n      dd: 'dl',\n      dt: 'dl',\n      li: 'ul ol',\n      td: 'tr',\n      th: 'tr',\n      tr: 'tbody thead tfoot',\n      tbody: 'table',\n      thead: 'table',\n      tfoot: 'table',\n      legend: 'fieldset',\n      area: 'map',\n      param: 'video audio object'\n    }, (parents, item) => {\n      if (elements[item]) {\n        elements[item].parentsRequired = split$1(parents);\n      }\n    });\n\n    if (settings.invalid_elements) {\n      each$d(explode$2(settings.invalid_elements), item => {\n        if (elements[item]) {\n          delete elements[item];\n        }\n      });\n    }\n\n    if (!getElementRule('span')) {\n      addValidElements('span[!data-mce-type|*]');\n    }\n\n    const getValidStyles = constant(validStyles);\n    const getInvalidStyles = constant(invalidStyles);\n    const getValidClasses = constant(validClasses);\n    const getBoolAttrs = constant(boolAttrMap);\n    const getBlockElements = constant(blockElementsMap);\n    const getTextBlockElements = constant(textBlockElementsMap);\n    const getTextInlineElements = constant(textInlineElementsMap);\n    const getVoidElements = constant(Object.seal(voidElementsMap));\n    const getSelfClosingElements = constant(selfClosingElementsMap);\n    const getNonEmptyElements = constant(nonEmptyElementsMap);\n    const getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);\n    const getWhitespaceElements = constant(whitespaceElementsMap);\n    const getSpecialElements = constant(Object.seal(specialElements));\n\n    const isValidChild = (name, child) => {\n      const parent = children[name.toLowerCase()];\n      return !!(parent && parent[child.toLowerCase()]);\n    };\n\n    const isValid = (name, attr) => {\n      let attrPatterns, i;\n      const rule = getElementRule(name);\n\n      if (rule) {\n        if (attr) {\n          if (rule.attributes[attr]) {\n            return true;\n          }\n\n          attrPatterns = rule.attributePatterns;\n\n          if (attrPatterns) {\n            i = attrPatterns.length;\n\n            while (i--) {\n              if (attrPatterns[i].pattern.test(attr)) {\n                return true;\n              }\n            }\n          }\n        } else {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    const getCustomElements = constant(customElementsMap);\n    return {\n      type: schemaType,\n      children,\n      elements,\n      getValidStyles,\n      getValidClasses,\n      getBlockElements,\n      getInvalidStyles,\n      getVoidElements,\n      getTextBlockElements,\n      getTextInlineElements,\n      getBoolAttrs,\n      getElementRule,\n      getSelfClosingElements,\n      getNonEmptyElements,\n      getMoveCaretBeforeOnEnterElements,\n      getWhitespaceElements,\n      getSpecialElements,\n      isValidChild,\n      isValid,\n      getCustomElements,\n      addValidElements,\n      setValidElements,\n      addCustomElements,\n      addValidChildren\n    };\n  };\n\n  const Styles = (settings, schema) => {\n    const urlOrStrRegExp = /(?:url(?:(?:\\(\\s*\\\"([^\\\"]+)\\\"\\s*\\))|(?:\\(\\s*\\'([^\\']+)\\'\\s*\\))|(?:\\(\\s*([^)\\s]+)\\s*\\))))|(?:\\'([^\\']+)\\')|(?:\\\"([^\\\"]+)\\\")/gi;\n    const styleRegExp = /\\s*([^:]+):\\s*([^;]+);?/g;\n    const trimRightRegExp = /\\s+$/;\n    let i;\n    const encodingLookup = {};\n    let validStyles;\n    let invalidStyles;\n    const invisibleChar = zeroWidth;\n    settings = settings || {};\n\n    if (schema) {\n      validStyles = schema.getValidStyles();\n      invalidStyles = schema.getInvalidStyles();\n    }\n\n    const encodingItems = (`\\\\\" \\\\' \\\\; \\\\: ; : ` + invisibleChar).split(' ');\n\n    for (i = 0; i < encodingItems.length; i++) {\n      encodingLookup[encodingItems[i]] = invisibleChar + i;\n      encodingLookup[invisibleChar + i] = encodingItems[i];\n    }\n\n    const self = {\n      parse: css => {\n        const styles = {};\n        let matches, name, value, isEncoded;\n        const urlConverter = settings.url_converter;\n        const urlConverterScope = settings.url_converter_scope || self;\n\n        const compress = (prefix, suffix, noJoin) => {\n          const top = styles[prefix + '-top' + suffix];\n\n          if (!top) {\n            return;\n          }\n\n          const right = styles[prefix + '-right' + suffix];\n\n          if (!right) {\n            return;\n          }\n\n          const bottom = styles[prefix + '-bottom' + suffix];\n\n          if (!bottom) {\n            return;\n          }\n\n          const left = styles[prefix + '-left' + suffix];\n\n          if (!left) {\n            return;\n          }\n\n          const box = [top, right, bottom, left];\n          i = box.length - 1;\n\n          while (i--) {\n            if (box[i] !== box[i + 1]) {\n              break;\n            }\n          }\n\n          if (i > -1 && noJoin) {\n            return;\n          }\n\n          styles[prefix + suffix] = i === -1 ? box[0] : box.join(' ');\n          delete styles[prefix + '-top' + suffix];\n          delete styles[prefix + '-right' + suffix];\n          delete styles[prefix + '-bottom' + suffix];\n          delete styles[prefix + '-left' + suffix];\n        };\n\n        const canCompress = key => {\n          let value = styles[key],\n              i;\n\n          if (!value) {\n            return;\n          }\n\n          value = value.split(' ');\n          i = value.length;\n\n          while (i--) {\n            if (value[i] !== value[0]) {\n              return false;\n            }\n          }\n\n          styles[key] = value[0];\n          return true;\n        };\n\n        const compress2 = (target, a, b, c) => {\n          if (!canCompress(a)) {\n            return;\n          }\n\n          if (!canCompress(b)) {\n            return;\n          }\n\n          if (!canCompress(c)) {\n            return;\n          }\n\n          styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];\n          delete styles[a];\n          delete styles[b];\n          delete styles[c];\n        };\n\n        const encode = str => {\n          isEncoded = true;\n          return encodingLookup[str];\n        };\n\n        const decode = (str, keepSlashes) => {\n          if (isEncoded) {\n            str = str.replace(/\\uFEFF[0-9]/g, str => {\n              return encodingLookup[str];\n            });\n          }\n\n          if (!keepSlashes) {\n            str = str.replace(/\\\\([\\'\\\";:])/g, '$1');\n          }\n\n          return str;\n        };\n\n        const decodeSingleHexSequence = escSeq => {\n          return String.fromCharCode(parseInt(escSeq.slice(1), 16));\n        };\n\n        const decodeHexSequences = value => {\n          return value.replace(/\\\\[0-9a-f]+/gi, decodeSingleHexSequence);\n        };\n\n        const processUrl = (match, url, url2, url3, str, str2) => {\n          str = str || str2;\n\n          if (str) {\n            str = decode(str);\n            return `'` + str.replace(/\\'/g, `\\\\'`) + `'`;\n          }\n\n          url = decode(url || url2 || url3);\n\n          if (!settings.allow_script_urls) {\n            const scriptUrl = url.replace(/[\\s\\r\\n]+/g, '');\n\n            if (/(java|vb)script:/i.test(scriptUrl)) {\n              return '';\n            }\n\n            if (!settings.allow_svg_data_urls && /^data:image\\/svg/i.test(scriptUrl)) {\n              return '';\n            }\n          }\n\n          if (urlConverter) {\n            url = urlConverter.call(urlConverterScope, url, 'style');\n          }\n\n          return `url('` + url.replace(/\\'/g, `\\\\'`) + `')`;\n        };\n\n        if (css) {\n          css = css.replace(/[\\u0000-\\u001F]/g, '');\n          css = css.replace(/\\\\[\\\"\\';:\\uFEFF]/g, encode).replace(/\\\"[^\\\"]+\\\"|\\'[^\\']+\\'/g, str => {\n            return str.replace(/[;:]/g, encode);\n          });\n\n          while (matches = styleRegExp.exec(css)) {\n            styleRegExp.lastIndex = matches.index + matches[0].length;\n            name = matches[1].replace(trimRightRegExp, '').toLowerCase();\n            value = matches[2].replace(trimRightRegExp, '');\n\n            if (name && value) {\n              name = decodeHexSequences(name);\n              value = decodeHexSequences(value);\n\n              if (name.indexOf(invisibleChar) !== -1 || name.indexOf('\"') !== -1) {\n                continue;\n              }\n\n              if (!settings.allow_script_urls && (name === 'behavior' || /expression\\s*\\(|\\/\\*|\\*\\//.test(value))) {\n                continue;\n              }\n\n              if (name === 'font-weight' && value === '700') {\n                value = 'bold';\n              } else if (name === 'color' || name === 'background-color') {\n                value = value.toLowerCase();\n              }\n\n              value = value.replace(urlOrStrRegExp, processUrl);\n              styles[name] = isEncoded ? decode(value, true) : value;\n            }\n          }\n\n          compress('border', '', true);\n          compress('border', '-width');\n          compress('border', '-color');\n          compress('border', '-style');\n          compress('padding', '');\n          compress('margin', '');\n          compress2('border', 'border-width', 'border-style', 'border-color');\n\n          if (styles.border === 'medium none') {\n            delete styles.border;\n          }\n\n          if (styles['border-image'] === 'none') {\n            delete styles['border-image'];\n          }\n        }\n\n        return styles;\n      },\n      serialize: (styles, elementName) => {\n        let css = '';\n\n        const serializeStyles = name => {\n          let value;\n          const styleList = validStyles[name];\n\n          if (styleList) {\n            for (let i = 0, l = styleList.length; i < l; i++) {\n              name = styleList[i];\n              value = styles[name];\n\n              if (value) {\n                css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\n              }\n            }\n          }\n        };\n\n        const isValid = (name, elementName) => {\n          let styleMap = invalidStyles['*'];\n\n          if (styleMap && styleMap[name]) {\n            return false;\n          }\n\n          styleMap = invalidStyles[elementName];\n          return !(styleMap && styleMap[name]);\n        };\n\n        if (elementName && validStyles) {\n          serializeStyles('*');\n          serializeStyles(elementName);\n        } else {\n          each$f(styles, (value, name) => {\n            if (value && (!invalidStyles || isValid(name, elementName))) {\n              css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\n            }\n          });\n        }\n\n        return css;\n      }\n    };\n    return self;\n  };\n\n  const deprecated = {\n    keyLocation: true,\n    layerX: true,\n    layerY: true,\n    returnValue: true,\n    webkitMovementX: true,\n    webkitMovementY: true,\n    keyIdentifier: true,\n    mozPressure: true\n  };\n\n  const isNativeEvent = event => event instanceof Event || isFunction(event.initEvent);\n\n  const hasIsDefaultPrevented = event => event.isDefaultPrevented === always || event.isDefaultPrevented === never;\n\n  const needsNormalizing = event => isNullable(event.preventDefault) || isNativeEvent(event);\n\n  const clone$3 = (originalEvent, data) => {\n    const event = data !== null && data !== void 0 ? data : {};\n\n    for (const name in originalEvent) {\n      if (!has$2(deprecated, name)) {\n        event[name] = originalEvent[name];\n      }\n    }\n\n    if (isNonNullable(event.composedPath)) {\n      event.composedPath = () => originalEvent.composedPath();\n    }\n\n    return event;\n  };\n\n  const normalize$3 = (type, originalEvent, fallbackTarget, data) => {\n    var _a;\n\n    const event = clone$3(originalEvent, data);\n    event.type = type;\n\n    if (isNullable(event.target)) {\n      event.target = (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;\n    }\n\n    if (needsNormalizing(originalEvent)) {\n      event.preventDefault = () => {\n        event.defaultPrevented = true;\n        event.isDefaultPrevented = always;\n\n        if (isFunction(originalEvent.preventDefault)) {\n          originalEvent.preventDefault();\n        }\n      };\n\n      event.stopPropagation = () => {\n        event.cancelBubble = true;\n        event.isPropagationStopped = always;\n\n        if (isFunction(originalEvent.stopPropagation)) {\n          originalEvent.stopPropagation();\n        }\n      };\n\n      event.stopImmediatePropagation = () => {\n        event.isImmediatePropagationStopped = always;\n        event.stopPropagation();\n      };\n\n      if (!hasIsDefaultPrevented(event)) {\n        event.isDefaultPrevented = event.defaultPrevented === true ? always : never;\n        event.isPropagationStopped = event.cancelBubble === true ? always : never;\n        event.isImmediatePropagationStopped = never;\n      }\n    }\n\n    return event;\n  };\n\n  const eventExpandoPrefix = 'mce-data-';\n  const mouseEventRe = /^(?:mouse|contextmenu)|click/;\n\n  const addEvent = (target, name, callback, capture) => {\n    if (target.addEventListener) {\n      target.addEventListener(name, callback, capture || false);\n    } else if (target.attachEvent) {\n      target.attachEvent('on' + name, callback);\n    }\n  };\n\n  const removeEvent = (target, name, callback, capture) => {\n    if (target.removeEventListener) {\n      target.removeEventListener(name, callback, capture || false);\n    } else if (target.detachEvent) {\n      target.detachEvent('on' + name, callback);\n    }\n  };\n\n  const isMouseEvent = event => isNonNullable(event) && mouseEventRe.test(event.type);\n\n  const fix = (originalEvent, data) => {\n    const event = normalize$3(originalEvent.type, originalEvent, document, data);\n\n    if (isMouseEvent(originalEvent) && isUndefined(originalEvent.pageX) && !isUndefined(originalEvent.clientX)) {\n      const eventDoc = event.target.ownerDocument || document;\n      const doc = eventDoc.documentElement;\n      const body = eventDoc.body;\n      const mouseEvent = event;\n      mouseEvent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n      mouseEvent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n    }\n\n    return event;\n  };\n\n  const bindOnReady = (win, callback, eventUtils) => {\n    const doc = win.document,\n          event = {\n      type: 'ready'\n    };\n\n    if (eventUtils.domLoaded) {\n      callback(event);\n      return;\n    }\n\n    const isDocReady = () => {\n      return doc.readyState === 'complete' || doc.readyState === 'interactive' && doc.body;\n    };\n\n    const readyHandler = () => {\n      removeEvent(win, 'DOMContentLoaded', readyHandler);\n      removeEvent(win, 'load', readyHandler);\n\n      if (!eventUtils.domLoaded) {\n        eventUtils.domLoaded = true;\n        callback(event);\n      }\n\n      win = null;\n    };\n\n    if (isDocReady()) {\n      readyHandler();\n    } else {\n      addEvent(win, 'DOMContentLoaded', readyHandler);\n    }\n\n    if (!eventUtils.domLoaded) {\n      addEvent(win, 'load', readyHandler);\n    }\n  };\n\n  class EventUtils {\n    constructor() {\n      this.domLoaded = false;\n      this.events = {};\n      this.count = 1;\n      this.expando = eventExpandoPrefix + (+new Date()).toString(32);\n      this.hasMouseEnterLeave = 'onmouseenter' in document.documentElement;\n      this.hasFocusIn = 'onfocusin' in document.documentElement;\n      this.count = 1;\n    }\n\n    bind(target, names, callback, scope) {\n      const self = this;\n      let id, callbackList, i, name, fakeName, nativeHandler, capture;\n      const win = window;\n\n      const defaultNativeHandler = evt => {\n        self.executeHandlers(fix(evt || win.event), id);\n      };\n\n      if (!target || target.nodeType === 3 || target.nodeType === 8) {\n        return;\n      }\n\n      if (!target[self.expando]) {\n        id = self.count++;\n        target[self.expando] = id;\n        self.events[id] = {};\n      } else {\n        id = target[self.expando];\n      }\n\n      scope = scope || target;\n      const namesList = names.split(' ');\n      i = namesList.length;\n\n      while (i--) {\n        name = namesList[i];\n        nativeHandler = defaultNativeHandler;\n        fakeName = capture = false;\n\n        if (name === 'DOMContentLoaded') {\n          name = 'ready';\n        }\n\n        if (self.domLoaded && name === 'ready' && target.readyState === 'complete') {\n          callback.call(scope, fix({\n            type: name\n          }));\n          continue;\n        }\n\n        if (!self.hasMouseEnterLeave) {\n          fakeName = self.mouseEnterLeave[name];\n\n          if (fakeName) {\n            nativeHandler = evt => {\n              const current = evt.currentTarget;\n              let related = evt.relatedTarget;\n\n              if (related && current.contains) {\n                related = current.contains(related);\n              } else {\n                while (related && related !== current) {\n                  related = related.parentNode;\n                }\n              }\n\n              if (!related) {\n                evt = fix(evt || win.event);\n                evt.type = evt.type === 'mouseout' ? 'mouseleave' : 'mouseenter';\n                evt.target = current;\n                self.executeHandlers(evt, id);\n              }\n            };\n          }\n        }\n\n        if (!self.hasFocusIn && (name === 'focusin' || name === 'focusout')) {\n          capture = true;\n          fakeName = name === 'focusin' ? 'focus' : 'blur';\n\n          nativeHandler = evt => {\n            evt = fix(evt || win.event);\n            evt.type = evt.type === 'focus' ? 'focusin' : 'focusout';\n            self.executeHandlers(evt, id);\n          };\n        }\n\n        callbackList = self.events[id][name];\n\n        if (!callbackList) {\n          self.events[id][name] = callbackList = [{\n            func: callback,\n            scope\n          }];\n          callbackList.fakeName = fakeName;\n          callbackList.capture = capture;\n          callbackList.nativeHandler = nativeHandler;\n\n          if (name === 'ready') {\n            bindOnReady(target, nativeHandler, self);\n          } else {\n            addEvent(target, fakeName || name, nativeHandler, capture);\n          }\n        } else {\n          if (name === 'ready' && self.domLoaded) {\n            callback(fix({\n              type: name\n            }));\n          } else {\n            callbackList.push({\n              func: callback,\n              scope\n            });\n          }\n        }\n      }\n\n      target = callbackList = null;\n      return callback;\n    }\n\n    unbind(target, names, callback) {\n      let callbackList, i, ci, name, eventMap;\n\n      if (!target || target.nodeType === 3 || target.nodeType === 8) {\n        return this;\n      }\n\n      const id = target[this.expando];\n\n      if (id) {\n        eventMap = this.events[id];\n\n        if (names) {\n          const namesList = names.split(' ');\n          i = namesList.length;\n\n          while (i--) {\n            name = namesList[i];\n            callbackList = eventMap[name];\n\n            if (callbackList) {\n              if (callback) {\n                ci = callbackList.length;\n\n                while (ci--) {\n                  if (callbackList[ci].func === callback) {\n                    const nativeHandler = callbackList.nativeHandler;\n                    const fakeName = callbackList.fakeName,\n                          capture = callbackList.capture;\n                    callbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));\n                    callbackList.nativeHandler = nativeHandler;\n                    callbackList.fakeName = fakeName;\n                    callbackList.capture = capture;\n                    eventMap[name] = callbackList;\n                  }\n                }\n              }\n\n              if (!callback || callbackList.length === 0) {\n                delete eventMap[name];\n                removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n              }\n            }\n          }\n        } else {\n          each$f(eventMap, (callbackList, name) => {\n            removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n          });\n          eventMap = {};\n        }\n\n        for (name in eventMap) {\n          if (has$2(eventMap, name)) {\n            return this;\n          }\n        }\n\n        delete this.events[id];\n\n        try {\n          delete target[this.expando];\n        } catch (ex) {\n          target[this.expando] = null;\n        }\n      }\n\n      return this;\n    }\n\n    fire(target, name, args) {\n      return this.dispatch(target, name, args);\n    }\n\n    dispatch(target, name, args) {\n      let id;\n\n      if (!target || target.nodeType === 3 || target.nodeType === 8) {\n        return this;\n      }\n\n      const event = fix({\n        type: name,\n        target\n      }, args);\n\n      do {\n        id = target[this.expando];\n\n        if (id) {\n          this.executeHandlers(event, id);\n        }\n\n        target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;\n      } while (target && !event.isPropagationStopped());\n\n      return this;\n    }\n\n    clean(target) {\n      let i, children;\n\n      if (!target || target.nodeType === 3 || target.nodeType === 8) {\n        return this;\n      }\n\n      if (target[this.expando]) {\n        this.unbind(target);\n      }\n\n      if (!target.getElementsByTagName) {\n        target = target.document;\n      }\n\n      if (target && target.getElementsByTagName) {\n        this.unbind(target);\n        children = target.getElementsByTagName('*');\n        i = children.length;\n\n        while (i--) {\n          target = children[i];\n\n          if (target[this.expando]) {\n            this.unbind(target);\n          }\n        }\n      }\n\n      return this;\n    }\n\n    destroy() {\n      this.events = {};\n    }\n\n    cancel(e) {\n      if (e) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n      }\n\n      return false;\n    }\n\n    executeHandlers(evt, id) {\n      const container = this.events[id];\n      const callbackList = container && container[evt.type];\n\n      if (callbackList) {\n        for (let i = 0, l = callbackList.length; i < l; i++) {\n          const callback = callbackList[i];\n\n          if (callback && callback.func.call(callback.scope, evt) === false) {\n            evt.preventDefault();\n          }\n\n          if (evt.isImmediatePropagationStopped()) {\n            return;\n          }\n        }\n      }\n    }\n\n  }\n\n  EventUtils.Event = new EventUtils();\n  const each$c = Tools.each;\n  const grep = Tools.grep;\n  const internalStyleName = 'data-mce-style';\n\n  const legacySetAttribute = (elm, name, value) => {\n    if (isNullable(value) || value === '') {\n      remove$a(elm, name);\n    } else {\n      set$2(elm, name, value);\n    }\n  };\n\n  const setupAttrHooks = (styles, settings, getContext) => {\n    const keepValues = settings.keep_values;\n    const keepUrlHook = {\n      set: (elm, value, name) => {\n        const sugarElm = SugarElement.fromDom(elm);\n\n        if (isFunction(settings.url_converter) && isNonNullable(value)) {\n          value = settings.url_converter.call(settings.url_converter_scope || getContext(), value, name, elm[0]);\n        }\n\n        const internalName = 'data-mce-' + name;\n        legacySetAttribute(sugarElm, internalName, value);\n        legacySetAttribute(sugarElm, name, value);\n      },\n      get: (elm, name) => {\n        const sugarElm = SugarElement.fromDom(elm);\n        return get$9(sugarElm, 'data-mce-' + name) || get$9(sugarElm, name);\n      }\n    };\n    const attrHooks = {\n      style: {\n        set: (elm, value) => {\n          const sugarElm = SugarElement.fromDom(elm);\n\n          if (isObject(value)) {\n            setAll(sugarElm, value);\n            return;\n          }\n\n          if (keepValues) {\n            legacySetAttribute(sugarElm, internalStyleName, value);\n          }\n\n          remove$a(sugarElm, 'style');\n\n          if (isString(value)) {\n            setAll(sugarElm, styles.parse(value));\n          }\n        },\n        get: elm => {\n          const sugarElm = SugarElement.fromDom(elm);\n          const value = get$9(sugarElm, internalStyleName) || get$9(sugarElm, 'style');\n          return styles.serialize(styles.parse(value), name(sugarElm));\n        }\n      }\n    };\n\n    if (keepValues) {\n      attrHooks.href = attrHooks.src = keepUrlHook;\n    }\n\n    return attrHooks;\n  };\n\n  const updateInternalStyleAttr = (styles, elm) => {\n    const rawValue = get$9(elm, 'style');\n    const value = styles.serialize(styles.parse(rawValue), name(elm));\n    legacySetAttribute(elm, internalStyleName, value);\n  };\n\n  const findNodeIndex = (node, normalized) => {\n    let idx = 0,\n        lastNodeType,\n        nodeType;\n\n    if (node) {\n      for (lastNodeType = node.nodeType, node = node.previousSibling; node; node = node.previousSibling) {\n        nodeType = node.nodeType;\n\n        if (normalized && nodeType === 3) {\n          if (nodeType === lastNodeType || !node.nodeValue.length) {\n            continue;\n          }\n        }\n\n        idx++;\n        lastNodeType = nodeType;\n      }\n    }\n\n    return idx;\n  };\n\n  const numericalCssMap = Tools.makeMap('fill-opacity font-weight line-height opacity orphans widows z-index zoom', ' ');\n\n  const camelCaseToHyphens = name => name.replace(/[A-Z]/g, v => '-' + v.toLowerCase());\n\n  const DOMUtils = function (doc) {\n    let settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const addedStyles = {};\n    const win = window;\n    const files = {};\n    let counter = 0;\n    const stdMode = true;\n    const boxModel = true;\n    const styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {\n      contentCssCors: settings.contentCssCors,\n      referrerPolicy: settings.referrerPolicy\n    });\n    const boundEvents = [];\n    const schema = settings.schema ? settings.schema : Schema({});\n    const styles = Styles({\n      url_converter: settings.url_converter,\n      url_converter_scope: settings.url_converter_scope\n    }, settings.schema);\n    const events = settings.ownEvents ? new EventUtils() : EventUtils.Event;\n    const blockElementsMap = schema.getBlockElements();\n\n    const isBlock = node => {\n      if (isString(node)) {\n        return has$2(blockElementsMap, node);\n      } else {\n        return isElement$6(node) && has$2(blockElementsMap, node.nodeName);\n      }\n    };\n\n    const get = elm => elm && doc && isString(elm) ? doc.getElementById(elm) : elm;\n\n    const _get = elm => {\n      const value = get(elm);\n      return isNonNullable(value) ? SugarElement.fromDom(value) : null;\n    };\n\n    const getAttrib = (elm, name, defaultVal) => {\n      let value;\n\n      const $elm = _get(elm);\n\n      if (isNonNullable($elm) && isElement$7($elm)) {\n        const hook = attrHooks[name];\n\n        if (hook && hook.get) {\n          value = hook.get($elm.dom, name);\n        } else {\n          value = get$9($elm, name);\n        }\n      }\n\n      return isNonNullable(value) ? value : defaultVal !== null && defaultVal !== void 0 ? defaultVal : '';\n    };\n\n    const getAttribs = elm => {\n      const node = get(elm);\n      return isNullable(node) ? [] : node.attributes;\n    };\n\n    const setAttrib = (elm, name, value) => {\n      run(elm, e => {\n        if (isElement$6(e)) {\n          const $elm = SugarElement.fromDom(e);\n\n          if (value === '') {\n            value = null;\n          }\n\n          const originalValue = get$9($elm, name);\n          const hook = attrHooks[name];\n\n          if (hook && hook.set) {\n            hook.set($elm.dom, value, name);\n          } else {\n            legacySetAttribute($elm, name, value);\n          }\n\n          if (originalValue !== value && settings.onSetAttrib) {\n            settings.onSetAttrib({\n              attrElm: $elm,\n              attrName: name,\n              attrValue: value\n            });\n          }\n        }\n      });\n    };\n\n    const clone = (node, deep) => {\n      return node.cloneNode(deep);\n    };\n\n    const getRoot = () => settings.root_element || doc.body;\n\n    const getViewPort = argWin => {\n      const vp = getBounds(argWin);\n      return {\n        x: vp.x,\n        y: vp.y,\n        w: vp.width,\n        h: vp.height\n      };\n    };\n\n    const getPos$1 = (elm, rootElm) => getPos(doc.body, get(elm), rootElm);\n\n    const setStyle = (elm, name, value) => {\n      const convertStyleToString = (cssValue, cssName) => {\n        if (isString(cssValue)) {\n          return cssValue;\n        } else if (isNumber(cssValue)) {\n          return has$2(numericalCssMap, cssName) ? cssValue + '' : cssValue + 'px';\n        } else {\n          return map$2(cssValue, convertStyleToString);\n        }\n      };\n\n      const applyStyle = ($elm, cssName, cssValue) => {\n        const normalizedName = camelCaseToHyphens(cssName);\n\n        if (isNullable(cssValue) || cssValue === '') {\n          remove$6($elm, normalizedName);\n        } else {\n          set$1($elm, normalizedName, convertStyleToString(cssValue, normalizedName));\n        }\n      };\n\n      run(elm, e => {\n        const $elm = SugarElement.fromDom(e);\n\n        if (isString(name)) {\n          applyStyle($elm, name, value);\n        } else {\n          each$f(name, (v, n) => {\n            applyStyle($elm, n, v);\n          });\n        }\n\n        if (settings.update_styles) {\n          updateInternalStyleAttr(styles, $elm);\n        }\n      });\n    };\n\n    const setStyles = (elm, stylesArg) => {\n      setStyle(elm, stylesArg);\n    };\n\n    const getStyle = (elm, name, computed) => {\n      const $elm = get(elm);\n\n      if (isNullable($elm) || !isElement$6($elm)) {\n        return undefined;\n      }\n\n      if (computed) {\n        return get$7(SugarElement.fromDom($elm), camelCaseToHyphens(name));\n      } else {\n        name = name.replace(/-(\\D)/g, (a, b) => b.toUpperCase());\n\n        if (name === 'float') {\n          name = 'cssFloat';\n        }\n\n        return $elm.style ? $elm.style[name] : undefined;\n      }\n    };\n\n    const getSize = elm => {\n      let w, h;\n      const $elm = get(elm);\n      w = getStyle($elm, 'width');\n      h = getStyle($elm, 'height');\n\n      if (w.indexOf('px') === -1) {\n        w = 0;\n      }\n\n      if (h.indexOf('px') === -1) {\n        h = 0;\n      }\n\n      return {\n        w: parseInt(w, 10) || $elm.offsetWidth || $elm.clientWidth,\n        h: parseInt(h, 10) || $elm.offsetHeight || $elm.clientHeight\n      };\n    };\n\n    const getRect = elm => {\n      const $elm = get(elm);\n      const pos = getPos$1($elm);\n      const size = getSize($elm);\n      return {\n        x: pos.x,\n        y: pos.y,\n        w: size.w,\n        h: size.h\n      };\n    };\n\n    const is = (elm, selector) => {\n      if (!elm) {\n        return false;\n      }\n\n      const elms = isArray$1(elm) ? elm : [elm];\n      return exists(elms, e => {\n        return is$1(SugarElement.fromDom(e), selector);\n      });\n    };\n\n    const getParents = (elm, selector, root, collect) => {\n      const result = [];\n      let selectorVal;\n      let node = get(elm);\n      collect = collect === undefined;\n      root = root || (getRoot().nodeName !== 'BODY' ? getRoot().parentNode : null);\n\n      if (isString(selector)) {\n        selectorVal = selector;\n\n        if (selector === '*') {\n          selector = isElement$6;\n        } else {\n          selector = node => is(node, selectorVal);\n        }\n      }\n\n      while (node) {\n        if (node === root || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment(node)) {\n          break;\n        }\n\n        if (!selector || selector(node)) {\n          if (collect) {\n            result.push(node);\n          } else {\n            return [node];\n          }\n        }\n\n        node = node.parentNode;\n      }\n\n      return collect ? result : null;\n    };\n\n    const getParent = (node, selector, root) => {\n      const parents = getParents(node, selector, root, false);\n      return parents && parents.length > 0 ? parents[0] : null;\n    };\n\n    const _findSib = (node, selector, name) => {\n      let func = selector;\n\n      if (node) {\n        if (isString(selector)) {\n          func = node => {\n            return is(node, selector);\n          };\n        }\n\n        for (node = node[name]; node; node = node[name]) {\n          if (isFunction(func) && func(node)) {\n            return node;\n          }\n        }\n      }\n\n      return null;\n    };\n\n    const getNext = (node, selector) => _findSib(node, selector, 'nextSibling');\n\n    const getPrev = (node, selector) => _findSib(node, selector, 'previousSibling');\n\n    const select = (selector, scope) => {\n      var _a, _b;\n\n      const elm = (_b = (_a = get(scope)) !== null && _a !== void 0 ? _a : settings.root_element) !== null && _b !== void 0 ? _b : doc;\n      return from(elm.querySelectorAll(selector));\n    };\n\n    const run = function (elm, func, scope) {\n      const context = scope !== null && scope !== void 0 ? scope : this;\n      const node = isString(elm) ? get(elm) : elm;\n\n      if (!node) {\n        return false;\n      }\n\n      if (isArray$1(node) && (node.length || node.length === 0)) {\n        const result = [];\n        each$c(node, (elm, i) => {\n          if (elm) {\n            result.push(func.call(context, isString(elm) ? get(elm) : elm, i));\n          }\n        });\n        return result;\n      } else {\n        return func.call(context, node);\n      }\n    };\n\n    const setAttribs = (elm, attrs) => {\n      run(elm, $elm => {\n        each$f(attrs, (value, name) => {\n          setAttrib($elm, name, value);\n        });\n      });\n    };\n\n    const setHTML = (elm, html) => {\n      run(elm, e => {\n        const $elm = SugarElement.fromDom(e);\n        set($elm, html);\n      });\n    };\n\n    const add = (parentElm, name, attrs, html, create) => run(parentElm, parentElm => {\n      const newElm = isString(name) ? doc.createElement(name) : name;\n\n      if (isNonNullable(attrs)) {\n        setAttribs(newElm, attrs);\n      }\n\n      if (html) {\n        if (!isString(html) && html.nodeType) {\n          newElm.appendChild(html);\n        } else if (isString(html)) {\n          setHTML(newElm, html);\n        }\n      }\n\n      return !create ? parentElm.appendChild(newElm) : newElm;\n    });\n\n    const create = (name, attrs, html) => add(doc.createElement(name), name, attrs, html, true);\n\n    const decode = Entities.decode;\n    const encode = Entities.encodeAllRaw;\n\n    const createHTML = function (name, attrs) {\n      let html = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      let outHtml = '',\n          key;\n      outHtml += '<' + name;\n\n      for (key in attrs) {\n        if (hasNonNullableKey(attrs, key)) {\n          outHtml += ' ' + key + '=\"' + encode(attrs[key]) + '\"';\n        }\n      }\n\n      if (isEmpty$3(html) && has$2(schema.getVoidElements(), name)) {\n        return outHtml + ' />';\n      } else {\n        return outHtml + '>' + html + '</' + name + '>';\n      }\n    };\n\n    const createFragment = html => {\n      let node;\n      const container = doc.createElement('div');\n      const frag = doc.createDocumentFragment();\n      frag.appendChild(container);\n\n      if (html) {\n        container.innerHTML = html;\n      }\n\n      while (node = container.firstChild) {\n        frag.appendChild(node);\n      }\n\n      frag.removeChild(container);\n      return frag;\n    };\n\n    const remove = (node, keepChildren) => {\n      return run(node, n => {\n        const $node = SugarElement.fromDom(n);\n\n        if (keepChildren) {\n          each$g(children($node), child => {\n            if (isText$9(child) && child.dom.length === 0) {\n              remove$5(child);\n            } else {\n              before$3($node, child);\n            }\n          });\n        }\n\n        remove$5($node);\n        return $node.dom;\n      });\n    };\n\n    const removeAllAttribs = e => run(e, e => {\n      const attrs = e.attributes;\n\n      for (let i = attrs.length - 1; i >= 0; i--) {\n        e.removeAttributeNode(attrs.item(i));\n      }\n    });\n\n    const parseStyle = cssText => styles.parse(cssText);\n\n    const serializeStyle = (stylesArg, name) => styles.serialize(stylesArg, name);\n\n    const addStyle = cssText => {\n      let head, styleElm;\n\n      if (self !== DOMUtils.DOM && doc === document) {\n        if (addedStyles[cssText]) {\n          return;\n        }\n\n        addedStyles[cssText] = true;\n      }\n\n      styleElm = doc.getElementById('mceDefaultStyles');\n\n      if (!styleElm) {\n        styleElm = doc.createElement('style');\n        styleElm.id = 'mceDefaultStyles';\n        styleElm.type = 'text/css';\n        head = doc.getElementsByTagName('head')[0];\n\n        if (head.firstChild) {\n          head.insertBefore(styleElm, head.firstChild);\n        } else {\n          head.appendChild(styleElm);\n        }\n      }\n\n      if (styleElm.styleSheet) {\n        styleElm.styleSheet.cssText += cssText;\n      } else {\n        styleElm.appendChild(doc.createTextNode(cssText));\n      }\n    };\n\n    const loadCSS = urls => {\n      if (!urls) {\n        urls = '';\n      }\n\n      each$g(urls.split(','), url => {\n        files[url] = true;\n        styleSheetLoader.load(url).catch(noop);\n      });\n    };\n\n    const toggleClass = (elm, cls, state) => {\n      run(elm, e => {\n        if (isElement$6(e)) {\n          const $elm = SugarElement.fromDom(e);\n          const classes = cls.split(' ');\n          each$g(classes, c => {\n            if (isNonNullable(state)) {\n              const fn = state ? add$2 : remove$7;\n              fn($elm, c);\n            } else {\n              toggle$1($elm, c);\n            }\n          });\n        }\n      });\n    };\n\n    const addClass = (elm, cls) => {\n      toggleClass(elm, cls, true);\n    };\n\n    const removeClass = (elm, cls) => {\n      toggleClass(elm, cls, false);\n    };\n\n    const hasClass = (elm, cls) => {\n      const $elm = _get(elm);\n\n      const classes = cls.split(' ');\n      return forall(classes, c => has($elm, c));\n    };\n\n    const show = elm => {\n      run(elm, e => remove$6(SugarElement.fromDom(e), 'display'));\n    };\n\n    const hide = elm => {\n      run(elm, e => set$1(SugarElement.fromDom(e), 'display', 'none'));\n    };\n\n    const isHidden = elm => {\n      const $elm = _get(elm);\n\n      return is$2(getRaw$1($elm, 'display'), 'none');\n    };\n\n    const uniqueId = prefix => (!prefix ? 'mce_' : prefix) + counter++;\n\n    const getOuterHTML = elm => {\n      const $elm = _get(elm);\n\n      return isElement$6($elm.dom) ? $elm.dom.outerHTML : getOuter($elm);\n    };\n\n    const setOuterHTML = (elm, html) => {\n      run(elm, $elm => {\n        if (isElement$6($elm)) {\n          $elm.outerHTML = html;\n        }\n      });\n    };\n\n    const insertAfter = (node, reference) => {\n      const referenceNode = get(reference);\n      return run(node, node => {\n        const parent = referenceNode.parentNode;\n        const nextSibling = referenceNode.nextSibling;\n\n        if (nextSibling) {\n          parent.insertBefore(node, nextSibling);\n        } else {\n          parent.appendChild(node);\n        }\n\n        return node;\n      });\n    };\n\n    const replace = (newElm, oldElm, keepChildren) => run(oldElm, oldElm => {\n      if (isArray$1(oldElm)) {\n        newElm = newElm.cloneNode(true);\n      }\n\n      if (keepChildren) {\n        each$c(grep(oldElm.childNodes), node => {\n          newElm.appendChild(node);\n        });\n      }\n\n      return oldElm.parentNode.replaceChild(newElm, oldElm);\n    });\n\n    const rename = (elm, name) => {\n      let newElm;\n\n      if (elm.nodeName !== name.toUpperCase()) {\n        newElm = create(name);\n        each$c(getAttribs(elm), attrNode => {\n          setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));\n        });\n        replace(newElm, elm, true);\n      }\n\n      return newElm || elm;\n    };\n\n    const findCommonAncestor = (a, b) => {\n      let ps = a,\n          pe;\n\n      while (ps) {\n        pe = b;\n\n        while (pe && ps !== pe) {\n          pe = pe.parentNode;\n        }\n\n        if (ps === pe) {\n          break;\n        }\n\n        ps = ps.parentNode;\n      }\n\n      if (!ps && a.ownerDocument) {\n        return a.ownerDocument.documentElement;\n      }\n\n      return ps;\n    };\n\n    const isNonEmptyElement = node => {\n      if (isElement$6(node)) {\n        const isNamedAnchor = node.nodeName.toLowerCase() === 'a' && !getAttrib(node, 'href') && getAttrib(node, 'id');\n\n        if (getAttrib(node, 'name') || getAttrib(node, 'data-mce-bookmark') || isNamedAnchor) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    const isEmpty = (node, elements) => {\n      let type,\n          name,\n          brCount = 0;\n\n      if (isNonEmptyElement(node)) {\n        return false;\n      }\n\n      node = node.firstChild;\n\n      if (node) {\n        const walker = new DomTreeWalker(node, node.parentNode);\n        const whitespace = schema ? schema.getWhitespaceElements() : {};\n        elements = elements || (schema ? schema.getNonEmptyElements() : null);\n\n        do {\n          type = node.nodeType;\n\n          if (isElement$6(node)) {\n            const bogusVal = node.getAttribute('data-mce-bogus');\n\n            if (bogusVal) {\n              node = walker.next(bogusVal === 'all');\n              continue;\n            }\n\n            name = node.nodeName.toLowerCase();\n\n            if (elements && elements[name]) {\n              if (name === 'br') {\n                brCount++;\n                node = walker.next();\n                continue;\n              }\n\n              return false;\n            }\n\n            if (isNonEmptyElement(node)) {\n              return false;\n            }\n          }\n\n          if (type === 8) {\n            return false;\n          }\n\n          if (type === 3 && !isWhitespaceText(node.nodeValue)) {\n            return false;\n          }\n\n          if (type === 3 && node.parentNode && whitespace[node.parentNode.nodeName] && isWhitespaceText(node.nodeValue)) {\n            return false;\n          }\n\n          node = walker.next();\n        } while (node);\n      }\n\n      return brCount <= 1;\n    };\n\n    const createRng = () => doc.createRange();\n\n    const split = (parentElm, splitElm, replacementElm) => {\n      let range = createRng();\n      let beforeFragment;\n      let afterFragment;\n      let parentNode;\n\n      if (parentElm && splitElm) {\n        range.setStart(parentElm.parentNode, findNodeIndex(parentElm));\n        range.setEnd(splitElm.parentNode, findNodeIndex(splitElm));\n        beforeFragment = range.extractContents();\n        range = createRng();\n        range.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);\n        range.setEnd(parentElm.parentNode, findNodeIndex(parentElm) + 1);\n        afterFragment = range.extractContents();\n        parentNode = parentElm.parentNode;\n        parentNode.insertBefore(trimNode(self, beforeFragment), parentElm);\n\n        if (replacementElm) {\n          parentNode.insertBefore(replacementElm, parentElm);\n        } else {\n          parentNode.insertBefore(splitElm, parentElm);\n        }\n\n        parentNode.insertBefore(trimNode(self, afterFragment), parentElm);\n        remove(parentElm);\n        return replacementElm || splitElm;\n      }\n    };\n\n    const bind = (target, name, func, scope) => {\n      if (isArray$1(target)) {\n        let i = target.length;\n        const rv = [];\n\n        while (i--) {\n          rv[i] = bind(target[i], name, func, scope);\n        }\n\n        return rv;\n      } else {\n        if (settings.collect && (target === doc || target === win)) {\n          boundEvents.push([target, name, func, scope]);\n        }\n\n        return events.bind(target, name, func, scope || self);\n      }\n    };\n\n    const unbind = (target, name, func) => {\n      if (isArray$1(target)) {\n        let i = target.length;\n        const rv = [];\n\n        while (i--) {\n          rv[i] = unbind(target[i], name, func);\n        }\n\n        return rv;\n      } else {\n        if (boundEvents.length > 0 && (target === doc || target === win)) {\n          let i = boundEvents.length;\n\n          while (i--) {\n            const item = boundEvents[i];\n\n            if (target === item[0] && (!name || name === item[1]) && (!func || func === item[2])) {\n              events.unbind(item[0], item[1], item[2]);\n            }\n          }\n        }\n\n        return events.unbind(target, name, func);\n      }\n    };\n\n    const dispatch = (target, name, evt) => events.dispatch(target, name, evt);\n\n    const fire = (target, name, evt) => events.dispatch(target, name, evt);\n\n    const getContentEditable = node => {\n      if (node && isElement$6(node)) {\n        const contentEditable = node.getAttribute('data-mce-contenteditable');\n\n        if (contentEditable && contentEditable !== 'inherit') {\n          return contentEditable;\n        }\n\n        return node.contentEditable !== 'inherit' ? node.contentEditable : null;\n      } else {\n        return null;\n      }\n    };\n\n    const getContentEditableParent = node => {\n      const root = getRoot();\n      let state = null;\n\n      for (; node && node !== root; node = node.parentNode) {\n        state = getContentEditable(node);\n\n        if (state !== null) {\n          break;\n        }\n      }\n\n      return state;\n    };\n\n    const destroy = () => {\n      if (boundEvents.length > 0) {\n        let i = boundEvents.length;\n\n        while (i--) {\n          const item = boundEvents[i];\n          events.unbind(item[0], item[1], item[2]);\n        }\n      }\n\n      each$f(files, (_, url) => {\n        styleSheetLoader.unload(url);\n        delete files[url];\n      });\n    };\n\n    const isChildOf = (node, parent) => {\n      return node === parent || parent.contains(node);\n    };\n\n    const dumpRng = r => 'startContainer: ' + r.startContainer.nodeName + ', startOffset: ' + r.startOffset + ', endContainer: ' + r.endContainer.nodeName + ', endOffset: ' + r.endOffset;\n\n    const self = {\n      doc,\n      settings,\n      win,\n      files,\n      stdMode,\n      boxModel,\n      styleSheetLoader,\n      boundEvents,\n      styles,\n      schema,\n      events,\n      isBlock,\n      root: null,\n      clone,\n      getRoot,\n      getViewPort,\n      getRect,\n      getSize,\n      getParent,\n      getParents,\n      get,\n      getNext,\n      getPrev,\n      select,\n      is,\n      add,\n      create,\n      createHTML,\n      createFragment,\n      remove,\n      setStyle,\n      getStyle,\n      setStyles,\n      removeAllAttribs,\n      setAttrib,\n      setAttribs,\n      getAttrib,\n      getPos: getPos$1,\n      parseStyle,\n      serializeStyle,\n      addStyle,\n      loadCSS,\n      addClass,\n      removeClass,\n      hasClass,\n      toggleClass,\n      show,\n      hide,\n      isHidden,\n      uniqueId,\n      setHTML,\n      getOuterHTML,\n      setOuterHTML,\n      decode,\n      encode,\n      insertAfter,\n      replace,\n      rename,\n      findCommonAncestor,\n      run,\n      getAttribs,\n      isEmpty,\n      createRng,\n      nodeIndex: findNodeIndex,\n      split,\n      bind: bind,\n      unbind: unbind,\n      fire,\n      dispatch,\n      getContentEditable,\n      getContentEditableParent,\n      destroy,\n      isChildOf,\n      dumpRng\n    };\n    const attrHooks = setupAttrHooks(styles, settings, constant(self));\n    return self;\n  };\n\n  DOMUtils.DOM = DOMUtils(document);\n  DOMUtils.nodeIndex = findNodeIndex;\n  const DOM$b = DOMUtils.DOM;\n  const QUEUED = 0;\n  const LOADING = 1;\n  const LOADED = 2;\n  const FAILED = 3;\n\n  class ScriptLoader {\n    constructor() {\n      let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.states = {};\n      this.queue = [];\n      this.scriptLoadedCallbacks = {};\n      this.queueLoadedCallbacks = [];\n      this.loading = false;\n      this.settings = settings;\n    }\n\n    _setReferrerPolicy(referrerPolicy) {\n      this.settings.referrerPolicy = referrerPolicy;\n    }\n\n    loadScript(url) {\n      return new Promise((resolve, reject) => {\n        const dom = DOM$b;\n        let elm;\n\n        const cleanup = () => {\n          dom.remove(id);\n\n          if (elm) {\n            elm.onerror = elm.onload = elm = null;\n          }\n        };\n\n        const done = () => {\n          cleanup();\n          resolve();\n        };\n\n        const error = () => {\n          cleanup();\n          reject('Failed to load script: ' + url);\n        };\n\n        const id = dom.uniqueId();\n        elm = document.createElement('script');\n        elm.id = id;\n        elm.type = 'text/javascript';\n        elm.src = Tools._addCacheSuffix(url);\n\n        if (this.settings.referrerPolicy) {\n          dom.setAttrib(elm, 'referrerpolicy', this.settings.referrerPolicy);\n        }\n\n        elm.onload = done;\n        elm.onerror = error;\n        (document.getElementsByTagName('head')[0] || document.body).appendChild(elm);\n      });\n    }\n\n    isDone(url) {\n      return this.states[url] === LOADED;\n    }\n\n    markDone(url) {\n      this.states[url] = LOADED;\n    }\n\n    add(url) {\n      const self = this;\n      self.queue.push(url);\n      const state = self.states[url];\n\n      if (state === undefined) {\n        self.states[url] = QUEUED;\n      }\n\n      return new Promise((resolve, reject) => {\n        if (!self.scriptLoadedCallbacks[url]) {\n          self.scriptLoadedCallbacks[url] = [];\n        }\n\n        self.scriptLoadedCallbacks[url].push({\n          resolve,\n          reject\n        });\n      });\n    }\n\n    load(url) {\n      return this.add(url);\n    }\n\n    remove(url) {\n      delete this.states[url];\n      delete this.scriptLoadedCallbacks[url];\n    }\n\n    loadQueue() {\n      const queue = this.queue;\n      this.queue = [];\n      return this.loadScripts(queue);\n    }\n\n    loadScripts(scripts) {\n      const self = this;\n\n      const execCallbacks = (name, url) => {\n        get$a(self.scriptLoadedCallbacks, url).each(callbacks => {\n          each$g(callbacks, callback => callback[name](url));\n        });\n        delete self.scriptLoadedCallbacks[url];\n      };\n\n      const processResults = results => {\n        const failures = filter$6(results, result => result.status === 'rejected');\n\n        if (failures.length > 0) {\n          return Promise.reject(bind$3(failures, _ref2 => {\n            let {\n              reason\n            } = _ref2;\n            return isArray$1(reason) ? reason : [reason];\n          }));\n        } else {\n          return Promise.resolve();\n        }\n      };\n\n      const load = urls => Promise.allSettled(map$3(urls, url => {\n        if (self.states[url] === LOADED) {\n          execCallbacks('resolve', url);\n          return Promise.resolve();\n        } else if (self.states[url] === FAILED) {\n          execCallbacks('reject', url);\n          return Promise.reject(url);\n        } else {\n          self.states[url] = LOADING;\n          return self.loadScript(url).then(() => {\n            self.states[url] = LOADED;\n            execCallbacks('resolve', url);\n            const queue = self.queue;\n\n            if (queue.length > 0) {\n              self.queue = [];\n              return load(queue).then(processResults);\n            }\n          }, () => {\n            self.states[url] = FAILED;\n            execCallbacks('reject', url);\n            return Promise.reject(url);\n          });\n        }\n      }));\n\n      const processQueue = urls => {\n        self.loading = true;\n        return load(urls).then(results => {\n          self.loading = false;\n          const nextQueuedItem = self.queueLoadedCallbacks.shift();\n          Optional.from(nextQueuedItem).each(call);\n          return processResults(results);\n        });\n      };\n\n      const uniqueScripts = stringArray(scripts);\n\n      if (self.loading) {\n        return new Promise((resolve, reject) => {\n          self.queueLoadedCallbacks.push(() => processQueue(uniqueScripts).then(resolve, reject));\n        });\n      } else {\n        return processQueue(uniqueScripts);\n      }\n    }\n\n  }\n\n  ScriptLoader.ScriptLoader = new ScriptLoader();\n\n  const Cell = initial => {\n    let value = initial;\n\n    const get = () => {\n      return value;\n    };\n\n    const set = v => {\n      value = v;\n    };\n\n    return {\n      get,\n      set\n    };\n  };\n\n  const isRaw = str => isObject(str) && has$2(str, 'raw');\n\n  const isTokenised = str => isArray$1(str) && str.length > 1;\n\n  const data = {};\n  const currentCode = Cell('en');\n\n  const getLanguageData = () => get$a(data, currentCode.get());\n\n  const getData$1 = () => map$2(data, value => ({ ...value\n  }));\n\n  const setCode = newCode => {\n    if (newCode) {\n      currentCode.set(newCode);\n    }\n  };\n\n  const getCode = () => currentCode.get();\n\n  const add$1 = (code, items) => {\n    let langData = data[code];\n\n    if (!langData) {\n      data[code] = langData = {};\n    }\n\n    each$f(items, (translation, name) => {\n      langData[name.toLowerCase()] = translation;\n    });\n  };\n\n  const translate = text => {\n    const langData = getLanguageData().getOr({});\n\n    const toString = obj => {\n      if (isFunction(obj)) {\n        return Object.prototype.toString.call(obj);\n      }\n\n      return !isEmpty(obj) ? '' + obj : '';\n    };\n\n    const isEmpty = text => text === '' || text === null || text === undefined;\n\n    const getLangData = text => {\n      const textstr = toString(text);\n      return get$a(langData, textstr.toLowerCase()).map(toString).getOr(textstr);\n    };\n\n    const removeContext = str => str.replace(/{context:\\w+}$/, '');\n\n    if (isEmpty(text)) {\n      return '';\n    }\n\n    if (isRaw(text)) {\n      return toString(text.raw);\n    }\n\n    if (isTokenised(text)) {\n      const values = text.slice(1);\n      const substitued = getLangData(text[0]).replace(/\\{([0-9]+)\\}/g, ($1, $2) => has$2(values, $2) ? toString(values[$2]) : $1);\n      return removeContext(substitued);\n    }\n\n    return removeContext(getLangData(text));\n  };\n\n  const isRtl$1 = () => getLanguageData().bind(items => get$a(items, '_dir')).exists(dir => dir === 'rtl');\n\n  const hasCode = code => has$2(data, code);\n\n  const I18n = {\n    getData: getData$1,\n    setCode,\n    getCode,\n    add: add$1,\n    translate,\n    isRtl: isRtl$1,\n    hasCode\n  };\n\n  const AddOnManager = () => {\n    const items = [];\n    const urls = {};\n    const lookup = {};\n    const _listeners = [];\n\n    const runListeners = (name, state) => {\n      const matchedListeners = filter$6(_listeners, listener => listener.name === name && listener.state === state);\n      each$g(matchedListeners, listener => listener.resolve());\n    };\n\n    const isLoaded = name => has$2(urls, name);\n\n    const isAdded = name => has$2(lookup, name);\n\n    const get = name => {\n      if (lookup[name]) {\n        return lookup[name].instance;\n      }\n\n      return undefined;\n    };\n\n    const loadLanguagePack = (name, languages) => {\n      const language = I18n.getCode();\n      const wrappedLanguages = ',' + (languages || '') + ',';\n\n      if (!language || languages && wrappedLanguages.indexOf(',' + language + ',') === -1) {\n        return;\n      }\n\n      ScriptLoader.ScriptLoader.add(urls[name] + '/langs/' + language + '.js');\n    };\n\n    const requireLangPack = (name, languages) => {\n      if (AddOnManager.languageLoad !== false) {\n        if (isLoaded(name)) {\n          loadLanguagePack(name, languages);\n        } else {\n          waitFor(name, 'loaded').then(() => loadLanguagePack(name, languages));\n        }\n      }\n    };\n\n    const add = (id, addOn) => {\n      items.push(addOn);\n      lookup[id] = {\n        instance: addOn\n      };\n      runListeners(id, 'added');\n      return addOn;\n    };\n\n    const remove = name => {\n      delete urls[name];\n      delete lookup[name];\n    };\n\n    const createUrl = (baseUrl, dep) => {\n      if (isString(dep)) {\n        return isString(baseUrl) ? {\n          prefix: '',\n          resource: dep,\n          suffix: ''\n        } : {\n          prefix: baseUrl.prefix,\n          resource: dep,\n          suffix: baseUrl.suffix\n        };\n      } else {\n        return dep;\n      }\n    };\n\n    const load = (name, addOnUrl) => {\n      if (urls[name]) {\n        return Promise.resolve();\n      }\n\n      let urlString = isString(addOnUrl) ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;\n\n      if (urlString.indexOf('/') !== 0 && urlString.indexOf('://') === -1) {\n        urlString = AddOnManager.baseURL + '/' + urlString;\n      }\n\n      urls[name] = urlString.substring(0, urlString.lastIndexOf('/'));\n\n      const done = () => {\n        runListeners(name, 'loaded');\n        return Promise.resolve();\n      };\n\n      if (lookup[name]) {\n        return done();\n      } else {\n        return ScriptLoader.ScriptLoader.add(urlString).then(done);\n      }\n    };\n\n    const waitFor = function (name) {\n      let state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'added';\n\n      if (state === 'added' && isAdded(name)) {\n        return Promise.resolve();\n      } else if (state === 'loaded' && isLoaded(name)) {\n        return Promise.resolve();\n      } else {\n        return new Promise(resolve => {\n          _listeners.push({\n            name,\n            state,\n            resolve\n          });\n        });\n      }\n    };\n\n    return {\n      items,\n      urls,\n      lookup,\n      get,\n      requireLangPack,\n      add,\n      remove,\n      createUrl,\n      load,\n      waitFor\n    };\n  };\n\n  AddOnManager.languageLoad = true;\n  AddOnManager.baseURL = '';\n  AddOnManager.PluginManager = AddOnManager();\n  AddOnManager.ThemeManager = AddOnManager();\n  AddOnManager.ModelManager = AddOnManager();\n\n  const singleton = doRevoke => {\n    const subject = Cell(Optional.none());\n\n    const revoke = () => subject.get().each(doRevoke);\n\n    const clear = () => {\n      revoke();\n      subject.set(Optional.none());\n    };\n\n    const isSet = () => subject.get().isSome();\n\n    const get = () => subject.get();\n\n    const set = s => {\n      revoke();\n      subject.set(Optional.some(s));\n    };\n\n    return {\n      clear,\n      isSet,\n      get,\n      set\n    };\n  };\n\n  const value$2 = () => {\n    const subject = singleton(noop);\n\n    const on = f => subject.get().each(f);\n\n    return { ...subject,\n      on\n    };\n  };\n\n  const first$1 = (fn, rate) => {\n    let timer = null;\n\n    const cancel = () => {\n      if (!isNull(timer)) {\n        clearTimeout(timer);\n        timer = null;\n      }\n    };\n\n    const throttle = function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n\n      if (isNull(timer)) {\n        timer = setTimeout(() => {\n          timer = null;\n          fn.apply(null, args);\n        }, rate);\n      }\n    };\n\n    return {\n      cancel,\n      throttle\n    };\n  };\n\n  const last$1 = (fn, rate) => {\n    let timer = null;\n\n    const cancel = () => {\n      if (!isNull(timer)) {\n        clearTimeout(timer);\n        timer = null;\n      }\n    };\n\n    const throttle = function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n\n      cancel();\n      timer = setTimeout(() => {\n        timer = null;\n        fn.apply(null, args);\n      }, rate);\n    };\n\n    return {\n      cancel,\n      throttle\n    };\n  };\n\n  const descendants$1 = (scope, predicate) => {\n    let result = [];\n    each$g(children(scope), x => {\n      if (predicate(x)) {\n        result = result.concat([x]);\n      }\n\n      result = result.concat(descendants$1(x, predicate));\n    });\n    return result;\n  };\n\n  const descendants = (scope, selector) => all(selector, scope);\n\n  const annotation = constant('mce-annotation');\n  const dataAnnotation = constant('data-mce-annotation');\n  const dataAnnotationId = constant('data-mce-annotation-uid');\n  const dataAnnotationActive = constant('data-mce-annotation-active');\n\n  const identify = (editor, annotationName) => {\n    const rng = editor.selection.getRng();\n    const start = SugarElement.fromDom(rng.startContainer);\n    const root = SugarElement.fromDom(editor.getBody());\n    const selector = annotationName.fold(() => '.' + annotation(), an => `[${dataAnnotation()}=\"${an}\"]`);\n    const newStart = child$1(start, rng.startOffset).getOr(start);\n    const closest = closest$3(newStart, selector, n => eq(n, root));\n\n    const getAttr = (c, property) => {\n      if (has$1(c, property)) {\n        return Optional.some(get$9(c, property));\n      } else {\n        return Optional.none();\n      }\n    };\n\n    return closest.bind(c => getAttr(c, `${dataAnnotationId()}`).bind(uid => getAttr(c, `${dataAnnotation()}`).map(name => {\n      const elements = findMarkers(editor, uid);\n      return {\n        uid,\n        name,\n        elements\n      };\n    })));\n  };\n\n  const isAnnotation = elem => isElement$7(elem) && has(elem, annotation());\n\n  const findMarkers = (editor, uid) => {\n    const body = SugarElement.fromDom(editor.getBody());\n    return descendants(body, `[${dataAnnotationId()}=\"${uid}\"]`);\n  };\n\n  const findAll = (editor, name) => {\n    const body = SugarElement.fromDom(editor.getBody());\n    const markers = descendants(body, `[${dataAnnotation()}=\"${name}\"]`);\n    const directory = {};\n    each$g(markers, m => {\n      const uid = get$9(m, dataAnnotationId());\n      const nodesAlready = get$a(directory, uid).getOr([]);\n      directory[uid] = nodesAlready.concat([m]);\n    });\n    return directory;\n  };\n\n  const setup$x = (editor, registry) => {\n    const changeCallbacks = Cell({});\n\n    const initData = () => ({\n      listeners: [],\n      previous: value$2()\n    });\n\n    const withCallbacks = (name, f) => {\n      updateCallbacks(name, data => {\n        f(data);\n        return data;\n      });\n    };\n\n    const updateCallbacks = (name, f) => {\n      const callbackMap = changeCallbacks.get();\n      const data = get$a(callbackMap, name).getOrThunk(initData);\n      const outputData = f(data);\n      callbackMap[name] = outputData;\n      changeCallbacks.set(callbackMap);\n    };\n\n    const fireCallbacks = (name, uid, elements) => {\n      withCallbacks(name, data => {\n        each$g(data.listeners, f => f(true, name, {\n          uid,\n          nodes: map$3(elements, elem => elem.dom)\n        }));\n      });\n    };\n\n    const fireNoAnnotation = name => {\n      withCallbacks(name, data => {\n        each$g(data.listeners, f => f(false, name));\n      });\n    };\n\n    const toggleActiveAttr = (uid, state) => {\n      each$g(findMarkers(editor, uid), span => {\n        if (state) {\n          set$2(span, dataAnnotationActive(), 'true');\n        } else {\n          remove$a(span, dataAnnotationActive());\n        }\n      });\n    };\n\n    const onNodeChange = last$1(() => {\n      const annotations = sort(registry.getNames());\n      each$g(annotations, name => {\n        updateCallbacks(name, data => {\n          const prev = data.previous.get();\n          identify(editor, Optional.some(name)).fold(() => {\n            prev.each(uid => {\n              fireNoAnnotation(name);\n              data.previous.clear();\n              toggleActiveAttr(uid, false);\n            });\n          }, _ref3 => {\n            let {\n              uid,\n              name,\n              elements\n            } = _ref3;\n\n            if (!is$2(prev, uid)) {\n              prev.each(uid => toggleActiveAttr(uid, false));\n              fireCallbacks(name, uid, elements);\n              data.previous.set(uid);\n              toggleActiveAttr(uid, true);\n            }\n          });\n          return {\n            previous: data.previous,\n            listeners: data.listeners\n          };\n        });\n      });\n    }, 30);\n    editor.on('remove', () => {\n      onNodeChange.cancel();\n    });\n    editor.on('NodeChange', () => {\n      onNodeChange.throttle();\n    });\n\n    const addListener = (name, f) => {\n      updateCallbacks(name, data => ({\n        previous: data.previous,\n        listeners: data.listeners.concat([f])\n      }));\n    };\n\n    return {\n      addListener\n    };\n  };\n\n  const setup$w = (editor, registry) => {\n    const identifyParserNode = span => Optional.from(span.attr(dataAnnotation())).bind(registry.lookup);\n\n    editor.serializer.addTempAttr(dataAnnotationActive());\n    editor.serializer.addNodeFilter('span', spans => {\n      each$g(spans, span => {\n        identifyParserNode(span).each(settings => {\n          if (settings.persistent === false) {\n            span.unwrap();\n          }\n        });\n      });\n    });\n  };\n\n  const create$b = () => {\n    const annotations = {};\n\n    const register = (name, settings) => {\n      annotations[name] = {\n        name,\n        settings\n      };\n    };\n\n    const lookup = name => get$a(annotations, name).map(a => a.settings);\n\n    const getNames = () => keys(annotations);\n\n    return {\n      register,\n      lookup,\n      getNames\n    };\n  };\n\n  let unique = 0;\n\n  const generate$1 = prefix => {\n    const date = new Date();\n    const time = date.getTime();\n    const random = Math.floor(Math.random() * 1000000000);\n    unique++;\n    return prefix + '_' + random + unique + String(time);\n  };\n\n  const add = (element, classes) => {\n    each$g(classes, x => {\n      add$2(element, x);\n    });\n  };\n\n  const clone$2 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));\n\n  const shallow$1 = original => clone$2(original, false);\n\n  const deep$1 = original => clone$2(original, true);\n\n  const shallowAs = (original, tag) => {\n    const nu = SugarElement.fromTag(tag);\n    const attributes = clone$4(original);\n    setAll$1(nu, attributes);\n    return nu;\n  };\n\n  const mutate = (original, tag) => {\n    const nu = shallowAs(original, tag);\n    after$4(original, nu);\n    const children$1 = children(original);\n    append(nu, children$1);\n    remove$5(original);\n    return nu;\n  };\n\n  const TextWalker = function (startNode, rootNode) {\n    let isBoundary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : never;\n    const walker = new DomTreeWalker(startNode, rootNode);\n\n    const walk = direction => {\n      let next;\n\n      do {\n        next = walker[direction]();\n      } while (next && !isText$8(next) && !isBoundary(next));\n\n      return Optional.from(next).filter(isText$8);\n    };\n\n    return {\n      current: () => Optional.from(walker.current()).filter(isText$8),\n      next: () => walk('next'),\n      prev: () => walk('prev'),\n      prev2: () => walk('prev2')\n    };\n  };\n\n  const TextSeeker = (dom, isBoundary) => {\n    const isBlockBoundary = isBoundary ? isBoundary : node => dom.isBlock(node) || isBr$5(node) || isContentEditableFalse$a(node);\n\n    const walk = (node, offset, walker, process) => {\n      if (isText$8(node)) {\n        const newOffset = process(node, offset, node.data);\n\n        if (newOffset !== -1) {\n          return Optional.some({\n            container: node,\n            offset: newOffset\n          });\n        }\n      }\n\n      return walker().bind(next => walk(next.container, next.offset, walker, process));\n    };\n\n    const backwards = (node, offset, process, root) => {\n      const walker = TextWalker(node, root, isBlockBoundary);\n      return walk(node, offset, () => walker.prev().map(prev => ({\n        container: prev,\n        offset: prev.length\n      })), process).getOrNull();\n    };\n\n    const forwards = (node, offset, process, root) => {\n      const walker = TextWalker(node, root, isBlockBoundary);\n      return walk(node, offset, () => walker.next().map(next => ({\n        container: next,\n        offset: 0\n      })), process).getOrNull();\n    };\n\n    return {\n      backwards,\n      forwards\n    };\n  };\n\n  const round$1 = Math.round;\n\n  const clone$1 = rect => {\n    if (!rect) {\n      return {\n        left: 0,\n        top: 0,\n        bottom: 0,\n        right: 0,\n        width: 0,\n        height: 0\n      };\n    }\n\n    return {\n      left: round$1(rect.left),\n      top: round$1(rect.top),\n      bottom: round$1(rect.bottom),\n      right: round$1(rect.right),\n      width: round$1(rect.width),\n      height: round$1(rect.height)\n    };\n  };\n\n  const collapse = (rect, toStart) => {\n    rect = clone$1(rect);\n\n    if (toStart) {\n      rect.right = rect.left;\n    } else {\n      rect.left = rect.left + rect.width;\n      rect.right = rect.left;\n    }\n\n    rect.width = 0;\n    return rect;\n  };\n\n  const isEqual = (rect1, rect2) => rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;\n\n  const isValidOverflow = (overflowY, rect1, rect2) => overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;\n\n  const isAbove$1 = (rect1, rect2) => {\n    const halfHeight = Math.min(rect2.height / 2, rect1.height / 2);\n\n    if (rect1.bottom - halfHeight < rect2.top) {\n      return true;\n    }\n\n    if (rect1.top > rect2.bottom) {\n      return false;\n    }\n\n    return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);\n  };\n\n  const isBelow$1 = (rect1, rect2) => {\n    if (rect1.top > rect2.bottom) {\n      return true;\n    }\n\n    if (rect1.bottom < rect2.top) {\n      return false;\n    }\n\n    return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);\n  };\n\n  const containsXY = (rect, clientX, clientY) => clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n\n  const boundingClientRectFromRects = rects => {\n    return foldl(rects, (acc, rect) => {\n      return acc.fold(() => Optional.some(rect), prevRect => {\n        const left = Math.min(rect.left, prevRect.left);\n        const top = Math.min(rect.top, prevRect.top);\n        const right = Math.max(rect.right, prevRect.right);\n        const bottom = Math.max(rect.bottom, prevRect.bottom);\n        return Optional.some({\n          top,\n          right,\n          bottom,\n          left,\n          width: right - left,\n          height: bottom - top\n        });\n      });\n    }, Optional.none());\n  };\n\n  const distanceToRectEdgeFromXY = (rect, x, y) => {\n    const cx = Math.max(Math.min(x, rect.left + rect.width), rect.left);\n    const cy = Math.max(Math.min(y, rect.top + rect.height), rect.top);\n    return Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));\n  };\n\n  const overlapY = (r1, r2) => Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));\n\n  const clamp$2 = (value, min, max) => Math.min(Math.max(value, min), max);\n\n  const getSelectedNode = range => {\n    const startContainer = range.startContainer,\n          startOffset = range.startOffset;\n\n    if (startContainer.hasChildNodes() && range.endOffset === startOffset + 1) {\n      return startContainer.childNodes[startOffset];\n    }\n\n    return null;\n  };\n\n  const getNode$1 = (container, offset) => {\n    if (isElement$6(container) && container.hasChildNodes()) {\n      const childNodes = container.childNodes;\n      const safeOffset = clamp$2(offset, 0, childNodes.length - 1);\n      return childNodes[safeOffset];\n    } else {\n      return container;\n    }\n  };\n\n  const getNodeUnsafe = (container, offset) => {\n    if (offset < 0 && isElement$6(container) && container.hasChildNodes()) {\n      return undefined;\n    } else {\n      return getNode$1(container, offset);\n    }\n  };\n\n  const extendingChars = new RegExp('[\\u0300-\\u036f\\u0483-\\u0487\\u0488-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1-\\u05c2\\u05c4-\\u05c5\\u05c7\\u0610-\\u061a' + '\\u064b-\\u065f\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7-\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0' + '\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08e3-\\u0902\\u093a\\u093c' + '\\u0941-\\u0948\\u094d\\u0951-\\u0957\\u0962-\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2-\\u09e3' + '\\u0a01-\\u0a02\\u0a3c\\u0a41-\\u0a42\\u0a47-\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70-\\u0a71\\u0a75\\u0a81-\\u0a82\\u0abc' + '\\u0ac1-\\u0ac5\\u0ac7-\\u0ac8\\u0acd\\u0ae2-\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57' + '\\u0b62-\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c00\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55-\\u0c56' + '\\u0c62-\\u0c63\\u0c81\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc-\\u0ccd\\u0cd5-\\u0cd6\\u0ce2-\\u0ce3\\u0d01\\u0d3e\\u0d41-\\u0d44' + '\\u0d4d\\u0d57\\u0d62-\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9' + '\\u0ebb-\\u0ebc\\u0ec8-\\u0ecd\\u0f18-\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97' + '\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039-\\u103a\\u103d-\\u103e\\u1058-\\u1059\\u105e-\\u1060\\u1071-\\u1074' + '\\u1082\\u1085-\\u1086\\u108d\\u109d\\u135d-\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752-\\u1753\\u1772-\\u1773\\u17b4-\\u17b5' + '\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927-\\u1928\\u1932\\u1939-\\u193b\\u1a17-\\u1a18' + '\\u1a1b\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1ab0-\\u1abd\\u1ABE\\u1b00-\\u1b03\\u1b34' + '\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80-\\u1b81\\u1ba2-\\u1ba5\\u1ba8-\\u1ba9\\u1bab-\\u1bad\\u1be6\\u1be8-\\u1be9' + '\\u1bed\\u1bef-\\u1bf1\\u1c2c-\\u1c33\\u1c36-\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1cf4\\u1cf8-\\u1cf9' + '\\u1dc0-\\u1df5\\u1dfc-\\u1dff\\u200c-\\u200d\\u20d0-\\u20dc\\u20DD-\\u20E0\\u20e1\\u20E2-\\u20E4\\u20e5-\\u20f0\\u2cef-\\u2cf1' + '\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302d\\u302e-\\u302f\\u3099-\\u309a\\ua66f\\uA670-\\uA672\\ua674-\\ua67d\\ua69e-\\ua69f\\ua6f0-\\ua6f1' + '\\ua802\\ua806\\ua80b\\ua825-\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc' + '\\ua9e5\\uaa29-\\uaa2e\\uaa31-\\uaa32\\uaa35-\\uaa36\\uaa43\\uaa4c\\uaa7c\\uaab0\\uaab2-\\uaab4\\uaab7-\\uaab8\\uaabe-\\uaabf\\uaac1' + '\\uaaec-\\uaaed\\uaaf6\\uabe5\\uabe8\\uabed\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\uff9e-\\uff9f]');\n\n  const isExtendingChar = ch => typeof ch === 'string' && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);\n\n  const or = function () {\n    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      args[_key9] = arguments[_key9];\n    }\n\n    return x => {\n      for (let i = 0; i < args.length; i++) {\n        if (args[i](x)) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n  };\n\n  const and = function () {\n    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      args[_key10] = arguments[_key10];\n    }\n\n    return x => {\n      for (let i = 0; i < args.length; i++) {\n        if (!args[i](x)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  };\n\n  const isElement$4 = isElement$6;\n  const isCaretCandidate$2 = isCaretCandidate$3;\n  const isBlock$1 = matchStyleValues('display', 'block table');\n  const isFloated = matchStyleValues('float', 'left right');\n  const isValidElementCaretCandidate = and(isElement$4, isCaretCandidate$2, not(isFloated));\n  const isNotPre = not(matchStyleValues('white-space', 'pre pre-line pre-wrap'));\n  const isText$5 = isText$8;\n  const isBr$2 = isBr$5;\n  const nodeIndex$1 = DOMUtils.nodeIndex;\n  const resolveIndex$1 = getNodeUnsafe;\n\n  const createRange$1 = doc => 'createRange' in doc ? doc.createRange() : DOMUtils.DOM.createRng();\n\n  const isWhiteSpace$1 = chr => chr && /[\\r\\n\\t ]/.test(chr);\n\n  const isRange = rng => !!rng.setStart && !!rng.setEnd;\n\n  const isHiddenWhiteSpaceRange = range => {\n    const container = range.startContainer;\n    const offset = range.startOffset;\n\n    if (isWhiteSpace$1(range.toString()) && isNotPre(container.parentNode) && isText$8(container)) {\n      const text = container.data;\n\n      if (isWhiteSpace$1(text[offset - 1]) || isWhiteSpace$1(text[offset + 1])) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  const getBrClientRect = brNode => {\n    const doc = brNode.ownerDocument;\n    const rng = createRange$1(doc);\n    const nbsp$1 = doc.createTextNode(nbsp);\n    const parentNode = brNode.parentNode;\n    parentNode.insertBefore(nbsp$1, brNode);\n    rng.setStart(nbsp$1, 0);\n    rng.setEnd(nbsp$1, 1);\n    const clientRect = clone$1(rng.getBoundingClientRect());\n    parentNode.removeChild(nbsp$1);\n    return clientRect;\n  };\n\n  const getBoundingClientRectWebKitText = rng => {\n    const sc = rng.startContainer;\n    const ec = rng.endContainer;\n    const so = rng.startOffset;\n    const eo = rng.endOffset;\n\n    if (sc === ec && isText$8(ec) && so === 0 && eo === 1) {\n      const newRng = rng.cloneRange();\n      newRng.setEndAfter(ec);\n      return getBoundingClientRect$1(newRng);\n    } else {\n      return null;\n    }\n  };\n\n  const isZeroRect = r => r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;\n\n  const getBoundingClientRect$1 = item => {\n    let clientRect;\n    const clientRects = item.getClientRects();\n\n    if (clientRects.length > 0) {\n      clientRect = clone$1(clientRects[0]);\n    } else {\n      clientRect = clone$1(item.getBoundingClientRect());\n    }\n\n    if (!isRange(item) && isBr$2(item) && isZeroRect(clientRect)) {\n      return getBrClientRect(item);\n    }\n\n    if (isZeroRect(clientRect) && isRange(item)) {\n      return getBoundingClientRectWebKitText(item);\n    }\n\n    return clientRect;\n  };\n\n  const collapseAndInflateWidth = (clientRect, toStart) => {\n    const newClientRect = collapse(clientRect, toStart);\n    newClientRect.width = 1;\n    newClientRect.right = newClientRect.left + 1;\n    return newClientRect;\n  };\n\n  const getCaretPositionClientRects = caretPosition => {\n    const clientRects = [];\n\n    const addUniqueAndValidRect = clientRect => {\n      if (clientRect.height === 0) {\n        return;\n      }\n\n      if (clientRects.length > 0) {\n        if (isEqual(clientRect, clientRects[clientRects.length - 1])) {\n          return;\n        }\n      }\n\n      clientRects.push(clientRect);\n    };\n\n    const addCharacterOffset = (container, offset) => {\n      const range = createRange$1(container.ownerDocument);\n\n      if (offset < container.data.length) {\n        if (isExtendingChar(container.data[offset])) {\n          return clientRects;\n        }\n\n        if (isExtendingChar(container.data[offset - 1])) {\n          range.setStart(container, offset);\n          range.setEnd(container, offset + 1);\n\n          if (!isHiddenWhiteSpaceRange(range)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\n            return clientRects;\n          }\n        }\n      }\n\n      if (offset > 0) {\n        range.setStart(container, offset - 1);\n        range.setEnd(container, offset);\n\n        if (!isHiddenWhiteSpaceRange(range)) {\n          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\n        }\n      }\n\n      if (offset < container.data.length) {\n        range.setStart(container, offset);\n        range.setEnd(container, offset + 1);\n\n        if (!isHiddenWhiteSpaceRange(range)) {\n          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), true));\n        }\n      }\n    };\n\n    const container = caretPosition.container();\n    const offset = caretPosition.offset();\n\n    if (isText$5(container)) {\n      addCharacterOffset(container, offset);\n      return clientRects;\n    }\n\n    if (isElement$4(container)) {\n      if (caretPosition.isAtEnd()) {\n        const node = resolveIndex$1(container, offset);\n\n        if (isText$5(node)) {\n          addCharacterOffset(node, node.data.length);\n        }\n\n        if (isValidElementCaretCandidate(node) && !isBr$2(node)) {\n          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\n        }\n      } else {\n        const node = resolveIndex$1(container, offset);\n\n        if (isText$5(node)) {\n          addCharacterOffset(node, 0);\n        }\n\n        if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {\n          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\n          return clientRects;\n        }\n\n        const beforeNode = resolveIndex$1(caretPosition.container(), caretPosition.offset() - 1);\n\n        if (isValidElementCaretCandidate(beforeNode) && !isBr$2(beforeNode)) {\n          if (isBlock$1(beforeNode) || isBlock$1(node) || !isValidElementCaretCandidate(node)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(beforeNode), false));\n          }\n        }\n\n        if (isValidElementCaretCandidate(node)) {\n          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), true));\n        }\n      }\n    }\n\n    return clientRects;\n  };\n\n  const CaretPosition = (container, offset, clientRects) => {\n    const isAtStart = () => {\n      if (isText$5(container)) {\n        return offset === 0;\n      }\n\n      return offset === 0;\n    };\n\n    const isAtEnd = () => {\n      if (isText$5(container)) {\n        return offset >= container.data.length;\n      }\n\n      return offset >= container.childNodes.length;\n    };\n\n    const toRange = () => {\n      const range = createRange$1(container.ownerDocument);\n      range.setStart(container, offset);\n      range.setEnd(container, offset);\n      return range;\n    };\n\n    const getClientRects = () => {\n      if (!clientRects) {\n        clientRects = getCaretPositionClientRects(CaretPosition(container, offset));\n      }\n\n      return clientRects;\n    };\n\n    const isVisible = () => getClientRects().length > 0;\n\n    const isEqual = caretPosition => caretPosition && container === caretPosition.container() && offset === caretPosition.offset();\n\n    const getNode = before => resolveIndex$1(container, before ? offset - 1 : offset);\n\n    return {\n      container: constant(container),\n      offset: constant(offset),\n      toRange,\n      getClientRects,\n      isVisible,\n      isAtStart,\n      isAtEnd,\n      isEqual,\n      getNode\n    };\n  };\n\n  CaretPosition.fromRangeStart = range => CaretPosition(range.startContainer, range.startOffset);\n\n  CaretPosition.fromRangeEnd = range => CaretPosition(range.endContainer, range.endOffset);\n\n  CaretPosition.after = node => CaretPosition(node.parentNode, nodeIndex$1(node) + 1);\n\n  CaretPosition.before = node => CaretPosition(node.parentNode, nodeIndex$1(node));\n\n  CaretPosition.isAbove = (pos1, pos2) => lift2(head(pos2.getClientRects()), last$3(pos1.getClientRects()), isAbove$1).getOr(false);\n\n  CaretPosition.isBelow = (pos1, pos2) => lift2(last$3(pos2.getClientRects()), head(pos1.getClientRects()), isBelow$1).getOr(false);\n\n  CaretPosition.isAtStart = pos => pos ? pos.isAtStart() : false;\n\n  CaretPosition.isAtEnd = pos => pos ? pos.isAtEnd() : false;\n\n  CaretPosition.isTextPosition = pos => pos ? isText$8(pos.container()) : false;\n\n  CaretPosition.isElementPosition = pos => CaretPosition.isTextPosition(pos) === false;\n\n  const trimEmptyTextNode$1 = (dom, node) => {\n    if (isText$8(node) && node.data.length === 0) {\n      dom.remove(node);\n    }\n  };\n\n  const insertNode = (dom, rng, node) => {\n    rng.insertNode(node);\n    trimEmptyTextNode$1(dom, node.previousSibling);\n    trimEmptyTextNode$1(dom, node.nextSibling);\n  };\n\n  const insertFragment = (dom, rng, frag) => {\n    const firstChild = Optional.from(frag.firstChild);\n    const lastChild = Optional.from(frag.lastChild);\n    rng.insertNode(frag);\n    firstChild.each(child => trimEmptyTextNode$1(dom, child.previousSibling));\n    lastChild.each(child => trimEmptyTextNode$1(dom, child.nextSibling));\n  };\n\n  const rangeInsertNode = (dom, rng, node) => {\n    if (isDocumentFragment(node)) {\n      insertFragment(dom, rng, node);\n    } else {\n      insertNode(dom, rng, node);\n    }\n  };\n\n  const isText$4 = isText$8;\n  const isBogus = isBogus$2;\n  const nodeIndex = DOMUtils.nodeIndex;\n\n  const normalizedParent = node => {\n    const parentNode = node.parentNode;\n\n    if (isBogus(parentNode)) {\n      return normalizedParent(parentNode);\n    }\n\n    return parentNode;\n  };\n\n  const getChildNodes = node => {\n    if (!node) {\n      return [];\n    }\n\n    return reduce(node.childNodes, (result, node) => {\n      if (isBogus(node) && node.nodeName !== 'BR') {\n        result = result.concat(getChildNodes(node));\n      } else {\n        result.push(node);\n      }\n\n      return result;\n    }, []);\n  };\n\n  const normalizedTextOffset = (node, offset) => {\n    while (node = node.previousSibling) {\n      if (!isText$4(node)) {\n        break;\n      }\n\n      offset += node.data.length;\n    }\n\n    return offset;\n  };\n\n  const equal = a => b => a === b;\n\n  const normalizedNodeIndex = node => {\n    let nodes, index;\n    nodes = getChildNodes(normalizedParent(node));\n    index = findIndex$1(nodes, equal(node), node);\n    nodes = nodes.slice(0, index + 1);\n    const numTextFragments = reduce(nodes, (result, node, i) => {\n      if (isText$4(node) && isText$4(nodes[i - 1])) {\n        result++;\n      }\n\n      return result;\n    }, 0);\n    nodes = filter$4(nodes, matchNodeNames([node.nodeName]));\n    index = findIndex$1(nodes, equal(node), node);\n    return index - numTextFragments;\n  };\n\n  const createPathItem = node => {\n    let name;\n\n    if (isText$4(node)) {\n      name = 'text()';\n    } else {\n      name = node.nodeName.toLowerCase();\n    }\n\n    return name + '[' + normalizedNodeIndex(node) + ']';\n  };\n\n  const parentsUntil$1 = (root, node, predicate) => {\n    const parents = [];\n\n    for (node = node.parentNode; node !== root; node = node.parentNode) {\n      if (predicate && predicate(node)) {\n        break;\n      }\n\n      parents.push(node);\n    }\n\n    return parents;\n  };\n\n  const create$a = (root, caretPosition) => {\n    let container,\n        offset,\n        path = [],\n        outputOffset,\n        childNodes,\n        parents;\n    container = caretPosition.container();\n    offset = caretPosition.offset();\n\n    if (isText$4(container)) {\n      outputOffset = normalizedTextOffset(container, offset);\n    } else {\n      childNodes = container.childNodes;\n\n      if (offset >= childNodes.length) {\n        outputOffset = 'after';\n        offset = childNodes.length - 1;\n      } else {\n        outputOffset = 'before';\n      }\n\n      container = childNodes[offset];\n    }\n\n    path.push(createPathItem(container));\n    parents = parentsUntil$1(root, container);\n    parents = filter$4(parents, not(isBogus$2));\n    path = path.concat(map$1(parents, node => {\n      return createPathItem(node);\n    }));\n    return path.reverse().join('/') + ',' + outputOffset;\n  };\n\n  const resolvePathItem = (node, name, index) => {\n    let nodes = getChildNodes(node);\n    nodes = filter$4(nodes, (node, index) => {\n      return !isText$4(node) || !isText$4(nodes[index - 1]);\n    });\n    nodes = filter$4(nodes, matchNodeNames([name]));\n    return nodes[index];\n  };\n\n  const findTextPosition = (container, offset) => {\n    let node = container,\n        targetOffset = 0,\n        dataLen;\n\n    while (isText$4(node)) {\n      dataLen = node.data.length;\n\n      if (offset >= targetOffset && offset <= targetOffset + dataLen) {\n        container = node;\n        offset = offset - targetOffset;\n        break;\n      }\n\n      if (!isText$4(node.nextSibling)) {\n        container = node;\n        offset = dataLen;\n        break;\n      }\n\n      targetOffset += dataLen;\n      node = node.nextSibling;\n    }\n\n    if (isText$4(container) && offset > container.data.length) {\n      offset = container.data.length;\n    }\n\n    return CaretPosition(container, offset);\n  };\n\n  const resolve$1 = (root, path) => {\n    let offset;\n\n    if (!path) {\n      return null;\n    }\n\n    const parts = path.split(',');\n    const paths = parts[0].split('/');\n    offset = parts.length > 1 ? parts[1] : 'before';\n    const container = reduce(paths, (result, value) => {\n      const match = /([\\w\\-\\(\\)]+)\\[([0-9]+)\\]/.exec(value);\n\n      if (!match) {\n        return null;\n      }\n\n      if (match[1] === 'text()') {\n        match[1] = '#text';\n      }\n\n      return resolvePathItem(result, match[1], parseInt(match[2], 10));\n    }, root);\n\n    if (!container) {\n      return null;\n    }\n\n    if (!isText$4(container)) {\n      if (offset === 'after') {\n        offset = nodeIndex(container) + 1;\n      } else {\n        offset = nodeIndex(container);\n      }\n\n      return CaretPosition(container.parentNode, offset);\n    }\n\n    return findTextPosition(container, parseInt(offset, 10));\n  };\n\n  const isContentEditableFalse$8 = isContentEditableFalse$a;\n\n  const getNormalizedTextOffset = (trim, container, offset) => {\n    let node, trimmedOffset;\n    trimmedOffset = trim(container.data.slice(0, offset)).length;\n\n    for (node = container.previousSibling; node && isText$8(node); node = node.previousSibling) {\n      trimmedOffset += trim(node.data).length;\n    }\n\n    return trimmedOffset;\n  };\n\n  const getPoint = (dom, trim, normalized, rng, start) => {\n    let container = rng[start ? 'startContainer' : 'endContainer'];\n    let offset = rng[start ? 'startOffset' : 'endOffset'];\n    const point = [];\n    let childNodes,\n        after = 0;\n    const root = dom.getRoot();\n\n    if (isText$8(container)) {\n      point.push(normalized ? getNormalizedTextOffset(trim, container, offset) : offset);\n    } else {\n      childNodes = container.childNodes;\n\n      if (offset >= childNodes.length && childNodes.length) {\n        after = 1;\n        offset = Math.max(0, childNodes.length - 1);\n      }\n\n      point.push(dom.nodeIndex(childNodes[offset], normalized) + after);\n    }\n\n    for (; container && container !== root; container = container.parentNode) {\n      point.push(dom.nodeIndex(container, normalized));\n    }\n\n    return point;\n  };\n\n  const getLocation = (trim, selection, normalized, rng) => {\n    const dom = selection.dom,\n          bookmark = {};\n    bookmark.start = getPoint(dom, trim, normalized, rng, true);\n\n    if (!selection.isCollapsed()) {\n      bookmark.end = getPoint(dom, trim, normalized, rng, false);\n    }\n\n    if (isRangeInCaretContainerBlock(rng)) {\n      bookmark.isFakeCaret = true;\n    }\n\n    return bookmark;\n  };\n\n  const findIndex = (dom, name, element) => {\n    let count = 0;\n    Tools.each(dom.select(name), node => {\n      if (node.getAttribute('data-mce-bogus') === 'all') {\n        return;\n      }\n\n      if (node === element) {\n        return false;\n      }\n\n      count++;\n    });\n    return count;\n  };\n\n  const moveEndPoint$1 = (rng, start) => {\n    let container, offset, childNodes;\n    const prefix = start ? 'start' : 'end';\n    container = rng[prefix + 'Container'];\n    offset = rng[prefix + 'Offset'];\n\n    if (isElement$6(container) && container.nodeName === 'TR') {\n      childNodes = container.childNodes;\n      container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];\n\n      if (container) {\n        offset = start ? 0 : container.childNodes.length;\n        rng['set' + (start ? 'Start' : 'End')](container, offset);\n      }\n    }\n  };\n\n  const normalizeTableCellSelection = rng => {\n    moveEndPoint$1(rng, true);\n    moveEndPoint$1(rng, false);\n    return rng;\n  };\n\n  const findSibling = (node, offset) => {\n    let sibling;\n\n    if (isElement$6(node)) {\n      node = getNode$1(node, offset);\n\n      if (isContentEditableFalse$8(node)) {\n        return node;\n      }\n    }\n\n    if (isCaretContainer$2(node)) {\n      if (isText$8(node) && isCaretContainerBlock$1(node)) {\n        node = node.parentNode;\n      }\n\n      sibling = node.previousSibling;\n\n      if (isContentEditableFalse$8(sibling)) {\n        return sibling;\n      }\n\n      sibling = node.nextSibling;\n\n      if (isContentEditableFalse$8(sibling)) {\n        return sibling;\n      }\n    }\n  };\n\n  const findAdjacentContentEditableFalseElm = rng => {\n    return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);\n  };\n\n  const getOffsetBookmark = (trim, normalized, selection) => {\n    const element = selection.getNode();\n    let name = element ? element.nodeName : null;\n    const rng = selection.getRng();\n\n    if (isContentEditableFalse$8(element) || name === 'IMG') {\n      return {\n        name,\n        index: findIndex(selection.dom, name, element)\n      };\n    }\n\n    const sibling = findAdjacentContentEditableFalseElm(rng);\n\n    if (sibling) {\n      name = sibling.tagName;\n      return {\n        name,\n        index: findIndex(selection.dom, name, sibling)\n      };\n    }\n\n    return getLocation(trim, selection, normalized, rng);\n  };\n\n  const getCaretBookmark = selection => {\n    const rng = selection.getRng();\n    return {\n      start: create$a(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),\n      end: create$a(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng))\n    };\n  };\n\n  const getRangeBookmark = selection => {\n    return {\n      rng: selection.getRng()\n    };\n  };\n\n  const createBookmarkSpan = (dom, id, filled) => {\n    const args = {\n      'data-mce-type': 'bookmark',\n      id,\n      'style': 'overflow:hidden;line-height:0px'\n    };\n    return filled ? dom.create('span', args, '&#xFEFF;') : dom.create('span', args);\n  };\n\n  const getPersistentBookmark = (selection, filled) => {\n    const dom = selection.dom;\n    let rng = selection.getRng();\n    const id = dom.uniqueId();\n    const collapsed = selection.isCollapsed();\n    const element = selection.getNode();\n    const name = element.nodeName;\n\n    if (name === 'IMG') {\n      return {\n        name,\n        index: findIndex(dom, name, element)\n      };\n    }\n\n    const rng2 = normalizeTableCellSelection(rng.cloneRange());\n\n    if (!collapsed) {\n      rng2.collapse(false);\n      const endBookmarkNode = createBookmarkSpan(dom, id + '_end', filled);\n      rangeInsertNode(dom, rng2, endBookmarkNode);\n    }\n\n    rng = normalizeTableCellSelection(rng);\n    rng.collapse(true);\n    const startBookmarkNode = createBookmarkSpan(dom, id + '_start', filled);\n    rangeInsertNode(dom, rng, startBookmarkNode);\n    selection.moveToBookmark({\n      id,\n      keep: true\n    });\n    return {\n      id\n    };\n  };\n\n  const getBookmark$2 = (selection, type, normalized) => {\n    if (type === 2) {\n      return getOffsetBookmark(trim$1, normalized, selection);\n    } else if (type === 3) {\n      return getCaretBookmark(selection);\n    } else if (type) {\n      return getRangeBookmark(selection);\n    } else {\n      return getPersistentBookmark(selection, false);\n    }\n  };\n\n  const getUndoBookmark = curry(getOffsetBookmark, identity, true);\n\n  const value$1 = value => {\n    const applyHelper = fn => fn(value);\n\n    const constHelper = constant(value);\n\n    const outputHelper = () => output;\n\n    const output = {\n      tag: true,\n      inner: value,\n      fold: (_onError, onValue) => onValue(value),\n      isValue: always,\n      isError: never,\n      map: mapper => Result.value(mapper(value)),\n      mapError: outputHelper,\n      bind: applyHelper,\n      exists: applyHelper,\n      forall: applyHelper,\n      getOr: constHelper,\n      or: outputHelper,\n      getOrThunk: constHelper,\n      orThunk: outputHelper,\n      getOrDie: constHelper,\n      each: fn => {\n        fn(value);\n      },\n      toOptional: () => Optional.some(value)\n    };\n    return output;\n  };\n\n  const error = error => {\n    const outputHelper = () => output;\n\n    const output = {\n      tag: false,\n      inner: error,\n      fold: (onError, _onValue) => onError(error),\n      isValue: never,\n      isError: always,\n      map: outputHelper,\n      mapError: mapper => Result.error(mapper(error)),\n      bind: outputHelper,\n      exists: never,\n      forall: always,\n      getOr: identity,\n      or: identity,\n      getOrThunk: apply$1,\n      orThunk: apply$1,\n      getOrDie: die(String(error)),\n      each: noop,\n      toOptional: Optional.none\n    };\n    return output;\n  };\n\n  const fromOption = (optional, err) => optional.fold(() => error(err), value$1);\n\n  const Result = {\n    value: value$1,\n    error,\n    fromOption\n  };\n\n  const generate = cases => {\n    if (!isArray$1(cases)) {\n      throw new Error('cases must be an array');\n    }\n\n    if (cases.length === 0) {\n      throw new Error('there must be at least one case');\n    }\n\n    const constructors = [];\n    const adt = {};\n    each$g(cases, (acase, count) => {\n      const keys$1 = keys(acase);\n\n      if (keys$1.length !== 1) {\n        throw new Error('one and only one name per case');\n      }\n\n      const key = keys$1[0];\n      const value = acase[key];\n\n      if (adt[key] !== undefined) {\n        throw new Error('duplicate key detected:' + key);\n      } else if (key === 'cata') {\n        throw new Error('cannot have a case named cata (sorry)');\n      } else if (!isArray$1(value)) {\n        throw new Error('case arguments must be an array');\n      }\n\n      constructors.push(key);\n\n      adt[key] = function () {\n        for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n          args[_key11] = arguments[_key11];\n        }\n\n        const argLength = args.length;\n\n        if (argLength !== value.length) {\n          throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);\n        }\n\n        const match = branches => {\n          const branchKeys = keys(branches);\n\n          if (constructors.length !== branchKeys.length) {\n            throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\\nActual: ' + branchKeys.join(','));\n          }\n\n          const allReqd = forall(constructors, reqKey => {\n            return contains$2(branchKeys, reqKey);\n          });\n\n          if (!allReqd) {\n            throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\\nRequired: ' + constructors.join(', '));\n          }\n\n          return branches[key].apply(null, args);\n        };\n\n        return {\n          fold: function () {\n            for (var _len12 = arguments.length, foldArgs = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n              foldArgs[_key12] = arguments[_key12];\n            }\n\n            if (foldArgs.length !== cases.length) {\n              throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);\n            }\n\n            const target = foldArgs[count];\n            return target.apply(null, args);\n          },\n          match,\n          log: label => {\n            console.log(label, {\n              constructors,\n              constructor: key,\n              params: args\n            });\n          }\n        };\n      };\n    });\n    return adt;\n  };\n\n  const Adt = {\n    generate\n  };\n  Adt.generate([{\n    bothErrors: ['error1', 'error2']\n  }, {\n    firstError: ['error1', 'value2']\n  }, {\n    secondError: ['value1', 'error2']\n  }, {\n    bothValues: ['value1', 'value2']\n  }]);\n\n  const partition$1 = results => {\n    const errors = [];\n    const values = [];\n    each$g(results, result => {\n      result.fold(err => {\n        errors.push(err);\n      }, value => {\n        values.push(value);\n      });\n    });\n    return {\n      errors,\n      values\n    };\n  };\n\n  const isInlinePattern = pattern => pattern.type === 'inline-command' || pattern.type === 'inline-format';\n\n  const isBlockPattern = pattern => pattern.type === 'block-command' || pattern.type === 'block-format';\n\n  const sortPatterns = patterns => sort(patterns, (a, b) => {\n    if (a.start.length === b.start.length) {\n      return 0;\n    }\n\n    return a.start.length > b.start.length ? -1 : 1;\n  });\n\n  const normalizePattern = pattern => {\n    const err = message => Result.error({\n      message,\n      pattern\n    });\n\n    const formatOrCmd = (name, onFormat, onCommand) => {\n      if (pattern.format !== undefined) {\n        let formats;\n\n        if (isArray$1(pattern.format)) {\n          if (!forall(pattern.format, isString)) {\n            return err(name + ' pattern has non-string items in the `format` array');\n          }\n\n          formats = pattern.format;\n        } else if (isString(pattern.format)) {\n          formats = [pattern.format];\n        } else {\n          return err(name + ' pattern has non-string `format` parameter');\n        }\n\n        return Result.value(onFormat(formats));\n      } else if (pattern.cmd !== undefined) {\n        if (!isString(pattern.cmd)) {\n          return err(name + ' pattern has non-string `cmd` parameter');\n        }\n\n        return Result.value(onCommand(pattern.cmd, pattern.value));\n      } else {\n        return err(name + ' pattern is missing both `format` and `cmd` parameters');\n      }\n    };\n\n    if (!isObject(pattern)) {\n      return err('Raw pattern is not an object');\n    }\n\n    if (!isString(pattern.start)) {\n      return err('Raw pattern is missing `start` parameter');\n    }\n\n    if (pattern.end !== undefined) {\n      if (!isString(pattern.end)) {\n        return err('Inline pattern has non-string `end` parameter');\n      }\n\n      if (pattern.start.length === 0 && pattern.end.length === 0) {\n        return err('Inline pattern has empty `start` and `end` parameters');\n      }\n\n      let start = pattern.start;\n      let end = pattern.end;\n\n      if (end.length === 0) {\n        end = start;\n        start = '';\n      }\n\n      return formatOrCmd('Inline', format => ({\n        type: 'inline-format',\n        start,\n        end,\n        format\n      }), (cmd, value) => ({\n        type: 'inline-command',\n        start,\n        end,\n        cmd,\n        value\n      }));\n    } else if (pattern.replacement !== undefined) {\n      if (!isString(pattern.replacement)) {\n        return err('Replacement pattern has non-string `replacement` parameter');\n      }\n\n      if (pattern.start.length === 0) {\n        return err('Replacement pattern has empty `start` parameter');\n      }\n\n      return Result.value({\n        type: 'inline-command',\n        start: '',\n        end: pattern.start,\n        cmd: 'mceInsertContent',\n        value: pattern.replacement\n      });\n    } else {\n      if (pattern.start.length === 0) {\n        return err('Block pattern has empty `start` parameter');\n      }\n\n      return formatOrCmd('Block', formats => ({\n        type: 'block-format',\n        start: pattern.start,\n        format: formats[0]\n      }), (command, commandValue) => ({\n        type: 'block-command',\n        start: pattern.start,\n        cmd: command,\n        value: commandValue\n      }));\n    }\n  };\n\n  const getBlockPatterns = patterns => sortPatterns(filter$6(patterns, isBlockPattern));\n\n  const getInlinePatterns = patterns => filter$6(patterns, isInlinePattern);\n\n  const createPatternSet = patterns => ({\n    inlinePatterns: getInlinePatterns(patterns),\n    blockPatterns: getBlockPatterns(patterns)\n  });\n\n  const fromRawPatterns = patterns => {\n    const normalized = partition$1(map$3(patterns, normalizePattern));\n    each$g(normalized.errors, err => console.error(err.message, err.pattern));\n    return normalized.values;\n  };\n\n  const deviceDetection$1 = detect$2().deviceType;\n  const isTouch = deviceDetection$1.isTouch();\n  const DOM$a = DOMUtils.DOM;\n\n  const getHash = value => {\n    const items = value.indexOf('=') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(',');\n    return foldl(items, (output, item) => {\n      const arr = item.split('=');\n      const key = arr[0];\n      const val = arr.length > 1 ? arr[1] : key;\n      output[trim$3(key)] = trim$3(val);\n      return output;\n    }, {});\n  };\n\n  const isRegExp = x => is$4(x, RegExp);\n\n  const option = name => editor => editor.options.get(name);\n\n  const stringOrObjectProcessor = value => isString(value) || isObject(value);\n\n  const bodyOptionProcessor = function (editor) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    return value => {\n      const valid = isString(value);\n\n      if (valid) {\n        if (value.indexOf('=') !== -1) {\n          const bodyObj = getHash(value);\n          return {\n            value: get$a(bodyObj, editor.id).getOr(defaultValue),\n            valid\n          };\n        } else {\n          return {\n            value,\n            valid\n          };\n        }\n      } else {\n        return {\n          valid: false,\n          message: 'Must be a string.'\n        };\n      }\n    };\n  };\n\n  const register$7 = editor => {\n    const registerOption = editor.options.register;\n    registerOption('id', {\n      processor: 'string',\n      default: editor.id\n    });\n    registerOption('selector', {\n      processor: 'string'\n    });\n    registerOption('target', {\n      processor: 'object'\n    });\n    registerOption('suffix', {\n      processor: 'string'\n    });\n    registerOption('cache_suffix', {\n      processor: 'string'\n    });\n    registerOption('base_url', {\n      processor: 'string'\n    });\n    registerOption('referrer_policy', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('language_load', {\n      processor: 'boolean'\n    });\n    registerOption('inline', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('iframe_attrs', {\n      processor: 'object',\n      default: {}\n    });\n    registerOption('doctype', {\n      processor: 'string',\n      default: '<!DOCTYPE html>'\n    });\n    registerOption('document_base_url', {\n      processor: 'string',\n      default: editor.documentBaseUrl\n    });\n    registerOption('body_id', {\n      processor: bodyOptionProcessor(editor, 'tinymce'),\n      default: 'tinymce'\n    });\n    registerOption('body_class', {\n      processor: bodyOptionProcessor(editor),\n      default: ''\n    });\n    registerOption('content_security_policy', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('br_in_pre', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('forced_root_block', {\n      processor: value => {\n        const valid = isString(value) && isNotEmpty(value);\n\n        if (valid) {\n          return {\n            value,\n            valid\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be a non-empty string.'\n          };\n        }\n      },\n      default: 'p'\n    });\n    registerOption('forced_root_block_attrs', {\n      processor: 'object',\n      default: {}\n    });\n    registerOption('br_newline_selector', {\n      processor: 'string',\n      default: '.mce-toc h2,figcaption,caption'\n    });\n    registerOption('no_newline_selector', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('keep_styles', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('end_container_on_empty_block', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('font_size_style_values', {\n      processor: 'string',\n      default: 'xx-small,x-small,small,medium,large,x-large,xx-large'\n    });\n    registerOption('font_size_legacy_values', {\n      processor: 'string',\n      default: 'xx-small,small,medium,large,x-large,xx-large,300%'\n    });\n    registerOption('font_size_classes', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('automatic_uploads', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('images_reuse_filename', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('images_replace_blob_uris', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('icons', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('icons_url', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('images_upload_url', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('images_upload_base_path', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('images_upload_base_path', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('images_upload_credentials', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('images_upload_handler', {\n      processor: 'function'\n    });\n    registerOption('language', {\n      processor: 'string',\n      default: 'en'\n    });\n    registerOption('language_url', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('entity_encoding', {\n      processor: 'string',\n      default: 'named'\n    });\n    registerOption('indent', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('indent_before', {\n      processor: 'string',\n      default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\n    });\n    registerOption('indent_after', {\n      processor: 'string',\n      default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\n    });\n    registerOption('indent_use_margin', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('indentation', {\n      processor: 'string',\n      default: '40px'\n    });\n    registerOption('content_css', {\n      processor: value => {\n        const valid = value === false || isString(value) || isArrayOf(value, isString);\n\n        if (valid) {\n          if (isString(value)) {\n            return {\n              value: map$3(value.split(','), trim$3),\n              valid\n            };\n          } else if (isArray$1(value)) {\n            return {\n              value,\n              valid\n            };\n          } else if (value === false) {\n            return {\n              value: [],\n              valid\n            };\n          } else {\n            return {\n              value,\n              valid\n            };\n          }\n        } else {\n          return {\n            valid: false,\n            message: 'Must be false, a string or an array of strings.'\n          };\n        }\n      },\n      default: isInline(editor) ? [] : ['default']\n    });\n    registerOption('content_style', {\n      processor: 'string'\n    });\n    registerOption('content_css_cors', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('font_css', {\n      processor: value => {\n        const valid = isString(value) || isArrayOf(value, isString);\n\n        if (valid) {\n          const newValue = isArray$1(value) ? value : map$3(value.split(','), trim$3);\n          return {\n            value: newValue,\n            valid\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be a string or an array of strings.'\n          };\n        }\n      },\n      default: []\n    });\n    registerOption('inline_boundaries', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('inline_boundaries_selector', {\n      processor: 'string',\n      default: 'a[href],code,.mce-annotation'\n    });\n    registerOption('object_resizing', {\n      processor: value => {\n        const valid = isBoolean(value) || isString(value);\n\n        if (valid) {\n          if (value === false || deviceDetection$1.isiPhone() || deviceDetection$1.isiPad()) {\n            return {\n              value: '',\n              valid\n            };\n          } else {\n            return {\n              value: value === true ? 'table,img,figure.image,div,video,iframe' : value,\n              valid\n            };\n          }\n        } else {\n          return {\n            valid: false,\n            message: 'Must be boolean or a string'\n          };\n        }\n      },\n      default: !isTouch\n    });\n    registerOption('resize_img_proportional', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('event_root', {\n      processor: 'object'\n    });\n    registerOption('service_message', {\n      processor: 'string'\n    });\n    registerOption('theme', {\n      processor: value => value === false || isString(value) || isFunction(value),\n      default: 'silver'\n    });\n    registerOption('theme_url', {\n      processor: 'string'\n    });\n    registerOption('formats', {\n      processor: 'object'\n    });\n    registerOption('format_empty_lines', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('preview_styles', {\n      processor: value => {\n        const valid = value === false || isString(value);\n\n        if (valid) {\n          return {\n            value: value === false ? '' : value,\n            valid\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be false or a string'\n          };\n        }\n      },\n      default: 'font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow'\n    });\n    registerOption('custom_ui_selector', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('hidden_input', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('submit_patch', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('encoding', {\n      processor: 'string'\n    });\n    registerOption('add_form_submit_trigger', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('add_unload_trigger', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('custom_undo_redo_levels', {\n      processor: 'number',\n      default: 0\n    });\n    registerOption('disable_nodechange', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('readonly', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('plugins', {\n      processor: 'string[]',\n      default: []\n    });\n    registerOption('external_plugins', {\n      processor: 'object'\n    });\n    registerOption('forced_plugins', {\n      processor: 'string[]'\n    });\n    registerOption('model', {\n      processor: 'string',\n      default: editor.hasPlugin('rtc') ? 'plugin' : 'dom'\n    });\n    registerOption('model_url', {\n      processor: 'string'\n    });\n    registerOption('block_unsupported_drop', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('visual', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('visual_table_class', {\n      processor: 'string',\n      default: 'mce-item-table'\n    });\n    registerOption('visual_anchor_class', {\n      processor: 'string',\n      default: 'mce-item-anchor'\n    });\n    registerOption('iframe_aria_text', {\n      processor: 'string',\n      default: 'Rich Text Area. Press ALT-0 for help.'\n    });\n    registerOption('setup', {\n      processor: 'function'\n    });\n    registerOption('init_instance_callback', {\n      processor: 'function'\n    });\n    registerOption('url_converter', {\n      processor: 'function',\n      default: editor.convertURL\n    });\n    registerOption('url_converter_scope', {\n      processor: 'object',\n      default: editor\n    });\n    registerOption('urlconverter_callback', {\n      processor: 'function'\n    });\n    registerOption('allow_conditional_comments', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('allow_html_data_urls', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('allow_svg_data_urls', {\n      processor: 'boolean'\n    });\n    registerOption('allow_html_in_named_anchor', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('allow_script_urls', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('allow_unsafe_link_target', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('convert_fonts_to_spans', {\n      processor: 'boolean',\n      default: true,\n      deprecated: true\n    });\n    registerOption('fix_list_elements', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('preserve_cdata', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('remove_trailing_brs', {\n      processor: 'boolean'\n    });\n    registerOption('inline_styles', {\n      processor: 'boolean',\n      default: true,\n      deprecated: true\n    });\n    registerOption('element_format', {\n      processor: 'string',\n      default: 'html'\n    });\n    registerOption('entities', {\n      processor: 'string'\n    });\n    registerOption('schema', {\n      processor: 'string',\n      default: 'html5'\n    });\n    registerOption('convert_urls', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('relative_urls', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('remove_script_host', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('custom_elements', {\n      processor: 'string'\n    });\n    registerOption('extended_valid_elements', {\n      processor: 'string'\n    });\n    registerOption('invalid_elements', {\n      processor: 'string'\n    });\n    registerOption('invalid_styles', {\n      processor: stringOrObjectProcessor\n    });\n    registerOption('valid_children', {\n      processor: 'string'\n    });\n    registerOption('valid_classes', {\n      processor: stringOrObjectProcessor\n    });\n    registerOption('valid_elements', {\n      processor: 'string'\n    });\n    registerOption('valid_styles', {\n      processor: stringOrObjectProcessor\n    });\n    registerOption('verify_html', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('auto_focus', {\n      processor: value => isString(value) || value === true\n    });\n    registerOption('browser_spellcheck', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('protect', {\n      processor: 'array'\n    });\n    registerOption('images_file_types', {\n      processor: 'string',\n      default: 'jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp'\n    });\n    registerOption('deprecation_warnings', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('a11y_advanced_options', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('api_key', {\n      processor: 'string'\n    });\n    registerOption('paste_block_drop', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('paste_data_images', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('paste_preprocess', {\n      processor: 'function'\n    });\n    registerOption('paste_postprocess', {\n      processor: 'function'\n    });\n    registerOption('paste_webkit_styles', {\n      processor: 'string',\n      default: 'none'\n    });\n    registerOption('paste_remove_styles_if_webkit', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('paste_merge_formats', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('smart_paste', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('paste_as_text', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('paste_tab_spaces', {\n      processor: 'number',\n      default: 4\n    });\n    registerOption('text_patterns', {\n      processor: value => {\n        if (isArrayOf(value, isObject) || value === false) {\n          const patterns = value === false ? [] : value;\n          return {\n            value: fromRawPatterns(patterns),\n            valid: true\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be an array of objects or false.'\n          };\n        }\n      },\n      default: [{\n        start: '*',\n        end: '*',\n        format: 'italic'\n      }, {\n        start: '**',\n        end: '**',\n        format: 'bold'\n      }, {\n        start: '#',\n        format: 'h1'\n      }, {\n        start: '##',\n        format: 'h2'\n      }, {\n        start: '###',\n        format: 'h3'\n      }, {\n        start: '####',\n        format: 'h4'\n      }, {\n        start: '#####',\n        format: 'h5'\n      }, {\n        start: '######',\n        format: 'h6'\n      }, {\n        start: '1. ',\n        cmd: 'InsertOrderedList'\n      }, {\n        start: '* ',\n        cmd: 'InsertUnorderedList'\n      }, {\n        start: '- ',\n        cmd: 'InsertUnorderedList'\n      }]\n    });\n    registerOption('noneditable_class', {\n      processor: 'string',\n      default: 'mceNonEditable'\n    });\n    registerOption('editable_class', {\n      processor: 'string',\n      default: 'mceEditable'\n    });\n    registerOption('noneditable_regexp', {\n      processor: value => {\n        if (isArrayOf(value, isRegExp)) {\n          return {\n            value,\n            valid: true\n          };\n        } else if (isRegExp(value)) {\n          return {\n            value: [value],\n            valid: true\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be a RegExp or an array of RegExp.'\n          };\n        }\n      },\n      default: []\n    });\n    registerOption('table_tab_navigation', {\n      processor: 'boolean',\n      default: true\n    });\n    editor.on('ScriptsLoaded', () => {\n      registerOption('directionality', {\n        processor: 'string',\n        default: I18n.isRtl() ? 'rtl' : undefined\n      });\n      registerOption('placeholder', {\n        processor: 'string',\n        default: DOM$a.getAttrib(editor.getElement(), 'placeholder')\n      });\n    });\n  };\n\n  const getIframeAttrs = option('iframe_attrs');\n  const getDocType = option('doctype');\n  const getDocumentBaseUrl = option('document_base_url');\n  const getBodyId = option('body_id');\n  const getBodyClass = option('body_class');\n  const getContentSecurityPolicy = option('content_security_policy');\n  const shouldPutBrInPre$1 = option('br_in_pre');\n  const getForcedRootBlock = option('forced_root_block');\n  const getForcedRootBlockAttrs = option('forced_root_block_attrs');\n  const getBrNewLineSelector = option('br_newline_selector');\n  const getNoNewLineSelector = option('no_newline_selector');\n  const shouldKeepStyles = option('keep_styles');\n  const shouldEndContainerOnEmptyBlock = option('end_container_on_empty_block');\n  const isAutomaticUploadsEnabled = option('automatic_uploads');\n  const shouldReuseFileName = option('images_reuse_filename');\n  const shouldReplaceBlobUris = option('images_replace_blob_uris');\n  const getIconPackName = option('icons');\n  const getIconsUrl = option('icons_url');\n  const getImageUploadUrl = option('images_upload_url');\n  const getImageUploadBasePath = option('images_upload_base_path');\n  const getImagesUploadCredentials = option('images_upload_credentials');\n  const getImagesUploadHandler = option('images_upload_handler');\n  const shouldUseContentCssCors = option('content_css_cors');\n  const getReferrerPolicy = option('referrer_policy');\n  const getLanguageCode = option('language');\n  const getLanguageUrl = option('language_url');\n  const shouldIndentUseMargin = option('indent_use_margin');\n  const getIndentation = option('indentation');\n  const getContentCss = option('content_css');\n  const getContentStyle = option('content_style');\n  const getFontCss = option('font_css');\n  const getDirectionality = option('directionality');\n  const getInlineBoundarySelector = option('inline_boundaries_selector');\n  const getObjectResizing = option('object_resizing');\n  const getResizeImgProportional = option('resize_img_proportional');\n  const getPlaceholder = option('placeholder');\n  const getEventRoot = option('event_root');\n  const getServiceMessage = option('service_message');\n  const getTheme = option('theme');\n  const getThemeUrl = option('theme_url');\n  const getModel = option('model');\n  const getModelUrl = option('model_url');\n  const isInlineBoundariesEnabled = option('inline_boundaries');\n  const getFormats = option('formats');\n  const getPreviewStyles = option('preview_styles');\n  const canFormatEmptyLines = option('format_empty_lines');\n  const getCustomUiSelector = option('custom_ui_selector');\n  const isInline = option('inline');\n  const hasHiddenInput = option('hidden_input');\n  const shouldPatchSubmit = option('submit_patch');\n  const shouldAddFormSubmitTrigger = option('add_form_submit_trigger');\n  const shouldAddUnloadTrigger = option('add_unload_trigger');\n  const getCustomUndoRedoLevels = option('custom_undo_redo_levels');\n  const shouldDisableNodeChange = option('disable_nodechange');\n  const isReadOnly$1 = option('readonly');\n  const hasContentCssCors = option('content_css_cors');\n  const getPlugins = option('plugins');\n  const getExternalPlugins$1 = option('external_plugins');\n  const shouldBlockUnsupportedDrop = option('block_unsupported_drop');\n  const isVisualAidsEnabled = option('visual');\n  const getVisualAidsTableClass = option('visual_table_class');\n  const getVisualAidsAnchorClass = option('visual_anchor_class');\n  const getIframeAriaText = option('iframe_aria_text');\n  const getSetupCallback = option('setup');\n  const getInitInstanceCallback = option('init_instance_callback');\n  const getUrlConverterCallback = option('urlconverter_callback');\n  const getAutoFocus = option('auto_focus');\n  const shouldBrowserSpellcheck = option('browser_spellcheck');\n  const getProtect = option('protect');\n  const shouldPasteBlockDrop = option('paste_block_drop');\n  const shouldPasteDataImages = option('paste_data_images');\n  const getPastePreProcess = option('paste_preprocess');\n  const getPastePostProcess = option('paste_postprocess');\n  const getPasteWebkitStyles = option('paste_webkit_styles');\n  const shouldPasteRemoveWebKitStyles = option('paste_remove_styles_if_webkit');\n  const shouldPasteMergeFormats = option('paste_merge_formats');\n  const isSmartPasteEnabled = option('smart_paste');\n  const isPasteAsTextEnabled = option('paste_as_text');\n  const getPasteTabSpaces = option('paste_tab_spaces');\n  const shouldAllowHtmlDataUrls = option('allow_html_data_urls');\n  const getTextPatterns = option('text_patterns');\n  const getNonEditableClass = option('noneditable_class');\n  const getEditableClass = option('editable_class');\n  const getNonEditableRegExps = option('noneditable_regexp');\n\n  const getFontStyleValues = editor => Tools.explode(editor.options.get('font_size_style_values'));\n\n  const getFontSizeClasses = editor => Tools.explode(editor.options.get('font_size_classes'));\n\n  const isEncodingXml = editor => editor.options.get('encoding') === 'xml';\n\n  const getAllowedImageFileTypes = editor => Tools.explode(editor.options.get('images_file_types'));\n\n  const hasTableTabNavigation = option('table_tab_navigation');\n  const isElement$3 = isElement$6;\n  const isText$3 = isText$8;\n\n  const removeNode$1 = node => {\n    const parentNode = node.parentNode;\n\n    if (parentNode) {\n      parentNode.removeChild(node);\n    }\n  };\n\n  const trimCount = text => {\n    const trimmedText = trim$1(text);\n    return {\n      count: text.length - trimmedText.length,\n      text: trimmedText\n    };\n  };\n\n  const deleteZwspChars = caretContainer => {\n    let idx;\n\n    while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) {\n      caretContainer.deleteData(idx, 1);\n    }\n  };\n\n  const removeUnchanged = (caretContainer, pos) => {\n    remove$4(caretContainer);\n    return pos;\n  };\n\n  const removeTextAndReposition = (caretContainer, pos) => {\n    const before = trimCount(caretContainer.data.substr(0, pos.offset()));\n    const after = trimCount(caretContainer.data.substr(pos.offset()));\n    const text = before.text + after.text;\n\n    if (text.length > 0) {\n      deleteZwspChars(caretContainer);\n      return CaretPosition(caretContainer, pos.offset() - before.count);\n    } else {\n      return pos;\n    }\n  };\n\n  const removeElementAndReposition = (caretContainer, pos) => {\n    const parentNode = pos.container();\n    const newPosition = indexOf$1(from(parentNode.childNodes), caretContainer).map(index => {\n      return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;\n    }).getOr(pos);\n    remove$4(caretContainer);\n    return newPosition;\n  };\n\n  const removeTextCaretContainer = (caretContainer, pos) => isText$3(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\n\n  const removeElementCaretContainer = (caretContainer, pos) => pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\n\n  const removeAndReposition = (container, pos) => CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);\n\n  const remove$4 = caretContainerNode => {\n    if (isElement$3(caretContainerNode) && isCaretContainer$2(caretContainerNode)) {\n      if (hasContent(caretContainerNode)) {\n        caretContainerNode.removeAttribute('data-mce-caret');\n      } else {\n        removeNode$1(caretContainerNode);\n      }\n    }\n\n    if (isText$3(caretContainerNode)) {\n      deleteZwspChars(caretContainerNode);\n\n      if (caretContainerNode.data.length === 0) {\n        removeNode$1(caretContainerNode);\n      }\n    }\n  };\n\n  const isContentEditableFalse$7 = isContentEditableFalse$a;\n  const isMedia$1 = isMedia$2;\n  const isTableCell$3 = isTableCell$5;\n  const inlineFakeCaretSelector = '*[contentEditable=false],video,audio,embed,object';\n\n  const getAbsoluteClientRect = (root, element, before) => {\n    const clientRect = collapse(element.getBoundingClientRect(), before);\n    let scrollX;\n    let scrollY;\n\n    if (root.tagName === 'BODY') {\n      const docElm = root.ownerDocument.documentElement;\n      scrollX = root.scrollLeft || docElm.scrollLeft;\n      scrollY = root.scrollTop || docElm.scrollTop;\n    } else {\n      const rootRect = root.getBoundingClientRect();\n      scrollX = root.scrollLeft - rootRect.left;\n      scrollY = root.scrollTop - rootRect.top;\n    }\n\n    clientRect.left += scrollX;\n    clientRect.right += scrollX;\n    clientRect.top += scrollY;\n    clientRect.bottom += scrollY;\n    clientRect.width = 1;\n    let margin = element.offsetWidth - element.clientWidth;\n\n    if (margin > 0) {\n      if (before) {\n        margin *= -1;\n      }\n\n      clientRect.left += margin;\n      clientRect.right += margin;\n    }\n\n    return clientRect;\n  };\n\n  const trimInlineCaretContainers = root => {\n    const fakeCaretTargetNodes = descendants(SugarElement.fromDom(root), inlineFakeCaretSelector);\n\n    for (let i = 0; i < fakeCaretTargetNodes.length; i++) {\n      const node = fakeCaretTargetNodes[i].dom;\n      let sibling = node.previousSibling;\n\n      if (endsWithCaretContainer$1(sibling)) {\n        const data = sibling.data;\n\n        if (data.length === 1) {\n          sibling.parentNode.removeChild(sibling);\n        } else {\n          sibling.deleteData(data.length - 1, 1);\n        }\n      }\n\n      sibling = node.nextSibling;\n\n      if (startsWithCaretContainer$1(sibling)) {\n        const data = sibling.data;\n\n        if (data.length === 1) {\n          sibling.parentNode.removeChild(sibling);\n        } else {\n          sibling.deleteData(0, 1);\n        }\n      }\n    }\n  };\n\n  const FakeCaret = (editor, root, isBlock, hasFocus) => {\n    const lastVisualCaret = value$2();\n    let cursorInterval;\n    let caretContainerNode;\n    const caretBlock = getForcedRootBlock(editor);\n    const dom = editor.dom;\n\n    const show = (before, element) => {\n      let rng;\n      hide();\n\n      if (isTableCell$3(element)) {\n        return null;\n      }\n\n      if (isBlock(element)) {\n        caretContainerNode = insertBlock(caretBlock, element, before);\n        const clientRect = getAbsoluteClientRect(root, element, before);\n        dom.setStyle(caretContainerNode, 'top', clientRect.top);\n        const caret = dom.create('div', {\n          'class': 'mce-visual-caret',\n          'data-mce-bogus': 'all'\n        });\n        dom.setStyles(caret, { ...clientRect\n        });\n        dom.add(root, caret);\n        lastVisualCaret.set({\n          caret,\n          element,\n          before\n        });\n\n        if (before) {\n          dom.addClass(caret, 'mce-visual-caret-before');\n        }\n\n        startBlink();\n        rng = element.ownerDocument.createRange();\n        rng.setStart(caretContainerNode, 0);\n        rng.setEnd(caretContainerNode, 0);\n      } else {\n        caretContainerNode = insertInline$1(element, before);\n        rng = element.ownerDocument.createRange();\n\n        if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {\n          rng.setStart(caretContainerNode, 0);\n          rng.setEnd(caretContainerNode, 0);\n        } else {\n          rng.setStart(caretContainerNode, 1);\n          rng.setEnd(caretContainerNode, 1);\n        }\n\n        return rng;\n      }\n\n      return rng;\n    };\n\n    const hide = () => {\n      trimInlineCaretContainers(root);\n\n      if (caretContainerNode) {\n        remove$4(caretContainerNode);\n        caretContainerNode = null;\n      }\n\n      lastVisualCaret.on(caretState => {\n        dom.remove(caretState.caret);\n        lastVisualCaret.clear();\n      });\n\n      if (cursorInterval) {\n        clearInterval(cursorInterval);\n        cursorInterval = undefined;\n      }\n    };\n\n    const startBlink = () => {\n      cursorInterval = setInterval(() => {\n        lastVisualCaret.on(caretState => {\n          if (hasFocus()) {\n            dom.toggleClass(caretState.caret, 'mce-visual-caret-hidden');\n          } else {\n            dom.addClass(caretState.caret, 'mce-visual-caret-hidden');\n          }\n        });\n      }, 500);\n    };\n\n    const reposition = () => {\n      lastVisualCaret.on(caretState => {\n        const clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);\n        dom.setStyles(caretState.caret, { ...clientRect\n        });\n      });\n    };\n\n    const destroy = () => clearInterval(cursorInterval);\n\n    const getCss = () => '.mce-visual-caret {' + 'position: absolute;' + 'background-color: black;' + 'background-color: currentcolor;' + '}' + '.mce-visual-caret-hidden {' + 'display: none;' + '}' + '*[data-mce-caret] {' + 'position: absolute;' + 'left: -1000px;' + 'right: auto;' + 'top: 0;' + 'margin: 0;' + 'padding: 0;' + '}';\n\n    return {\n      show,\n      hide,\n      getCss,\n      reposition,\n      destroy\n    };\n  };\n\n  const isFakeCaretTableBrowser = () => Env.browser.isFirefox();\n\n  const isInlineFakeCaretTarget = node => isContentEditableFalse$7(node) || isMedia$1(node);\n\n  const isFakeCaretTarget = node => isInlineFakeCaretTarget(node) || isTable$3(node) && isFakeCaretTableBrowser();\n\n  const isContentEditableTrue$2 = isContentEditableTrue$4;\n  const isContentEditableFalse$6 = isContentEditableFalse$a;\n  const isMedia = isMedia$2;\n  const isBlockLike = matchStyleValues('display', 'block table table-cell table-caption list-item');\n  const isCaretContainer = isCaretContainer$2;\n  const isCaretContainerBlock = isCaretContainerBlock$1;\n  const isElement$2 = isElement$6;\n  const isCaretCandidate$1 = isCaretCandidate$3;\n\n  const isForwards = direction => direction > 0;\n\n  const isBackwards = direction => direction < 0;\n\n  const skipCaretContainers = (walk, shallow) => {\n    let node;\n\n    while (node = walk(shallow)) {\n      if (!isCaretContainerBlock(node)) {\n        return node;\n      }\n    }\n\n    return null;\n  };\n\n  const findNode = (node, direction, predicateFn, rootNode, shallow) => {\n    const walker = new DomTreeWalker(node, rootNode);\n    const isCefOrCaretContainer = isContentEditableFalse$6(node) || isCaretContainerBlock(node);\n\n    if (isBackwards(direction)) {\n      if (isCefOrCaretContainer) {\n        node = skipCaretContainers(walker.prev.bind(walker), true);\n\n        if (predicateFn(node)) {\n          return node;\n        }\n      }\n\n      while (node = skipCaretContainers(walker.prev.bind(walker), shallow)) {\n        if (predicateFn(node)) {\n          return node;\n        }\n      }\n    }\n\n    if (isForwards(direction)) {\n      if (isCefOrCaretContainer) {\n        node = skipCaretContainers(walker.next.bind(walker), true);\n\n        if (predicateFn(node)) {\n          return node;\n        }\n      }\n\n      while (node = skipCaretContainers(walker.next.bind(walker), shallow)) {\n        if (predicateFn(node)) {\n          return node;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  const getEditingHost = (node, rootNode) => {\n    const isCETrue = node => isContentEditableTrue$2(node.dom);\n\n    const isRoot = node => node.dom === rootNode;\n\n    return ancestor$3(SugarElement.fromDom(node), isCETrue, isRoot).map(elm => elm.dom).getOr(rootNode);\n  };\n\n  const getParentBlock$3 = (node, rootNode) => {\n    while (node && node !== rootNode) {\n      if (isBlockLike(node)) {\n        return node;\n      }\n\n      node = node.parentNode;\n    }\n\n    return null;\n  };\n\n  const isInSameBlock = (caretPosition1, caretPosition2, rootNode) => getParentBlock$3(caretPosition1.container(), rootNode) === getParentBlock$3(caretPosition2.container(), rootNode);\n\n  const getChildNodeAtRelativeOffset = (relativeOffset, caretPosition) => {\n    if (!caretPosition) {\n      return null;\n    }\n\n    const container = caretPosition.container();\n    const offset = caretPosition.offset();\n\n    if (!isElement$2(container)) {\n      return null;\n    }\n\n    return container.childNodes[offset + relativeOffset];\n  };\n\n  const beforeAfter = (before, node) => {\n    const range = node.ownerDocument.createRange();\n\n    if (before) {\n      range.setStartBefore(node);\n      range.setEndBefore(node);\n    } else {\n      range.setStartAfter(node);\n      range.setEndAfter(node);\n    }\n\n    return range;\n  };\n\n  const isNodesInSameBlock = (root, node1, node2) => getParentBlock$3(node1, root) === getParentBlock$3(node2, root);\n\n  const lean = (left, root, node) => {\n    const siblingName = left ? 'previousSibling' : 'nextSibling';\n\n    while (node && node !== root) {\n      let sibling = node[siblingName];\n\n      if (isCaretContainer(sibling)) {\n        sibling = sibling[siblingName];\n      }\n\n      if (isContentEditableFalse$6(sibling) || isMedia(sibling)) {\n        if (isNodesInSameBlock(root, sibling, node)) {\n          return sibling;\n        }\n\n        break;\n      }\n\n      if (isCaretCandidate$1(sibling)) {\n        break;\n      }\n\n      node = node.parentNode;\n    }\n\n    return null;\n  };\n\n  const before$2 = curry(beforeAfter, true);\n  const after$2 = curry(beforeAfter, false);\n\n  const normalizeRange = (direction, root, range) => {\n    let node;\n    const leanLeft = curry(lean, true, root);\n    const leanRight = curry(lean, false, root);\n    let container = range.startContainer;\n    const offset = range.startOffset;\n\n    if (isCaretContainerBlock$1(container)) {\n      if (!isElement$2(container)) {\n        container = container.parentNode;\n      }\n\n      const location = container.getAttribute('data-mce-caret');\n\n      if (location === 'before') {\n        node = container.nextSibling;\n\n        if (isFakeCaretTarget(node)) {\n          return before$2(node);\n        }\n      }\n\n      if (location === 'after') {\n        node = container.previousSibling;\n\n        if (isFakeCaretTarget(node)) {\n          return after$2(node);\n        }\n      }\n    }\n\n    if (!range.collapsed) {\n      return range;\n    }\n\n    if (isText$8(container)) {\n      if (isCaretContainer(container)) {\n        if (direction === 1) {\n          node = leanRight(container);\n\n          if (node) {\n            return before$2(node);\n          }\n\n          node = leanLeft(container);\n\n          if (node) {\n            return after$2(node);\n          }\n        }\n\n        if (direction === -1) {\n          node = leanLeft(container);\n\n          if (node) {\n            return after$2(node);\n          }\n\n          node = leanRight(container);\n\n          if (node) {\n            return before$2(node);\n          }\n        }\n\n        return range;\n      }\n\n      if (endsWithCaretContainer$1(container) && offset >= container.data.length - 1) {\n        if (direction === 1) {\n          node = leanRight(container);\n\n          if (node) {\n            return before$2(node);\n          }\n        }\n\n        return range;\n      }\n\n      if (startsWithCaretContainer$1(container) && offset <= 1) {\n        if (direction === -1) {\n          node = leanLeft(container);\n\n          if (node) {\n            return after$2(node);\n          }\n        }\n\n        return range;\n      }\n\n      if (offset === container.data.length) {\n        node = leanRight(container);\n\n        if (node) {\n          return before$2(node);\n        }\n\n        return range;\n      }\n\n      if (offset === 0) {\n        node = leanLeft(container);\n\n        if (node) {\n          return after$2(node);\n        }\n\n        return range;\n      }\n    }\n\n    return range;\n  };\n\n  const getRelativeCefElm = (forward, caretPosition) => Optional.from(getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition)).filter(isContentEditableFalse$6);\n\n  const getNormalizedRangeEndPoint = (direction, root, range) => {\n    const normalizedRange = normalizeRange(direction, root, range);\n\n    if (direction === -1) {\n      return CaretPosition.fromRangeStart(normalizedRange);\n    }\n\n    return CaretPosition.fromRangeEnd(normalizedRange);\n  };\n\n  const getElementFromPosition = pos => Optional.from(pos.getNode()).map(SugarElement.fromDom);\n\n  const getElementFromPrevPosition = pos => Optional.from(pos.getNode(true)).map(SugarElement.fromDom);\n\n  const getVisualCaretPosition = (walkFn, caretPosition) => {\n    while (caretPosition = walkFn(caretPosition)) {\n      if (caretPosition.isVisible()) {\n        return caretPosition;\n      }\n    }\n\n    return caretPosition;\n  };\n\n  const isMoveInsideSameBlock = (from, to) => {\n    const inSameBlock = isInSameBlock(from, to);\n\n    if (!inSameBlock && isBr$5(from.getNode())) {\n      return true;\n    }\n\n    return inSameBlock;\n  };\n\n  var HDirection;\n\n  (function (HDirection) {\n    HDirection[HDirection['Backwards'] = -1] = 'Backwards';\n    HDirection[HDirection['Forwards'] = 1] = 'Forwards';\n  })(HDirection || (HDirection = {}));\n\n  const isContentEditableFalse$5 = isContentEditableFalse$a;\n  const isText$2 = isText$8;\n  const isElement$1 = isElement$6;\n  const isBr$1 = isBr$5;\n  const isCaretCandidate = isCaretCandidate$3;\n  const isAtomic = isAtomic$1;\n  const isEditableCaretCandidate = isEditableCaretCandidate$1;\n\n  const getParents$3 = (node, root) => {\n    const parents = [];\n\n    while (node && node !== root) {\n      parents.push(node);\n      node = node.parentNode;\n    }\n\n    return parents;\n  };\n\n  const nodeAtIndex = (container, offset) => {\n    if (container.hasChildNodes() && offset < container.childNodes.length) {\n      return container.childNodes[offset];\n    }\n\n    return null;\n  };\n\n  const getCaretCandidatePosition = (direction, node) => {\n    if (isForwards(direction)) {\n      if (isCaretCandidate(node.previousSibling) && !isText$2(node.previousSibling)) {\n        return CaretPosition.before(node);\n      }\n\n      if (isText$2(node)) {\n        return CaretPosition(node, 0);\n      }\n    }\n\n    if (isBackwards(direction)) {\n      if (isCaretCandidate(node.nextSibling) && !isText$2(node.nextSibling)) {\n        return CaretPosition.after(node);\n      }\n\n      if (isText$2(node)) {\n        return CaretPosition(node, node.data.length);\n      }\n    }\n\n    if (isBackwards(direction)) {\n      if (isBr$1(node)) {\n        return CaretPosition.before(node);\n      }\n\n      return CaretPosition.after(node);\n    }\n\n    return CaretPosition.before(node);\n  };\n\n  const moveForwardFromBr = (root, nextNode) => {\n    const nextSibling = nextNode.nextSibling;\n\n    if (nextSibling && isCaretCandidate(nextSibling)) {\n      if (isText$2(nextSibling)) {\n        return CaretPosition(nextSibling, 0);\n      } else {\n        return CaretPosition.before(nextSibling);\n      }\n    } else {\n      return findCaretPosition$1(HDirection.Forwards, CaretPosition.after(nextNode), root);\n    }\n  };\n\n  const findCaretPosition$1 = (direction, startPos, root) => {\n    let node;\n    let nextNode;\n    let innerNode;\n    let caretPosition;\n\n    if (!isElement$1(root) || !startPos) {\n      return null;\n    }\n\n    if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {\n      caretPosition = CaretPosition.after(root.lastChild);\n\n      if (isBackwards(direction) && isCaretCandidate(root.lastChild) && isElement$1(root.lastChild)) {\n        return isBr$1(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;\n      }\n    } else {\n      caretPosition = startPos;\n    }\n\n    const container = caretPosition.container();\n    let offset = caretPosition.offset();\n\n    if (isText$2(container)) {\n      if (isBackwards(direction) && offset > 0) {\n        return CaretPosition(container, --offset);\n      }\n\n      if (isForwards(direction) && offset < container.length) {\n        return CaretPosition(container, ++offset);\n      }\n\n      node = container;\n    } else {\n      if (isBackwards(direction) && offset > 0) {\n        nextNode = nodeAtIndex(container, offset - 1);\n\n        if (isCaretCandidate(nextNode)) {\n          if (!isAtomic(nextNode)) {\n            innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\n\n            if (innerNode) {\n              if (isText$2(innerNode)) {\n                return CaretPosition(innerNode, innerNode.data.length);\n              }\n\n              return CaretPosition.after(innerNode);\n            }\n          }\n\n          if (isText$2(nextNode)) {\n            return CaretPosition(nextNode, nextNode.data.length);\n          }\n\n          return CaretPosition.before(nextNode);\n        }\n      }\n\n      if (isForwards(direction) && offset < container.childNodes.length) {\n        nextNode = nodeAtIndex(container, offset);\n\n        if (isCaretCandidate(nextNode)) {\n          if (isBr$1(nextNode)) {\n            return moveForwardFromBr(root, nextNode);\n          }\n\n          if (!isAtomic(nextNode)) {\n            innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\n\n            if (innerNode) {\n              if (isText$2(innerNode)) {\n                return CaretPosition(innerNode, 0);\n              }\n\n              return CaretPosition.before(innerNode);\n            }\n          }\n\n          if (isText$2(nextNode)) {\n            return CaretPosition(nextNode, 0);\n          }\n\n          return CaretPosition.after(nextNode);\n        }\n      }\n\n      node = nextNode ? nextNode : caretPosition.getNode();\n    }\n\n    if (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart()) {\n      node = findNode(node, direction, always, root, true);\n\n      if (isEditableCaretCandidate(node, root)) {\n        return getCaretCandidatePosition(direction, node);\n      }\n    }\n\n    nextNode = findNode(node, direction, isEditableCaretCandidate, root);\n    const rootContentEditableFalseElm = last$2(filter$6(getParents$3(container, root), isContentEditableFalse$5));\n\n    if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {\n      if (isForwards(direction)) {\n        caretPosition = CaretPosition.after(rootContentEditableFalseElm);\n      } else {\n        caretPosition = CaretPosition.before(rootContentEditableFalseElm);\n      }\n\n      return caretPosition;\n    }\n\n    if (nextNode) {\n      return getCaretCandidatePosition(direction, nextNode);\n    }\n\n    return null;\n  };\n\n  const CaretWalker = root => ({\n    next: caretPosition => {\n      return findCaretPosition$1(HDirection.Forwards, caretPosition, root);\n    },\n    prev: caretPosition => {\n      return findCaretPosition$1(HDirection.Backwards, caretPosition, root);\n    }\n  });\n\n  const walkToPositionIn = (forward, root, start) => {\n    const position = forward ? CaretPosition.before(start) : CaretPosition.after(start);\n    return fromPosition(forward, root, position);\n  };\n\n  const afterElement = node => isBr$5(node) ? CaretPosition.before(node) : CaretPosition.after(node);\n\n  const isBeforeOrStart = position => {\n    if (CaretPosition.isTextPosition(position)) {\n      return position.offset() === 0;\n    } else {\n      return isCaretCandidate$3(position.getNode());\n    }\n  };\n\n  const isAfterOrEnd = position => {\n    if (CaretPosition.isTextPosition(position)) {\n      const container = position.container();\n      return position.offset() === container.data.length;\n    } else {\n      return isCaretCandidate$3(position.getNode(true));\n    }\n  };\n\n  const isBeforeAfterSameElement = (from, to) => !CaretPosition.isTextPosition(from) && !CaretPosition.isTextPosition(to) && from.getNode() === to.getNode(true);\n\n  const isAtBr = position => !CaretPosition.isTextPosition(position) && isBr$5(position.getNode());\n\n  const shouldSkipPosition = (forward, from, to) => {\n    if (forward) {\n      return !isBeforeAfterSameElement(from, to) && !isAtBr(from) && isAfterOrEnd(from) && isBeforeOrStart(to);\n    } else {\n      return !isBeforeAfterSameElement(to, from) && isBeforeOrStart(from) && isAfterOrEnd(to);\n    }\n  };\n\n  const fromPosition = (forward, root, pos) => {\n    const walker = CaretWalker(root);\n    return Optional.from(forward ? walker.next(pos) : walker.prev(pos));\n  };\n\n  const navigate = (forward, root, from) => fromPosition(forward, root, from).bind(to => {\n    if (isInSameBlock(from, to, root) && shouldSkipPosition(forward, from, to)) {\n      return fromPosition(forward, root, to);\n    } else {\n      return Optional.some(to);\n    }\n  });\n\n  const navigateIgnore = (forward, root, from, ignoreFilter) => navigate(forward, root, from).bind(pos => ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos));\n\n  const positionIn = (forward, element) => {\n    const startNode = forward ? element.firstChild : element.lastChild;\n\n    if (isText$8(startNode)) {\n      return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));\n    } else if (startNode) {\n      if (isCaretCandidate$3(startNode)) {\n        return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));\n      } else {\n        return walkToPositionIn(forward, element, startNode);\n      }\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const nextPosition = curry(fromPosition, true);\n  const prevPosition = curry(fromPosition, false);\n  const firstPositionIn = curry(positionIn, true);\n  const lastPositionIn = curry(positionIn, false);\n  const CARET_ID$1 = '_mce_caret';\n\n  const isCaretNode = node => isElement$6(node) && node.id === CARET_ID$1;\n\n  const getParentCaretContainer = (body, node) => {\n    while (node && node !== body) {\n      if (node.id === CARET_ID$1) {\n        return node;\n      }\n\n      node = node.parentNode;\n    }\n\n    return null;\n  };\n\n  const isStringPathBookmark = bookmark => isString(bookmark.start);\n\n  const isRangeBookmark = bookmark => has$2(bookmark, 'rng');\n\n  const isIdBookmark = bookmark => has$2(bookmark, 'id');\n\n  const isIndexBookmark = bookmark => has$2(bookmark, 'name');\n\n  const isPathBookmark = bookmark => Tools.isArray(bookmark.start);\n\n  const addBogus = (dom, node) => {\n    if (isElement$6(node) && dom.isBlock(node) && !node.innerHTML) {\n      node.innerHTML = '<br data-mce-bogus=\"1\" />';\n    }\n\n    return node;\n  };\n\n  const resolveCaretPositionBookmark = (dom, bookmark) => {\n    let pos;\n    const rng = dom.createRng();\n    pos = resolve$1(dom.getRoot(), bookmark.start);\n    rng.setStart(pos.container(), pos.offset());\n    pos = resolve$1(dom.getRoot(), bookmark.end);\n    rng.setEnd(pos.container(), pos.offset());\n    return rng;\n  };\n\n  const insertZwsp = (node, rng) => {\n    const textNode = node.ownerDocument.createTextNode(ZWSP$1);\n    node.appendChild(textNode);\n    rng.setStart(textNode, 0);\n    rng.setEnd(textNode, 0);\n  };\n\n  const isEmpty$1 = node => node.hasChildNodes() === false;\n\n  const tryFindRangePosition = (node, rng) => lastPositionIn(node).fold(never, pos => {\n    rng.setStart(pos.container(), pos.offset());\n    rng.setEnd(pos.container(), pos.offset());\n    return true;\n  });\n\n  const padEmptyCaretContainer = (root, node, rng) => {\n    if (isEmpty$1(node) && getParentCaretContainer(root, node)) {\n      insertZwsp(node, rng);\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  const setEndPoint = (dom, start, bookmark, rng) => {\n    const point = bookmark[start ? 'start' : 'end'];\n    let i, node, offset, children;\n    const root = dom.getRoot();\n\n    if (point) {\n      offset = point[0];\n\n      for (node = root, i = point.length - 1; i >= 1; i--) {\n        children = node.childNodes;\n\n        if (padEmptyCaretContainer(root, node, rng)) {\n          return true;\n        }\n\n        if (point[i] > children.length - 1) {\n          if (padEmptyCaretContainer(root, node, rng)) {\n            return true;\n          }\n\n          return tryFindRangePosition(node, rng);\n        }\n\n        node = children[point[i]];\n      }\n\n      if (node.nodeType === 3) {\n        offset = Math.min(point[0], node.nodeValue.length);\n      }\n\n      if (node.nodeType === 1) {\n        offset = Math.min(point[0], node.childNodes.length);\n      }\n\n      if (start) {\n        rng.setStart(node, offset);\n      } else {\n        rng.setEnd(node, offset);\n      }\n    }\n\n    return true;\n  };\n\n  const isValidTextNode = node => isText$8(node) && node.data.length > 0;\n\n  const restoreEndPoint = (dom, suffix, bookmark) => {\n    let marker = dom.get(bookmark.id + '_' + suffix),\n        node,\n        idx,\n        next,\n        prev;\n    const keep = bookmark.keep;\n    let container, offset;\n\n    if (marker) {\n      node = marker.parentNode;\n\n      if (suffix === 'start') {\n        if (!keep) {\n          idx = dom.nodeIndex(marker);\n        } else {\n          if (marker.hasChildNodes()) {\n            node = marker.firstChild;\n            idx = 1;\n          } else if (isValidTextNode(marker.nextSibling)) {\n            node = marker.nextSibling;\n            idx = 0;\n          } else if (isValidTextNode(marker.previousSibling)) {\n            node = marker.previousSibling;\n            idx = marker.previousSibling.data.length;\n          } else {\n            node = marker.parentNode;\n            idx = dom.nodeIndex(marker) + 1;\n          }\n        }\n\n        container = node;\n        offset = idx;\n      } else {\n        if (!keep) {\n          idx = dom.nodeIndex(marker);\n        } else {\n          if (marker.hasChildNodes()) {\n            node = marker.firstChild;\n            idx = 1;\n          } else if (isValidTextNode(marker.previousSibling)) {\n            node = marker.previousSibling;\n            idx = marker.previousSibling.data.length;\n          } else {\n            node = marker.parentNode;\n            idx = dom.nodeIndex(marker);\n          }\n        }\n\n        container = node;\n        offset = idx;\n      }\n\n      if (!keep) {\n        prev = marker.previousSibling;\n        next = marker.nextSibling;\n        Tools.each(Tools.grep(marker.childNodes), node => {\n          if (isText$8(node)) {\n            node.nodeValue = node.nodeValue.replace(/\\uFEFF/g, '');\n          }\n        });\n\n        while (marker = dom.get(bookmark.id + '_' + suffix)) {\n          dom.remove(marker, true);\n        }\n\n        if (prev && next && prev.nodeType === next.nodeType && isText$8(prev) && !Env.browser.isOpera()) {\n          idx = prev.nodeValue.length;\n          prev.appendData(next.nodeValue);\n          dom.remove(next);\n          container = prev;\n          offset = idx;\n        }\n      }\n\n      return Optional.some(CaretPosition(container, offset));\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const resolvePaths = (dom, bookmark) => {\n    const rng = dom.createRng();\n\n    if (setEndPoint(dom, true, bookmark, rng) && setEndPoint(dom, false, bookmark, rng)) {\n      return Optional.some(rng);\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const resolveId = (dom, bookmark) => {\n    const startPos = restoreEndPoint(dom, 'start', bookmark);\n    const endPos = restoreEndPoint(dom, 'end', bookmark);\n    return lift2(startPos, endPos.or(startPos), (spos, epos) => {\n      const rng = dom.createRng();\n      rng.setStart(addBogus(dom, spos.container()), spos.offset());\n      rng.setEnd(addBogus(dom, epos.container()), epos.offset());\n      return rng;\n    });\n  };\n\n  const resolveIndex = (dom, bookmark) => Optional.from(dom.select(bookmark.name)[bookmark.index]).map(elm => {\n    const rng = dom.createRng();\n    rng.selectNode(elm);\n    return rng;\n  });\n\n  const resolve = (selection, bookmark) => {\n    const dom = selection.dom;\n\n    if (bookmark) {\n      if (isPathBookmark(bookmark)) {\n        return resolvePaths(dom, bookmark);\n      } else if (isStringPathBookmark(bookmark)) {\n        return Optional.some(resolveCaretPositionBookmark(dom, bookmark));\n      } else if (isIdBookmark(bookmark)) {\n        return resolveId(dom, bookmark);\n      } else if (isIndexBookmark(bookmark)) {\n        return resolveIndex(dom, bookmark);\n      } else if (isRangeBookmark(bookmark)) {\n        return Optional.some(bookmark.rng);\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const getBookmark$1 = (selection, type, normalized) => {\n    return getBookmark$2(selection, type, normalized);\n  };\n\n  const moveToBookmark = (selection, bookmark) => {\n    resolve(selection, bookmark).each(rng => {\n      selection.setRng(rng);\n    });\n  };\n\n  const isBookmarkNode$1 = node => {\n    return isElement$6(node) && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';\n  };\n\n  const is = expected => actual => expected === actual;\n\n  const isNbsp = is(nbsp);\n\n  const isWhiteSpace = chr => chr !== '' && ' \\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\n\n  const isContent = chr => !isWhiteSpace(chr) && !isNbsp(chr) && !isZwsp$1(chr);\n\n  const hexColour = value => ({\n    value\n  });\n\n  const toHex = component => {\n    const hex = component.toString(16);\n    return (hex.length === 1 ? '0' + hex : hex).toUpperCase();\n  };\n\n  const fromRgba = rgbaColour => {\n    const value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);\n    return hexColour(value);\n  };\n\n  const rgbRegex = /^\\s*rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)\\s*$/i;\n  const rgbaRegex = /^\\s*rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d?(?:\\.\\d+)?)\\s*\\)\\s*$/i;\n\n  const rgbaColour = (red, green, blue, alpha) => ({\n    red,\n    green,\n    blue,\n    alpha\n  });\n\n  const fromStringValues = (red, green, blue, alpha) => {\n    const r = parseInt(red, 10);\n    const g = parseInt(green, 10);\n    const b = parseInt(blue, 10);\n    const a = parseFloat(alpha);\n    return rgbaColour(r, g, b, a);\n  };\n\n  const fromString = rgbaString => {\n    if (rgbaString === 'transparent') {\n      return Optional.some(rgbaColour(0, 0, 0, 0));\n    }\n\n    const rgbMatch = rgbRegex.exec(rgbaString);\n\n    if (rgbMatch !== null) {\n      return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));\n    }\n\n    const rgbaMatch = rgbaRegex.exec(rgbaString);\n\n    if (rgbaMatch !== null) {\n      return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));\n    }\n\n    return Optional.none();\n  };\n\n  const rgbaToHexString = color => fromString(color).map(fromRgba).map(h => '#' + h.value).getOr(color);\n\n  const isNode = node => !!node.nodeType;\n\n  const isInlineBlock = node => {\n    return node && /^(IMG)$/.test(node.nodeName);\n  };\n\n  const moveStart = (dom, selection, rng) => {\n    const offset = rng.startOffset;\n    let container = rng.startContainer;\n\n    if (container === rng.endContainer) {\n      if (isInlineBlock(container.childNodes[offset])) {\n        return;\n      }\n    }\n\n    if (isElement$6(container)) {\n      const nodes = container.childNodes;\n      let walker;\n\n      if (offset < nodes.length) {\n        container = nodes[offset];\n        walker = new DomTreeWalker(container, dom.getParent(container, dom.isBlock));\n      } else {\n        container = nodes[nodes.length - 1];\n        walker = new DomTreeWalker(container, dom.getParent(container, dom.isBlock));\n        walker.next(true);\n      }\n\n      for (let node = walker.current(); node; node = walker.next()) {\n        if (isText$8(node) && !isWhiteSpaceNode$1(node)) {\n          rng.setStart(node, 0);\n          selection.setRng(rng);\n          return;\n        }\n      }\n    }\n  };\n\n  const getNonWhiteSpaceSibling = (node, next, inc) => {\n    if (node) {\n      const nextName = next ? 'nextSibling' : 'previousSibling';\n\n      for (node = inc ? node : node[nextName]; node; node = node[nextName]) {\n        if (isElement$6(node) || !isWhiteSpaceNode$1(node)) {\n          return node;\n        }\n      }\n    }\n  };\n\n  const isTextBlock$1 = (editor, name) => {\n    if (isNode(name)) {\n      name = name.nodeName;\n    }\n\n    return !!editor.schema.getTextBlockElements()[name.toLowerCase()];\n  };\n\n  const isValid = (ed, parent, child) => {\n    return ed.schema.isValidChild(parent, child);\n  };\n\n  const isWhiteSpaceNode$1 = function (node) {\n    let allowSpaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (isNonNullable(node) && isText$8(node)) {\n      const data = allowSpaces ? node.data.replace(/ /g, '\\xA0') : node.data;\n      return isWhitespaceText(data);\n    } else {\n      return false;\n    }\n  };\n\n  const isEmptyTextNode$1 = node => {\n    return isNonNullable(node) && isText$8(node) && node.length === 0;\n  };\n\n  const replaceVars = (value, vars) => {\n    if (isFunction(value)) {\n      value = value(vars);\n    } else if (isNonNullable(vars)) {\n      value = value.replace(/%(\\w+)/g, (str, name) => {\n        return vars[name] || str;\n      });\n    }\n\n    return value;\n  };\n\n  const isEq$5 = (str1, str2) => {\n    str1 = str1 || '';\n    str2 = str2 || '';\n    str1 = '' + (str1.nodeName || str1);\n    str2 = '' + (str2.nodeName || str2);\n    return str1.toLowerCase() === str2.toLowerCase();\n  };\n\n  const normalizeStyleValue = (value, name) => {\n    if (name === 'color' || name === 'backgroundColor') {\n      value = rgbaToHexString(value);\n    }\n\n    if (name === 'fontWeight' && value === 700) {\n      value = 'bold';\n    }\n\n    if (name === 'fontFamily') {\n      value = value.replace(/[\\'\\\"]/g, '').replace(/,\\s+/g, ',');\n    }\n\n    return '' + value;\n  };\n\n  const getStyle = (dom, node, name) => {\n    return normalizeStyleValue(dom.getStyle(node, name), name);\n  };\n\n  const getTextDecoration = (dom, node) => {\n    let decoration;\n    dom.getParent(node, n => {\n      decoration = dom.getStyle(n, 'text-decoration');\n      return decoration && decoration !== 'none';\n    });\n    return decoration;\n  };\n\n  const getParents$2 = (dom, node, selector) => {\n    return dom.getParents(node, selector, dom.getRoot());\n  };\n\n  const isVariableFormatName = (editor, formatName) => {\n    const hasVariableValues = format => {\n      const isVariableValue = val => val.length > 1 && val.charAt(0) === '%';\n\n      return exists(['styles', 'attributes'], key => get$a(format, key).exists(field => {\n        const fieldValues = isArray$1(field) ? field : values(field);\n        return exists(fieldValues, isVariableValue);\n      }));\n    };\n\n    return exists(editor.formatter.get(formatName), hasVariableValues);\n  };\n\n  const areSimilarFormats = (editor, formatName, otherFormatName) => {\n    const validKeys = ['inline', 'block', 'selector', 'attributes', 'styles', 'classes'];\n\n    const filterObj = format => filter$5(format, (_, key) => exists(validKeys, validKey => validKey === key));\n\n    return exists(editor.formatter.get(formatName), fmt1 => {\n      const filteredFmt1 = filterObj(fmt1);\n      return exists(editor.formatter.get(otherFormatName), fmt2 => {\n        const filteredFmt2 = filterObj(fmt2);\n        return equal$1(filteredFmt1, filteredFmt2);\n      });\n    });\n  };\n\n  const isBlockFormat = format => hasNonNullableKey(format, 'block');\n\n  const isSelectorFormat = format => hasNonNullableKey(format, 'selector');\n\n  const isInlineFormat = format => hasNonNullableKey(format, 'inline');\n\n  const isMixedFormat = format => isSelectorFormat(format) && isInlineFormat(format) && is$2(get$a(format, 'mixed'), true);\n\n  const shouldExpandToSelector = format => isSelectorFormat(format) && format.expand !== false && !isInlineFormat(format);\n\n  const isBookmarkNode = isBookmarkNode$1;\n  const getParents$1 = getParents$2;\n  const isWhiteSpaceNode = isWhiteSpaceNode$1;\n  const isTextBlock = isTextBlock$1;\n\n  const isBogusBr = node => {\n    return isBr$5(node) && node.getAttribute('data-mce-bogus') && !node.nextSibling;\n  };\n\n  const findParentContentEditable = (dom, node) => {\n    let parent = node;\n\n    while (parent) {\n      if (isElement$6(parent) && dom.getContentEditable(parent)) {\n        return dom.getContentEditable(parent) === 'false' ? parent : node;\n      }\n\n      parent = parent.parentNode;\n    }\n\n    return node;\n  };\n\n  const walkText = (start, node, offset, predicate) => {\n    const str = node.data;\n\n    for (let i = offset; start ? i >= 0 : i < str.length; start ? i-- : i++) {\n      if (predicate(str.charAt(i))) {\n        return start ? i + 1 : i;\n      }\n    }\n\n    return -1;\n  };\n\n  const findSpace = (start, node, offset) => walkText(start, node, offset, c => isNbsp(c) || isWhiteSpace(c));\n\n  const findContent = (start, node, offset) => walkText(start, node, offset, isContent);\n\n  const findWordEndPoint = (dom, body, container, offset, start, includeTrailingSpaces) => {\n    let lastTextNode;\n    const rootNode = dom.getParent(container, dom.isBlock) || body;\n\n    const walk = (container, offset, pred) => {\n      const textSeeker = TextSeeker(dom);\n      const walker = start ? textSeeker.backwards : textSeeker.forwards;\n      return Optional.from(walker(container, offset, (text, textOffset) => {\n        if (isBookmarkNode(text.parentNode)) {\n          return -1;\n        } else {\n          lastTextNode = text;\n          return pred(start, text, textOffset);\n        }\n      }, rootNode));\n    };\n\n    const spaceResult = walk(container, offset, findSpace);\n    return spaceResult.bind(result => includeTrailingSpaces ? walk(result.container, result.offset + (start ? -1 : 0), findContent) : Optional.some(result)).orThunk(() => lastTextNode ? Optional.some({\n      container: lastTextNode,\n      offset: start ? 0 : lastTextNode.length\n    }) : Optional.none());\n  };\n\n  const findSelectorEndPoint = (dom, formatList, rng, container, siblingName) => {\n    if (isText$8(container) && isEmpty$3(container.data) && container[siblingName]) {\n      container = container[siblingName];\n    }\n\n    const parents = getParents$1(dom, container);\n\n    for (let i = 0; i < parents.length; i++) {\n      for (let y = 0; y < formatList.length; y++) {\n        const curFormat = formatList[y];\n\n        if (isNonNullable(curFormat.collapsed) && curFormat.collapsed !== rng.collapsed) {\n          continue;\n        }\n\n        if (isSelectorFormat(curFormat) && dom.is(parents[i], curFormat.selector)) {\n          return parents[i];\n        }\n      }\n    }\n\n    return container;\n  };\n\n  const findBlockEndPoint = (editor, formatList, container, siblingName) => {\n    let node = container;\n    const dom = editor.dom;\n    const root = dom.getRoot();\n    const format = formatList[0];\n\n    if (isBlockFormat(format)) {\n      node = format.wrapper ? null : dom.getParent(container, format.block, root);\n    }\n\n    if (!node) {\n      const scopeRoot = dom.getParent(container, 'LI,TD,TH');\n      node = dom.getParent(isText$8(container) ? container.parentNode : container, node => node !== root && isTextBlock(editor, node), scopeRoot);\n    }\n\n    if (node && isBlockFormat(format) && format.wrapper) {\n      node = getParents$1(dom, node, 'ul,ol').reverse()[0] || node;\n    }\n\n    if (!node) {\n      node = container;\n\n      while (node[siblingName] && !dom.isBlock(node[siblingName])) {\n        node = node[siblingName];\n\n        if (isEq$5(node, 'br')) {\n          break;\n        }\n      }\n    }\n\n    return node || container;\n  };\n\n  const isAtBlockBoundary$1 = (dom, root, container, siblingName) => {\n    const parent = container.parentNode;\n\n    if (isNonNullable(container[siblingName])) {\n      return false;\n    } else if (parent === root || isNullable(parent) || dom.isBlock(parent)) {\n      return true;\n    } else {\n      return isAtBlockBoundary$1(dom, root, parent, siblingName);\n    }\n  };\n\n  const findParentContainer = (dom, formatList, container, offset, start) => {\n    let parent = container;\n    const siblingName = start ? 'previousSibling' : 'nextSibling';\n    const root = dom.getRoot();\n\n    if (isText$8(container) && !isWhiteSpaceNode(container)) {\n      if (start ? offset > 0 : offset < container.data.length) {\n        return container;\n      }\n    }\n\n    while (true) {\n      if (!formatList[0].block_expand && dom.isBlock(parent)) {\n        return parent;\n      }\n\n      for (let sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {\n        const allowSpaces = isText$8(sibling) && !isAtBlockBoundary$1(dom, root, sibling, siblingName);\n\n        if (!isBookmarkNode(sibling) && !isBogusBr(sibling) && !isWhiteSpaceNode(sibling, allowSpaces)) {\n          return parent;\n        }\n      }\n\n      if (parent === root || parent.parentNode === root) {\n        container = parent;\n        break;\n      }\n\n      parent = parent.parentNode;\n    }\n\n    return container;\n  };\n\n  const isSelfOrParentBookmark = container => isBookmarkNode(container.parentNode) || isBookmarkNode(container);\n\n  const expandRng = function (editor, rng, formatList) {\n    let includeTrailingSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let {\n      startContainer,\n      startOffset,\n      endContainer,\n      endOffset\n    } = rng;\n    const dom = editor.dom;\n    const format = formatList[0];\n\n    if (isElement$6(startContainer) && startContainer.hasChildNodes()) {\n      startContainer = getNode$1(startContainer, startOffset);\n\n      if (isText$8(startContainer)) {\n        startOffset = 0;\n      }\n    }\n\n    if (isElement$6(endContainer) && endContainer.hasChildNodes()) {\n      endContainer = getNode$1(endContainer, rng.collapsed ? endOffset : endOffset - 1);\n\n      if (isText$8(endContainer)) {\n        endOffset = endContainer.nodeValue.length;\n      }\n    }\n\n    startContainer = findParentContentEditable(dom, startContainer);\n    endContainer = findParentContentEditable(dom, endContainer);\n\n    if (isSelfOrParentBookmark(startContainer)) {\n      startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;\n\n      if (rng.collapsed) {\n        startContainer = startContainer.previousSibling || startContainer;\n      } else {\n        startContainer = startContainer.nextSibling || startContainer;\n      }\n\n      if (isText$8(startContainer)) {\n        startOffset = rng.collapsed ? startContainer.length : 0;\n      }\n    }\n\n    if (isSelfOrParentBookmark(endContainer)) {\n      endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;\n\n      if (rng.collapsed) {\n        endContainer = endContainer.nextSibling || endContainer;\n      } else {\n        endContainer = endContainer.previousSibling || endContainer;\n      }\n\n      if (isText$8(endContainer)) {\n        endOffset = rng.collapsed ? 0 : endContainer.length;\n      }\n    }\n\n    if (rng.collapsed) {\n      const startPoint = findWordEndPoint(dom, editor.getBody(), startContainer, startOffset, true, includeTrailingSpace);\n      startPoint.each(_ref4 => {\n        let {\n          container,\n          offset\n        } = _ref4;\n        startContainer = container;\n        startOffset = offset;\n      });\n      const endPoint = findWordEndPoint(dom, editor.getBody(), endContainer, endOffset, false, includeTrailingSpace);\n      endPoint.each(_ref5 => {\n        let {\n          container,\n          offset\n        } = _ref5;\n        endContainer = container;\n        endOffset = offset;\n      });\n    }\n\n    if (isInlineFormat(format) || format.block_expand) {\n      if (!isInlineFormat(format) || !isText$8(startContainer) || startOffset === 0) {\n        startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\n      }\n\n      if (!isInlineFormat(format) || !isText$8(endContainer) || endOffset === endContainer.nodeValue.length) {\n        endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\n      }\n    }\n\n    if (shouldExpandToSelector(format)) {\n      startContainer = findSelectorEndPoint(dom, formatList, rng, startContainer, 'previousSibling');\n      endContainer = findSelectorEndPoint(dom, formatList, rng, endContainer, 'nextSibling');\n    }\n\n    if (isBlockFormat(format) || isSelectorFormat(format)) {\n      startContainer = findBlockEndPoint(editor, formatList, startContainer, 'previousSibling');\n      endContainer = findBlockEndPoint(editor, formatList, endContainer, 'nextSibling');\n\n      if (isBlockFormat(format)) {\n        if (!dom.isBlock(startContainer)) {\n          startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\n        }\n\n        if (!dom.isBlock(endContainer)) {\n          endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\n        }\n      }\n    }\n\n    if (isElement$6(startContainer)) {\n      startOffset = dom.nodeIndex(startContainer);\n      startContainer = startContainer.parentNode;\n    }\n\n    if (isElement$6(endContainer)) {\n      endOffset = dom.nodeIndex(endContainer) + 1;\n      endContainer = endContainer.parentNode;\n    }\n\n    return {\n      startContainer,\n      startOffset,\n      endContainer,\n      endOffset\n    };\n  };\n\n  const walk$3 = (dom, rng, callback) => {\n    const startOffset = rng.startOffset;\n    const startContainer = getNode$1(rng.startContainer, startOffset);\n    const endOffset = rng.endOffset;\n    const endContainer = getNode$1(rng.endContainer, endOffset - 1);\n\n    const exclude = nodes => {\n      const firstNode = nodes[0];\n\n      if (isText$8(firstNode) && firstNode === startContainer && startOffset >= firstNode.data.length) {\n        nodes.splice(0, 1);\n      }\n\n      const lastNode = nodes[nodes.length - 1];\n\n      if (endOffset === 0 && nodes.length > 0 && lastNode === endContainer && isText$8(lastNode)) {\n        nodes.splice(nodes.length - 1, 1);\n      }\n\n      return nodes;\n    };\n\n    const collectSiblings = (node, name, endNode) => {\n      const siblings = [];\n\n      for (; node && node !== endNode; node = node[name]) {\n        siblings.push(node);\n      }\n\n      return siblings;\n    };\n\n    const findEndPoint = (node, root) => dom.getParent(node, node => node.parentNode === root, root);\n\n    const walkBoundary = (startNode, endNode, next) => {\n      const siblingName = next ? 'nextSibling' : 'previousSibling';\n\n      for (let node = startNode, parent = node.parentNode; node && node !== endNode; node = parent) {\n        parent = node.parentNode;\n        const siblings = collectSiblings(node === startNode ? node : node[siblingName], siblingName);\n\n        if (siblings.length) {\n          if (!next) {\n            siblings.reverse();\n          }\n\n          callback(exclude(siblings));\n        }\n      }\n    };\n\n    if (startContainer === endContainer) {\n      return callback(exclude([startContainer]));\n    }\n\n    const ancestor = dom.findCommonAncestor(startContainer, endContainer);\n\n    if (dom.isChildOf(startContainer, endContainer)) {\n      return walkBoundary(startContainer, ancestor, true);\n    }\n\n    if (dom.isChildOf(endContainer, startContainer)) {\n      return walkBoundary(endContainer, ancestor);\n    }\n\n    const startPoint = findEndPoint(startContainer, ancestor) || startContainer;\n    const endPoint = findEndPoint(endContainer, ancestor) || endContainer;\n    walkBoundary(startContainer, startPoint, true);\n    const siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, 'nextSibling', endPoint === endContainer ? endPoint.nextSibling : endPoint);\n\n    if (siblings.length) {\n      callback(exclude(siblings));\n    }\n\n    walkBoundary(endContainer, endPoint);\n  };\n\n  const getRanges$1 = selection => {\n    const ranges = [];\n\n    if (selection) {\n      for (let i = 0; i < selection.rangeCount; i++) {\n        ranges.push(selection.getRangeAt(i));\n      }\n    }\n\n    return ranges;\n  };\n\n  const getSelectedNodes = ranges => {\n    return bind$3(ranges, range => {\n      const node = getSelectedNode(range);\n      return node ? [SugarElement.fromDom(node)] : [];\n    });\n  };\n\n  const hasMultipleRanges = selection => {\n    return getRanges$1(selection).length > 1;\n  };\n\n  const getCellsFromRanges = ranges => filter$6(getSelectedNodes(ranges), isTableCell$4);\n\n  const getCellsFromElement = elm => descendants(elm, 'td[data-mce-selected],th[data-mce-selected]');\n\n  const getCellsFromElementOrRanges = (ranges, element) => {\n    const selectedCells = getCellsFromElement(element);\n    return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);\n  };\n\n  const getCellsFromEditor = editor => getCellsFromElementOrRanges(getRanges$1(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));\n\n  const getClosestTable = (cell, isRoot) => ancestor$2(cell, 'table', isRoot);\n\n  const getStartNode = rng => {\n    const sc = rng.startContainer,\n          so = rng.startOffset;\n\n    if (isText$8(sc)) {\n      return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();\n    } else {\n      return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);\n    }\n  };\n\n  const getEndNode = rng => {\n    const ec = rng.endContainer,\n          eo = rng.endOffset;\n\n    if (isText$8(ec)) {\n      return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();\n    } else {\n      return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);\n    }\n  };\n\n  const getFirstChildren = node => {\n    return firstChild(node).fold(constant([node]), child => {\n      return [node].concat(getFirstChildren(child));\n    });\n  };\n\n  const getLastChildren$1 = node => {\n    return lastChild(node).fold(constant([node]), child => {\n      if (name(child) === 'br') {\n        return prevSibling(child).map(sibling => {\n          return [node].concat(getLastChildren$1(sibling));\n        }).getOr([]);\n      } else {\n        return [node].concat(getLastChildren$1(child));\n      }\n    });\n  };\n\n  const hasAllContentsSelected = (elm, rng) => {\n    return lift2(getStartNode(rng), getEndNode(rng), (startNode, endNode) => {\n      const start = find$2(getFirstChildren(elm), curry(eq, startNode));\n      const end = find$2(getLastChildren$1(elm), curry(eq, endNode));\n      return start.isSome() && end.isSome();\n    }).getOr(false);\n  };\n\n  const moveEndPoint = (dom, rng, node, start) => {\n    const root = node,\n          walker = new DomTreeWalker(node, root);\n    const moveCaretBeforeOnEnterElementsMap = filter$5(dom.schema.getMoveCaretBeforeOnEnterElements(), (_, name) => !contains$2(['td', 'th', 'table'], name.toLowerCase()));\n\n    do {\n      if (isText$8(node) && Tools.trim(node.nodeValue).length !== 0) {\n        if (start) {\n          rng.setStart(node, 0);\n        } else {\n          rng.setEnd(node, node.nodeValue.length);\n        }\n\n        return;\n      }\n\n      if (moveCaretBeforeOnEnterElementsMap[node.nodeName]) {\n        if (start) {\n          rng.setStartBefore(node);\n        } else {\n          if (node.nodeName === 'BR') {\n            rng.setEndBefore(node);\n          } else {\n            rng.setEndAfter(node);\n          }\n        }\n\n        return;\n      }\n    } while (node = start ? walker.next() : walker.prev());\n\n    if (root.nodeName === 'BODY') {\n      if (start) {\n        rng.setStart(root, 0);\n      } else {\n        rng.setEnd(root, root.childNodes.length);\n      }\n    }\n  };\n\n  const hasAnyRanges = editor => {\n    const sel = editor.selection.getSel();\n    return sel && sel.rangeCount > 0;\n  };\n\n  const runOnRanges = (editor, executor) => {\n    const fakeSelectionNodes = getCellsFromEditor(editor);\n\n    if (fakeSelectionNodes.length > 0) {\n      each$g(fakeSelectionNodes, elem => {\n        const node = elem.dom;\n        const fakeNodeRng = editor.dom.createRng();\n        fakeNodeRng.setStartBefore(node);\n        fakeNodeRng.setEndAfter(node);\n        executor(fakeNodeRng, true);\n      });\n    } else {\n      executor(editor.selection.getRng(), false);\n    }\n  };\n\n  const preserve = (selection, fillBookmark, executor) => {\n    const bookmark = getPersistentBookmark(selection, fillBookmark);\n    executor(bookmark);\n    selection.moveToBookmark(bookmark);\n  };\n\n  const NodeValue = (is, name) => {\n    const get = element => {\n      if (!is(element)) {\n        throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\n      }\n\n      return getOption(element).getOr('');\n    };\n\n    const getOption = element => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\n\n    const set = (element, value) => {\n      if (!is(element)) {\n        throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\n      }\n\n      element.dom.nodeValue = value;\n    };\n\n    return {\n      get,\n      getOption,\n      set\n    };\n  };\n\n  const api$1 = NodeValue(isText$9, 'text');\n\n  const get$3 = element => api$1.get(element);\n\n  const getOption = element => api$1.getOption(element);\n\n  const isZeroWidth = elem => isText$9(elem) && get$3(elem) === ZWSP$1;\n\n  const context = (editor, elem, wrapName, nodeName) => parent(elem).fold(() => 'skipping', parent => {\n    if (nodeName === 'br' || isZeroWidth(elem)) {\n      return 'valid';\n    } else if (isAnnotation(elem)) {\n      return 'existing';\n    } else if (isCaretNode(elem.dom)) {\n      return 'caret';\n    } else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent), wrapName)) {\n      return 'invalid-child';\n    } else {\n      return 'valid';\n    }\n  });\n\n  const applyWordGrab = (editor, rng) => {\n    const r = expandRng(editor, rng, [{\n      inline: 'span'\n    }]);\n    rng.setStart(r.startContainer, r.startOffset);\n    rng.setEnd(r.endContainer, r.endOffset);\n    editor.selection.setRng(rng);\n  };\n\n  const makeAnnotation = (eDoc, _ref6, annotationName, decorate) => {\n    let {\n      uid = generate$1('mce-annotation'),\n      ...data\n    } = _ref6;\n    const master = SugarElement.fromTag('span', eDoc);\n    add$2(master, annotation());\n    set$2(master, `${dataAnnotationId()}`, uid);\n    set$2(master, `${dataAnnotation()}`, annotationName);\n    const {\n      attributes = {},\n      classes = []\n    } = decorate(uid, data);\n    setAll$1(master, attributes);\n    add(master, classes);\n    return master;\n  };\n\n  const annotate = (editor, rng, annotationName, decorate, data) => {\n    const newWrappers = [];\n    const master = makeAnnotation(editor.getDoc(), data, annotationName, decorate);\n    const wrapper = value$2();\n\n    const finishWrapper = () => {\n      wrapper.clear();\n    };\n\n    const getOrOpenWrapper = () => wrapper.get().getOrThunk(() => {\n      const nu = shallow$1(master);\n      newWrappers.push(nu);\n      wrapper.set(nu);\n      return nu;\n    });\n\n    const processElements = elems => {\n      each$g(elems, processElement);\n    };\n\n    const processElement = elem => {\n      const ctx = context(editor, elem, 'span', name(elem));\n\n      switch (ctx) {\n        case 'invalid-child':\n          {\n            finishWrapper();\n            const children$1 = children(elem);\n            processElements(children$1);\n            finishWrapper();\n            break;\n          }\n\n        case 'valid':\n          {\n            const w = getOrOpenWrapper();\n            wrap$2(elem, w);\n            break;\n          }\n      }\n    };\n\n    const processNodes = nodes => {\n      const elems = map$3(nodes, SugarElement.fromDom);\n      processElements(elems);\n    };\n\n    walk$3(editor.dom, rng, nodes => {\n      finishWrapper();\n      processNodes(nodes);\n    });\n    return newWrappers;\n  };\n\n  const annotateWithBookmark = (editor, name, settings, data) => {\n    editor.undoManager.transact(() => {\n      const selection = editor.selection;\n      const initialRng = selection.getRng();\n      const hasFakeSelection = getCellsFromEditor(editor).length > 0;\n\n      if (initialRng.collapsed && !hasFakeSelection) {\n        applyWordGrab(editor, initialRng);\n      }\n\n      if (selection.getRng().collapsed && !hasFakeSelection) {\n        const wrapper = makeAnnotation(editor.getDoc(), data, name, settings.decorate);\n        set(wrapper, nbsp);\n        selection.getRng().insertNode(wrapper.dom);\n        selection.select(wrapper.dom);\n      } else {\n        preserve(selection, false, () => {\n          runOnRanges(editor, selectionRng => {\n            annotate(editor, selectionRng, name, settings.decorate, data);\n          });\n        });\n      }\n    });\n  };\n\n  const Annotator = editor => {\n    const registry = create$b();\n    setup$w(editor, registry);\n    const changes = setup$x(editor, registry);\n    return {\n      register: (name, settings) => {\n        registry.register(name, settings);\n      },\n      annotate: (name, data) => {\n        registry.lookup(name).each(settings => {\n          annotateWithBookmark(editor, name, settings, data);\n        });\n      },\n      annotationChanged: (name, callback) => {\n        changes.addListener(name, callback);\n      },\n      remove: name => {\n        const bookmark = editor.selection.getBookmark();\n        identify(editor, Optional.some(name)).each(_ref7 => {\n          let {\n            elements\n          } = _ref7;\n          each$g(elements, unwrap);\n        });\n        editor.selection.moveToBookmark(bookmark);\n      },\n      removeAll: name => {\n        const bookmark = editor.selection.getBookmark();\n        each$f(findAll(editor, name), (spans, _) => each$g(spans, unwrap));\n        editor.selection.moveToBookmark(bookmark);\n      },\n      getAll: name => {\n        const directory = findAll(editor, name);\n        return map$2(directory, elems => map$3(elems, elem => elem.dom));\n      }\n    };\n  };\n\n  const BookmarkManager = selection => {\n    return {\n      getBookmark: curry(getBookmark$1, selection),\n      moveToBookmark: curry(moveToBookmark, selection)\n    };\n  };\n\n  BookmarkManager.isBookmarkNode = isBookmarkNode$1;\n\n  const isXYWithinRange = (clientX, clientY, range) => {\n    if (range.collapsed) {\n      return false;\n    } else {\n      return exists(range.getClientRects(), rect => containsXY(rect, clientX, clientY));\n    }\n  };\n\n  const firePreProcess = (editor, args) => editor.dispatch('PreProcess', args);\n\n  const firePostProcess = (editor, args) => editor.dispatch('PostProcess', args);\n\n  const fireRemove = editor => editor.dispatch('remove');\n\n  const fireDetach = editor => editor.dispatch('detach');\n\n  const fireSwitchMode = (editor, mode) => editor.dispatch('SwitchMode', {\n    mode\n  });\n\n  const fireObjectResizeStart = (editor, target, width, height, origin) => {\n    editor.dispatch('ObjectResizeStart', {\n      target,\n      width,\n      height,\n      origin\n    });\n  };\n\n  const fireObjectResized = (editor, target, width, height, origin) => {\n    editor.dispatch('ObjectResized', {\n      target,\n      width,\n      height,\n      origin\n    });\n  };\n\n  const firePreInit = editor => editor.dispatch('PreInit');\n\n  const firePostRender = editor => editor.dispatch('PostRender');\n\n  const fireInit = editor => editor.dispatch('Init');\n\n  const firePlaceholderToggle = (editor, state) => editor.dispatch('PlaceholderToggle', {\n    state\n  });\n\n  const fireError = (editor, errorType, error) => editor.dispatch(errorType, error);\n\n  const fireFormatApply = (editor, format, node, vars) => editor.dispatch('FormatApply', {\n    format,\n    node,\n    vars\n  });\n\n  const fireFormatRemove = (editor, format, node, vars) => editor.dispatch('FormatRemove', {\n    format,\n    node,\n    vars\n  });\n\n  const fireBeforeSetContent = (editor, args) => editor.dispatch('BeforeSetContent', args);\n\n  const fireSetContent = (editor, args) => editor.dispatch('SetContent', args);\n\n  const fireBeforeGetContent = (editor, args) => editor.dispatch('BeforeGetContent', args);\n\n  const fireGetContent = (editor, args) => editor.dispatch('GetContent', args);\n\n  const fireAutocompleterStart = (editor, args) => editor.dispatch('AutocompleterStart', args);\n\n  const fireAutocompleterUpdate = (editor, args) => editor.dispatch('AutocompleterUpdate', args);\n\n  const fireAutocompleterEnd = editor => editor.dispatch('AutocompleterEnd');\n\n  const firePastePreProcess = (editor, html, internal) => editor.dispatch('PastePreProcess', {\n    content: html,\n    internal\n  });\n\n  const firePastePostProcess = (editor, node, internal) => editor.dispatch('PastePostProcess', {\n    node,\n    internal\n  });\n\n  const firePastePlainTextToggle = (editor, state) => editor.dispatch('PastePlainTextToggle', {\n    state\n  });\n\n  const VK = {\n    BACKSPACE: 8,\n    DELETE: 46,\n    DOWN: 40,\n    ENTER: 13,\n    ESC: 27,\n    LEFT: 37,\n    RIGHT: 39,\n    SPACEBAR: 32,\n    TAB: 9,\n    UP: 38,\n    PAGE_UP: 33,\n    PAGE_DOWN: 34,\n    END: 35,\n    HOME: 36,\n    modifierPressed: e => {\n      return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);\n    },\n    metaKeyPressed: e => {\n      return Env.os.isMacOS() || Env.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey;\n    }\n  };\n\n  const ControlSelection = (selection, editor) => {\n    const elementSelectionAttr = 'data-mce-selected';\n    const dom = editor.dom,\n          each = Tools.each;\n    let selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;\n    let startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;\n    let width, height;\n    const editableDoc = editor.getDoc(),\n          rootDocument = document;\n    const abs = Math.abs,\n          round = Math.round,\n          rootElement = editor.getBody();\n    let startScrollWidth, startScrollHeight;\n    const resizeHandles = {\n      nw: [0, 0, -1, -1],\n      ne: [1, 0, 1, -1],\n      se: [1, 1, 1, 1],\n      sw: [0, 1, -1, 1]\n    };\n\n    const isImage = elm => isNonNullable(elm) && (isImg(elm) || editor.dom.is(elm, 'figure.image'));\n\n    const isMedia = elm => isMedia$2(elm) || dom.hasClass(elm, 'mce-preview-object');\n\n    const isEventOnImageOutsideRange = (evt, range) => {\n      if (evt.type === 'longpress' || evt.type.indexOf('touch') === 0) {\n        const touch = evt.touches[0];\n        return isImage(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range);\n      } else {\n        return isImage(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range);\n      }\n    };\n\n    const contextMenuSelectImage = evt => {\n      const target = evt.target;\n\n      if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {\n        editor.selection.select(target);\n      }\n    };\n\n    const getResizeTargets = elm => {\n      if (dom.is(elm, 'figure.image')) {\n        return [elm.querySelector('img')];\n      } else if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {\n        return [elm, elm.firstElementChild];\n      } else {\n        return [elm];\n      }\n    };\n\n    const isResizable = elm => {\n      const selector = getObjectResizing(editor);\n\n      if (!selector) {\n        return false;\n      }\n\n      if (elm.getAttribute('data-mce-resize') === 'false') {\n        return false;\n      }\n\n      if (elm === editor.getBody()) {\n        return false;\n      }\n\n      if (dom.hasClass(elm, 'mce-preview-object')) {\n        return is$1(SugarElement.fromDom(elm.firstElementChild), selector);\n      } else {\n        return is$1(SugarElement.fromDom(elm), selector);\n      }\n    };\n\n    const createGhostElement = elm => {\n      if (isMedia(elm)) {\n        return dom.create('img', {\n          src: Env.transparentSrc\n        });\n      } else {\n        return elm.cloneNode(true);\n      }\n    };\n\n    const setSizeProp = (element, name, value) => {\n      if (isNonNullable(value)) {\n        const targets = getResizeTargets(element);\n        each$g(targets, target => {\n          if (target.style[name] || !editor.schema.isValid(target.nodeName.toLowerCase(), name)) {\n            dom.setStyle(target, name, value);\n          } else {\n            dom.setAttrib(target, name, '' + value);\n          }\n        });\n      }\n    };\n\n    const setGhostElmSize = (ghostElm, width, height) => {\n      setSizeProp(ghostElm, 'width', width);\n      setSizeProp(ghostElm, 'height', height);\n    };\n\n    const resizeGhostElement = e => {\n      let deltaX, deltaY, proportional;\n      let resizeHelperX, resizeHelperY;\n      deltaX = e.screenX - startX;\n      deltaY = e.screenY - startY;\n      width = deltaX * selectedHandle[2] + startW;\n      height = deltaY * selectedHandle[3] + startH;\n      width = width < 5 ? 5 : width;\n      height = height < 5 ? 5 : height;\n\n      if ((isImage(selectedElm) || isMedia(selectedElm)) && getResizeImgProportional(editor) !== false) {\n        proportional = !VK.modifierPressed(e);\n      } else {\n        proportional = VK.modifierPressed(e);\n      }\n\n      if (proportional) {\n        if (abs(deltaX) > abs(deltaY)) {\n          height = round(width * ratio);\n          width = round(height / ratio);\n        } else {\n          width = round(height / ratio);\n          height = round(width * ratio);\n        }\n      }\n\n      setGhostElmSize(selectedElmGhost, width, height);\n      resizeHelperX = selectedHandle.startPos.x + deltaX;\n      resizeHelperY = selectedHandle.startPos.y + deltaY;\n      resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;\n      resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;\n      dom.setStyles(resizeHelper, {\n        left: resizeHelperX,\n        top: resizeHelperY,\n        display: 'block'\n      });\n      resizeHelper.innerHTML = width + ' &times; ' + height;\n\n      if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {\n        dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));\n      }\n\n      if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {\n        dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));\n      }\n\n      deltaX = rootElement.scrollWidth - startScrollWidth;\n      deltaY = rootElement.scrollHeight - startScrollHeight;\n\n      if (deltaX + deltaY !== 0) {\n        dom.setStyles(resizeHelper, {\n          left: resizeHelperX - deltaX,\n          top: resizeHelperY - deltaY\n        });\n      }\n\n      if (!resizeStarted) {\n        fireObjectResizeStart(editor, selectedElm, startW, startH, 'corner-' + selectedHandle.name);\n        resizeStarted = true;\n      }\n    };\n\n    const endGhostResize = () => {\n      const wasResizeStarted = resizeStarted;\n      resizeStarted = false;\n\n      if (wasResizeStarted) {\n        setSizeProp(selectedElm, 'width', width);\n        setSizeProp(selectedElm, 'height', height);\n      }\n\n      dom.unbind(editableDoc, 'mousemove', resizeGhostElement);\n      dom.unbind(editableDoc, 'mouseup', endGhostResize);\n\n      if (rootDocument !== editableDoc) {\n        dom.unbind(rootDocument, 'mousemove', resizeGhostElement);\n        dom.unbind(rootDocument, 'mouseup', endGhostResize);\n      }\n\n      dom.remove(selectedElmGhost);\n      dom.remove(resizeHelper);\n      dom.remove(resizeBackdrop);\n      showResizeRect(selectedElm);\n\n      if (wasResizeStarted) {\n        fireObjectResized(editor, selectedElm, width, height, 'corner-' + selectedHandle.name);\n        dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));\n      }\n\n      editor.nodeChanged();\n    };\n\n    const showResizeRect = targetElm => {\n      unbindResizeHandleEvents();\n      const position = dom.getPos(targetElm, rootElement);\n      const selectedElmX = position.x;\n      const selectedElmY = position.y;\n      const rect = targetElm.getBoundingClientRect();\n      const targetWidth = rect.width || rect.right - rect.left;\n      const targetHeight = rect.height || rect.bottom - rect.top;\n\n      if (selectedElm !== targetElm) {\n        hideResizeRect();\n        selectedElm = targetElm;\n        width = height = 0;\n      }\n\n      const e = editor.dispatch('ObjectSelected', {\n        target: targetElm\n      });\n      const selectedValue = dom.getAttrib(selectedElm, elementSelectionAttr, '1');\n\n      if (isResizable(targetElm) && !e.isDefaultPrevented()) {\n        each(resizeHandles, (handle, name) => {\n          let handleElm;\n\n          const startDrag = e => {\n            const target = getResizeTargets(selectedElm)[0];\n            startX = e.screenX;\n            startY = e.screenY;\n            startW = target.clientWidth;\n            startH = target.clientHeight;\n            ratio = startH / startW;\n            selectedHandle = handle;\n            selectedHandle.name = name;\n            selectedHandle.startPos = {\n              x: targetWidth * handle[0] + selectedElmX,\n              y: targetHeight * handle[1] + selectedElmY\n            };\n            startScrollWidth = rootElement.scrollWidth;\n            startScrollHeight = rootElement.scrollHeight;\n            resizeBackdrop = dom.add(rootElement, 'div', {\n              'class': 'mce-resize-backdrop',\n              'data-mce-bogus': 'all'\n            });\n            dom.setStyles(resizeBackdrop, {\n              position: 'fixed',\n              left: '0',\n              top: '0',\n              width: '100%',\n              height: '100%'\n            });\n            selectedElmGhost = createGhostElement(selectedElm);\n            dom.addClass(selectedElmGhost, 'mce-clonedresizable');\n            dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');\n            selectedElmGhost.contentEditable = 'false';\n            dom.setStyles(selectedElmGhost, {\n              left: selectedElmX,\n              top: selectedElmY,\n              margin: 0\n            });\n            setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);\n            selectedElmGhost.removeAttribute(elementSelectionAttr);\n            rootElement.appendChild(selectedElmGhost);\n            dom.bind(editableDoc, 'mousemove', resizeGhostElement);\n            dom.bind(editableDoc, 'mouseup', endGhostResize);\n\n            if (rootDocument !== editableDoc) {\n              dom.bind(rootDocument, 'mousemove', resizeGhostElement);\n              dom.bind(rootDocument, 'mouseup', endGhostResize);\n            }\n\n            resizeHelper = dom.add(rootElement, 'div', {\n              'class': 'mce-resize-helper',\n              'data-mce-bogus': 'all'\n            }, startW + ' &times; ' + startH);\n          };\n\n          handleElm = dom.get('mceResizeHandle' + name);\n\n          if (handleElm) {\n            dom.remove(handleElm);\n          }\n\n          handleElm = dom.add(rootElement, 'div', {\n            'id': 'mceResizeHandle' + name,\n            'data-mce-bogus': 'all',\n            'class': 'mce-resizehandle',\n            'unselectable': true,\n            'style': 'cursor:' + name + '-resize; margin:0; padding:0'\n          });\n          dom.bind(handleElm, 'mousedown', e => {\n            e.stopImmediatePropagation();\n            e.preventDefault();\n            startDrag(e);\n          });\n          handle.elm = handleElm;\n          dom.setStyles(handleElm, {\n            left: targetWidth * handle[0] + selectedElmX - handleElm.offsetWidth / 2,\n            top: targetHeight * handle[1] + selectedElmY - handleElm.offsetHeight / 2\n          });\n        });\n      } else {\n        hideResizeRect();\n      }\n\n      if (!dom.getAttrib(selectedElm, elementSelectionAttr)) {\n        selectedElm.setAttribute(elementSelectionAttr, selectedValue);\n      }\n    };\n\n    const hideResizeRect = () => {\n      unbindResizeHandleEvents();\n\n      if (selectedElm) {\n        selectedElm.removeAttribute(elementSelectionAttr);\n      }\n\n      each$f(resizeHandles, (value, name) => {\n        const handleElm = dom.get('mceResizeHandle' + name);\n\n        if (handleElm) {\n          dom.unbind(handleElm);\n          dom.remove(handleElm);\n        }\n      });\n    };\n\n    const updateResizeRect = e => {\n      var _a;\n\n      let startElm, controlElm;\n\n      const isChildOrEqual = (node, parent) => {\n        if (node) {\n          do {\n            if (node === parent) {\n              return true;\n            }\n          } while (node = node.parentNode);\n        }\n      };\n\n      if (resizeStarted || editor.removed) {\n        return;\n      }\n\n      each(dom.select('img[data-mce-selected],hr[data-mce-selected]'), img => {\n        img.removeAttribute(elementSelectionAttr);\n      });\n      controlElm = e.type === 'mousedown' ? e.target : selection.getNode();\n      controlElm = (_a = closest$3(SugarElement.fromDom(controlElm), 'table,img,figure.image,hr,video,span.mce-preview-object').getOrUndefined()) === null || _a === void 0 ? void 0 : _a.dom;\n\n      if (isChildOrEqual(controlElm, rootElement)) {\n        disableGeckoResize();\n        startElm = selection.getStart(true);\n\n        if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {\n          showResizeRect(controlElm);\n          return;\n        }\n      }\n\n      hideResizeRect();\n    };\n\n    const unbindResizeHandleEvents = () => {\n      each$f(resizeHandles, handle => {\n        if (handle.elm) {\n          dom.unbind(handle.elm);\n          delete handle.elm;\n        }\n      });\n    };\n\n    const disableGeckoResize = () => {\n      try {\n        editor.getDoc().execCommand('enableObjectResizing', false, 'false');\n      } catch (ex) {}\n    };\n\n    editor.on('init', () => {\n      disableGeckoResize();\n      const throttledUpdateResizeRect = first$1(e => {\n        if (!editor.composing) {\n          updateResizeRect(e);\n        }\n      }, 0);\n      editor.on('nodechange ResizeEditor ResizeWindow ResizeContent drop FullscreenStateChanged', throttledUpdateResizeRect.throttle);\n      editor.on('keyup compositionend', e => {\n        if (selectedElm && selectedElm.nodeName === 'TABLE') {\n          throttledUpdateResizeRect.throttle(e);\n        }\n      });\n      editor.on('hide blur', hideResizeRect);\n      editor.on('contextmenu longpress', contextMenuSelectImage, true);\n    });\n    editor.on('remove', unbindResizeHandleEvents);\n\n    const destroy = () => {\n      selectedElm = selectedElmGhost = resizeBackdrop = null;\n    };\n\n    return {\n      isResizable,\n      showResizeRect,\n      hideResizeRect,\n      updateResizeRect,\n      destroy\n    };\n  };\n\n  const setStart = (rng, situ) => {\n    situ.fold(e => {\n      rng.setStartBefore(e.dom);\n    }, (e, o) => {\n      rng.setStart(e.dom, o);\n    }, e => {\n      rng.setStartAfter(e.dom);\n    });\n  };\n\n  const setFinish = (rng, situ) => {\n    situ.fold(e => {\n      rng.setEndBefore(e.dom);\n    }, (e, o) => {\n      rng.setEnd(e.dom, o);\n    }, e => {\n      rng.setEndAfter(e.dom);\n    });\n  };\n\n  const relativeToNative = (win, startSitu, finishSitu) => {\n    const range = win.document.createRange();\n    setStart(range, startSitu);\n    setFinish(range, finishSitu);\n    return range;\n  };\n\n  const exactToNative = (win, start, soffset, finish, foffset) => {\n    const rng = win.document.createRange();\n    rng.setStart(start.dom, soffset);\n    rng.setEnd(finish.dom, foffset);\n    return rng;\n  };\n\n  const adt$3 = Adt.generate([{\n    ltr: ['start', 'soffset', 'finish', 'foffset']\n  }, {\n    rtl: ['start', 'soffset', 'finish', 'foffset']\n  }]);\n\n  const fromRange = (win, type, range) => type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);\n\n  const getRanges = (win, selection) => selection.match({\n    domRange: rng => {\n      return {\n        ltr: constant(rng),\n        rtl: Optional.none\n      };\n    },\n    relative: (startSitu, finishSitu) => {\n      return {\n        ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),\n        rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))\n      };\n    },\n    exact: (start, soffset, finish, foffset) => {\n      return {\n        ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),\n        rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))\n      };\n    }\n  });\n\n  const doDiagnose = (win, ranges) => {\n    const rng = ranges.ltr();\n\n    if (rng.collapsed) {\n      const reversed = ranges.rtl().filter(rev => rev.collapsed === false);\n      return reversed.map(rev => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));\n    } else {\n      return fromRange(win, adt$3.ltr, rng);\n    }\n  };\n\n  const diagnose = (win, selection) => {\n    const ranges = getRanges(win, selection);\n    return doDiagnose(win, ranges);\n  };\n\n  adt$3.ltr;\n  adt$3.rtl;\n\n  const create$9 = (start, soffset, finish, foffset) => ({\n    start,\n    soffset,\n    finish,\n    foffset\n  });\n\n  const SimRange = {\n    create: create$9\n  };\n\n  const caretPositionFromPoint = (doc, x, y) => {\n    var _a, _b;\n\n    return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)).bind(pos => {\n      if (pos.offsetNode === null) {\n        return Optional.none();\n      }\n\n      const r = doc.dom.createRange();\n      r.setStart(pos.offsetNode, pos.offset);\n      r.collapse();\n      return Optional.some(r);\n    });\n  };\n\n  const caretRangeFromPoint = (doc, x, y) => {\n    var _a, _b;\n\n    return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y));\n  };\n\n  const availableSearch = (() => {\n    if (document.caretPositionFromPoint) {\n      return caretPositionFromPoint;\n    } else if (document.caretRangeFromPoint) {\n      return caretRangeFromPoint;\n    } else {\n      return Optional.none;\n    }\n  })();\n\n  const fromPoint$1 = (win, x, y) => {\n    const doc = SugarElement.fromDom(win.document);\n    return availableSearch(doc, x, y).map(rng => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));\n  };\n\n  const adt$2 = Adt.generate([{\n    before: ['element']\n  }, {\n    on: ['element', 'offset']\n  }, {\n    after: ['element']\n  }]);\n\n  const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);\n\n  const getStart$2 = situ => situ.fold(identity, identity, identity);\n\n  const before$1 = adt$2.before;\n  const on = adt$2.on;\n  const after$1 = adt$2.after;\n  const Situ = {\n    before: before$1,\n    on,\n    after: after$1,\n    cata,\n    getStart: getStart$2\n  };\n  const adt$1 = Adt.generate([{\n    domRange: ['rng']\n  }, {\n    relative: ['startSitu', 'finishSitu']\n  }, {\n    exact: ['start', 'soffset', 'finish', 'foffset']\n  }]);\n\n  const exactFromRange = simRange => adt$1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);\n\n  const getStart$1 = selection => selection.match({\n    domRange: rng => SugarElement.fromDom(rng.startContainer),\n    relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),\n    exact: (start, _soffset, _finish, _foffset) => start\n  });\n\n  const domRange = adt$1.domRange;\n  const relative = adt$1.relative;\n  const exact = adt$1.exact;\n\n  const getWin = selection => {\n    const start = getStart$1(selection);\n    return defaultView(start);\n  };\n\n  const range = SimRange.create;\n  const SimSelection = {\n    domRange,\n    relative,\n    exact,\n    exactFromRange,\n    getWin,\n    range\n  };\n\n  const beforeSpecial = (element, offset) => {\n    const name$1 = name(element);\n\n    if ('input' === name$1) {\n      return Situ.after(element);\n    } else if (!contains$2(['br', 'img'], name$1)) {\n      return Situ.on(element, offset);\n    } else {\n      return offset === 0 ? Situ.before(element) : Situ.after(element);\n    }\n  };\n\n  const preprocessRelative = (startSitu, finishSitu) => {\n    const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);\n    const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);\n    return SimSelection.relative(start, finish);\n  };\n\n  const preprocessExact = (start, soffset, finish, foffset) => {\n    const startSitu = beforeSpecial(start, soffset);\n    const finishSitu = beforeSpecial(finish, foffset);\n    return SimSelection.relative(startSitu, finishSitu);\n  };\n\n  const preprocess = selection => selection.match({\n    domRange: rng => {\n      const start = SugarElement.fromDom(rng.startContainer);\n      const finish = SugarElement.fromDom(rng.endContainer);\n      return preprocessExact(start, rng.startOffset, finish, rng.endOffset);\n    },\n    relative: preprocessRelative,\n    exact: preprocessExact\n  });\n\n  const fromElements = (elements, scope) => {\n    const doc = scope || document;\n    const fragment = doc.createDocumentFragment();\n    each$g(elements, element => {\n      fragment.appendChild(element.dom);\n    });\n    return SugarElement.fromDom(fragment);\n  };\n\n  const toNative = selection => {\n    const win = SimSelection.getWin(selection).dom;\n\n    const getDomRange = (start, soffset, finish, foffset) => exactToNative(win, start, soffset, finish, foffset);\n\n    const filtered = preprocess(selection);\n    return diagnose(win, filtered).match({\n      ltr: getDomRange,\n      rtl: getDomRange\n    });\n  };\n\n  const getAtPoint = (win, x, y) => fromPoint$1(win, x, y);\n\n  const fromPoint = (clientX, clientY, doc) => getAtPoint(doc.defaultView, clientX, clientY).map(simRange => {\n    const rng = doc.createRange();\n    rng.setStart(simRange.start.dom, simRange.soffset);\n    rng.setEnd(simRange.finish.dom, simRange.foffset);\n    return rng;\n  }).getOrUndefined();\n\n  const isEq$4 = (rng1, rng2) => {\n    return rng1 && rng2 && rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset && rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset;\n  };\n\n  const findParent = (node, rootNode, predicate) => {\n    while (node && node !== rootNode) {\n      if (predicate(node)) {\n        return node;\n      }\n\n      node = node.parentNode;\n    }\n\n    return null;\n  };\n\n  const hasParent$1 = (node, rootNode, predicate) => findParent(node, rootNode, predicate) !== null;\n\n  const hasParentWithName = (node, rootNode, name) => hasParent$1(node, rootNode, node => {\n    return node.nodeName === name;\n  });\n\n  const isTable = node => node && node.nodeName === 'TABLE';\n\n  const isTableCell$2 = node => node && /^(TD|TH|CAPTION)$/.test(node.nodeName);\n\n  const isCeFalseCaretContainer = (node, rootNode) => isCaretContainer$2(node) && hasParent$1(node, rootNode, isCaretNode) === false;\n\n  const hasBrBeforeAfter = (dom, node, left) => {\n    const walker = new DomTreeWalker(node, dom.getParent(node.parentNode, dom.isBlock) || dom.getRoot());\n\n    while (node = walker[left ? 'prev' : 'next']()) {\n      if (isBr$5(node)) {\n        return true;\n      }\n    }\n  };\n\n  const isPrevNode = (node, name) => node.previousSibling && node.previousSibling.nodeName === name;\n\n  const hasContentEditableFalseParent = (body, node) => {\n    while (node && node !== body) {\n      if (isContentEditableFalse$a(node)) {\n        return true;\n      }\n\n      node = node.parentNode;\n    }\n\n    return false;\n  };\n\n  const findTextNodeRelative = (dom, isAfterNode, collapsed, left, startNode) => {\n    let lastInlineElement;\n    const body = dom.getRoot();\n    let node;\n    const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\n    const parentBlockContainer = dom.getParent(startNode.parentNode, dom.isBlock) || body;\n\n    if (left && isBr$5(startNode) && isAfterNode && dom.isEmpty(parentBlockContainer)) {\n      return Optional.some(CaretPosition(startNode.parentNode, dom.nodeIndex(startNode)));\n    }\n\n    const walker = new DomTreeWalker(startNode, parentBlockContainer);\n\n    while (node = walker[left ? 'prev' : 'next']()) {\n      if (dom.getContentEditableParent(node) === 'false' || isCeFalseCaretContainer(node, body)) {\n        return Optional.none();\n      }\n\n      if (isText$8(node) && node.nodeValue.length > 0) {\n        if (hasParentWithName(node, body, 'A') === false) {\n          return Optional.some(CaretPosition(node, left ? node.nodeValue.length : 0));\n        }\n\n        return Optional.none();\n      }\n\n      if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\n        return Optional.none();\n      }\n\n      lastInlineElement = node;\n    }\n\n    if (collapsed && lastInlineElement) {\n      return Optional.some(CaretPosition(lastInlineElement, 0));\n    }\n\n    return Optional.none();\n  };\n\n  const normalizeEndPoint = (dom, collapsed, start, rng) => {\n    let container, offset;\n    const body = dom.getRoot();\n    let node;\n    let directionLeft,\n        normalized = false;\n    container = rng[(start ? 'start' : 'end') + 'Container'];\n    offset = rng[(start ? 'start' : 'end') + 'Offset'];\n    const isAfterNode = isElement$6(container) && offset === container.childNodes.length;\n    const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\n    directionLeft = start;\n\n    if (isCaretContainer$2(container)) {\n      return Optional.none();\n    }\n\n    if (isElement$6(container) && offset > container.childNodes.length - 1) {\n      directionLeft = false;\n    }\n\n    if (isDocument$1(container)) {\n      container = body;\n      offset = 0;\n    }\n\n    if (container === body) {\n      if (directionLeft) {\n        node = container.childNodes[offset > 0 ? offset - 1 : 0];\n\n        if (node) {\n          if (isCaretContainer$2(node)) {\n            return Optional.none();\n          }\n\n          if (nonEmptyElementsMap[node.nodeName] || isTable(node)) {\n            return Optional.none();\n          }\n        }\n      }\n\n      if (container.hasChildNodes()) {\n        offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);\n        container = container.childNodes[offset];\n        offset = isText$8(container) && isAfterNode ? container.data.length : 0;\n\n        if (!collapsed && container === body.lastChild && isTable(container)) {\n          return Optional.none();\n        }\n\n        if (hasContentEditableFalseParent(body, container) || isCaretContainer$2(container)) {\n          return Optional.none();\n        }\n\n        if (container.hasChildNodes() && isTable(container) === false) {\n          node = container;\n          const walker = new DomTreeWalker(container, body);\n\n          do {\n            if (isContentEditableFalse$a(node) || isCaretContainer$2(node)) {\n              normalized = false;\n              break;\n            }\n\n            if (isText$8(node) && node.nodeValue.length > 0) {\n              offset = directionLeft ? 0 : node.nodeValue.length;\n              container = node;\n              normalized = true;\n              break;\n            }\n\n            if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCell$2(node)) {\n              offset = dom.nodeIndex(node);\n              container = node.parentNode;\n\n              if (!directionLeft) {\n                offset++;\n              }\n\n              normalized = true;\n              break;\n            }\n          } while (node = directionLeft ? walker.next() : walker.prev());\n        }\n      }\n    }\n\n    if (collapsed) {\n      if (isText$8(container) && offset === 0) {\n        findTextNodeRelative(dom, isAfterNode, collapsed, true, container).each(pos => {\n          container = pos.container();\n          offset = pos.offset();\n          normalized = true;\n        });\n      }\n\n      if (isElement$6(container)) {\n        node = container.childNodes[offset];\n\n        if (!node) {\n          node = container.childNodes[offset - 1];\n        }\n\n        if (node && isBr$5(node) && !isPrevNode(node, 'A') && !hasBrBeforeAfter(dom, node, false) && !hasBrBeforeAfter(dom, node, true)) {\n          findTextNodeRelative(dom, isAfterNode, collapsed, true, node).each(pos => {\n            container = pos.container();\n            offset = pos.offset();\n            normalized = true;\n          });\n        }\n      }\n    }\n\n    if (directionLeft && !collapsed && isText$8(container) && offset === container.nodeValue.length) {\n      findTextNodeRelative(dom, isAfterNode, collapsed, false, container).each(pos => {\n        container = pos.container();\n        offset = pos.offset();\n        normalized = true;\n      });\n    }\n\n    return normalized ? Optional.some(CaretPosition(container, offset)) : Optional.none();\n  };\n\n  const normalize$2 = (dom, rng) => {\n    const collapsed = rng.collapsed,\n          normRng = rng.cloneRange();\n    const startPos = CaretPosition.fromRangeStart(rng);\n    normalizeEndPoint(dom, collapsed, true, normRng).each(pos => {\n      if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {\n        normRng.setStart(pos.container(), pos.offset());\n      }\n    });\n\n    if (!collapsed) {\n      normalizeEndPoint(dom, collapsed, false, normRng).each(pos => {\n        normRng.setEnd(pos.container(), pos.offset());\n      });\n    }\n\n    if (collapsed) {\n      normRng.collapse(true);\n    }\n\n    return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);\n  };\n\n  const splitText = (node, offset) => {\n    return node.splitText(offset);\n  };\n\n  const split = rng => {\n    let startContainer = rng.startContainer,\n        startOffset = rng.startOffset,\n        endContainer = rng.endContainer,\n        endOffset = rng.endOffset;\n\n    if (startContainer === endContainer && isText$8(startContainer)) {\n      if (startOffset > 0 && startOffset < startContainer.nodeValue.length) {\n        endContainer = splitText(startContainer, startOffset);\n        startContainer = endContainer.previousSibling;\n\n        if (endOffset > startOffset) {\n          endOffset = endOffset - startOffset;\n          startContainer = endContainer = splitText(endContainer, endOffset).previousSibling;\n          endOffset = endContainer.nodeValue.length;\n          startOffset = 0;\n        } else {\n          endOffset = 0;\n        }\n      }\n    } else {\n      if (isText$8(startContainer) && startOffset > 0 && startOffset < startContainer.nodeValue.length) {\n        startContainer = splitText(startContainer, startOffset);\n        startOffset = 0;\n      }\n\n      if (isText$8(endContainer) && endOffset > 0 && endOffset < endContainer.nodeValue.length) {\n        endContainer = splitText(endContainer, endOffset).previousSibling;\n        endOffset = endContainer.nodeValue.length;\n      }\n    }\n\n    return {\n      startContainer,\n      startOffset,\n      endContainer,\n      endOffset\n    };\n  };\n\n  const RangeUtils = dom => {\n    const walk = (rng, callback) => {\n      return walk$3(dom, rng, callback);\n    };\n\n    const split$1 = split;\n\n    const normalize = rng => {\n      return normalize$2(dom, rng).fold(never, normalizedRng => {\n        rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);\n        rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);\n        return true;\n      });\n    };\n\n    return {\n      walk,\n      split: split$1,\n      normalize\n    };\n  };\n\n  RangeUtils.compareRanges = isEq$4;\n  RangeUtils.getCaretRangeFromPoint = fromPoint;\n  RangeUtils.getSelectedNode = getSelectedNode;\n  RangeUtils.getNode = getNode$1;\n\n  const Dimension = (name, getOffset) => {\n    const set = (element, h) => {\n      if (!isNumber(h) && !h.match(/^[0-9]+$/)) {\n        throw new Error(name + '.set accepts only positive integer values. Value was ' + h);\n      }\n\n      const dom = element.dom;\n\n      if (isSupported$1(dom)) {\n        dom.style[name] = h + 'px';\n      }\n    };\n\n    const get = element => {\n      const r = getOffset(element);\n\n      if (r <= 0 || r === null) {\n        const css = get$7(element, name);\n        return parseFloat(css) || 0;\n      }\n\n      return r;\n    };\n\n    const getOuter = get;\n\n    const aggregate = (element, properties) => foldl(properties, (acc, property) => {\n      const val = get$7(element, property);\n      const value = val === undefined ? 0 : parseInt(val, 10);\n      return isNaN(value) ? acc : acc + value;\n    }, 0);\n\n    const max = (element, value, properties) => {\n      const cumulativeInclusions = aggregate(element, properties);\n      const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;\n      return absoluteMax;\n    };\n\n    return {\n      set,\n      get,\n      getOuter,\n      aggregate,\n      max\n    };\n  };\n\n  const api = Dimension('height', element => {\n    const dom = element.dom;\n    return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;\n  });\n\n  const get$2 = element => api.get(element);\n\n  const getDocument = () => SugarElement.fromDom(document);\n\n  const walkUp = (navigation, doc) => {\n    const frame = navigation.view(doc);\n    return frame.fold(constant([]), f => {\n      const parent = navigation.owner(f);\n      const rest = walkUp(navigation, parent);\n      return [f].concat(rest);\n    });\n  };\n\n  const pathTo = (element, navigation) => {\n    const d = navigation.owner(element);\n    return walkUp(navigation, d);\n  };\n\n  const view = doc => {\n    var _a;\n\n    const element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);\n    return element.map(SugarElement.fromDom);\n  };\n\n  const owner = element => documentOrOwner(element);\n\n  var Navigation = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    view: view,\n    owner: owner\n  });\n\n  const find = element => {\n    const doc = getDocument();\n    const scroll = get$5(doc);\n    const frames = pathTo(element, Navigation);\n    const offset = viewport(element);\n    const r = foldr(frames, (b, a) => {\n      const loc = viewport(a);\n      return {\n        left: b.left + loc.left,\n        top: b.top + loc.top\n      };\n    }, {\n      left: 0,\n      top: 0\n    });\n    return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);\n  };\n\n  const excludeFromDescend = element => name(element) === 'textarea';\n\n  const fireScrollIntoViewEvent = (editor, data) => {\n    const scrollEvent = editor.dispatch('ScrollIntoView', data);\n    return scrollEvent.isDefaultPrevented();\n  };\n\n  const fireAfterScrollIntoViewEvent = (editor, data) => {\n    editor.dispatch('AfterScrollIntoView', data);\n  };\n\n  const descend = (element, offset) => {\n    const children$1 = children(element);\n\n    if (children$1.length === 0 || excludeFromDescend(element)) {\n      return {\n        element,\n        offset\n      };\n    } else if (offset < children$1.length && !excludeFromDescend(children$1[offset])) {\n      return {\n        element: children$1[offset],\n        offset: 0\n      };\n    } else {\n      const last = children$1[children$1.length - 1];\n\n      if (excludeFromDescend(last)) {\n        return {\n          element,\n          offset\n        };\n      } else {\n        if (name(last) === 'img') {\n          return {\n            element: last,\n            offset: 1\n          };\n        } else if (isText$9(last)) {\n          return {\n            element: last,\n            offset: get$3(last).length\n          };\n        } else {\n          return {\n            element: last,\n            offset: children(last).length\n          };\n        }\n      }\n    }\n  };\n\n  const markerInfo = (element, cleanupFun) => {\n    const pos = absolute(element);\n    const height = get$2(element);\n    return {\n      element,\n      bottom: pos.top + height,\n      height,\n      pos,\n      cleanup: cleanupFun\n    };\n  };\n\n  const createMarker$1 = (element, offset) => {\n    const startPoint = descend(element, offset);\n    const span = SugarElement.fromHtml('<span data-mce-bogus=\"all\" style=\"display: inline-block;\">' + ZWSP$1 + '</span>');\n    before$3(startPoint.element, span);\n    return markerInfo(span, () => remove$5(span));\n  };\n\n  const elementMarker = element => markerInfo(SugarElement.fromDom(element), noop);\n\n  const withMarker = (editor, f, rng, alignToTop) => {\n    preserveWith(editor, (_s, _e) => applyWithMarker(editor, f, rng, alignToTop), rng);\n  };\n\n  const withScrollEvents = (editor, doc, f, marker, alignToTop) => {\n    const data = {\n      elm: marker.element.dom,\n      alignToTop\n    };\n\n    if (fireScrollIntoViewEvent(editor, data)) {\n      return;\n    }\n\n    const scrollTop = get$5(doc).top;\n    f(doc, scrollTop, marker, alignToTop);\n    fireAfterScrollIntoViewEvent(editor, data);\n  };\n\n  const applyWithMarker = (editor, f, rng, alignToTop) => {\n    const body = SugarElement.fromDom(editor.getBody());\n    const doc = SugarElement.fromDom(editor.getDoc());\n    reflow(body);\n    const marker = createMarker$1(SugarElement.fromDom(rng.startContainer), rng.startOffset);\n    withScrollEvents(editor, doc, f, marker, alignToTop);\n    marker.cleanup();\n  };\n\n  const withElement = (editor, element, f, alignToTop) => {\n    const doc = SugarElement.fromDom(editor.getDoc());\n    withScrollEvents(editor, doc, f, elementMarker(element), alignToTop);\n  };\n\n  const preserveWith = (editor, f, rng) => {\n    const startElement = rng.startContainer;\n    const startOffset = rng.startOffset;\n    const endElement = rng.endContainer;\n    const endOffset = rng.endOffset;\n    f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));\n    const newRng = editor.dom.createRng();\n    newRng.setStart(startElement, startOffset);\n    newRng.setEnd(endElement, endOffset);\n    editor.selection.setRng(rng);\n  };\n\n  const scrollToMarker = (marker, viewHeight, alignToTop, doc) => {\n    const pos = marker.pos;\n\n    if (alignToTop) {\n      to(pos.left, pos.top, doc);\n    } else {\n      const y = pos.top - viewHeight + marker.height;\n      to(pos.left, y, doc);\n    }\n  };\n\n  const intoWindowIfNeeded = (doc, scrollTop, viewHeight, marker, alignToTop) => {\n    const viewportBottom = viewHeight + scrollTop;\n    const markerTop = marker.pos.top;\n    const markerBottom = marker.bottom;\n    const largerThanViewport = markerBottom - markerTop >= viewHeight;\n\n    if (markerTop < scrollTop) {\n      scrollToMarker(marker, viewHeight, alignToTop !== false, doc);\n    } else if (markerTop > viewportBottom) {\n      const align = largerThanViewport ? alignToTop !== false : alignToTop === true;\n      scrollToMarker(marker, viewHeight, align, doc);\n    } else if (markerBottom > viewportBottom && !largerThanViewport) {\n      scrollToMarker(marker, viewHeight, alignToTop === true, doc);\n    }\n  };\n\n  const intoWindow = (doc, scrollTop, marker, alignToTop) => {\n    const viewHeight = doc.dom.defaultView.innerHeight;\n    intoWindowIfNeeded(doc, scrollTop, viewHeight, marker, alignToTop);\n  };\n\n  const intoFrame = (doc, scrollTop, marker, alignToTop) => {\n    const frameViewHeight = doc.dom.defaultView.innerHeight;\n    intoWindowIfNeeded(doc, scrollTop, frameViewHeight, marker, alignToTop);\n    const op = find(marker.element);\n    const viewportBounds = getBounds(window);\n\n    if (op.top < viewportBounds.y) {\n      intoView(marker.element, alignToTop !== false);\n    } else if (op.top > viewportBounds.bottom) {\n      intoView(marker.element, alignToTop === true);\n    }\n  };\n\n  const rangeIntoWindow = (editor, rng, alignToTop) => withMarker(editor, intoWindow, rng, alignToTop);\n\n  const elementIntoWindow = (editor, element, alignToTop) => withElement(editor, element, intoWindow, alignToTop);\n\n  const rangeIntoFrame = (editor, rng, alignToTop) => withMarker(editor, intoFrame, rng, alignToTop);\n\n  const elementIntoFrame = (editor, element, alignToTop) => withElement(editor, element, intoFrame, alignToTop);\n\n  const scrollElementIntoView = (editor, element, alignToTop) => {\n    const scroller = editor.inline ? elementIntoWindow : elementIntoFrame;\n    scroller(editor, element, alignToTop);\n  };\n\n  const scrollRangeIntoView = (editor, rng, alignToTop) => {\n    const scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;\n    scroller(editor, rng, alignToTop);\n  };\n\n  const focus$1 = element => element.dom.focus();\n\n  const hasFocus$1 = element => {\n    const root = getRootNode(element).dom;\n    return element.dom === root.activeElement;\n  };\n\n  const active$1 = function () {\n    let root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getDocument();\n    return Optional.from(root.dom.activeElement).map(SugarElement.fromDom);\n  };\n\n  const search = element => active$1(getRootNode(element)).filter(e => element.dom.contains(e.dom));\n\n  const clamp$1 = (offset, element) => {\n    const max = isText$9(element) ? get$3(element).length : children(element).length + 1;\n\n    if (offset > max) {\n      return max;\n    } else if (offset < 0) {\n      return 0;\n    }\n\n    return offset;\n  };\n\n  const normalizeRng = rng => SimSelection.range(rng.start, clamp$1(rng.soffset, rng.start), rng.finish, clamp$1(rng.foffset, rng.finish));\n\n  const isOrContains = (root, elm) => !isRestrictedNode(elm.dom) && (contains(root, elm) || eq(root, elm));\n\n  const isRngInRoot = root => rng => isOrContains(root, rng.start) && isOrContains(root, rng.finish);\n\n  const shouldStore = editor => editor.inline;\n\n  const nativeRangeToSelectionRange = r => SimSelection.range(SugarElement.fromDom(r.startContainer), r.startOffset, SugarElement.fromDom(r.endContainer), r.endOffset);\n\n  const readRange = win => {\n    const selection = win.getSelection();\n    const rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));\n    return rng.map(nativeRangeToSelectionRange);\n  };\n\n  const getBookmark = root => {\n    const win = defaultView(root);\n    return readRange(win.dom).filter(isRngInRoot(root));\n  };\n\n  const validate = (root, bookmark) => Optional.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);\n\n  const bookmarkToNativeRng = bookmark => {\n    const rng = document.createRange();\n\n    try {\n      rng.setStart(bookmark.start.dom, bookmark.soffset);\n      rng.setEnd(bookmark.finish.dom, bookmark.foffset);\n      return Optional.some(rng);\n    } catch (_) {\n      return Optional.none();\n    }\n  };\n\n  const store = editor => {\n    const newBookmark = shouldStore(editor) ? getBookmark(SugarElement.fromDom(editor.getBody())) : Optional.none();\n    editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;\n  };\n\n  const getRng = editor => {\n    const bookmark = editor.bookmark ? editor.bookmark : Optional.none();\n    return bookmark.bind(x => validate(SugarElement.fromDom(editor.getBody()), x)).bind(bookmarkToNativeRng);\n  };\n\n  const restore = editor => {\n    getRng(editor).each(rng => editor.selection.setRng(rng));\n  };\n\n  const isEditorUIElement$1 = elm => {\n    const className = elm.className.toString();\n    return className.indexOf('tox-') !== -1 || className.indexOf('mce-') !== -1;\n  };\n\n  const FocusManager = {\n    isEditorUIElement: isEditorUIElement$1\n  };\n\n  const wrappedSetTimeout = (callback, time) => {\n    if (!isNumber(time)) {\n      time = 0;\n    }\n\n    return setTimeout(callback, time);\n  };\n\n  const wrappedSetInterval = (callback, time) => {\n    if (!isNumber(time)) {\n      time = 0;\n    }\n\n    return setInterval(callback, time);\n  };\n\n  const Delay = {\n    setEditorTimeout: (editor, callback, time) => {\n      return wrappedSetTimeout(() => {\n        if (!editor.removed) {\n          callback();\n        }\n      }, time);\n    },\n    setEditorInterval: (editor, callback, time) => {\n      const timer = wrappedSetInterval(() => {\n        if (!editor.removed) {\n          callback();\n        } else {\n          clearInterval(timer);\n        }\n      }, time);\n      return timer;\n    }\n  };\n\n  const isManualNodeChange = e => {\n    return e.type === 'nodechange' && e.selectionChange;\n  };\n\n  const registerPageMouseUp = (editor, throttledStore) => {\n    const mouseUpPage = () => {\n      throttledStore.throttle();\n    };\n\n    DOMUtils.DOM.bind(document, 'mouseup', mouseUpPage);\n    editor.on('remove', () => {\n      DOMUtils.DOM.unbind(document, 'mouseup', mouseUpPage);\n    });\n  };\n\n  const registerMouseUp = (editor, throttledStore) => {\n    editor.on('mouseup touchend', _e => {\n      throttledStore.throttle();\n    });\n  };\n\n  const registerEditorEvents = (editor, throttledStore) => {\n    registerMouseUp(editor, throttledStore);\n    editor.on('keyup NodeChange AfterSetSelectionRange', e => {\n      if (!isManualNodeChange(e)) {\n        store(editor);\n      }\n    });\n  };\n\n  const register$6 = editor => {\n    const throttledStore = first$1(() => {\n      store(editor);\n    }, 0);\n    editor.on('init', () => {\n      if (editor.inline) {\n        registerPageMouseUp(editor, throttledStore);\n      }\n\n      registerEditorEvents(editor, throttledStore);\n    });\n    editor.on('remove', () => {\n      throttledStore.cancel();\n    });\n  };\n\n  let documentFocusInHandler;\n  const DOM$9 = DOMUtils.DOM;\n\n  const isEditorUIElement = elm => {\n    return FocusManager.isEditorUIElement(elm);\n  };\n\n  const isEditorContentAreaElement = elm => {\n    const classList = elm.classList;\n\n    if (classList !== undefined) {\n      return classList.contains('tox-edit-area') || classList.contains('tox-edit-area__iframe') || classList.contains('mce-content-body');\n    } else {\n      return false;\n    }\n  };\n\n  const isUIElement = (editor, elm) => {\n    const customSelector = getCustomUiSelector(editor);\n    const parent = DOM$9.getParent(elm, elm => {\n      return isEditorUIElement(elm) || (customSelector ? editor.dom.is(elm, customSelector) : false);\n    });\n    return parent !== null;\n  };\n\n  const getActiveElement = editor => {\n    try {\n      const root = getRootNode(SugarElement.fromDom(editor.getElement()));\n      return active$1(root).fold(() => document.body, x => x.dom);\n    } catch (ex) {\n      return document.body;\n    }\n  };\n\n  const registerEvents$1 = (editorManager, e) => {\n    const editor = e.editor;\n    register$6(editor);\n    editor.on('focusin', () => {\n      const focusedEditor = editorManager.focusedEditor;\n\n      if (focusedEditor !== editor) {\n        if (focusedEditor) {\n          focusedEditor.dispatch('blur', {\n            focusedEditor: editor\n          });\n        }\n\n        editorManager.setActive(editor);\n        editorManager.focusedEditor = editor;\n        editor.dispatch('focus', {\n          blurredEditor: focusedEditor\n        });\n        editor.focus(true);\n      }\n    });\n    editor.on('focusout', () => {\n      Delay.setEditorTimeout(editor, () => {\n        const focusedEditor = editorManager.focusedEditor;\n\n        if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {\n          editor.dispatch('blur', {\n            focusedEditor: null\n          });\n          editorManager.focusedEditor = null;\n        }\n      });\n    });\n\n    if (!documentFocusInHandler) {\n      documentFocusInHandler = e => {\n        const activeEditor = editorManager.activeEditor;\n\n        if (activeEditor) {\n          getOriginalEventTarget(e).each(target => {\n            if (target.ownerDocument === document) {\n              if (target !== document.body && !isUIElement(activeEditor, target) && editorManager.focusedEditor === activeEditor) {\n                activeEditor.dispatch('blur', {\n                  focusedEditor: null\n                });\n                editorManager.focusedEditor = null;\n              }\n            }\n          });\n        }\n      };\n\n      DOM$9.bind(document, 'focusin', documentFocusInHandler);\n    }\n  };\n\n  const unregisterDocumentEvents = (editorManager, e) => {\n    if (editorManager.focusedEditor === e.editor) {\n      editorManager.focusedEditor = null;\n    }\n\n    if (!editorManager.activeEditor) {\n      DOM$9.unbind(document, 'focusin', documentFocusInHandler);\n      documentFocusInHandler = null;\n    }\n  };\n\n  const setup$v = editorManager => {\n    editorManager.on('AddEditor', curry(registerEvents$1, editorManager));\n    editorManager.on('RemoveEditor', curry(unregisterDocumentEvents, editorManager));\n  };\n\n  const getContentEditableHost = (editor, node) => editor.dom.getParent(node, node => editor.dom.getContentEditable(node) === 'true');\n\n  const getCollapsedNode = rng => rng.collapsed ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();\n\n  const getFocusInElement = (root, rng) => getCollapsedNode(rng).bind(node => {\n    if (isTableSection(node)) {\n      return Optional.some(node);\n    } else if (contains(root, node) === false) {\n      return Optional.some(root);\n    } else {\n      return Optional.none();\n    }\n  });\n\n  const normalizeSelection$1 = (editor, rng) => {\n    getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind(elm => {\n      return firstPositionIn(elm.dom);\n    }).fold(() => {\n      editor.selection.normalize();\n      return;\n    }, caretPos => editor.selection.setRng(caretPos.toRange()));\n  };\n\n  const focusBody = body => {\n    if (body.setActive) {\n      try {\n        body.setActive();\n      } catch (ex) {\n        body.focus();\n      }\n    } else {\n      body.focus();\n    }\n  };\n\n  const hasElementFocus = elm => hasFocus$1(elm) || search(elm).isSome();\n\n  const hasIframeFocus = editor => editor.iframeElement && hasFocus$1(SugarElement.fromDom(editor.iframeElement));\n\n  const hasInlineFocus = editor => {\n    const rawBody = editor.getBody();\n    return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));\n  };\n\n  const hasUiFocus = editor => {\n    const dos = getRootNode(SugarElement.fromDom(editor.getElement()));\n    return active$1(dos).filter(elem => !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom)).isSome();\n  };\n\n  const hasFocus = editor => editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);\n\n  const hasEditorOrUiFocus = editor => hasFocus(editor) || hasUiFocus(editor);\n\n  const focusEditor = editor => {\n    const selection = editor.selection;\n    const body = editor.getBody();\n    let rng = selection.getRng();\n    editor.quirks.refreshContentEditable();\n\n    if (editor.bookmark !== undefined && hasFocus(editor) === false) {\n      getRng(editor).each(bookmarkRng => {\n        editor.selection.setRng(bookmarkRng);\n        rng = bookmarkRng;\n      });\n    }\n\n    const contentEditableHost = getContentEditableHost(editor, selection.getNode());\n\n    if (editor.dom.isChildOf(contentEditableHost, body)) {\n      focusBody(contentEditableHost);\n      normalizeSelection$1(editor, rng);\n      activateEditor(editor);\n      return;\n    }\n\n    if (!editor.inline) {\n      if (!Env.browser.isOpera()) {\n        focusBody(body);\n      }\n\n      editor.getWin().focus();\n    }\n\n    if (Env.browser.isFirefox() || editor.inline) {\n      focusBody(body);\n      normalizeSelection$1(editor, rng);\n    }\n\n    activateEditor(editor);\n  };\n\n  const activateEditor = editor => editor.editorManager.setActive(editor);\n\n  const focus = (editor, skipFocus) => {\n    if (editor.removed) {\n      return;\n    }\n\n    if (skipFocus) {\n      activateEditor(editor);\n    } else {\n      focusEditor(editor);\n    }\n  };\n\n  const getEndpointElement = (root, rng, start, real, resolve) => {\n    const container = start ? rng.startContainer : rng.endContainer;\n    const offset = start ? rng.startOffset : rng.endOffset;\n    return Optional.from(container).map(SugarElement.fromDom).map(elm => !real || !rng.collapsed ? child$1(elm, resolve(elm, offset)).getOr(elm) : elm).bind(elm => isElement$7(elm) ? Optional.some(elm) : parent(elm).filter(isElement$7)).map(elm => elm.dom).getOr(root);\n  };\n\n  const getStart = (root, rng, real) => getEndpointElement(root, rng, true, real, (elm, offset) => Math.min(childNodesCount(elm), offset));\n\n  const getEnd$1 = (root, rng, real) => getEndpointElement(root, rng, false, real, (elm, offset) => offset > 0 ? offset - 1 : offset);\n\n  const skipEmptyTextNodes = (node, forwards) => {\n    const orig = node;\n\n    while (node && isText$8(node) && node.length === 0) {\n      node = forwards ? node.nextSibling : node.previousSibling;\n    }\n\n    return node || orig;\n  };\n\n  const getNode = (root, rng) => {\n    let elm, startContainer, endContainer;\n\n    if (!rng) {\n      return root;\n    }\n\n    startContainer = rng.startContainer;\n    endContainer = rng.endContainer;\n    const startOffset = rng.startOffset;\n    const endOffset = rng.endOffset;\n    elm = rng.commonAncestorContainer;\n\n    if (!rng.collapsed) {\n      if (startContainer === endContainer) {\n        if (endOffset - startOffset < 2) {\n          if (startContainer.hasChildNodes()) {\n            elm = startContainer.childNodes[startOffset];\n          }\n        }\n      }\n\n      if (startContainer.nodeType === 3 && endContainer.nodeType === 3) {\n        if (startContainer.length === startOffset) {\n          startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);\n        } else {\n          startContainer = startContainer.parentNode;\n        }\n\n        if (endOffset === 0) {\n          endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);\n        } else {\n          endContainer = endContainer.parentNode;\n        }\n\n        if (startContainer && startContainer === endContainer) {\n          return startContainer;\n        }\n      }\n    }\n\n    if (elm && elm.nodeType === 3) {\n      return elm.parentNode;\n    }\n\n    return elm;\n  };\n\n  const getSelectedBlocks = (dom, rng, startElm, endElm) => {\n    let node;\n    const selectedBlocks = [];\n    const root = dom.getRoot();\n    startElm = dom.getParent(startElm || getStart(root, rng, rng.collapsed), dom.isBlock);\n    endElm = dom.getParent(endElm || getEnd$1(root, rng, rng.collapsed), dom.isBlock);\n\n    if (startElm && startElm !== root) {\n      selectedBlocks.push(startElm);\n    }\n\n    if (startElm && endElm && startElm !== endElm) {\n      node = startElm;\n      const walker = new DomTreeWalker(startElm, root);\n\n      while ((node = walker.next()) && node !== endElm) {\n        if (dom.isBlock(node)) {\n          selectedBlocks.push(node);\n        }\n      }\n    }\n\n    if (endElm && startElm !== endElm && endElm !== root) {\n      selectedBlocks.push(endElm);\n    }\n\n    return selectedBlocks;\n  };\n\n  const select = (dom, node, content) => Optional.from(node).map(node => {\n    const idx = dom.nodeIndex(node);\n    const rng = dom.createRng();\n    rng.setStart(node.parentNode, idx);\n    rng.setEnd(node.parentNode, idx + 1);\n\n    if (content) {\n      moveEndPoint(dom, rng, node, true);\n      moveEndPoint(dom, rng, node, false);\n    }\n\n    return rng;\n  });\n\n  const processRanges = (editor, ranges) => map$3(ranges, range => {\n    const evt = editor.dispatch('GetSelectionRange', {\n      range\n    });\n    return evt.range !== range ? evt.range : range;\n  });\n\n  const getEnd = element => name(element) === 'img' ? 1 : getOption(element).fold(() => children(element).length, v => v.length);\n\n  const isTextNodeWithCursorPosition = el => getOption(el).filter(text => text.trim().length !== 0 || text.indexOf(nbsp) > -1).isSome();\n\n  const elementsWithCursorPosition = ['img', 'br'];\n\n  const isCursorPosition = elem => {\n    const hasCursorPosition = isTextNodeWithCursorPosition(elem);\n    return hasCursorPosition || contains$2(elementsWithCursorPosition, name(elem));\n  };\n\n  const first = element => descendant$1(element, isCursorPosition);\n\n  const last = element => descendantRtl(element, isCursorPosition);\n\n  const descendantRtl = (scope, predicate) => {\n    const descend = element => {\n      const children$1 = children(element);\n\n      for (let i = children$1.length - 1; i >= 0; i--) {\n        const child = children$1[i];\n\n        if (predicate(child)) {\n          return Optional.some(child);\n        }\n\n        const res = descend(child);\n\n        if (res.isSome()) {\n          return res;\n        }\n      }\n\n      return Optional.none();\n    };\n\n    return descend(scope);\n  };\n\n  const autocompleteSelector = '[data-mce-autocompleter]';\n\n  const create$8 = (editor, range) => {\n    if (findIn(SugarElement.fromDom(editor.getBody())).isNone()) {\n      const wrapper = SugarElement.fromHtml('<span data-mce-autocompleter=\"1\" data-mce-bogus=\"1\"></span>', editor.getDoc());\n      append$1(wrapper, SugarElement.fromDom(range.extractContents()));\n      range.insertNode(wrapper.dom);\n      parent(wrapper).each(elm => elm.dom.normalize());\n      last(wrapper).map(last => {\n        editor.selection.setCursorLocation(last.dom, getEnd(last));\n      });\n    }\n  };\n\n  const detect$1 = elm => closest$3(elm, autocompleteSelector);\n\n  const findIn = elm => descendant(elm, autocompleteSelector);\n\n  const remove$3 = (editor, elm) => findIn(elm).each(wrapper => {\n    const bookmark = editor.selection.getBookmark();\n    unwrap(wrapper);\n    editor.selection.moveToBookmark(bookmark);\n  });\n\n  const typeLookup = {\n    '#text': 3,\n    '#comment': 8,\n    '#cdata': 4,\n    '#pi': 7,\n    '#doctype': 10,\n    '#document-fragment': 11\n  };\n\n  const walk$2 = (node, root, prev) => {\n    const startName = prev ? 'lastChild' : 'firstChild';\n    const siblingName = prev ? 'prev' : 'next';\n\n    if (node[startName]) {\n      return node[startName];\n    }\n\n    if (node !== root) {\n      let sibling = node[siblingName];\n\n      if (sibling) {\n        return sibling;\n      }\n\n      for (let parent = node.parent; parent && parent !== root; parent = parent.parent) {\n        sibling = parent[siblingName];\n\n        if (sibling) {\n          return sibling;\n        }\n      }\n    }\n  };\n\n  const isEmptyTextNode = node => {\n    if (!isWhitespaceText(node.value)) {\n      return false;\n    }\n\n    const parentNode = node.parent;\n\n    if (parentNode && (parentNode.name !== 'span' || parentNode.attr('style')) && /^[ ]+$/.test(node.value)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  const isNonEmptyElement = node => {\n    const isNamedAnchor = node.name === 'a' && !node.attr('href') && node.attr('id');\n    return node.attr('name') || node.attr('id') && !node.firstChild || node.attr('data-mce-bookmark') || isNamedAnchor;\n  };\n\n  class AstNode {\n    constructor(name, type) {\n      this.name = name;\n      this.type = type;\n\n      if (type === 1) {\n        this.attributes = [];\n        this.attributes.map = {};\n      }\n    }\n\n    static create(name, attrs) {\n      const node = new AstNode(name, typeLookup[name] || 1);\n\n      if (attrs) {\n        each$f(attrs, (value, attrName) => {\n          node.attr(attrName, value);\n        });\n      }\n\n      return node;\n    }\n\n    replace(node) {\n      const self = this;\n\n      if (node.parent) {\n        node.remove();\n      }\n\n      self.insert(node, self);\n      self.remove();\n      return self;\n    }\n\n    attr(name, value) {\n      const self = this;\n      let attrs;\n\n      if (typeof name !== 'string') {\n        if (name !== undefined && name !== null) {\n          each$f(name, (value, key) => {\n            self.attr(key, value);\n          });\n        }\n\n        return self;\n      }\n\n      if (attrs = self.attributes) {\n        if (value !== undefined) {\n          if (value === null) {\n            if (name in attrs.map) {\n              delete attrs.map[name];\n              let i = attrs.length;\n\n              while (i--) {\n                if (attrs[i].name === name) {\n                  attrs.splice(i, 1);\n                  return self;\n                }\n              }\n            }\n\n            return self;\n          }\n\n          if (name in attrs.map) {\n            let i = attrs.length;\n\n            while (i--) {\n              if (attrs[i].name === name) {\n                attrs[i].value = value;\n                break;\n              }\n            }\n          } else {\n            attrs.push({\n              name,\n              value\n            });\n          }\n\n          attrs.map[name] = value;\n          return self;\n        }\n\n        return attrs.map[name];\n      }\n    }\n\n    clone() {\n      const self = this;\n      const clone = new AstNode(self.name, self.type);\n      let selfAttrs;\n\n      if (selfAttrs = self.attributes) {\n        const cloneAttrs = [];\n        cloneAttrs.map = {};\n\n        for (let i = 0, l = selfAttrs.length; i < l; i++) {\n          const selfAttr = selfAttrs[i];\n\n          if (selfAttr.name !== 'id') {\n            cloneAttrs[cloneAttrs.length] = {\n              name: selfAttr.name,\n              value: selfAttr.value\n            };\n            cloneAttrs.map[selfAttr.name] = selfAttr.value;\n          }\n        }\n\n        clone.attributes = cloneAttrs;\n      }\n\n      clone.value = self.value;\n      return clone;\n    }\n\n    wrap(wrapper) {\n      const self = this;\n      self.parent.insert(wrapper, self);\n      wrapper.append(self);\n      return self;\n    }\n\n    unwrap() {\n      const self = this;\n\n      for (let node = self.firstChild; node;) {\n        const next = node.next;\n        self.insert(node, self, true);\n        node = next;\n      }\n\n      self.remove();\n    }\n\n    remove() {\n      const self = this,\n            parent = self.parent,\n            next = self.next,\n            prev = self.prev;\n\n      if (parent) {\n        if (parent.firstChild === self) {\n          parent.firstChild = next;\n\n          if (next) {\n            next.prev = null;\n          }\n        } else {\n          prev.next = next;\n        }\n\n        if (parent.lastChild === self) {\n          parent.lastChild = prev;\n\n          if (prev) {\n            prev.next = null;\n          }\n        } else {\n          next.prev = prev;\n        }\n\n        self.parent = self.next = self.prev = null;\n      }\n\n      return self;\n    }\n\n    append(node) {\n      const self = this;\n\n      if (node.parent) {\n        node.remove();\n      }\n\n      const last = self.lastChild;\n\n      if (last) {\n        last.next = node;\n        node.prev = last;\n        self.lastChild = node;\n      } else {\n        self.lastChild = self.firstChild = node;\n      }\n\n      node.parent = self;\n      return node;\n    }\n\n    insert(node, refNode, before) {\n      if (node.parent) {\n        node.remove();\n      }\n\n      const parent = refNode.parent || this;\n\n      if (before) {\n        if (refNode === parent.firstChild) {\n          parent.firstChild = node;\n        } else {\n          refNode.prev.next = node;\n        }\n\n        node.prev = refNode.prev;\n        node.next = refNode;\n        refNode.prev = node;\n      } else {\n        if (refNode === parent.lastChild) {\n          parent.lastChild = node;\n        } else {\n          refNode.next.prev = node;\n        }\n\n        node.next = refNode.next;\n        node.prev = refNode;\n        refNode.next = node;\n      }\n\n      node.parent = parent;\n      return node;\n    }\n\n    getAll(name) {\n      const self = this;\n      const collection = [];\n\n      for (let node = self.firstChild; node; node = walk$2(node, self)) {\n        if (node.name === name) {\n          collection.push(node);\n        }\n      }\n\n      return collection;\n    }\n\n    children() {\n      const self = this;\n      const collection = [];\n\n      for (let node = self.firstChild; node; node = node.next) {\n        collection.push(node);\n      }\n\n      return collection;\n    }\n\n    empty() {\n      const self = this;\n\n      if (self.firstChild) {\n        const nodes = [];\n\n        for (let node = self.firstChild; node; node = walk$2(node, self)) {\n          nodes.push(node);\n        }\n\n        let i = nodes.length;\n\n        while (i--) {\n          const node = nodes[i];\n          node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;\n        }\n      }\n\n      self.firstChild = self.lastChild = null;\n      return self;\n    }\n\n    isEmpty(elements) {\n      let whitespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      let predicate = arguments.length > 2 ? arguments[2] : undefined;\n      const self = this;\n      let node = self.firstChild;\n\n      if (isNonEmptyElement(self)) {\n        return false;\n      }\n\n      if (node) {\n        do {\n          if (node.type === 1) {\n            if (node.attr('data-mce-bogus')) {\n              continue;\n            }\n\n            if (elements[node.name]) {\n              return false;\n            }\n\n            if (isNonEmptyElement(node)) {\n              return false;\n            }\n          }\n\n          if (node.type === 8) {\n            return false;\n          }\n\n          if (node.type === 3 && !isEmptyTextNode(node)) {\n            return false;\n          }\n\n          if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText(node.value)) {\n            return false;\n          }\n\n          if (predicate && predicate(node)) {\n            return false;\n          }\n        } while (node = walk$2(node, self));\n      }\n\n      return true;\n    }\n\n    walk(prev) {\n      return walk$2(this, null, prev);\n    }\n\n  }\n\n  const isConditionalComment = (html, startIndex) => /^\\s*\\[if [\\w\\W]+\\]>.*<!\\[endif\\](--!?)?>/.test(html.substr(startIndex));\n\n  const findCommentEndIndex = function (html, isBogus) {\n    let startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const lcHtml = html.toLowerCase();\n\n    if (lcHtml.indexOf('[if ', startIndex) !== -1 && isConditionalComment(lcHtml, startIndex)) {\n      const endIfIndex = lcHtml.indexOf('[endif]', startIndex);\n      return lcHtml.indexOf('>', endIfIndex);\n    } else {\n      if (isBogus) {\n        const endIndex = lcHtml.indexOf('>', startIndex);\n        return endIndex !== -1 ? endIndex : lcHtml.length;\n      } else {\n        const endCommentRegexp = /--!?>/g;\n        endCommentRegexp.lastIndex = startIndex;\n        const match = endCommentRegexp.exec(html);\n        return match ? match.index + match[0].length : lcHtml.length;\n      }\n    }\n  };\n\n  const findMatchingEndTagIndex = (schema, html, startIndex) => {\n    const startTagRegExp = /<([!?\\/])?([A-Za-z0-9\\-_:.]+)/g;\n    const endTagRegExp = /(?:\\s(?:[^'\">]+(?:\"[^\"]*\"|'[^']*'))*[^\"'>]*(?:\"[^\">]*|'[^'>]*)?|\\s*|\\/)>/g;\n    const voidElements = schema.getVoidElements();\n    let count = 1,\n        index = startIndex;\n\n    while (count !== 0) {\n      startTagRegExp.lastIndex = index;\n\n      while (true) {\n        const startMatch = startTagRegExp.exec(html);\n\n        if (startMatch === null) {\n          return index;\n        } else if (startMatch[1] === '!') {\n          if (startsWith(startMatch[2], '--')) {\n            index = findCommentEndIndex(html, false, startMatch.index + '!--'.length);\n          } else {\n            index = findCommentEndIndex(html, true, startMatch.index + 1);\n          }\n\n          break;\n        } else {\n          endTagRegExp.lastIndex = startTagRegExp.lastIndex;\n          const endMatch = endTagRegExp.exec(html);\n\n          if (isNull(endMatch) || endMatch.index !== startTagRegExp.lastIndex) {\n            continue;\n          }\n\n          if (startMatch[1] === '/') {\n            count -= 1;\n          } else if (!has$2(voidElements, startMatch[2])) {\n            count += 1;\n          }\n\n          index = startTagRegExp.lastIndex + endMatch[0].length;\n          break;\n        }\n      }\n    }\n\n    return index;\n  };\n\n  const trimHtml$1 = (tempAttrs, html) => {\n    const trimContentRegExp = new RegExp(['\\\\s?(' + tempAttrs.join('|') + ')=\"[^\"]+\"'].join('|'), 'gi');\n    return html.replace(trimContentRegExp, '');\n  };\n\n  const trimInternal = (serializer, html) => {\n    const bogusAllRegExp = /<(\\w+) [^>]*data-mce-bogus=\"all\"[^>]*>/g;\n    const schema = serializer.schema;\n    let content = trimHtml$1(serializer.getTempAttrs(), html);\n    const voidElements = schema.getVoidElements();\n    let matches;\n\n    while (matches = bogusAllRegExp.exec(content)) {\n      const index = bogusAllRegExp.lastIndex;\n      const matchLength = matches[0].length;\n      let endTagIndex;\n\n      if (voidElements[matches[1]]) {\n        endTagIndex = index;\n      } else {\n        endTagIndex = findMatchingEndTagIndex(schema, content, index);\n      }\n\n      content = content.substring(0, index - matchLength) + content.substring(endTagIndex);\n      bogusAllRegExp.lastIndex = index - matchLength;\n    }\n\n    return trim$1(content);\n  };\n\n  const trimExternal = trimInternal;\n\n  const trimEmptyContents = (editor, html) => {\n    const blockName = getForcedRootBlock(editor);\n    const emptyRegExp = new RegExp(`^(<${blockName}[^>]*>(&nbsp;|&#160;|\\\\s|\\u00a0|<br \\\\/>|)<\\\\/${blockName}>[\\r\\n]*|<br \\\\/>[\\r\\n]*)$`);\n    return html.replace(emptyRegExp, '');\n  };\n\n  const getContentFromBody = (editor, args, body) => {\n    let content;\n\n    if (args.format === 'raw') {\n      content = Tools.trim(trimExternal(editor.serializer, body.innerHTML));\n    } else if (args.format === 'text') {\n      content = editor.dom.isEmpty(body) ? '' : trim$1(body.innerText || body.textContent);\n    } else if (args.format === 'tree') {\n      content = editor.serializer.serialize(body, args);\n    } else {\n      content = trimEmptyContents(editor, editor.serializer.serialize(body, args));\n    }\n\n    const shouldTrim = args.format !== 'text' && !isWsPreserveElement(SugarElement.fromDom(body));\n    return shouldTrim && isString(content) ? Tools.trim(content) : content;\n  };\n\n  const getContentInternal = (editor, args) => Optional.from(editor.getBody()).fold(constant(args.format === 'tree' ? new AstNode('body', 11) : ''), body => getContentFromBody(editor, args, body));\n\n  const each$b = Tools.each;\n\n  const ElementUtils = dom => {\n    const compare = (node1, node2) => {\n      if (node1.nodeName !== node2.nodeName) {\n        return false;\n      }\n\n      const getAttribs = node => {\n        const attribs = {};\n        each$b(dom.getAttribs(node), attr => {\n          const name = attr.nodeName.toLowerCase();\n\n          if (name.indexOf('_') !== 0 && name !== 'style' && name.indexOf('data-') !== 0) {\n            attribs[name] = dom.getAttrib(node, name);\n          }\n        });\n        return attribs;\n      };\n\n      const compareObjects = (obj1, obj2) => {\n        let value, name;\n\n        for (name in obj1) {\n          if (has$2(obj1, name)) {\n            value = obj2[name];\n\n            if (typeof value === 'undefined') {\n              return false;\n            }\n\n            if (obj1[name] !== value) {\n              return false;\n            }\n\n            delete obj2[name];\n          }\n        }\n\n        for (name in obj2) {\n          if (has$2(obj2, name)) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n\n      if (!compareObjects(getAttribs(node1), getAttribs(node2))) {\n        return false;\n      }\n\n      if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {\n        return false;\n      }\n\n      return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);\n    };\n\n    return {\n      compare\n    };\n  };\n\n  const makeMap$1 = Tools.makeMap;\n\n  const Writer = settings => {\n    const html = [];\n    settings = settings || {};\n    const indent = settings.indent;\n    const indentBefore = makeMap$1(settings.indent_before || '');\n    const indentAfter = makeMap$1(settings.indent_after || '');\n    const encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);\n    const htmlOutput = settings.element_format !== 'xhtml';\n    return {\n      start: (name, attrs, empty) => {\n        let i, l, attr, value;\n\n        if (indent && indentBefore[name] && html.length > 0) {\n          value = html[html.length - 1];\n\n          if (value.length > 0 && value !== '\\n') {\n            html.push('\\n');\n          }\n        }\n\n        html.push('<', name);\n\n        if (attrs) {\n          for (i = 0, l = attrs.length; i < l; i++) {\n            attr = attrs[i];\n            html.push(' ', attr.name, '=\"', encode(attr.value, true), '\"');\n          }\n        }\n\n        if (!empty || htmlOutput) {\n          html[html.length] = '>';\n        } else {\n          html[html.length] = ' />';\n        }\n\n        if (empty && indent && indentAfter[name] && html.length > 0) {\n          value = html[html.length - 1];\n\n          if (value.length > 0 && value !== '\\n') {\n            html.push('\\n');\n          }\n        }\n      },\n      end: name => {\n        let value;\n        html.push('</', name, '>');\n\n        if (indent && indentAfter[name] && html.length > 0) {\n          value = html[html.length - 1];\n\n          if (value.length > 0 && value !== '\\n') {\n            html.push('\\n');\n          }\n        }\n      },\n      text: (text, raw) => {\n        if (text.length > 0) {\n          html[html.length] = raw ? text : encode(text);\n        }\n      },\n      cdata: text => {\n        html.push('<![CDATA[', text, ']]>');\n      },\n      comment: text => {\n        html.push('<!--', text, '-->');\n      },\n      pi: (name, text) => {\n        if (text) {\n          html.push('<?', name, ' ', encode(text), '?>');\n        } else {\n          html.push('<?', name, '?>');\n        }\n\n        if (indent) {\n          html.push('\\n');\n        }\n      },\n      doctype: text => {\n        html.push('<!DOCTYPE', text, '>', indent ? '\\n' : '');\n      },\n      reset: () => {\n        html.length = 0;\n      },\n      getContent: () => {\n        return html.join('').replace(/\\n$/, '');\n      }\n    };\n  };\n\n  const HtmlSerializer = function (settings) {\n    let schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Schema();\n    const writer = Writer(settings);\n    settings = settings || {};\n    settings.validate = 'validate' in settings ? settings.validate : true;\n\n    const serialize = node => {\n      const validate = settings.validate;\n      const handlers = {\n        3: node => {\n          writer.text(node.value, node.raw);\n        },\n        8: node => {\n          writer.comment(node.value);\n        },\n        7: node => {\n          writer.pi(node.name, node.value);\n        },\n        10: node => {\n          writer.doctype(node.value);\n        },\n        4: node => {\n          writer.cdata(node.value);\n        },\n        11: node => {\n          if (node = node.firstChild) {\n            do {\n              walk(node);\n            } while (node = node.next);\n          }\n        }\n      };\n      writer.reset();\n\n      const walk = node => {\n        const handler = handlers[node.type];\n\n        if (!handler) {\n          const name = node.name;\n          const isEmpty = (name in schema.getVoidElements());\n          let attrs = node.attributes;\n\n          if (validate && attrs && attrs.length > 1) {\n            const sortedAttrs = [];\n            sortedAttrs.map = {};\n            const elementRule = schema.getElementRule(node.name);\n\n            if (elementRule) {\n              for (let i = 0, l = elementRule.attributesOrder.length; i < l; i++) {\n                const attrName = elementRule.attributesOrder[i];\n\n                if (attrName in attrs.map) {\n                  const attrValue = attrs.map[attrName];\n                  sortedAttrs.map[attrName] = attrValue;\n                  sortedAttrs.push({\n                    name: attrName,\n                    value: attrValue\n                  });\n                }\n              }\n\n              for (let i = 0, l = attrs.length; i < l; i++) {\n                const attrName = attrs[i].name;\n\n                if (!(attrName in sortedAttrs.map)) {\n                  const attrValue = attrs.map[attrName];\n                  sortedAttrs.map[attrName] = attrValue;\n                  sortedAttrs.push({\n                    name: attrName,\n                    value: attrValue\n                  });\n                }\n              }\n\n              attrs = sortedAttrs;\n            }\n          }\n\n          writer.start(name, attrs, isEmpty);\n\n          if (!isEmpty) {\n            let child = node.firstChild;\n\n            if (child) {\n              if ((name === 'pre' || name === 'textarea') && child.type === 3 && child.value[0] === '\\n') {\n                writer.text('\\n', true);\n              }\n\n              do {\n                walk(child);\n              } while (child = child.next);\n            }\n\n            writer.end(name);\n          }\n        } else {\n          handler(node);\n        }\n      };\n\n      if (node.type === 1 && !settings.inner) {\n        walk(node);\n      } else if (node.type === 3) {\n        handlers[3](node);\n      } else {\n        handlers[11](node);\n      }\n\n      return writer.getContent();\n    };\n\n    return {\n      serialize\n    };\n  };\n\n  const nonInheritableStyles = new Set();\n\n  (() => {\n    const nonInheritableStylesArr = ['margin', 'margin-left', 'margin-right', 'margin-top', 'margin-bottom', 'padding', 'padding-left', 'padding-right', 'padding-top', 'padding-bottom', 'border', 'border-width', 'border-style', 'border-color', 'background', 'background-attachment', 'background-clip', 'background-color', 'background-image', 'background-origin', 'background-position', 'background-repeat', 'background-size', 'float', 'position', 'left', 'right', 'top', 'bottom', 'z-index', 'display', 'transform', 'width', 'max-width', 'min-width', 'height', 'max-height', 'min-height', 'overflow', 'overflow-x', 'overflow-y', 'text-overflow', 'vertical-align', 'transition', 'transition-delay', 'transition-duration', 'transition-property', 'transition-timing-function'];\n    each$g(nonInheritableStylesArr, style => {\n      nonInheritableStyles.add(style);\n    });\n  })();\n\n  const shorthandStyleProps = ['font', 'text-decoration', 'text-emphasis'];\n\n  const getStyleProps = (dom, node) => keys(dom.parseStyle(dom.getAttrib(node, 'style')));\n\n  const isNonInheritableStyle = style => nonInheritableStyles.has(style);\n\n  const hasInheritableStyles = (dom, node) => forall(getStyleProps(dom, node), style => !isNonInheritableStyle(style));\n\n  const getLonghandStyleProps = styles => filter$6(styles, style => exists(shorthandStyleProps, prop => startsWith(style, prop)));\n\n  const hasStyleConflict = (dom, node, parentNode) => {\n    const nodeStyleProps = getStyleProps(dom, node);\n    const parentNodeStyleProps = getStyleProps(dom, parentNode);\n\n    const valueMismatch = prop => {\n      var _a, _b;\n\n      const nodeValue = (_a = dom.getStyle(node, prop)) !== null && _a !== void 0 ? _a : '';\n      const parentValue = (_b = dom.getStyle(parentNode, prop)) !== null && _b !== void 0 ? _b : '';\n      return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;\n    };\n\n    return exists(nodeStyleProps, nodeStyleProp => {\n      const propExists = props => exists(props, prop => prop === nodeStyleProp);\n\n      if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {\n        const longhandProps = getLonghandStyleProps(parentNodeStyleProps);\n        return exists(longhandProps, valueMismatch);\n      } else {\n        return valueMismatch(nodeStyleProp);\n      }\n    });\n  };\n\n  const isChar = (forward, predicate, pos) => Optional.from(pos.container()).filter(isText$8).exists(text => {\n    const delta = forward ? 0 : -1;\n    return predicate(text.data.charAt(pos.offset() + delta));\n  });\n\n  const isBeforeSpace = curry(isChar, true, isWhiteSpace);\n  const isAfterSpace = curry(isChar, false, isWhiteSpace);\n\n  const isEmptyText = pos => {\n    const container = pos.container();\n    return isText$8(container) && (container.data.length === 0 || isZwsp(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));\n  };\n\n  const matchesElementPosition = (before, predicate) => pos => Optional.from(getChildNodeAtRelativeOffset(before ? 0 : -1, pos)).filter(predicate).isSome();\n\n  const isImageBlock = node => isImg(node) && get$7(SugarElement.fromDom(node), 'display') === 'block';\n\n  const isCefNode = node => isContentEditableFalse$a(node) && !isBogusAll$1(node);\n\n  const isBeforeImageBlock = matchesElementPosition(true, isImageBlock);\n  const isAfterImageBlock = matchesElementPosition(false, isImageBlock);\n  const isBeforeMedia = matchesElementPosition(true, isMedia$2);\n  const isAfterMedia = matchesElementPosition(false, isMedia$2);\n  const isBeforeTable = matchesElementPosition(true, isTable$3);\n  const isAfterTable = matchesElementPosition(false, isTable$3);\n  const isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);\n  const isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);\n\n  const getLastChildren = elm => {\n    const children = [];\n    let rawNode = elm.dom;\n\n    while (rawNode) {\n      children.push(SugarElement.fromDom(rawNode));\n      rawNode = rawNode.lastChild;\n    }\n\n    return children;\n  };\n\n  const removeTrailingBr = elm => {\n    const allBrs = descendants(elm, 'br');\n    const brs = filter$6(getLastChildren(elm).slice(-1), isBr$4);\n\n    if (allBrs.length === brs.length) {\n      each$g(brs, remove$5);\n    }\n  };\n\n  const fillWithPaddingBr = elm => {\n    empty(elm);\n    append$1(elm, SugarElement.fromHtml('<br data-mce-bogus=\"1\">'));\n  };\n\n  const trimBlockTrailingBr = elm => {\n    lastChild(elm).each(lastChild => {\n      prevSibling(lastChild).each(lastChildPrevSibling => {\n        if (isBlock$2(elm) && isBr$4(lastChild) && isBlock$2(lastChildPrevSibling)) {\n          remove$5(lastChild);\n        }\n      });\n    });\n  };\n\n  const dropLast = xs => xs.slice(0, -1);\n\n  const parentsUntil = (start, root, predicate) => {\n    if (contains(root, start)) {\n      return dropLast(parents$1(start, elm => {\n        return predicate(elm) || eq(elm, root);\n      }));\n    } else {\n      return [];\n    }\n  };\n\n  const parents = (start, root) => parentsUntil(start, root, never);\n\n  const parentsAndSelf = (start, root) => [start].concat(parents(start, root));\n\n  const navigateIgnoreEmptyTextNodes = (forward, root, from) => navigateIgnore(forward, root, from, isEmptyText);\n\n  const getClosestBlock$1 = (root, pos) => find$2(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);\n\n  const isAtBeforeAfterBlockBoundary = (forward, root, pos) => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => getClosestBlock$1(root, pos).fold(() => isInSameBlock(newPos, pos, root.dom) === false, fromBlock => isInSameBlock(newPos, pos, root.dom) === false && contains(fromBlock, SugarElement.fromDom(newPos.container()))));\n\n  const isAtBlockBoundary = (forward, root, pos) => getClosestBlock$1(root, pos).fold(() => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => isInSameBlock(newPos, pos, root.dom) === false), parent => navigateIgnoreEmptyTextNodes(forward, parent.dom, pos).isNone());\n\n  const isAtStartOfBlock = curry(isAtBlockBoundary, false);\n  const isAtEndOfBlock = curry(isAtBlockBoundary, true);\n  const isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);\n  const isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);\n\n  const isBr = pos => getElementFromPosition(pos).exists(isBr$4);\n\n  const findBr = (forward, root, pos) => {\n    const parentBlocks = filter$6(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);\n    const scope = head(parentBlocks).getOr(root);\n    return fromPosition(forward, scope.dom, pos).filter(isBr);\n  };\n\n  const isBeforeBr$1 = (root, pos) => getElementFromPosition(pos).exists(isBr$4) || findBr(true, root, pos).isSome();\n\n  const isAfterBr = (root, pos) => getElementFromPrevPosition(pos).exists(isBr$4) || findBr(false, root, pos).isSome();\n\n  const findPreviousBr = curry(findBr, false);\n  const findNextBr = curry(findBr, true);\n\n  const isInMiddleOfText = pos => CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();\n\n  const getClosestBlock = (root, pos) => {\n    const parentBlocks = filter$6(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);\n    return head(parentBlocks).getOr(root);\n  };\n\n  const hasSpaceBefore = (root, pos) => {\n    if (isInMiddleOfText(pos)) {\n      return isAfterSpace(pos);\n    } else {\n      return isAfterSpace(pos) || prevPosition(getClosestBlock(root, pos).dom, pos).exists(isAfterSpace);\n    }\n  };\n\n  const hasSpaceAfter = (root, pos) => {\n    if (isInMiddleOfText(pos)) {\n      return isBeforeSpace(pos);\n    } else {\n      return isBeforeSpace(pos) || nextPosition(getClosestBlock(root, pos).dom, pos).exists(isBeforeSpace);\n    }\n  };\n\n  const isPreValue = value => contains$2(['pre', 'pre-wrap'], value);\n\n  const isInPre = pos => getElementFromPosition(pos).bind(elm => closest$4(elm, isElement$7)).exists(elm => isPreValue(get$7(elm, 'white-space')));\n\n  const isAtBeginningOfBody = (root, pos) => prevPosition(root.dom, pos).isNone();\n\n  const isAtEndOfBody = (root, pos) => nextPosition(root.dom, pos).isNone();\n\n  const isAtLineBoundary = (root, pos) => isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos) || isAtEndOfBlock(root, pos) || isAfterBr(root, pos) || isBeforeBr$1(root, pos);\n\n  const needsToHaveNbsp = (root, pos) => {\n    if (isInPre(pos)) {\n      return false;\n    } else {\n      return isAtLineBoundary(root, pos) || hasSpaceBefore(root, pos) || hasSpaceAfter(root, pos);\n    }\n  };\n\n  const needsToBeNbspLeft = (root, pos) => {\n    if (isInPre(pos)) {\n      return false;\n    } else {\n      return isAtStartOfBlock(root, pos) || isBeforeBlock(root, pos) || isAfterBr(root, pos) || hasSpaceBefore(root, pos);\n    }\n  };\n\n  const leanRight = pos => {\n    const container = pos.container();\n    const offset = pos.offset();\n\n    if (isText$8(container) && offset < container.data.length) {\n      return CaretPosition(container, offset + 1);\n    } else {\n      return pos;\n    }\n  };\n\n  const needsToBeNbspRight = (root, pos) => {\n    if (isInPre(pos)) {\n      return false;\n    } else {\n      return isAtEndOfBlock(root, pos) || isAfterBlock(root, pos) || isBeforeBr$1(root, pos) || hasSpaceAfter(root, pos);\n    }\n  };\n\n  const needsToBeNbsp = (root, pos) => needsToBeNbspLeft(root, pos) || needsToBeNbspRight(root, leanRight(pos));\n\n  const isNbspAt = (text, offset) => isNbsp(text.charAt(offset));\n\n  const hasNbsp = pos => {\n    const container = pos.container();\n    return isText$8(container) && contains$1(container.data, nbsp);\n  };\n\n  const normalizeNbspMiddle = text => {\n    const chars = text.split('');\n    return map$3(chars, (chr, i) => {\n      if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent(chars[i - 1]) && isContent(chars[i + 1])) {\n        return ' ';\n      } else {\n        return chr;\n      }\n    }).join('');\n  };\n\n  const normalizeNbspAtStart = (root, node) => {\n    const text = node.data;\n    const firstPos = CaretPosition(node, 0);\n\n    if (isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos)) {\n      node.data = ' ' + text.slice(1);\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  const normalizeNbspInMiddleOfTextNode = node => {\n    const text = node.data;\n    const newText = normalizeNbspMiddle(text);\n\n    if (newText !== text) {\n      node.data = newText;\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  const normalizeNbspAtEnd = (root, node) => {\n    const text = node.data;\n    const lastPos = CaretPosition(node, text.length - 1);\n\n    if (isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos)) {\n      node.data = text.slice(0, -1) + ' ';\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  const normalizeNbsps = (root, pos) => Optional.some(pos).filter(hasNbsp).bind(pos => {\n    const container = pos.container();\n    const normalized = normalizeNbspAtStart(root, container) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container);\n    return normalized ? Optional.some(pos) : Optional.none();\n  });\n\n  const normalizeNbspsInEditor = editor => {\n    const root = SugarElement.fromDom(editor.getBody());\n\n    if (editor.selection.isCollapsed()) {\n      normalizeNbsps(root, CaretPosition.fromRangeStart(editor.selection.getRng())).each(pos => {\n        editor.selection.setRng(pos.toRange());\n      });\n    }\n  };\n\n  const normalize$1 = (node, offset, count) => {\n    if (count === 0) {\n      return;\n    }\n\n    const elm = SugarElement.fromDom(node);\n    const root = ancestor$3(elm, isBlock$2).getOr(elm);\n    const whitespace = node.data.slice(offset, offset + count);\n    const isEndOfContent = offset + count >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length));\n    const isStartOfContent = offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0));\n    node.replaceData(offset, count, normalize$4(whitespace, 4, isStartOfContent, isEndOfContent));\n  };\n\n  const normalizeWhitespaceAfter = (node, offset) => {\n    const content = node.data.slice(offset);\n    const whitespaceCount = content.length - lTrim(content).length;\n    normalize$1(node, offset, whitespaceCount);\n  };\n\n  const normalizeWhitespaceBefore = (node, offset) => {\n    const content = node.data.slice(0, offset);\n    const whitespaceCount = content.length - rTrim(content).length;\n    normalize$1(node, offset - whitespaceCount, whitespaceCount);\n  };\n\n  const mergeTextNodes = function (prevNode, nextNode, normalizeWhitespace) {\n    let mergeToPrev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    const whitespaceOffset = rTrim(prevNode.data).length;\n    const newNode = mergeToPrev ? prevNode : nextNode;\n    const removeNode = mergeToPrev ? nextNode : prevNode;\n\n    if (mergeToPrev) {\n      newNode.appendData(removeNode.data);\n    } else {\n      newNode.insertData(0, removeNode.data);\n    }\n\n    remove$5(SugarElement.fromDom(removeNode));\n\n    if (normalizeWhitespace) {\n      normalizeWhitespaceAfter(newNode, whitespaceOffset);\n    }\n\n    return newNode;\n  };\n\n  const needsReposition = (pos, elm) => {\n    const container = pos.container();\n    const offset = pos.offset();\n    return CaretPosition.isTextPosition(pos) === false && container === elm.parentNode && offset > CaretPosition.before(elm).offset();\n  };\n\n  const reposition = (elm, pos) => needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;\n\n  const beforeOrStartOf = node => isText$8(node) ? CaretPosition(node, 0) : CaretPosition.before(node);\n\n  const afterOrEndOf = node => isText$8(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);\n\n  const getPreviousSiblingCaretPosition = elm => {\n    if (isCaretCandidate$3(elm.previousSibling)) {\n      return Optional.some(afterOrEndOf(elm.previousSibling));\n    } else {\n      return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();\n    }\n  };\n\n  const getNextSiblingCaretPosition = elm => {\n    if (isCaretCandidate$3(elm.nextSibling)) {\n      return Optional.some(beforeOrStartOf(elm.nextSibling));\n    } else {\n      return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();\n    }\n  };\n\n  const findCaretPositionBackwardsFromElm = (rootElement, elm) => {\n    const startPosition = CaretPosition.before(elm.previousSibling ? elm.previousSibling : elm.parentNode);\n    return prevPosition(rootElement, startPosition).fold(() => nextPosition(rootElement, CaretPosition.after(elm)), Optional.some);\n  };\n\n  const findCaretPositionForwardsFromElm = (rootElement, elm) => nextPosition(rootElement, CaretPosition.after(elm)).fold(() => prevPosition(rootElement, CaretPosition.before(elm)), Optional.some);\n\n  const findCaretPositionBackwards = (rootElement, elm) => getPreviousSiblingCaretPosition(elm).orThunk(() => getNextSiblingCaretPosition(elm)).orThunk(() => findCaretPositionBackwardsFromElm(rootElement, elm));\n\n  const findCaretPositionForward = (rootElement, elm) => getNextSiblingCaretPosition(elm).orThunk(() => getPreviousSiblingCaretPosition(elm)).orThunk(() => findCaretPositionForwardsFromElm(rootElement, elm));\n\n  const findCaretPosition = (forward, rootElement, elm) => forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);\n\n  const findCaretPosOutsideElmAfterDelete = (forward, rootElement, elm) => findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));\n\n  const setSelection$1 = (editor, forward, pos) => {\n    pos.fold(() => {\n      editor.focus();\n    }, pos => {\n      editor.selection.setRng(pos.toRange(), forward);\n    });\n  };\n\n  const eqRawNode = rawNode => elm => elm.dom === rawNode;\n\n  const isBlock = (editor, elm) => elm && has$2(editor.schema.getBlockElements(), name(elm));\n\n  const paddEmptyBlock = elm => {\n    if (isEmpty$2(elm)) {\n      const br = SugarElement.fromHtml('<br data-mce-bogus=\"1\">');\n      empty(elm);\n      append$1(elm, br);\n      return Optional.some(CaretPosition.before(br.dom));\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const deleteNormalized = (elm, afterDeletePosOpt, normalizeWhitespace) => {\n    const prevTextOpt = prevSibling(elm).filter(isText$9);\n    const nextTextOpt = nextSibling(elm).filter(isText$9);\n    remove$5(elm);\n    return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, (prev, next, pos) => {\n      const prevNode = prev.dom,\n            nextNode = next.dom;\n      const offset = prevNode.data.length;\n      mergeTextNodes(prevNode, nextNode, normalizeWhitespace);\n      return pos.container() === nextNode ? CaretPosition(prevNode, offset) : pos;\n    }).orThunk(() => {\n      if (normalizeWhitespace) {\n        prevTextOpt.each(elm => normalizeWhitespaceBefore(elm.dom, elm.dom.length));\n        nextTextOpt.each(elm => normalizeWhitespaceAfter(elm.dom, 0));\n      }\n\n      return afterDeletePosOpt;\n    });\n  };\n\n  const isInlineElement = (editor, element) => has$2(editor.schema.getTextInlineElements(), name(element));\n\n  const deleteElement$2 = function (editor, forward, elm) {\n    let moveCaret = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    const afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);\n    const parentBlock = ancestor$3(elm, curry(isBlock, editor), eqRawNode(editor.getBody()));\n    const normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, isInlineElement(editor, elm));\n\n    if (editor.dom.isEmpty(editor.getBody())) {\n      editor.setContent('');\n      editor.selection.setCursorLocation();\n    } else {\n      parentBlock.bind(paddEmptyBlock).fold(() => {\n        if (moveCaret) {\n          setSelection$1(editor, forward, normalizedAfterDeletePos);\n        }\n      }, paddPos => {\n        if (moveCaret) {\n          setSelection$1(editor, forward, Optional.some(paddPos));\n        }\n      });\n    }\n  };\n\n  const isRootFromElement = root => cur => eq(root, cur);\n\n  const getTableCells = table => descendants(table, 'td,th');\n\n  const getTableDetailsFromRange = (rng, isRoot) => {\n    const getTable = node => getClosestTable(SugarElement.fromDom(node), isRoot);\n\n    const startTable = getTable(rng.startContainer);\n    const endTable = getTable(rng.endContainer);\n    const isStartInTable = startTable.isSome();\n    const isEndInTable = endTable.isSome();\n    const isSameTable = lift2(startTable, endTable, eq).getOr(false);\n    const isMultiTable = !isSameTable && isStartInTable && isEndInTable;\n    return {\n      startTable,\n      endTable,\n      isStartInTable,\n      isEndInTable,\n      isSameTable,\n      isMultiTable\n    };\n  };\n\n  const tableCellRng = (start, end) => ({\n    start,\n    end\n  });\n\n  const tableSelection = (rng, table, cells) => ({\n    rng,\n    table,\n    cells\n  });\n\n  const deleteAction = Adt.generate([{\n    singleCellTable: ['rng', 'cell']\n  }, {\n    fullTable: ['table']\n  }, {\n    partialTable: ['cells', 'outsideDetails']\n  }, {\n    multiTable: ['startTableCells', 'endTableCells', 'betweenRng']\n  }]);\n\n  const getClosestCell$1 = (container, isRoot) => closest$3(SugarElement.fromDom(container), 'td,th', isRoot);\n\n  const isExpandedCellRng = cellRng => !eq(cellRng.start, cellRng.end);\n\n  const getTableFromCellRng = (cellRng, isRoot) => getClosestTable(cellRng.start, isRoot).bind(startParentTable => getClosestTable(cellRng.end, isRoot).bind(endParentTable => someIf(eq(startParentTable, endParentTable), startParentTable)));\n\n  const isSingleCellTable = (cellRng, isRoot) => !isExpandedCellRng(cellRng) && getTableFromCellRng(cellRng, isRoot).exists(table => {\n    const rows = table.dom.rows;\n    return rows.length === 1 && rows[0].cells.length === 1;\n  });\n\n  const getCellRng = (rng, isRoot) => {\n    const startCell = getClosestCell$1(rng.startContainer, isRoot);\n    const endCell = getClosestCell$1(rng.endContainer, isRoot);\n    return lift2(startCell, endCell, tableCellRng);\n  };\n\n  const getCellRangeFromStartTable = isRoot => startCell => getClosestTable(startCell, isRoot).bind(table => last$3(getTableCells(table)).map(endCell => tableCellRng(startCell, endCell)));\n\n  const getCellRangeFromEndTable = isRoot => endCell => getClosestTable(endCell, isRoot).bind(table => head(getTableCells(table)).map(startCell => tableCellRng(startCell, endCell)));\n\n  const getTableSelectionFromCellRng = isRoot => cellRng => getTableFromCellRng(cellRng, isRoot).map(table => tableSelection(cellRng, table, getTableCells(table)));\n\n  const getTableSelections = (cellRng, selectionDetails, rng, isRoot) => {\n    if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) {\n      return Optional.none();\n    } else if (selectionDetails.isSameTable) {\n      const sameTableSelection = cellRng.bind(getTableSelectionFromCellRng(isRoot));\n      return Optional.some({\n        start: sameTableSelection,\n        end: sameTableSelection\n      });\n    } else {\n      const startCell = getClosestCell$1(rng.startContainer, isRoot);\n      const endCell = getClosestCell$1(rng.endContainer, isRoot);\n      const startTableSelection = startCell.bind(getCellRangeFromStartTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\n      const endTableSelection = endCell.bind(getCellRangeFromEndTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\n      return Optional.some({\n        start: startTableSelection,\n        end: endTableSelection\n      });\n    }\n  };\n\n  const getCellIndex = (cells, cell) => findIndex$2(cells, x => eq(x, cell));\n\n  const getSelectedCells = tableSelection => lift2(getCellIndex(tableSelection.cells, tableSelection.rng.start), getCellIndex(tableSelection.cells, tableSelection.rng.end), (startIndex, endIndex) => tableSelection.cells.slice(startIndex, endIndex + 1));\n\n  const isSingleCellTableContentSelected = (optCellRng, rng, isRoot) => optCellRng.exists(cellRng => isSingleCellTable(cellRng, isRoot) && hasAllContentsSelected(cellRng.start, rng));\n\n  const unselectCells = (rng, selectionDetails) => {\n    const {\n      startTable,\n      endTable\n    } = selectionDetails;\n    const otherContentRng = rng.cloneRange();\n    startTable.each(table => otherContentRng.setStartAfter(table.dom));\n    endTable.each(table => otherContentRng.setEndBefore(table.dom));\n    return otherContentRng;\n  };\n\n  const handleSingleTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(_ref8 => {\n    let {\n      start,\n      end\n    } = _ref8;\n    return start.or(end);\n  }).bind(tableSelection => {\n    const {\n      isSameTable\n    } = selectionDetails;\n    const selectedCells = getSelectedCells(tableSelection).getOr([]);\n\n    if (isSameTable && tableSelection.cells.length === selectedCells.length) {\n      return Optional.some(deleteAction.fullTable(tableSelection.table));\n    } else if (selectedCells.length > 0) {\n      if (isSameTable) {\n        return Optional.some(deleteAction.partialTable(selectedCells, Optional.none()));\n      } else {\n        const otherContentRng = unselectCells(rng, selectionDetails);\n        return Optional.some(deleteAction.partialTable(selectedCells, Optional.some({ ...selectionDetails,\n          rng: otherContentRng\n        })));\n      }\n    } else {\n      return Optional.none();\n    }\n  });\n\n  const handleMultiTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(_ref9 => {\n    let {\n      start,\n      end\n    } = _ref9;\n    const startTableSelectedCells = start.bind(getSelectedCells).getOr([]);\n    const endTableSelectedCells = end.bind(getSelectedCells).getOr([]);\n\n    if (startTableSelectedCells.length > 0 && endTableSelectedCells.length > 0) {\n      const otherContentRng = unselectCells(rng, selectionDetails);\n      return Optional.some(deleteAction.multiTable(startTableSelectedCells, endTableSelectedCells, otherContentRng));\n    } else {\n      return Optional.none();\n    }\n  });\n\n  const getActionFromRange = (root, rng) => {\n    const isRoot = isRootFromElement(root);\n    const optCellRng = getCellRng(rng, isRoot);\n    const selectionDetails = getTableDetailsFromRange(rng, isRoot);\n\n    if (isSingleCellTableContentSelected(optCellRng, rng, isRoot)) {\n      return optCellRng.map(cellRng => deleteAction.singleCellTable(rng, cellRng.start));\n    } else if (selectionDetails.isMultiTable) {\n      return handleMultiTable(optCellRng, selectionDetails, rng, isRoot);\n    } else {\n      return handleSingleTable(optCellRng, selectionDetails, rng, isRoot);\n    }\n  };\n\n  const freefallRtl = root => {\n    const child = isComment$1(root) ? prevSibling(root) : lastChild(root);\n    return child.bind(freefallRtl).orThunk(() => Optional.some(root));\n  };\n\n  const cleanCells = cells => each$g(cells, cell => {\n    remove$a(cell, 'contenteditable');\n    fillWithPaddingBr(cell);\n  });\n\n  const getOutsideBlock = (editor, container) => Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(SugarElement.fromDom);\n\n  const handleEmptyBlock = (editor, startInTable, emptyBlock) => {\n    emptyBlock.each(block => {\n      if (startInTable) {\n        remove$5(block);\n      } else {\n        fillWithPaddingBr(block);\n        editor.selection.setCursorLocation(block.dom, 0);\n      }\n    });\n  };\n\n  const deleteContentInsideCell = (editor, cell, rng, isFirstCellInSelection) => {\n    const insideTableRng = rng.cloneRange();\n\n    if (isFirstCellInSelection) {\n      insideTableRng.setStart(rng.startContainer, rng.startOffset);\n      insideTableRng.setEndAfter(cell.dom.lastChild);\n    } else {\n      insideTableRng.setStartBefore(cell.dom.firstChild);\n      insideTableRng.setEnd(rng.endContainer, rng.endOffset);\n    }\n\n    deleteCellContents(editor, insideTableRng, cell, false).each(action => action());\n  };\n\n  const collapseAndRestoreCellSelection = editor => {\n    const selectedCells = getCellsFromEditor(editor);\n    const selectedNode = SugarElement.fromDom(editor.selection.getNode());\n\n    if (isTableCell$5(selectedNode.dom) && isEmpty$2(selectedNode)) {\n      editor.selection.setCursorLocation(selectedNode.dom, 0);\n    } else {\n      editor.selection.collapse(true);\n    }\n\n    if (selectedCells.length > 1 && exists(selectedCells, cell => eq(cell, selectedNode))) {\n      set$2(selectedNode, 'data-mce-selected', '1');\n    }\n  };\n\n  const emptySingleTableCells = (editor, cells, outsideDetails) => Optional.some(() => {\n    const editorRng = editor.selection.getRng();\n    const cellsToClean = outsideDetails.bind(_ref10 => {\n      let {\n        rng,\n        isStartInTable\n      } = _ref10;\n      const outsideBlock = getOutsideBlock(editor, isStartInTable ? rng.endContainer : rng.startContainer);\n      rng.deleteContents();\n      handleEmptyBlock(editor, isStartInTable, outsideBlock.filter(isEmpty$2));\n      const endPointCell = isStartInTable ? cells[0] : cells[cells.length - 1];\n      deleteContentInsideCell(editor, endPointCell, editorRng, isStartInTable);\n\n      if (!isEmpty$2(endPointCell)) {\n        return Optional.some(isStartInTable ? cells.slice(1) : cells.slice(0, -1));\n      } else {\n        return Optional.none();\n      }\n    }).getOr(cells);\n    cleanCells(cellsToClean);\n    collapseAndRestoreCellSelection(editor);\n  });\n\n  const emptyMultiTableCells = (editor, startTableCells, endTableCells, betweenRng) => Optional.some(() => {\n    const rng = editor.selection.getRng();\n    const startCell = startTableCells[0];\n    const endCell = endTableCells[endTableCells.length - 1];\n    deleteContentInsideCell(editor, startCell, rng, true);\n    deleteContentInsideCell(editor, endCell, rng, false);\n    const startTableCellsToClean = isEmpty$2(startCell) ? startTableCells : startTableCells.slice(1);\n    const endTableCellsToClean = isEmpty$2(endCell) ? endTableCells : endTableCells.slice(0, -1);\n    cleanCells(startTableCellsToClean.concat(endTableCellsToClean));\n    betweenRng.deleteContents();\n    collapseAndRestoreCellSelection(editor);\n  });\n\n  const deleteCellContents = function (editor, rng, cell) {\n    let moveSelection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    return Optional.some(() => {\n      rng.deleteContents();\n      const lastNode = freefallRtl(cell).getOr(cell);\n      const lastBlock = SugarElement.fromDom(editor.dom.getParent(lastNode.dom, editor.dom.isBlock));\n\n      if (isEmpty$2(lastBlock)) {\n        fillWithPaddingBr(lastBlock);\n\n        if (moveSelection) {\n          editor.selection.setCursorLocation(lastBlock.dom, 0);\n        }\n      }\n\n      if (!eq(cell, lastBlock)) {\n        const additionalCleanupNodes = is$2(parent(lastBlock), cell) ? [] : siblings(lastBlock);\n        each$g(additionalCleanupNodes.concat(children(cell)), node => {\n          if (!eq(node, lastBlock) && !contains(node, lastBlock) && isEmpty$2(node)) {\n            remove$5(node);\n          }\n        });\n      }\n    });\n  };\n\n  const deleteTableElement = (editor, table) => Optional.some(() => deleteElement$2(editor, false, table));\n\n  const deleteCellRange = (editor, rootElm, rng) => getActionFromRange(rootElm, rng).bind(action => action.fold(curry(deleteCellContents, editor), curry(deleteTableElement, editor), curry(emptySingleTableCells, editor), curry(emptyMultiTableCells, editor)));\n\n  const deleteCaptionRange = (editor, caption) => emptyElement(editor, caption);\n\n  const deleteTableRange = (editor, rootElm, rng, startElm) => getParentCaption(rootElm, startElm).fold(() => deleteCellRange(editor, rootElm, rng), caption => deleteCaptionRange(editor, caption));\n\n  const deleteRange$2 = (editor, startElm, selectedCells) => {\n    const rootNode = SugarElement.fromDom(editor.getBody());\n    const rng = editor.selection.getRng();\n    return selectedCells.length !== 0 ? emptySingleTableCells(editor, selectedCells, Optional.none()) : deleteTableRange(editor, rootNode, rng, startElm);\n  };\n\n  const getParentCell = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTableCell$4);\n\n  const getParentCaption = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTag('caption'));\n\n  const deleteBetweenCells = (editor, rootElm, forward, fromCell, from) => navigate(forward, editor.getBody(), from).bind(to => getParentCell(rootElm, SugarElement.fromDom(to.getNode())).bind(toCell => eq(toCell, fromCell) ? Optional.none() : Optional.some(noop)));\n\n  const emptyElement = (editor, elm) => Optional.some(() => {\n    fillWithPaddingBr(elm);\n    editor.selection.setCursorLocation(elm.dom, 0);\n  });\n\n  const isDeleteOfLastCharPos = (fromCaption, forward, from, to) => firstPositionIn(fromCaption.dom).bind(first => lastPositionIn(fromCaption.dom).map(last => forward ? from.isEqual(first) && to.isEqual(last) : from.isEqual(last) && to.isEqual(first))).getOr(true);\n\n  const emptyCaretCaption = (editor, elm) => emptyElement(editor, elm);\n\n  const validateCaretCaption = (rootElm, fromCaption, to) => getParentCaption(rootElm, SugarElement.fromDom(to.getNode())).fold(() => Optional.some(noop), toCaption => someIf(!eq(toCaption, fromCaption), noop));\n\n  const deleteCaretInsideCaption = (editor, rootElm, forward, fromCaption, from) => navigate(forward, editor.getBody(), from).fold(() => Optional.some(noop), to => isDeleteOfLastCharPos(fromCaption, forward, from, to) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to));\n\n  const deleteCaretCells = (editor, forward, rootElm, startElm) => {\n    const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n    return getParentCell(rootElm, startElm).bind(fromCell => isEmpty$2(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from));\n  };\n\n  const deleteCaretCaption = (editor, forward, rootElm, fromCaption) => {\n    const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n    return isEmpty$2(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from);\n  };\n\n  const isNearTable = (forward, pos) => forward ? isBeforeTable(pos) : isAfterTable(pos);\n\n  const isBeforeOrAfterTable = (editor, forward) => {\n    const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n    return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos).exists(pos => isNearTable(forward, pos));\n  };\n\n  const deleteCaret$3 = (editor, forward, startElm) => {\n    const rootElm = SugarElement.fromDom(editor.getBody());\n    return getParentCaption(rootElm, startElm).fold(() => deleteCaretCells(editor, forward, rootElm, startElm).orThunk(() => someIf(isBeforeOrAfterTable(editor, forward), noop)), fromCaption => deleteCaretCaption(editor, forward, rootElm, fromCaption));\n  };\n\n  const backspaceDelete$9 = (editor, forward) => {\n    const startElm = SugarElement.fromDom(editor.selection.getStart(true));\n    const cells = getCellsFromEditor(editor);\n    return editor.selection.isCollapsed() && cells.length === 0 ? deleteCaret$3(editor, forward, startElm) : deleteRange$2(editor, startElm, cells);\n  };\n\n  const getContentEditableRoot$1 = (root, node) => {\n    while (node && node !== root) {\n      if (isContentEditableTrue$4(node) || isContentEditableFalse$a(node)) {\n        return node;\n      }\n\n      node = node.parentNode;\n    }\n\n    return null;\n  };\n\n  const traverse = (node, fn) => {\n    fn(node);\n\n    if (node.firstChild) {\n      traverse(node.firstChild, fn);\n    }\n\n    if (node.next) {\n      traverse(node.next, fn);\n    }\n  };\n\n  const matchNode$1 = (nodeFilters, attributeFilters, node, matches) => {\n    const name = node.name;\n\n    for (let ni = 0, nl = nodeFilters.length; ni < nl; ni++) {\n      const filter = nodeFilters[ni];\n\n      if (filter.name === name) {\n        const match = matches.nodes[name];\n\n        if (match) {\n          match.nodes.push(node);\n        } else {\n          matches.nodes[name] = {\n            filter,\n            nodes: [node]\n          };\n        }\n      }\n    }\n\n    if (node.attributes) {\n      for (let ai = 0, al = attributeFilters.length; ai < al; ai++) {\n        const filter = attributeFilters[ai];\n        const attrName = filter.name;\n\n        if (attrName in node.attributes.map) {\n          const match = matches.attributes[attrName];\n\n          if (match) {\n            match.nodes.push(node);\n          } else {\n            matches.attributes[attrName] = {\n              filter,\n              nodes: [node]\n            };\n          }\n        }\n      }\n    }\n  };\n\n  const findMatchingNodes = (nodeFilters, attributeFilters, node) => {\n    const matches = {\n      nodes: {},\n      attributes: {}\n    };\n\n    if (node.firstChild) {\n      traverse(node.firstChild, node => {\n        matchNode$1(nodeFilters, attributeFilters, node, matches);\n      });\n    }\n\n    return matches;\n  };\n\n  const runFilters = (matches, args) => {\n    const run = matchRecord => {\n      each$f(matchRecord, match => {\n        const nodes = filter$6(match.nodes, node => isNonNullable(node.parent));\n        each$g(match.filter.callbacks, callback => {\n          callback(nodes, match.filter.name, args);\n        });\n      });\n    };\n\n    run(matches.nodes);\n    run(matches.attributes);\n  };\n\n  const filter$3 = function (nodeFilters, attributeFilters, node) {\n    let args = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const matches = findMatchingNodes(nodeFilters, attributeFilters, node);\n    runFilters(matches, args);\n  };\n\n  const paddEmptyNode = (settings, args, blockElements, node) => {\n    if (args.insert && blockElements[node.name]) {\n      node.empty().append(new AstNode('br', 1));\n    } else {\n      node.empty().append(new AstNode('#text', 3)).value = nbsp;\n    }\n  };\n\n  const isPaddedWithNbsp = node => hasOnlyChild(node, '#text') && node.firstChild.value === nbsp;\n\n  const hasOnlyChild = (node, name) => node && node.firstChild && node.firstChild === node.lastChild && node.firstChild.name === name;\n\n  const isPadded = (schema, node) => {\n    const rule = schema.getElementRule(node.name);\n    return rule && rule.paddEmpty;\n  };\n\n  const isEmpty = (schema, nonEmptyElements, whitespaceElements, node) => node.isEmpty(nonEmptyElements, whitespaceElements, node => isPadded(schema, node));\n\n  const isLineBreakNode = (node, blockElements) => node && (node.name in blockElements || node.name === 'br');\n\n  const removeOrUnwrapInvalidNode = function (node, schema) {\n    let originalNodeParent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : node.parent;\n\n    if (schema.getSpecialElements()[node.name]) {\n      node.empty().remove();\n    } else {\n      const children = node.children();\n\n      for (const childNode of children) {\n        if (!schema.isValidChild(originalNodeParent.name, childNode.name)) {\n          removeOrUnwrapInvalidNode(childNode, schema, originalNodeParent);\n        }\n      }\n\n      node.unwrap();\n    }\n  };\n\n  const cleanInvalidNodes = function (nodes, schema) {\n    let onCreate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n    const textBlockElements = schema.getTextBlockElements();\n    const nonEmptyElements = schema.getNonEmptyElements();\n    const whitespaceElements = schema.getWhitespaceElements();\n    const nonSplittableElements = Tools.makeMap('tr,td,th,tbody,thead,tfoot,table');\n    const fixed = new Set();\n\n    for (let ni = 0; ni < nodes.length; ni++) {\n      const node = nodes[ni];\n      let parent;\n      let newParent;\n      let tempNode;\n\n      if (!node.parent || fixed.has(node)) {\n        continue;\n      }\n\n      if (textBlockElements[node.name] && node.parent.name === 'li') {\n        let sibling = node.next;\n\n        while (sibling) {\n          if (textBlockElements[sibling.name]) {\n            sibling.name = 'li';\n            fixed.add(sibling);\n            node.parent.insert(sibling, node.parent);\n          } else {\n            break;\n          }\n\n          sibling = sibling.next;\n        }\n\n        node.unwrap();\n        continue;\n      }\n\n      const parents = [node];\n\n      for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) && !nonSplittableElements[parent.name]; parent = parent.parent) {\n        parents.push(parent);\n      }\n\n      if (parent && parents.length > 1) {\n        if (schema.isValidChild(parent.name, node.name)) {\n          parents.reverse();\n          newParent = parents[0].clone();\n          onCreate(newParent);\n          let currentNode = newParent;\n\n          for (let i = 0; i < parents.length - 1; i++) {\n            if (schema.isValidChild(currentNode.name, parents[i].name)) {\n              tempNode = parents[i].clone();\n              onCreate(tempNode);\n              currentNode.append(tempNode);\n            } else {\n              tempNode = currentNode;\n            }\n\n            for (let childNode = parents[i].firstChild; childNode && childNode !== parents[i + 1];) {\n              const nextNode = childNode.next;\n              tempNode.append(childNode);\n              childNode = nextNode;\n            }\n\n            currentNode = tempNode;\n          }\n\n          if (!isEmpty(schema, nonEmptyElements, whitespaceElements, newParent)) {\n            parent.insert(newParent, parents[0], true);\n            parent.insert(node, newParent);\n          } else {\n            parent.insert(node, parents[0], true);\n          }\n\n          parent = parents[0];\n\n          if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent) || hasOnlyChild(parent, 'br')) {\n            parent.empty().remove();\n          }\n        } else {\n          removeOrUnwrapInvalidNode(node, schema);\n        }\n      } else if (node.parent) {\n        if (node.name === 'li') {\n          let sibling = node.prev;\n\n          if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {\n            sibling.append(node);\n            continue;\n          }\n\n          sibling = node.next;\n\n          if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {\n            sibling.insert(node, sibling.firstChild, true);\n            continue;\n          }\n\n          const wrapper = new AstNode('ul', 1);\n          onCreate(wrapper);\n          node.wrap(wrapper);\n          continue;\n        }\n\n        if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {\n          const wrapper = new AstNode('div', 1);\n          onCreate(wrapper);\n          node.wrap(wrapper);\n        } else {\n          removeOrUnwrapInvalidNode(node, schema);\n        }\n      }\n    }\n  };\n\n  const createRange = (sc, so, ec, eo) => {\n    const rng = document.createRange();\n    rng.setStart(sc, so);\n    rng.setEnd(ec, eo);\n    return rng;\n  };\n\n  const normalizeBlockSelectionRange = rng => {\n    const startPos = CaretPosition.fromRangeStart(rng);\n    const endPos = CaretPosition.fromRangeEnd(rng);\n    const rootNode = rng.commonAncestorContainer;\n    return fromPosition(false, rootNode, endPos).map(newEndPos => {\n      if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {\n        return createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());\n      } else {\n        return rng;\n      }\n    }).getOr(rng);\n  };\n\n  const normalize = rng => rng.collapsed ? rng : normalizeBlockSelectionRange(rng);\n\n  const hasOnlyOneChild$1 = node => {\n    return node.firstChild && node.firstChild === node.lastChild;\n  };\n\n  const isPaddingNode = node => {\n    return node.name === 'br' || node.value === nbsp;\n  };\n\n  const isPaddedEmptyBlock = (schema, node) => {\n    const blockElements = schema.getBlockElements();\n    return blockElements[node.name] && hasOnlyOneChild$1(node) && isPaddingNode(node.firstChild);\n  };\n\n  const isEmptyFragmentElement = (schema, node) => {\n    const nonEmptyElements = schema.getNonEmptyElements();\n    return node && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));\n  };\n\n  const isListFragment = (schema, fragment) => {\n    let firstChild = fragment.firstChild;\n    let lastChild = fragment.lastChild;\n\n    if (firstChild && firstChild.name === 'meta') {\n      firstChild = firstChild.next;\n    }\n\n    if (lastChild && lastChild.attr('id') === 'mce_marker') {\n      lastChild = lastChild.prev;\n    }\n\n    if (isEmptyFragmentElement(schema, lastChild)) {\n      lastChild = lastChild.prev;\n    }\n\n    if (!firstChild || firstChild !== lastChild) {\n      return false;\n    }\n\n    return firstChild.name === 'ul' || firstChild.name === 'ol';\n  };\n\n  const cleanupDomFragment = domFragment => {\n    const firstChild = domFragment.firstChild;\n    const lastChild = domFragment.lastChild;\n\n    if (firstChild && firstChild.nodeName === 'META') {\n      firstChild.parentNode.removeChild(firstChild);\n    }\n\n    if (lastChild && lastChild.id === 'mce_marker') {\n      lastChild.parentNode.removeChild(lastChild);\n    }\n\n    return domFragment;\n  };\n\n  const toDomFragment = (dom, serializer, fragment) => {\n    const html = serializer.serialize(fragment);\n    const domFragment = dom.createFragment(html);\n    return cleanupDomFragment(domFragment);\n  };\n\n  const listItems = elm => {\n    return filter$6(elm.childNodes, child => {\n      return child.nodeName === 'LI';\n    });\n  };\n\n  const isPadding = node => {\n    return node.data === nbsp || isBr$5(node);\n  };\n\n  const isListItemPadded = node => {\n    return node && node.firstChild && node.firstChild === node.lastChild && isPadding(node.firstChild);\n  };\n\n  const isEmptyOrPadded = elm => {\n    return !elm.firstChild || isListItemPadded(elm);\n  };\n\n  const trimListItems = elms => {\n    return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;\n  };\n\n  const getParentLi = (dom, node) => {\n    const parentBlock = dom.getParent(node, dom.isBlock);\n    return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;\n  };\n\n  const isParentBlockLi = (dom, node) => {\n    return !!getParentLi(dom, node);\n  };\n\n  const getSplit = (parentNode, rng) => {\n    const beforeRng = rng.cloneRange();\n    const afterRng = rng.cloneRange();\n    beforeRng.setStartBefore(parentNode);\n    afterRng.setEndAfter(parentNode);\n    return [beforeRng.cloneContents(), afterRng.cloneContents()];\n  };\n\n  const findFirstIn = (node, rootNode) => {\n    const caretPos = CaretPosition.before(node);\n    const caretWalker = CaretWalker(rootNode);\n    const newCaretPos = caretWalker.next(caretPos);\n    return newCaretPos ? newCaretPos.toRange() : null;\n  };\n\n  const findLastOf = (node, rootNode) => {\n    const caretPos = CaretPosition.after(node);\n    const caretWalker = CaretWalker(rootNode);\n    const newCaretPos = caretWalker.prev(caretPos);\n    return newCaretPos ? newCaretPos.toRange() : null;\n  };\n\n  const insertMiddle = (target, elms, rootNode, rng) => {\n    const parts = getSplit(target, rng);\n    const parentElm = target.parentNode;\n    parentElm.insertBefore(parts[0], target);\n    Tools.each(elms, li => {\n      parentElm.insertBefore(li, target);\n    });\n    parentElm.insertBefore(parts[1], target);\n    parentElm.removeChild(target);\n    return findLastOf(elms[elms.length - 1], rootNode);\n  };\n\n  const insertBefore$1 = (target, elms, rootNode) => {\n    const parentElm = target.parentNode;\n    Tools.each(elms, elm => {\n      parentElm.insertBefore(elm, target);\n    });\n    return findFirstIn(target, rootNode);\n  };\n\n  const insertAfter$1 = (target, elms, rootNode, dom) => {\n    dom.insertAfter(elms.reverse(), target);\n    return findLastOf(elms[0], rootNode);\n  };\n\n  const insertAtCaret$1 = (serializer, dom, rng, fragment) => {\n    const domFragment = toDomFragment(dom, serializer, fragment);\n    const liTarget = getParentLi(dom, rng.startContainer);\n    const liElms = trimListItems(listItems(domFragment.firstChild));\n    const BEGINNING = 1,\n          END = 2;\n    const rootNode = dom.getRoot();\n\n    const isAt = location => {\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      const caretWalker = CaretWalker(dom.getRoot());\n      const newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);\n      return newPos ? getParentLi(dom, newPos.getNode()) !== liTarget : true;\n    };\n\n    if (isAt(BEGINNING)) {\n      return insertBefore$1(liTarget, liElms, rootNode);\n    } else if (isAt(END)) {\n      return insertAfter$1(liTarget, liElms, rootNode, dom);\n    }\n\n    return insertMiddle(liTarget, liElms, rootNode, rng);\n  };\n\n  const isTableCell$1 = isTableCell$5;\n\n  const isTableCellContentSelected = (dom, rng, cell) => {\n    if (cell !== null) {\n      const endCell = dom.getParent(rng.endContainer, isTableCell$1);\n      return cell === endCell && hasAllContentsSelected(SugarElement.fromDom(cell), rng);\n    } else {\n      return false;\n    }\n  };\n\n  const validInsertion = (editor, value, parentNode) => {\n    if (parentNode.getAttribute('data-mce-bogus') === 'all') {\n      parentNode.parentNode.insertBefore(editor.dom.createFragment(value), parentNode);\n    } else {\n      const node = parentNode.firstChild;\n      const node2 = parentNode.lastChild;\n\n      if (!node || node === node2 && node.nodeName === 'BR') {\n        editor.dom.setHTML(parentNode, value);\n      } else {\n        editor.selection.setContent(value, {\n          no_events: true\n        });\n      }\n    }\n  };\n\n  const trimBrsFromTableCell = (dom, elm) => {\n    Optional.from(dom.getParent(elm, 'td,th')).map(SugarElement.fromDom).each(trimBlockTrailingBr);\n  };\n\n  const reduceInlineTextElements = (editor, merge) => {\n    const textInlineElements = editor.schema.getTextInlineElements();\n    const dom = editor.dom;\n\n    if (merge) {\n      const root = editor.getBody();\n      const elementUtils = ElementUtils(dom);\n      Tools.each(dom.select('*[data-mce-fragment]'), node => {\n        const isInline = isNonNullable(textInlineElements[node.nodeName.toLowerCase()]);\n\n        if (isInline && hasInheritableStyles(dom, node)) {\n          for (let parentNode = node.parentNode; isNonNullable(parentNode) && parentNode !== root; parentNode = parentNode.parentNode) {\n            const styleConflict = hasStyleConflict(dom, node, parentNode);\n\n            if (styleConflict) {\n              break;\n            }\n\n            if (elementUtils.compare(parentNode, node)) {\n              dom.remove(node, true);\n              break;\n            }\n          }\n        }\n      });\n    }\n  };\n\n  const markFragmentElements = fragment => {\n    let node = fragment;\n\n    while (node = node.walk()) {\n      if (node.type === 1) {\n        node.attr('data-mce-fragment', '1');\n      }\n    }\n  };\n\n  const unmarkFragmentElements = elm => {\n    Tools.each(elm.getElementsByTagName('*'), elm => {\n      elm.removeAttribute('data-mce-fragment');\n    });\n  };\n\n  const isPartOfFragment = node => {\n    return !!node.getAttribute('data-mce-fragment');\n  };\n\n  const canHaveChildren = (editor, node) => {\n    return node && !editor.schema.getVoidElements()[node.nodeName];\n  };\n\n  const moveSelectionToMarker = (editor, marker) => {\n    let nextRng;\n    const dom = editor.dom;\n    const selection = editor.selection;\n\n    if (!marker) {\n      return;\n    }\n\n    selection.scrollIntoView(marker);\n    const parentEditableElm = getContentEditableRoot$1(editor.getBody(), marker);\n\n    if (dom.getContentEditable(parentEditableElm) === 'false') {\n      dom.remove(marker);\n      selection.select(parentEditableElm);\n      return;\n    }\n\n    let rng = dom.createRng();\n    const node = marker.previousSibling;\n\n    if (isText$8(node)) {\n      rng.setStart(node, node.nodeValue.length);\n      const node2 = marker.nextSibling;\n\n      if (isText$8(node2)) {\n        node.appendData(node2.data);\n        node2.parentNode.removeChild(node2);\n      }\n    } else {\n      rng.setStartBefore(marker);\n      rng.setEndBefore(marker);\n    }\n\n    const findNextCaretRng = rng => {\n      let caretPos = CaretPosition.fromRangeStart(rng);\n      const caretWalker = CaretWalker(editor.getBody());\n      caretPos = caretWalker.next(caretPos);\n\n      if (caretPos) {\n        return caretPos.toRange();\n      }\n    };\n\n    const parentBlock = dom.getParent(marker, dom.isBlock);\n    dom.remove(marker);\n\n    if (parentBlock && dom.isEmpty(parentBlock)) {\n      empty(SugarElement.fromDom(parentBlock));\n      rng.setStart(parentBlock, 0);\n      rng.setEnd(parentBlock, 0);\n\n      if (!isTableCell$1(parentBlock) && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {\n        rng = nextRng;\n        dom.remove(parentBlock);\n      } else {\n        dom.add(parentBlock, dom.create('br', {\n          'data-mce-bogus': '1'\n        }));\n      }\n    }\n\n    selection.setRng(rng);\n  };\n\n  const deleteSelectedContent = editor => {\n    const dom = editor.dom;\n    const rng = normalize(editor.selection.getRng());\n    editor.selection.setRng(rng);\n    const startCell = dom.getParent(rng.startContainer, isTableCell$1);\n\n    if (isTableCellContentSelected(dom, rng, startCell)) {\n      deleteCellContents(editor, rng, SugarElement.fromDom(startCell));\n    } else {\n      editor.getDoc().execCommand('Delete', false, null);\n    }\n  };\n\n  const insertHtmlAtCaret = (editor, value, details) => {\n    let parentNode;\n    let rng, node;\n    const selection = editor.selection;\n    const dom = editor.dom;\n    const parser = editor.parser;\n    const merge = details.merge;\n    const serializer = HtmlSerializer({\n      validate: true\n    }, editor.schema);\n    const bookmarkHtml = '<span id=\"mce_marker\" data-mce-type=\"bookmark\">&#xFEFF;</span>';\n\n    if (value.indexOf('{$caret}') === -1) {\n      value += '{$caret}';\n    }\n\n    value = value.replace(/\\{\\$caret\\}/, bookmarkHtml);\n    rng = selection.getRng();\n    const caretElement = rng.startContainer || (rng.parentElement ? rng.parentElement() : null);\n    const body = editor.getBody();\n\n    if (caretElement === body && selection.isCollapsed()) {\n      if (dom.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom.isEmpty(body.firstChild)) {\n        rng = dom.createRng();\n        rng.setStart(body.firstChild, 0);\n        rng.setEnd(body.firstChild, 0);\n        selection.setRng(rng);\n      }\n    }\n\n    if (!selection.isCollapsed()) {\n      deleteSelectedContent(editor);\n    }\n\n    parentNode = selection.getNode();\n    const parserArgs = {\n      context: parentNode.nodeName.toLowerCase(),\n      data: details.data,\n      insert: true\n    };\n    const fragment = parser.parse(value, parserArgs);\n\n    if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom, parentNode)) {\n      rng = insertAtCaret$1(serializer, dom, selection.getRng(), fragment);\n      selection.setRng(rng);\n      return value;\n    }\n\n    markFragmentElements(fragment);\n    node = fragment.lastChild;\n\n    if (node.attr('id') === 'mce_marker') {\n      const marker = node;\n\n      for (node = node.prev; node; node = node.walk(true)) {\n        if (node.type === 3 || !dom.isBlock(node.name)) {\n          if (editor.schema.isValidChild(node.parent.name, 'span')) {\n            node.parent.insert(marker, node, node.name === 'br');\n          }\n\n          break;\n        }\n      }\n    }\n\n    editor._selectionOverrides.showBlockCaretContainer(parentNode);\n\n    if (!parserArgs.invalid) {\n      value = serializer.serialize(fragment);\n      validInsertion(editor, value, parentNode);\n    } else {\n      editor.selection.setContent(bookmarkHtml);\n      parentNode = selection.getNode();\n      const rootNode = editor.getBody();\n\n      if (parentNode.nodeType === 9) {\n        parentNode = node = rootNode;\n      } else {\n        node = parentNode;\n      }\n\n      while (node !== rootNode) {\n        parentNode = node;\n        node = node.parentNode;\n      }\n\n      value = parentNode === rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);\n      const root = parser.parse(value);\n\n      for (let markerNode = root; markerNode; markerNode = markerNode.walk()) {\n        if (markerNode.attr('id') === 'mce_marker') {\n          markerNode.replace(fragment);\n          break;\n        }\n      }\n\n      const toExtract = fragment.children();\n      const parent = fragment.parent.name;\n      fragment.unwrap();\n      const invalidChildren = filter$6(toExtract, node => !editor.schema.isValidChild(parent, node.name));\n      cleanInvalidNodes(invalidChildren, editor.schema);\n      filter$3(parser.getNodeFilters(), parser.getAttributeFilters(), root);\n      value = serializer.serialize(root);\n\n      if (parentNode === rootNode) {\n        dom.setHTML(rootNode, value);\n      } else {\n        dom.setOuterHTML(parentNode, value);\n      }\n    }\n\n    reduceInlineTextElements(editor, merge);\n    moveSelectionToMarker(editor, dom.get('mce_marker'));\n    unmarkFragmentElements(editor.getBody());\n    trimBrsFromTableCell(dom, selection.getStart());\n    return value;\n  };\n\n  const isTreeNode = content => content instanceof AstNode;\n\n  const moveSelection = editor => {\n    if (hasFocus(editor)) {\n      firstPositionIn(editor.getBody()).each(pos => {\n        const node = pos.getNode();\n        const caretPos = isTable$3(node) ? firstPositionIn(node).getOr(pos) : pos;\n        editor.selection.setRng(caretPos.toRange());\n      });\n    }\n  };\n\n  const setEditorHtml = (editor, html, noSelection) => {\n    editor.dom.setHTML(editor.getBody(), html);\n\n    if (noSelection !== true) {\n      moveSelection(editor);\n    }\n  };\n\n  const setContentString = (editor, body, content, args) => {\n    if (content.length === 0 || /^\\s+$/.test(content)) {\n      const padd = '<br data-mce-bogus=\"1\">';\n\n      if (body.nodeName === 'TABLE') {\n        content = '<tr><td>' + padd + '</td></tr>';\n      } else if (/^(UL|OL)$/.test(body.nodeName)) {\n        content = '<li>' + padd + '</li>';\n      }\n\n      const forcedRootBlockName = getForcedRootBlock(editor);\n\n      if (editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {\n        content = padd;\n        content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);\n      } else if (!content) {\n        content = padd;\n      }\n\n      setEditorHtml(editor, content, args.no_selection);\n      return {\n        content,\n        html: content\n      };\n    } else {\n      if (args.format !== 'raw') {\n        content = HtmlSerializer({\n          validate: false\n        }, editor.schema).serialize(editor.parser.parse(content, {\n          isRootContent: true,\n          insert: true\n        }));\n      }\n\n      const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);\n      setEditorHtml(editor, trimmedHtml, args.no_selection);\n      return {\n        content: trimmedHtml,\n        html: trimmedHtml\n      };\n    }\n  };\n\n  const setContentTree = (editor, body, content, args) => {\n    filter$3(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);\n    const html = HtmlSerializer({\n      validate: false\n    }, editor.schema).serialize(content);\n    const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? html : Tools.trim(html);\n    setEditorHtml(editor, trimmedHtml, args.no_selection);\n    return {\n      content,\n      html: trimmedHtml\n    };\n  };\n\n  const setContentInternal = (editor, content, args) => {\n    return Optional.from(editor.getBody()).map(body => {\n      if (isTreeNode(content)) {\n        return setContentTree(editor, body, content, args);\n      } else {\n        return setContentString(editor, body, content, args);\n      }\n    }).getOr({\n      content,\n      html: isTreeNode(args.content) ? '' : args.content\n    });\n  };\n\n  const sibling = (scope, predicate) => sibling$1(scope, predicate).isSome();\n\n  const ensureIsRoot = isRoot => isFunction(isRoot) ? isRoot : never;\n\n  const ancestor = (scope, transform, isRoot) => {\n    let element = scope.dom;\n    const stop = ensureIsRoot(isRoot);\n\n    while (element.parentNode) {\n      element = element.parentNode;\n      const el = SugarElement.fromDom(element);\n      const transformed = transform(el);\n\n      if (transformed.isSome()) {\n        return transformed;\n      } else if (stop(el)) {\n        break;\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const closest$2 = (scope, transform, isRoot) => {\n    const current = transform(scope);\n    const stop = ensureIsRoot(isRoot);\n    return current.orThunk(() => stop(scope) ? Optional.none() : ancestor(scope, transform, stop));\n  };\n\n  const isEq$3 = isEq$5;\n\n  const matchesUnInheritedFormatSelector = (ed, node, name) => {\n    const formatList = ed.formatter.get(name);\n\n    if (formatList) {\n      for (let i = 0; i < formatList.length; i++) {\n        const format = formatList[i];\n\n        if (isSelectorFormat(format) && format.inherit === false && ed.dom.is(node, format.selector)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  const matchParents = (editor, node, name, vars, similar) => {\n    const root = editor.dom.getRoot();\n\n    if (node === root) {\n      return false;\n    }\n\n    node = editor.dom.getParent(node, node => {\n      if (matchesUnInheritedFormatSelector(editor, node, name)) {\n        return true;\n      }\n\n      return node.parentNode === root || !!matchNode(editor, node, name, vars, true);\n    });\n    return !!matchNode(editor, node, name, vars, similar);\n  };\n\n  const matchName = (dom, node, format) => {\n    if (isInlineFormat(format) && isEq$3(node, format.inline)) {\n      return true;\n    }\n\n    if (isBlockFormat(format) && isEq$3(node, format.block)) {\n      return true;\n    }\n\n    if (isSelectorFormat(format)) {\n      return isElement$6(node) && dom.is(node, format.selector);\n    }\n\n    return false;\n  };\n\n  const matchItems = (dom, node, format, itemName, similar, vars) => {\n    const items = format[itemName];\n\n    if (isFunction(format.onmatch)) {\n      return format.onmatch(node, format, itemName);\n    }\n\n    if (items) {\n      if (isUndefined(items.length)) {\n        for (const key in items) {\n          if (has$2(items, key)) {\n            const value = itemName === 'attributes' ? dom.getAttrib(node, key) : getStyle(dom, node, key);\n            const expectedValue = replaceVars(items[key], vars);\n            const isEmptyValue = isNullable(value) || isEmpty$3(value);\n\n            if (isEmptyValue && isNullable(expectedValue)) {\n              continue;\n            }\n\n            if (similar && isEmptyValue && !format.exact) {\n              return false;\n            }\n\n            if ((!similar || format.exact) && !isEq$3(value, normalizeStyleValue(expectedValue, key))) {\n              return false;\n            }\n          }\n        }\n      } else {\n        for (let i = 0; i < items.length; i++) {\n          if (itemName === 'attributes' ? dom.getAttrib(node, items[i]) : getStyle(dom, node, items[i])) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  const matchNode = (ed, node, name, vars, similar) => {\n    const formatList = ed.formatter.get(name);\n    const dom = ed.dom;\n\n    if (formatList && node) {\n      for (let i = 0; i < formatList.length; i++) {\n        const format = formatList[i];\n\n        if (matchName(ed.dom, node, format) && matchItems(dom, node, format, 'attributes', similar, vars) && matchItems(dom, node, format, 'styles', similar, vars)) {\n          const classes = format.classes;\n\n          if (classes) {\n            for (let x = 0; x < classes.length; x++) {\n              if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) {\n                return;\n              }\n            }\n          }\n\n          return format;\n        }\n      }\n    }\n  };\n\n  const match$2 = (editor, name, vars, node, similar) => {\n    if (node) {\n      return matchParents(editor, node, name, vars, similar);\n    }\n\n    node = editor.selection.getNode();\n\n    if (matchParents(editor, node, name, vars, similar)) {\n      return true;\n    }\n\n    const startNode = editor.selection.getStart();\n\n    if (startNode !== node) {\n      if (matchParents(editor, startNode, name, vars, similar)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  const matchAll = (editor, names, vars) => {\n    const matchedFormatNames = [];\n    const checkedMap = {};\n    const startElement = editor.selection.getStart();\n    editor.dom.getParent(startElement, node => {\n      for (let i = 0; i < names.length; i++) {\n        const name = names[i];\n\n        if (!checkedMap[name] && matchNode(editor, node, name, vars)) {\n          checkedMap[name] = true;\n          matchedFormatNames.push(name);\n        }\n      }\n    }, editor.dom.getRoot());\n    return matchedFormatNames;\n  };\n\n  const closest$1 = (editor, names) => {\n    const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\n\n    const match = (elm, name) => matchNode(editor, elm.dom, name) ? Optional.some(name) : Optional.none();\n\n    return Optional.from(editor.selection.getStart(true)).bind(rawElm => closest$2(SugarElement.fromDom(rawElm), elm => findMap(names, name => match(elm, name)), isRoot)).getOrNull();\n  };\n\n  const canApply = (editor, name) => {\n    const formatList = editor.formatter.get(name);\n    const dom = editor.dom;\n\n    if (formatList) {\n      const startNode = editor.selection.getStart();\n      const parents = getParents$2(dom, startNode);\n\n      for (let x = formatList.length - 1; x >= 0; x--) {\n        const format = formatList[x];\n\n        if (!isSelectorFormat(format)) {\n          return true;\n        }\n\n        for (let i = parents.length - 1; i >= 0; i--) {\n          if (dom.is(parents[i], format.selector)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n\n  const matchAllOnNode = (editor, node, formatNames) => foldl(formatNames, (acc, name) => {\n    const matchSimilar = isVariableFormatName(editor, name);\n\n    if (editor.formatter.matchNode(node, name, {}, matchSimilar)) {\n      return acc.concat([name]);\n    } else {\n      return acc;\n    }\n  }, []);\n\n  const ZWSP = ZWSP$1,\n        CARET_ID = '_mce_caret';\n\n  const importNode = (ownerDocument, node) => {\n    return ownerDocument.importNode(node, true);\n  };\n\n  const getEmptyCaretContainers = node => {\n    const nodes = [];\n\n    while (node) {\n      if (node.nodeType === 3 && node.nodeValue !== ZWSP || node.childNodes.length > 1) {\n        return [];\n      }\n\n      if (node.nodeType === 1) {\n        nodes.push(node);\n      }\n\n      node = node.firstChild;\n    }\n\n    return nodes;\n  };\n\n  const isCaretContainerEmpty = node => {\n    return getEmptyCaretContainers(node).length > 0;\n  };\n\n  const findFirstTextNode = node => {\n    if (node) {\n      const walker = new DomTreeWalker(node, node);\n\n      for (node = walker.current(); node; node = walker.next()) {\n        if (isText$8(node)) {\n          return node;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  const createCaretContainer = fill => {\n    const caretContainer = SugarElement.fromTag('span');\n    setAll$1(caretContainer, {\n      'id': CARET_ID,\n      'data-mce-bogus': '1',\n      'data-mce-type': 'format-caret'\n    });\n\n    if (fill) {\n      append$1(caretContainer, SugarElement.fromText(ZWSP));\n    }\n\n    return caretContainer;\n  };\n\n  const trimZwspFromCaretContainer = caretContainerNode => {\n    const textNode = findFirstTextNode(caretContainerNode);\n\n    if (textNode && textNode.nodeValue.charAt(0) === ZWSP) {\n      textNode.deleteData(0, 1);\n    }\n\n    return textNode;\n  };\n\n  const removeCaretContainerNode = function (editor, node) {\n    let moveCaret = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const dom = editor.dom,\n          selection = editor.selection;\n\n    if (isCaretContainerEmpty(node)) {\n      deleteElement$2(editor, false, SugarElement.fromDom(node), moveCaret);\n    } else {\n      const rng = selection.getRng();\n      const block = dom.getParent(node, dom.isBlock);\n      const startContainer = rng.startContainer;\n      const startOffset = rng.startOffset;\n      const endContainer = rng.endContainer;\n      const endOffset = rng.endOffset;\n      const textNode = trimZwspFromCaretContainer(node);\n      dom.remove(node, true);\n\n      if (startContainer === textNode && startOffset > 0) {\n        rng.setStart(textNode, startOffset - 1);\n      }\n\n      if (endContainer === textNode && endOffset > 0) {\n        rng.setEnd(textNode, endOffset - 1);\n      }\n\n      if (block && dom.isEmpty(block)) {\n        fillWithPaddingBr(SugarElement.fromDom(block));\n      }\n\n      selection.setRng(rng);\n    }\n  };\n\n  const removeCaretContainer = function (editor, node) {\n    let moveCaret = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const dom = editor.dom,\n          selection = editor.selection;\n\n    if (!node) {\n      node = getParentCaretContainer(editor.getBody(), selection.getStart());\n\n      if (!node) {\n        while (node = dom.get(CARET_ID)) {\n          removeCaretContainerNode(editor, node, false);\n        }\n      }\n    } else {\n      removeCaretContainerNode(editor, node, moveCaret);\n    }\n  };\n\n  const insertCaretContainerNode = (editor, caretContainer, formatNode) => {\n    const dom = editor.dom,\n          block = dom.getParent(formatNode, curry(isTextBlock$1, editor));\n\n    if (block && dom.isEmpty(block)) {\n      formatNode.parentNode.replaceChild(caretContainer, formatNode);\n    } else {\n      removeTrailingBr(SugarElement.fromDom(formatNode));\n\n      if (dom.isEmpty(formatNode)) {\n        formatNode.parentNode.replaceChild(caretContainer, formatNode);\n      } else {\n        dom.insertAfter(caretContainer, formatNode);\n      }\n    }\n  };\n\n  const appendNode = (parentNode, node) => {\n    parentNode.appendChild(node);\n    return node;\n  };\n\n  const insertFormatNodesIntoCaretContainer = (formatNodes, caretContainer) => {\n    const innerMostFormatNode = foldr(formatNodes, (parentNode, formatNode) => {\n      return appendNode(parentNode, formatNode.cloneNode(false));\n    }, caretContainer);\n    return appendNode(innerMostFormatNode, innerMostFormatNode.ownerDocument.createTextNode(ZWSP));\n  };\n\n  const cleanFormatNode = (editor, caretContainer, formatNode, name, vars, similar) => {\n    const formatter = editor.formatter;\n    const dom = editor.dom;\n    const validFormats = filter$6(keys(formatter.get()), formatName => formatName !== name && !contains$1(formatName, 'removeformat'));\n    const matchedFormats = matchAllOnNode(editor, formatNode, validFormats);\n    const uniqueFormats = filter$6(matchedFormats, fmtName => !areSimilarFormats(editor, fmtName, name));\n\n    if (uniqueFormats.length > 0) {\n      const clonedFormatNode = formatNode.cloneNode(false);\n      dom.add(caretContainer, clonedFormatNode);\n      formatter.remove(name, vars, clonedFormatNode, similar);\n      dom.remove(clonedFormatNode);\n      return Optional.some(clonedFormatNode);\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const applyCaretFormat = (editor, name, vars) => {\n    let caretContainer, textNode;\n    const selection = editor.selection;\n    const selectionRng = selection.getRng();\n    let offset = selectionRng.startOffset;\n    const container = selectionRng.startContainer;\n    const text = container.nodeValue;\n    caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());\n\n    if (caretContainer) {\n      textNode = findFirstTextNode(caretContainer);\n    }\n\n    const wordcharRegex = /[^\\s\\u00a0\\u00ad\\u200b\\ufeff]/;\n\n    if (text && offset > 0 && offset < text.length && wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {\n      const bookmark = selection.getBookmark();\n      selectionRng.collapse(true);\n      let rng = expandRng(editor, selectionRng, editor.formatter.get(name));\n      rng = split(rng);\n      editor.formatter.apply(name, vars, rng);\n      selection.moveToBookmark(bookmark);\n    } else {\n      if (!caretContainer || textNode.nodeValue !== ZWSP) {\n        caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);\n        textNode = caretContainer.firstChild;\n        selectionRng.insertNode(caretContainer);\n        offset = 1;\n        editor.formatter.apply(name, vars, caretContainer);\n      } else {\n        editor.formatter.apply(name, vars, caretContainer);\n      }\n\n      selection.setCursorLocation(textNode, offset);\n    }\n  };\n\n  const removeCaretFormat = (editor, name, vars, similar) => {\n    const dom = editor.dom;\n    const selection = editor.selection;\n    let hasContentAfter, node, formatNode;\n    const parents = [];\n    const rng = selection.getRng();\n    const container = rng.startContainer;\n    const offset = rng.startOffset;\n    node = container;\n\n    if (container.nodeType === 3) {\n      if (offset !== container.nodeValue.length) {\n        hasContentAfter = true;\n      }\n\n      node = node.parentNode;\n    }\n\n    while (node) {\n      if (matchNode(editor, node, name, vars, similar)) {\n        formatNode = node;\n        break;\n      }\n\n      if (node.nextSibling) {\n        hasContentAfter = true;\n      }\n\n      parents.push(node);\n      node = node.parentNode;\n    }\n\n    if (!formatNode) {\n      return;\n    }\n\n    if (hasContentAfter) {\n      const bookmark = selection.getBookmark();\n      rng.collapse(true);\n      let expandedRng = expandRng(editor, rng, editor.formatter.get(name), true);\n      expandedRng = split(expandedRng);\n      editor.formatter.remove(name, vars, expandedRng, similar);\n      selection.moveToBookmark(bookmark);\n    } else {\n      const caretContainer = getParentCaretContainer(editor.getBody(), formatNode);\n      const newCaretContainer = createCaretContainer(false).dom;\n      insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null ? caretContainer : formatNode);\n      const cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name, vars, similar);\n      const caretTextNode = insertFormatNodesIntoCaretContainer(parents.concat(cleanedFormatNode.toArray()), newCaretContainer);\n      removeCaretContainerNode(editor, caretContainer, false);\n      selection.setCursorLocation(caretTextNode, 1);\n\n      if (dom.isEmpty(formatNode)) {\n        dom.remove(formatNode);\n      }\n    }\n  };\n\n  const disableCaretContainer = (editor, keyCode) => {\n    const selection = editor.selection,\n          body = editor.getBody();\n    removeCaretContainer(editor, null, false);\n\n    if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP) {\n      removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));\n    }\n\n    if (keyCode === 37 || keyCode === 39) {\n      removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));\n    }\n  };\n\n  const setup$u = editor => {\n    editor.on('mouseup keydown', e => {\n      disableCaretContainer(editor, e.keyCode);\n    });\n  };\n\n  const replaceWithCaretFormat = (targetNode, formatNodes) => {\n    const caretContainer = createCaretContainer(false);\n    const innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);\n    before$3(SugarElement.fromDom(targetNode), caretContainer);\n    remove$5(SugarElement.fromDom(targetNode));\n    return CaretPosition(innerMost, 0);\n  };\n\n  const isFormatElement = (editor, element) => {\n    const inlineElements = editor.schema.getTextInlineElements();\n    return has$2(inlineElements, name(element)) && !isCaretNode(element.dom) && !isBogus$2(element.dom);\n  };\n\n  const isEmptyCaretFormatElement = element => {\n    return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);\n  };\n\n  const postProcessHooks = {};\n  const filter$2 = filter$4;\n  const each$a = each$e;\n\n  const addPostProcessHook = (name, hook) => {\n    const hooks = postProcessHooks[name];\n\n    if (!hooks) {\n      postProcessHooks[name] = [];\n    }\n\n    postProcessHooks[name].push(hook);\n  };\n\n  const postProcess$1 = (name, editor) => {\n    each$a(postProcessHooks[name], hook => {\n      hook(editor);\n    });\n  };\n\n  addPostProcessHook('pre', editor => {\n    const rng = editor.selection.getRng();\n    let blocks;\n\n    const hasPreSibling = pre => {\n      return isPre(pre.previousSibling) && indexOf(blocks, pre.previousSibling) !== -1;\n    };\n\n    const joinPre = (pre1, pre2) => {\n      const sPre2 = SugarElement.fromDom(pre2);\n      const doc = documentOrOwner(sPre2).dom;\n      remove$5(sPre2);\n      append(SugarElement.fromDom(pre1), [SugarElement.fromTag('br', doc), SugarElement.fromTag('br', doc), ...children(sPre2)]);\n    };\n\n    const isPre = matchNodeNames(['pre']);\n\n    if (!rng.collapsed) {\n      blocks = editor.selection.getSelectedBlocks();\n      each$a(filter$2(filter$2(blocks, isPre), hasPreSibling), pre => {\n        joinPre(pre.previousSibling, pre);\n      });\n    }\n  });\n  const each$9 = Tools.each;\n\n  const isElementNode$1 = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);\n\n  const findElementSibling = (node, siblingName) => {\n    for (let sibling = node; sibling; sibling = sibling[siblingName]) {\n      if (isText$8(sibling) && isNotEmpty(sibling.data)) {\n        return node;\n      }\n\n      if (isElement$6(sibling) && !isBookmarkNode$1(sibling)) {\n        return sibling;\n      }\n    }\n\n    return node;\n  };\n\n  const mergeSiblingsNodes = (dom, prev, next) => {\n    const elementUtils = ElementUtils(dom);\n\n    if (prev && next) {\n      prev = findElementSibling(prev, 'previousSibling');\n      next = findElementSibling(next, 'nextSibling');\n\n      if (elementUtils.compare(prev, next)) {\n        for (let sibling = prev.nextSibling; sibling && sibling !== next;) {\n          const tmpSibling = sibling;\n          sibling = sibling.nextSibling;\n          prev.appendChild(tmpSibling);\n        }\n\n        dom.remove(next);\n        Tools.each(Tools.grep(next.childNodes), node => {\n          prev.appendChild(node);\n        });\n        return prev;\n      }\n    }\n\n    return next;\n  };\n\n  const mergeSiblings = (dom, format, vars, node) => {\n    if (node && format.merge_siblings !== false) {\n      const newNode = mergeSiblingsNodes(dom, getNonWhiteSpaceSibling(node), node);\n      mergeSiblingsNodes(dom, newNode, getNonWhiteSpaceSibling(newNode, true));\n    }\n  };\n\n  const clearChildStyles = (dom, format, node) => {\n    if (format.clear_child_styles) {\n      const selector = format.links ? '*:not(a)' : '*';\n      each$9(dom.select(selector, node), node => {\n        if (isElementNode$1(node)) {\n          each$9(format.styles, (value, name) => {\n            dom.setStyle(node, name, '');\n          });\n        }\n      });\n    }\n  };\n\n  const processChildElements = (node, filter, process) => {\n    each$9(node.childNodes, node => {\n      if (isElementNode$1(node)) {\n        if (filter(node)) {\n          process(node);\n        }\n\n        if (node.hasChildNodes()) {\n          processChildElements(node, filter, process);\n        }\n      }\n    });\n  };\n\n  const unwrapEmptySpan = (dom, node) => {\n    if (node.nodeName === 'SPAN' && dom.getAttribs(node).length === 0) {\n      dom.remove(node, true);\n    }\n  };\n\n  const hasStyle = (dom, name) => node => !!(node && getStyle(dom, node, name));\n\n  const applyStyle = (dom, name, value) => node => {\n    dom.setStyle(node, name, value);\n\n    if (node.getAttribute('style') === '') {\n      node.removeAttribute('style');\n    }\n\n    unwrapEmptySpan(dom, node);\n  };\n\n  const removeResult = Adt.generate([{\n    keep: []\n  }, {\n    rename: ['name']\n  }, {\n    removed: []\n  }]);\n  const MCE_ATTR_RE = /^(src|href|style)$/;\n  const each$8 = Tools.each;\n  const isEq$2 = isEq$5;\n\n  const isTableCellOrRow = node => /^(TR|TH|TD)$/.test(node.nodeName);\n\n  const isChildOfInlineParent = (dom, node, parent) => dom.isChildOf(node, parent) && node !== parent && !dom.isBlock(parent);\n\n  const getContainer = (ed, rng, start) => {\n    let container = rng[start ? 'startContainer' : 'endContainer'];\n    let offset = rng[start ? 'startOffset' : 'endOffset'];\n\n    if (isElement$6(container)) {\n      const lastIdx = container.childNodes.length - 1;\n\n      if (!start && offset) {\n        offset--;\n      }\n\n      container = container.childNodes[offset > lastIdx ? lastIdx : offset];\n    }\n\n    if (isText$8(container) && start && offset >= container.nodeValue.length) {\n      container = new DomTreeWalker(container, ed.getBody()).next() || container;\n    }\n\n    if (isText$8(container) && !start && offset === 0) {\n      container = new DomTreeWalker(container, ed.getBody()).prev() || container;\n    }\n\n    return container;\n  };\n\n  const normalizeTableSelection = (node, start) => {\n    const prop = start ? 'firstChild' : 'lastChild';\n\n    if (isTableCellOrRow(node) && node[prop]) {\n      const childNode = node[prop];\n\n      if (node.nodeName === 'TR') {\n        return childNode[prop] || childNode;\n      } else {\n        return childNode;\n      }\n    }\n\n    return node;\n  };\n\n  const wrap$1 = (dom, node, name, attrs) => {\n    const wrapper = dom.create(name, attrs);\n    node.parentNode.insertBefore(wrapper, node);\n    wrapper.appendChild(node);\n    return wrapper;\n  };\n\n  const wrapWithSiblings = (dom, node, next, name, attrs) => {\n    const start = SugarElement.fromDom(node);\n    const wrapper = SugarElement.fromDom(dom.create(name, attrs));\n    const siblings = next ? nextSiblings(start) : prevSiblings(start);\n    append(wrapper, siblings);\n\n    if (next) {\n      before$3(start, wrapper);\n      prepend(wrapper, start);\n    } else {\n      after$4(start, wrapper);\n      append$1(wrapper, start);\n    }\n\n    return wrapper.dom;\n  };\n\n  const isColorFormatAndAnchor = (node, format) => format.links && node.nodeName === 'A';\n\n  const removeNode = (ed, node, format) => {\n    const parentNode = node.parentNode;\n    let rootBlockElm;\n    const dom = ed.dom;\n    const forcedRootBlock = getForcedRootBlock(ed);\n\n    if (isBlockFormat(format)) {\n      if (parentNode === dom.getRoot()) {\n        if (!format.list_block || !isEq$2(node, format.list_block)) {\n          each$g(from(node.childNodes), node => {\n            if (isValid(ed, forcedRootBlock, node.nodeName.toLowerCase())) {\n              if (!rootBlockElm) {\n                rootBlockElm = wrap$1(dom, node, forcedRootBlock);\n                dom.setAttribs(rootBlockElm, getForcedRootBlockAttrs(ed));\n              } else {\n                rootBlockElm.appendChild(node);\n              }\n            } else {\n              rootBlockElm = null;\n            }\n          });\n        }\n      }\n    }\n\n    if (isMixedFormat(format) && !isEq$2(format.inline, node)) {\n      return;\n    }\n\n    dom.remove(node, true);\n  };\n\n  const removeFormatInternal = (ed, format, vars, node, compareNode) => {\n    let stylesModified;\n    const dom = ed.dom;\n\n    if (!matchName(dom, node, format) && !isColorFormatAndAnchor(node, format)) {\n      return removeResult.keep();\n    }\n\n    const elm = node;\n\n    if (isInlineFormat(format) && format.remove === 'all' && isArray$1(format.preserve_attributes)) {\n      const attrsToPreserve = filter$6(dom.getAttribs(elm), attr => contains$2(format.preserve_attributes, attr.name.toLowerCase()));\n      dom.removeAllAttribs(elm);\n      each$g(attrsToPreserve, attr => dom.setAttrib(elm, attr.name, attr.value));\n\n      if (attrsToPreserve.length > 0) {\n        return removeResult.rename('span');\n      }\n    }\n\n    if (format.remove !== 'all') {\n      each$8(format.styles, (value, name) => {\n        value = normalizeStyleValue(replaceVars(value, vars), name + '');\n\n        if (isNumber(name)) {\n          name = value;\n          compareNode = null;\n        }\n\n        if (format.remove_similar || !compareNode || isEq$2(getStyle(dom, compareNode, name), value)) {\n          dom.setStyle(elm, name, '');\n        }\n\n        stylesModified = true;\n      });\n\n      if (stylesModified && dom.getAttrib(elm, 'style') === '') {\n        elm.removeAttribute('style');\n        elm.removeAttribute('data-mce-style');\n      }\n\n      each$8(format.attributes, (value, name) => {\n        let valueOut;\n        value = replaceVars(value, vars);\n\n        if (isNumber(name)) {\n          name = value;\n          compareNode = null;\n        }\n\n        if (format.remove_similar || !compareNode || isEq$2(dom.getAttrib(compareNode, name), value)) {\n          if (name === 'class') {\n            value = dom.getAttrib(elm, name);\n\n            if (value) {\n              valueOut = '';\n              each$g(value.split(/\\s+/), cls => {\n                if (/mce\\-\\w+/.test(cls)) {\n                  valueOut += (valueOut ? ' ' : '') + cls;\n                }\n              });\n\n              if (valueOut) {\n                dom.setAttrib(elm, name, valueOut);\n                return;\n              }\n            }\n          }\n\n          if (MCE_ATTR_RE.test(name)) {\n            elm.removeAttribute('data-mce-' + name);\n          }\n\n          if (name === 'style' && matchNodeNames(['li'])(elm) && dom.getStyle(elm, 'list-style-type') === 'none') {\n            elm.removeAttribute(name);\n            dom.setStyle(elm, 'list-style-type', 'none');\n            return;\n          }\n\n          if (name === 'class') {\n            elm.removeAttribute('className');\n          }\n\n          elm.removeAttribute(name);\n        }\n      });\n      each$8(format.classes, value => {\n        value = replaceVars(value, vars);\n\n        if (!compareNode || dom.hasClass(compareNode, value)) {\n          dom.removeClass(elm, value);\n        }\n      });\n      const attrs = dom.getAttribs(elm);\n\n      for (let i = 0; i < attrs.length; i++) {\n        const attrName = attrs[i].nodeName;\n\n        if (attrName.indexOf('_') !== 0 && attrName.indexOf('data-') !== 0) {\n          return removeResult.keep();\n        }\n      }\n    }\n\n    if (format.remove !== 'none') {\n      removeNode(ed, elm, format);\n      return removeResult.removed();\n    }\n\n    return removeResult.keep();\n  };\n\n  const removeFormat$1 = (ed, format, vars, node, compareNode) => removeFormatInternal(ed, format, vars, node, compareNode).fold(never, newName => {\n    ed.dom.rename(node, newName);\n    return true;\n  }, always);\n\n  const findFormatRoot = (editor, container, name, vars, similar) => {\n    let formatRoot;\n    each$g(getParents$2(editor.dom, container.parentNode).reverse(), parent => {\n      if (!formatRoot && parent.id !== '_start' && parent.id !== '_end') {\n        const format = matchNode(editor, parent, name, vars, similar);\n\n        if (format && format.split !== false) {\n          formatRoot = parent;\n        }\n      }\n    });\n    return formatRoot;\n  };\n\n  const removeFormatFromClone = (editor, format, vars, clone) => removeFormatInternal(editor, format, vars, clone, clone).fold(constant(clone), newName => {\n    const fragment = editor.dom.createFragment();\n    fragment.appendChild(clone);\n    return editor.dom.rename(clone, newName);\n  }, constant(null));\n\n  const wrapAndSplit = (editor, formatList, formatRoot, container, target, split, format, vars) => {\n    let clone, lastClone, firstClone;\n    const dom = editor.dom;\n\n    if (formatRoot) {\n      const formatRootParent = formatRoot.parentNode;\n\n      for (let parent = container.parentNode; parent && parent !== formatRootParent; parent = parent.parentNode) {\n        clone = dom.clone(parent, false);\n\n        for (let i = 0; i < formatList.length; i++) {\n          clone = removeFormatFromClone(editor, formatList[i], vars, clone);\n\n          if (clone === null) {\n            break;\n          }\n        }\n\n        if (clone) {\n          if (lastClone) {\n            clone.appendChild(lastClone);\n          }\n\n          if (!firstClone) {\n            firstClone = clone;\n          }\n\n          lastClone = clone;\n        }\n      }\n\n      if (split && (!format.mixed || !dom.isBlock(formatRoot))) {\n        container = dom.split(formatRoot, container);\n      }\n\n      if (lastClone) {\n        target.parentNode.insertBefore(lastClone, target);\n        firstClone.appendChild(target);\n\n        if (isInlineFormat(format)) {\n          mergeSiblings(dom, format, vars, lastClone);\n        }\n      }\n    }\n\n    return container;\n  };\n\n  const remove$2 = (ed, name, vars, node, similar) => {\n    const formatList = ed.formatter.get(name);\n    const format = formatList[0];\n    let contentEditable = true;\n    const dom = ed.dom;\n    const selection = ed.selection;\n\n    const splitToFormatRoot = container => {\n      const formatRoot = findFormatRoot(ed, container, name, vars, similar);\n      return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);\n    };\n\n    const isRemoveBookmarkNode = node => isBookmarkNode$1(node) && isElement$6(node) && (node.id === '_start' || node.id === '_end');\n\n    const removeNodeFormat = node => exists(formatList, fmt => removeFormat$1(ed, fmt, vars, node, node));\n\n    const process = node => {\n      let lastContentEditable = true;\n      let hasContentEditableState = false;\n\n      if (isElement$6(node) && dom.getContentEditable(node)) {\n        lastContentEditable = contentEditable;\n        contentEditable = dom.getContentEditable(node) === 'true';\n        hasContentEditableState = true;\n      }\n\n      const children = from(node.childNodes);\n\n      if (contentEditable && !hasContentEditableState) {\n        const removed = removeNodeFormat(node);\n        const currentNodeMatches = removed || exists(formatList, f => matchName(dom, node, f));\n        const parentNode = node.parentNode;\n\n        if (!currentNodeMatches && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\n          removeNodeFormat(parentNode);\n        }\n      }\n\n      if (format.deep) {\n        if (children.length) {\n          for (let i = 0; i < children.length; i++) {\n            process(children[i]);\n          }\n\n          if (hasContentEditableState) {\n            contentEditable = lastContentEditable;\n          }\n        }\n      }\n\n      const textDecorations = ['underline', 'line-through', 'overline'];\n      each$g(textDecorations, decoration => {\n        if (isElement$6(node) && ed.dom.getStyle(node, 'text-decoration') === decoration && node.parentNode && getTextDecoration(dom, node.parentNode) === decoration) {\n          removeFormat$1(ed, {\n            deep: false,\n            exact: true,\n            inline: 'span',\n            styles: {\n              textDecoration: decoration\n            }\n          }, null, node);\n        }\n      });\n    };\n\n    const unwrap = start => {\n      const node = dom.get(start ? '_start' : '_end');\n      let out = node[start ? 'firstChild' : 'lastChild'];\n\n      if (isRemoveBookmarkNode(out)) {\n        out = out[start ? 'firstChild' : 'lastChild'];\n      }\n\n      if (isText$8(out) && out.data.length === 0) {\n        out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;\n      }\n\n      dom.remove(node, true);\n      return out;\n    };\n\n    const removeRngStyle = rng => {\n      let startContainer, endContainer;\n      let expandedRng = expandRng(ed, rng, formatList, rng.collapsed);\n\n      if (format.split) {\n        expandedRng = split(expandedRng);\n        startContainer = getContainer(ed, expandedRng, true);\n        endContainer = getContainer(ed, expandedRng);\n\n        if (startContainer !== endContainer) {\n          startContainer = normalizeTableSelection(startContainer, true);\n          endContainer = normalizeTableSelection(endContainer, false);\n\n          if (isChildOfInlineParent(dom, startContainer, endContainer)) {\n            const marker = Optional.from(startContainer.firstChild).getOr(startContainer);\n            splitToFormatRoot(wrapWithSiblings(dom, marker, true, 'span', {\n              'id': '_start',\n              'data-mce-type': 'bookmark'\n            }));\n            unwrap(true);\n            return;\n          }\n\n          if (isChildOfInlineParent(dom, endContainer, startContainer)) {\n            const marker = Optional.from(endContainer.lastChild).getOr(endContainer);\n            splitToFormatRoot(wrapWithSiblings(dom, marker, false, 'span', {\n              'id': '_end',\n              'data-mce-type': 'bookmark'\n            }));\n            unwrap(false);\n            return;\n          }\n\n          startContainer = wrap$1(dom, startContainer, 'span', {\n            'id': '_start',\n            'data-mce-type': 'bookmark'\n          });\n          endContainer = wrap$1(dom, endContainer, 'span', {\n            'id': '_end',\n            'data-mce-type': 'bookmark'\n          });\n          const newRng = dom.createRng();\n          newRng.setStartAfter(startContainer);\n          newRng.setEndBefore(endContainer);\n          walk$3(dom, newRng, nodes => {\n            each$g(nodes, n => {\n              if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) {\n                splitToFormatRoot(n);\n              }\n            });\n          });\n          splitToFormatRoot(startContainer);\n          splitToFormatRoot(endContainer);\n          startContainer = unwrap(true);\n          endContainer = unwrap();\n        } else {\n          startContainer = endContainer = splitToFormatRoot(startContainer);\n        }\n\n        expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;\n        expandedRng.startOffset = dom.nodeIndex(startContainer);\n        expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;\n        expandedRng.endOffset = dom.nodeIndex(endContainer) + 1;\n      }\n\n      walk$3(dom, expandedRng, nodes => {\n        each$g(nodes, process);\n      });\n    };\n\n    if (node) {\n      if (isNode(node)) {\n        const rng = dom.createRng();\n        rng.setStartBefore(node);\n        rng.setEndAfter(node);\n        removeRngStyle(rng);\n      } else {\n        removeRngStyle(node);\n      }\n\n      fireFormatRemove(ed, name, node, vars);\n      return;\n    }\n\n    if (dom.getContentEditable(selection.getNode()) === 'false') {\n      node = selection.getNode();\n\n      for (let i = 0; i < formatList.length; i++) {\n        if (formatList[i].ceFalseOverride) {\n          if (removeFormat$1(ed, formatList[i], vars, node, node)) {\n            break;\n          }\n        }\n      }\n\n      fireFormatRemove(ed, name, node, vars);\n      return;\n    }\n\n    if (!selection.isCollapsed() || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\n      preserve(selection, true, () => {\n        runOnRanges(ed, removeRngStyle);\n      });\n\n      if (isInlineFormat(format) && match$2(ed, name, vars, selection.getStart())) {\n        moveStart(dom, selection, selection.getRng());\n      }\n\n      ed.nodeChanged();\n    } else {\n      removeCaretFormat(ed, name, vars, similar);\n    }\n\n    fireFormatRemove(ed, name, node, vars);\n  };\n\n  const each$7 = Tools.each;\n\n  const mergeTextDecorationsAndColor = (dom, format, vars, node) => {\n    const processTextDecorationsAndColor = n => {\n      if (n.nodeType === 1 && n.parentNode && n.parentNode.nodeType === 1) {\n        const textDecoration = getTextDecoration(dom, n.parentNode);\n\n        if (dom.getStyle(n, 'color') && textDecoration) {\n          dom.setStyle(n, 'text-decoration', textDecoration);\n        } else if (dom.getStyle(n, 'text-decoration') === textDecoration) {\n          dom.setStyle(n, 'text-decoration', null);\n        }\n      }\n    };\n\n    if (format.styles && (format.styles.color || format.styles.textDecoration)) {\n      Tools.walk(node, processTextDecorationsAndColor, 'childNodes');\n      processTextDecorationsAndColor(node);\n    }\n  };\n\n  const mergeBackgroundColorAndFontSize = (dom, format, vars, node) => {\n    if (format.styles && format.styles.backgroundColor) {\n      processChildElements(node, hasStyle(dom, 'fontSize'), applyStyle(dom, 'backgroundColor', replaceVars(format.styles.backgroundColor, vars)));\n    }\n  };\n\n  const mergeSubSup = (dom, format, vars, node) => {\n    if (isInlineFormat(format) && (format.inline === 'sub' || format.inline === 'sup')) {\n      processChildElements(node, hasStyle(dom, 'fontSize'), applyStyle(dom, 'fontSize', ''));\n      dom.remove(dom.select(format.inline === 'sup' ? 'sub' : 'sup', node), true);\n    }\n  };\n\n  const mergeWithChildren = (editor, formatList, vars, node) => {\n    each$7(formatList, format => {\n      if (isInlineFormat(format)) {\n        each$7(editor.dom.select(format.inline, node), child => {\n          if (!isElementNode$1(child)) {\n            return;\n          }\n\n          removeFormat$1(editor, format, vars, child, format.exact ? child : null);\n        });\n      }\n\n      clearChildStyles(editor.dom, format, node);\n    });\n  };\n\n  const mergeWithParents = (editor, format, name, vars, node) => {\n    if (matchNode(editor, node.parentNode, name, vars)) {\n      if (removeFormat$1(editor, format, vars, node)) {\n        return;\n      }\n    }\n\n    if (format.merge_with_parents) {\n      editor.dom.getParent(node.parentNode, parent => {\n        if (matchNode(editor, parent, name, vars)) {\n          removeFormat$1(editor, format, vars, node);\n          return true;\n        }\n      });\n    }\n  };\n\n  const each$6 = Tools.each;\n\n  const isElementNode = node => {\n    return isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);\n  };\n\n  const canFormatBR = (editor, format, node, parentName) => {\n    if (canFormatEmptyLines(editor) && isInlineFormat(format)) {\n      const validBRParentElements = { ...editor.schema.getTextBlockElements(),\n        td: {},\n        th: {},\n        li: {},\n        dt: {},\n        dd: {},\n        figcaption: {},\n        caption: {},\n        details: {},\n        summary: {}\n      };\n      const hasCaretNodeSibling = sibling(SugarElement.fromDom(node), sibling => isCaretNode(sibling.dom));\n      return hasNonNullableKey(validBRParentElements, parentName) && isEmpty$2(SugarElement.fromDom(node.parentNode), false) && !hasCaretNodeSibling;\n    } else {\n      return false;\n    }\n  };\n\n  const applyFormat$1 = (ed, name, vars, node) => {\n    const formatList = ed.formatter.get(name);\n    const format = formatList[0];\n    const isCollapsed = !node && ed.selection.isCollapsed();\n    const dom = ed.dom;\n    const selection = ed.selection;\n\n    const setElementFormat = function (elm) {\n      let fmt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : format;\n\n      if (isFunction(fmt.onformat)) {\n        fmt.onformat(elm, fmt, vars, node);\n      }\n\n      each$6(fmt.styles, (value, name) => {\n        dom.setStyle(elm, name, replaceVars(value, vars));\n      });\n\n      if (fmt.styles) {\n        const styleVal = dom.getAttrib(elm, 'style');\n\n        if (styleVal) {\n          dom.setAttrib(elm, 'data-mce-style', styleVal);\n        }\n      }\n\n      each$6(fmt.attributes, (value, name) => {\n        dom.setAttrib(elm, name, replaceVars(value, vars));\n      });\n      each$6(fmt.classes, value => {\n        value = replaceVars(value, vars);\n\n        if (!dom.hasClass(elm, value)) {\n          dom.addClass(elm, value);\n        }\n      });\n    };\n\n    const applyNodeStyle = (formatList, node) => {\n      let found = false;\n      each$6(formatList, format => {\n        if (!isSelectorFormat(format)) {\n          return false;\n        }\n\n        if (isNonNullable(format.collapsed) && format.collapsed !== isCollapsed) {\n          return;\n        }\n\n        if (dom.is(node, format.selector) && !isCaretNode(node)) {\n          setElementFormat(node, format);\n          found = true;\n          return false;\n        }\n      });\n      return found;\n    };\n\n    const createWrapElement = wrapName => {\n      if (isString(wrapName)) {\n        const wrapElm = dom.create(wrapName);\n        setElementFormat(wrapElm);\n        return wrapElm;\n      } else {\n        return null;\n      }\n    };\n\n    const applyRngStyle = (dom, rng, nodeSpecific) => {\n      const newWrappers = [];\n      let contentEditable = true;\n      const wrapName = format.inline || format.block;\n      const wrapElm = createWrapElement(wrapName);\n      walk$3(dom, rng, nodes => {\n        let currentWrapElm;\n\n        const process = node => {\n          let hasContentEditableState = false;\n          let lastContentEditable = contentEditable;\n          const nodeName = node.nodeName.toLowerCase();\n          const parentNode = node.parentNode;\n          const parentName = parentNode.nodeName.toLowerCase();\n\n          if (isElement$6(node) && dom.getContentEditable(node)) {\n            lastContentEditable = contentEditable;\n            contentEditable = dom.getContentEditable(node) === 'true';\n            hasContentEditableState = true;\n          }\n\n          if (isBr$5(node) && !canFormatBR(ed, format, node, parentName)) {\n            currentWrapElm = null;\n\n            if (isBlockFormat(format)) {\n              dom.remove(node);\n            }\n\n            return;\n          }\n\n          if (isBlockFormat(format) && format.wrapper && matchNode(ed, node, name, vars)) {\n            currentWrapElm = null;\n            return;\n          }\n\n          if (contentEditable && !hasContentEditableState && isBlockFormat(format) && !format.wrapper && isTextBlock$1(ed, nodeName) && isValid(ed, parentName, wrapName)) {\n            const elm = dom.rename(node, wrapName);\n            setElementFormat(elm);\n            newWrappers.push(elm);\n            currentWrapElm = null;\n            return;\n          }\n\n          if (isSelectorFormat(format)) {\n            let found = applyNodeStyle(formatList, node);\n\n            if (!found && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\n              found = applyNodeStyle(formatList, parentNode);\n            }\n\n            if (!isInlineFormat(format) || found) {\n              currentWrapElm = null;\n              return;\n            }\n          }\n\n          if (contentEditable && !hasContentEditableState && isValid(ed, wrapName, nodeName) && isValid(ed, parentName, wrapName) && !(!nodeSpecific && isText$8(node) && isZwsp(node.data)) && !isCaretNode(node) && (!isInlineFormat(format) || !dom.isBlock(node))) {\n            if (!currentWrapElm) {\n              currentWrapElm = dom.clone(wrapElm, false);\n              node.parentNode.insertBefore(currentWrapElm, node);\n              newWrappers.push(currentWrapElm);\n            }\n\n            currentWrapElm.appendChild(node);\n          } else {\n            currentWrapElm = null;\n            each$g(from(node.childNodes), process);\n\n            if (hasContentEditableState) {\n              contentEditable = lastContentEditable;\n            }\n\n            currentWrapElm = null;\n          }\n        };\n\n        each$g(nodes, process);\n      });\n\n      if (format.links === true) {\n        each$g(newWrappers, node => {\n          const process = node => {\n            if (node.nodeName === 'A') {\n              setElementFormat(node, format);\n            }\n\n            each$g(from(node.childNodes), process);\n          };\n\n          process(node);\n        });\n      }\n\n      each$g(newWrappers, node => {\n        const getChildCount = node => {\n          let count = 0;\n          each$g(node.childNodes, node => {\n            if (!isEmptyTextNode$1(node) && !isBookmarkNode$1(node)) {\n              count++;\n            }\n          });\n          return count;\n        };\n\n        const mergeStyles = node => {\n          const childElement = find$2(node.childNodes, isElementNode).filter(child => matchName(dom, child, format));\n          return childElement.map(child => {\n            const clone = dom.clone(child, false);\n            setElementFormat(clone);\n            dom.replace(clone, node, true);\n            dom.remove(child, true);\n            return clone;\n          }).getOr(node);\n        };\n\n        const childCount = getChildCount(node);\n\n        if ((newWrappers.length > 1 || !dom.isBlock(node)) && childCount === 0) {\n          dom.remove(node, true);\n          return;\n        }\n\n        if (isInlineFormat(format) || isBlockFormat(format) && format.wrapper) {\n          if (!format.exact && childCount === 1) {\n            node = mergeStyles(node);\n          }\n\n          mergeWithChildren(ed, formatList, vars, node);\n          mergeWithParents(ed, format, name, vars, node);\n          mergeBackgroundColorAndFontSize(dom, format, vars, node);\n          mergeTextDecorationsAndColor(dom, format, vars, node);\n          mergeSubSup(dom, format, vars, node);\n          mergeSiblings(dom, format, vars, node);\n        }\n      });\n    };\n\n    if (dom.getContentEditable(selection.getNode()) === 'false') {\n      node = selection.getNode();\n\n      for (let i = 0, l = formatList.length; i < l; i++) {\n        const formatItem = formatList[i];\n\n        if (formatItem.ceFalseOverride && isSelectorFormat(formatItem) && dom.is(node, formatItem.selector)) {\n          setElementFormat(node, formatItem);\n          break;\n        }\n      }\n\n      fireFormatApply(ed, name, node, vars);\n      return;\n    }\n\n    if (format) {\n      if (node) {\n        if (isNode(node)) {\n          if (!applyNodeStyle(formatList, node)) {\n            const rng = dom.createRng();\n            rng.setStartBefore(node);\n            rng.setEndAfter(node);\n            applyRngStyle(dom, expandRng(ed, rng, formatList), true);\n          }\n        } else {\n          applyRngStyle(dom, node, true);\n        }\n      } else {\n        if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\n          selection.setRng(normalize(selection.getRng()));\n          preserve(selection, true, () => {\n            runOnRanges(ed, (selectionRng, fake) => {\n              const expandedRng = fake ? selectionRng : expandRng(ed, selectionRng, formatList);\n              applyRngStyle(dom, expandedRng, false);\n            });\n          });\n          moveStart(dom, selection, selection.getRng());\n          ed.nodeChanged();\n        } else {\n          applyCaretFormat(ed, name, vars);\n        }\n      }\n\n      postProcess$1(name, ed);\n    }\n\n    fireFormatApply(ed, name, node, vars);\n  };\n\n  const hasVars = value => has$2(value, 'vars');\n\n  const setup$t = (registeredFormatListeners, editor) => {\n    registeredFormatListeners.set({});\n    editor.on('NodeChange', e => {\n      updateAndFireChangeCallbacks(editor, e.element, registeredFormatListeners.get());\n    });\n    editor.on('FormatApply FormatRemove', e => {\n      const element = Optional.from(e.node).map(nodeOrRange => isNode(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer).bind(node => isElement$6(node) ? Optional.some(node) : Optional.from(node.parentElement)).getOrThunk(() => fallbackElement(editor));\n      updateAndFireChangeCallbacks(editor, element, registeredFormatListeners.get());\n    });\n  };\n\n  const fallbackElement = editor => editor.selection.getStart();\n\n  const matchingNode = (editor, parents, format, similar, vars) => {\n    const isMatchingNode = node => {\n      const matchingFormat = editor.formatter.matchNode(node, format, vars !== null && vars !== void 0 ? vars : {}, similar);\n      return !isUndefined(matchingFormat);\n    };\n\n    const isUnableToMatch = node => {\n      if (matchesUnInheritedFormatSelector(editor, node, format)) {\n        return true;\n      } else {\n        if (!similar) {\n          return isNonNullable(editor.formatter.matchNode(node, format, vars, true));\n        } else {\n          return false;\n        }\n      }\n    };\n\n    return findUntil$1(parents, isMatchingNode, isUnableToMatch);\n  };\n\n  const getParents = (editor, elm) => {\n    const element = elm !== null && elm !== void 0 ? elm : fallbackElement(editor);\n    return filter$6(getParents$2(editor.dom, element), node => isElement$6(node) && !isBogus$2(node));\n  };\n\n  const updateAndFireChangeCallbacks = (editor, elm, registeredCallbacks) => {\n    const parents = getParents(editor, elm);\n    each$f(registeredCallbacks, (data, format) => {\n      const runIfChanged = spec => {\n        const match = matchingNode(editor, parents, format, spec.similar, hasVars(spec) ? spec.vars : undefined);\n        const isSet = match.isSome();\n\n        if (spec.state.get() !== isSet) {\n          spec.state.set(isSet);\n          const node = match.getOr(elm);\n\n          if (hasVars(spec)) {\n            spec.callback(isSet, {\n              node,\n              format,\n              parents\n            });\n          } else {\n            each$g(spec.callbacks, callback => callback(isSet, {\n              node,\n              format,\n              parents\n            }));\n          }\n        }\n      };\n\n      each$g([data.withSimilar, data.withoutSimilar], runIfChanged);\n      each$g(data.withVars, runIfChanged);\n    });\n  };\n\n  const addListeners = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\n    const formatChangeItems = registeredFormatListeners.get();\n    each$g(formats.split(','), format => {\n      const group = get$a(formatChangeItems, format).getOrThunk(() => {\n        const base = {\n          withSimilar: {\n            state: Cell(false),\n            similar: true,\n            callbacks: []\n          },\n          withoutSimilar: {\n            state: Cell(false),\n            similar: false,\n            callbacks: []\n          },\n          withVars: []\n        };\n        formatChangeItems[format] = base;\n        return base;\n      });\n\n      const getCurrent = () => {\n        const parents = getParents(editor);\n        return matchingNode(editor, parents, format, similar, vars).isSome();\n      };\n\n      if (isUndefined(vars)) {\n        const toAppendTo = similar ? group.withSimilar : group.withoutSimilar;\n        toAppendTo.callbacks.push(callback);\n\n        if (toAppendTo.callbacks.length === 1) {\n          toAppendTo.state.set(getCurrent());\n        }\n      } else {\n        group.withVars.push({\n          state: Cell(getCurrent()),\n          similar,\n          vars,\n          callback\n        });\n      }\n    });\n    registeredFormatListeners.set(formatChangeItems);\n  };\n\n  const removeListeners = (registeredFormatListeners, formats, callback) => {\n    const formatChangeItems = registeredFormatListeners.get();\n    each$g(formats.split(','), format => get$a(formatChangeItems, format).each(group => {\n      formatChangeItems[format] = {\n        withSimilar: { ...group.withSimilar,\n          callbacks: filter$6(group.withSimilar.callbacks, cb => cb !== callback)\n        },\n        withoutSimilar: { ...group.withoutSimilar,\n          callbacks: filter$6(group.withoutSimilar.callbacks, cb => cb !== callback)\n        },\n        withVars: filter$6(group.withVars, item => item.callback !== callback)\n      };\n    }));\n    registeredFormatListeners.set(formatChangeItems);\n  };\n\n  const formatChangedInternal = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\n    if (registeredFormatListeners.get() === null) {\n      setup$t(registeredFormatListeners, editor);\n    }\n\n    addListeners(editor, registeredFormatListeners, formats, callback, similar, vars);\n    return {\n      unbind: () => removeListeners(registeredFormatListeners, formats, callback)\n    };\n  };\n\n  const toggle = (editor, name, vars, node) => {\n    const fmt = editor.formatter.get(name);\n\n    if (match$2(editor, name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {\n      remove$2(editor, name, vars, node);\n    } else {\n      applyFormat$1(editor, name, vars, node);\n    }\n  };\n\n  function _toConsumableArray(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n        arr2[i] = arr[i];\n      }\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  }\n\n  var hasOwnProperty = Object.hasOwnProperty,\n      setPrototypeOf = Object.setPrototypeOf,\n      isFrozen = Object.isFrozen,\n      getPrototypeOf = Object.getPrototypeOf,\n      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  var freeze = Object.freeze,\n      seal = Object.seal,\n      create$7 = Object.create;\n\n  var _ref = typeof Reflect !== 'undefined' && Reflect,\n      apply = _ref.apply,\n      construct = _ref.construct;\n\n  if (!apply) {\n    apply = function apply(fun, thisValue, args) {\n      return fun.apply(thisValue, args);\n    };\n  }\n\n  if (!freeze) {\n    freeze = function freeze(x) {\n      return x;\n    };\n  }\n\n  if (!seal) {\n    seal = function seal(x) {\n      return x;\n    };\n  }\n\n  if (!construct) {\n    construct = function construct(Func, args) {\n      return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();\n    };\n  }\n\n  var arrayForEach = unapply(Array.prototype.forEach);\n  var arrayPop = unapply(Array.prototype.pop);\n  var arrayPush = unapply(Array.prototype.push);\n  var stringToLowerCase = unapply(String.prototype.toLowerCase);\n  var stringMatch = unapply(String.prototype.match);\n  var stringReplace = unapply(String.prototype.replace);\n  var stringIndexOf = unapply(String.prototype.indexOf);\n  var stringTrim = unapply(String.prototype.trim);\n  var regExpTest = unapply(RegExp.prototype.test);\n  var typeErrorCreate = unconstruct(TypeError);\n\n  function unapply(func) {\n    return function (thisArg) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return apply(func, thisArg, args);\n    };\n  }\n\n  function unconstruct(func) {\n    return function () {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return construct(func, args);\n    };\n  }\n\n  function addToSet(set, array) {\n    if (setPrototypeOf) {\n      setPrototypeOf(set, null);\n    }\n\n    var l = array.length;\n\n    while (l--) {\n      var element = array[l];\n\n      if (typeof element === 'string') {\n        var lcElement = stringToLowerCase(element);\n\n        if (lcElement !== element) {\n          if (!isFrozen(array)) {\n            array[l] = lcElement;\n          }\n\n          element = lcElement;\n        }\n      }\n\n      set[element] = true;\n    }\n\n    return set;\n  }\n\n  function clone(object) {\n    var newObject = create$7(null);\n    var property = void 0;\n\n    for (property in object) {\n      if (apply(hasOwnProperty, object, [property])) {\n        newObject[property] = object[property];\n      }\n    }\n\n    return newObject;\n  }\n\n  function lookupGetter(object, prop) {\n    while (object !== null) {\n      var desc = getOwnPropertyDescriptor(object, prop);\n\n      if (desc) {\n        if (desc.get) {\n          return unapply(desc.get);\n        }\n\n        if (typeof desc.value === 'function') {\n          return unapply(desc.value);\n        }\n      }\n\n      object = getPrototypeOf(object);\n    }\n\n    function fallbackValue(element) {\n      console.warn('fallback value for', element);\n      return null;\n    }\n\n    return fallbackValue;\n  }\n\n  var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n  var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n  var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);\n  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n  var text = freeze(['#text']);\n  var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);\n  var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n  var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n  var MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm);\n  var ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\n  var DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/);\n  var ARIA_ATTR = seal(/^aria-[\\-\\w]+$/);\n  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i);\n  var IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n  var ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g);\n  var DOCTYPE_NAME = seal(/^html$/i);\n\n  var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;\n  };\n\n  function _toConsumableArray$1(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n        arr2[i] = arr[i];\n      }\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  }\n\n  var getGlobal = function getGlobal() {\n    return typeof window === 'undefined' ? null : window;\n  };\n\n  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n    if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n      return null;\n    }\n\n    var suffix = null;\n    var ATTR_NAME = 'data-tt-policy-suffix';\n\n    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n      suffix = document.currentScript.getAttribute(ATTR_NAME);\n    }\n\n    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n    try {\n      return trustedTypes.createPolicy(policyName, {\n        createHTML: function createHTML(html$$1) {\n          return html$$1;\n        }\n      });\n    } catch (_) {\n      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n      return null;\n    }\n  };\n\n  function createDOMPurify() {\n    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n    var DOMPurify = function DOMPurify(root) {\n      return createDOMPurify(root);\n    };\n\n    DOMPurify.version = '2.3.6';\n    DOMPurify.removed = [];\n\n    if (!window || !window.document || window.document.nodeType !== 9) {\n      DOMPurify.isSupported = false;\n      return DOMPurify;\n    }\n\n    var originalDocument = window.document;\n    var document = window.document;\n    var DocumentFragment = window.DocumentFragment,\n        HTMLTemplateElement = window.HTMLTemplateElement,\n        Node = window.Node,\n        Element = window.Element,\n        NodeFilter = window.NodeFilter,\n        _window$NamedNodeMap = window.NamedNodeMap,\n        NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,\n        HTMLFormElement = window.HTMLFormElement,\n        DOMParser = window.DOMParser,\n        trustedTypes = window.trustedTypes;\n    var ElementPrototype = Element.prototype;\n    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n    var getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n    if (typeof HTMLTemplateElement === 'function') {\n      var template = document.createElement('template');\n\n      if (template.content && template.content.ownerDocument) {\n        document = template.content.ownerDocument;\n      }\n    }\n\n    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\n\n    var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';\n    var _document = document,\n        implementation = _document.implementation,\n        createNodeIterator = _document.createNodeIterator,\n        createDocumentFragment = _document.createDocumentFragment,\n        getElementsByTagName = _document.getElementsByTagName;\n    var importNode = originalDocument.importNode;\n    var documentMode = {};\n\n    try {\n      documentMode = clone(document).documentMode ? document.documentMode : {};\n    } catch (_) {}\n\n    var hooks = {};\n    DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;\n    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,\n        ERB_EXPR$$1 = ERB_EXPR,\n        DATA_ATTR$$1 = DATA_ATTR,\n        ARIA_ATTR$$1 = ARIA_ATTR,\n        IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,\n        ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n    var ALLOWED_TAGS = null;\n    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));\n    var ALLOWED_ATTR = null;\n    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));\n    var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {\n      tagNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null\n      },\n      attributeNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null\n      },\n      allowCustomizedBuiltInElements: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: false\n      }\n    }));\n    var FORBID_TAGS = null;\n    var FORBID_ATTR = null;\n    var ALLOW_ARIA_ATTR = true;\n    var ALLOW_DATA_ATTR = true;\n    var ALLOW_UNKNOWN_PROTOCOLS = false;\n    var SAFE_FOR_TEMPLATES = false;\n    var WHOLE_DOCUMENT = false;\n    var SET_CONFIG = false;\n    var FORCE_BODY = false;\n    var RETURN_DOM = false;\n    var RETURN_DOM_FRAGMENT = false;\n    var RETURN_TRUSTED_TYPE = false;\n    var SANITIZE_DOM = true;\n    var KEEP_CONTENT = true;\n    var IN_PLACE = false;\n    var USE_PROFILES = {};\n    var FORBID_CONTENTS = null;\n    var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n    var DATA_URI_TAGS = null;\n    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n    var URI_SAFE_ATTRIBUTES = null;\n    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);\n    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n    var NAMESPACE = HTML_NAMESPACE;\n    var IS_EMPTY_INPUT = false;\n    var PARSER_MEDIA_TYPE = void 0;\n    var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n    var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n    var transformCaseFunc = void 0;\n    var CONFIG = null;\n    var formElement = document.createElement('form');\n\n    var isRegexOrFunction = function isRegexOrFunction(testValue) {\n      return testValue instanceof RegExp || testValue instanceof Function;\n    };\n\n    var _parseConfig = function _parseConfig(cfg) {\n      if (CONFIG && CONFIG === cfg) {\n        return;\n      }\n\n      if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {\n        cfg = {};\n      }\n\n      cfg = clone(cfg);\n      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;\n      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;\n      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;\n      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;\n      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;\n      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;\n      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;\n      RETURN_DOM = cfg.RETURN_DOM || false;\n      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;\n      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;\n      FORCE_BODY = cfg.FORCE_BODY || false;\n      SANITIZE_DOM = cfg.SANITIZE_DOM !== false;\n      KEEP_CONTENT = cfg.KEEP_CONTENT !== false;\n      IN_PLACE = cfg.IN_PLACE || false;\n      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n\n      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n      }\n\n      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n      }\n\n      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {\n        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n      }\n\n      PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;\n      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {\n        return x;\n      } : stringToLowerCase;\n\n      if (SAFE_FOR_TEMPLATES) {\n        ALLOW_DATA_ATTR = false;\n      }\n\n      if (RETURN_DOM_FRAGMENT) {\n        RETURN_DOM = true;\n      }\n\n      if (USE_PROFILES) {\n        ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));\n        ALLOWED_ATTR = [];\n\n        if (USE_PROFILES.html === true) {\n          addToSet(ALLOWED_TAGS, html);\n          addToSet(ALLOWED_ATTR, html$1);\n        }\n\n        if (USE_PROFILES.svg === true) {\n          addToSet(ALLOWED_TAGS, svg);\n          addToSet(ALLOWED_ATTR, svg$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.svgFilters === true) {\n          addToSet(ALLOWED_TAGS, svgFilters);\n          addToSet(ALLOWED_ATTR, svg$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.mathMl === true) {\n          addToSet(ALLOWED_TAGS, mathMl);\n          addToSet(ALLOWED_ATTR, mathMl$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n      }\n\n      if (cfg.ADD_TAGS) {\n        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n          ALLOWED_TAGS = clone(ALLOWED_TAGS);\n        }\n\n        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n      }\n\n      if (cfg.ADD_ATTR) {\n        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n          ALLOWED_ATTR = clone(ALLOWED_ATTR);\n        }\n\n        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n      }\n\n      if (cfg.ADD_URI_SAFE_ATTR) {\n        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n      }\n\n      if (cfg.FORBID_CONTENTS) {\n        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n          FORBID_CONTENTS = clone(FORBID_CONTENTS);\n        }\n\n        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);\n      }\n\n      if (KEEP_CONTENT) {\n        ALLOWED_TAGS['#text'] = true;\n      }\n\n      if (WHOLE_DOCUMENT) {\n        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n      }\n\n      if (ALLOWED_TAGS.table) {\n        addToSet(ALLOWED_TAGS, ['tbody']);\n        delete FORBID_TAGS.tbody;\n      }\n\n      if (freeze) {\n        freeze(cfg);\n      }\n\n      CONFIG = cfg;\n    };\n\n    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);\n    var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n    var ALL_SVG_TAGS = addToSet({}, svg);\n    addToSet(ALL_SVG_TAGS, svgFilters);\n    addToSet(ALL_SVG_TAGS, svgDisallowed);\n    var ALL_MATHML_TAGS = addToSet({}, mathMl);\n    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n\n    var _checkValidNamespace = function _checkValidNamespace(element) {\n      var parent = getParentNode(element);\n\n      if (!parent || !parent.tagName) {\n        parent = {\n          namespaceURI: HTML_NAMESPACE,\n          tagName: 'template'\n        };\n      }\n\n      var tagName = stringToLowerCase(element.tagName);\n      var parentTagName = stringToLowerCase(parent.tagName);\n\n      if (element.namespaceURI === SVG_NAMESPACE) {\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'svg';\n        }\n\n        if (parent.namespaceURI === MATHML_NAMESPACE) {\n          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n        }\n\n        return Boolean(ALL_SVG_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === MATHML_NAMESPACE) {\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'math';\n        }\n\n        if (parent.namespaceURI === SVG_NAMESPACE) {\n          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n        }\n\n        return Boolean(ALL_MATHML_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === HTML_NAMESPACE) {\n        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n      }\n\n      return false;\n    };\n\n    var _forceRemove = function _forceRemove(node) {\n      arrayPush(DOMPurify.removed, {\n        element: node\n      });\n\n      try {\n        node.parentNode.removeChild(node);\n      } catch (_) {\n        try {\n          node.outerHTML = emptyHTML;\n        } catch (_) {\n          node.remove();\n        }\n      }\n    };\n\n    var _removeAttribute = function _removeAttribute(name, node) {\n      try {\n        arrayPush(DOMPurify.removed, {\n          attribute: node.getAttributeNode(name),\n          from: node\n        });\n      } catch (_) {\n        arrayPush(DOMPurify.removed, {\n          attribute: null,\n          from: node\n        });\n      }\n\n      node.removeAttribute(name);\n\n      if (name === 'is' && !ALLOWED_ATTR[name]) {\n        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n          try {\n            _forceRemove(node);\n          } catch (_) {}\n        } else {\n          try {\n            node.setAttribute(name, '');\n          } catch (_) {}\n        }\n      }\n    };\n\n    var _initDocument = function _initDocument(dirty) {\n      var doc = void 0;\n      var leadingWhitespace = void 0;\n\n      if (FORCE_BODY) {\n        dirty = '<remove></remove>' + dirty;\n      } else {\n        var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n        leadingWhitespace = matches && matches[0];\n      }\n\n      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {\n        dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n      }\n\n      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n\n      if (NAMESPACE === HTML_NAMESPACE) {\n        try {\n          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n        } catch (_) {}\n      }\n\n      if (!doc || !doc.documentElement) {\n        doc = implementation.createDocument(NAMESPACE, 'template', null);\n\n        try {\n          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;\n        } catch (_) {}\n      }\n\n      var body = doc.body || doc.documentElement;\n\n      if (dirty && leadingWhitespace) {\n        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n      }\n\n      if (NAMESPACE === HTML_NAMESPACE) {\n        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n      }\n\n      return WHOLE_DOCUMENT ? doc.documentElement : body;\n    };\n\n    var _createIterator = function _createIterator(root) {\n      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n    };\n\n    var _isClobbered = function _isClobbered(elm) {\n      return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function');\n    };\n\n    var _isNode = function _isNode(object) {\n      return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n    };\n\n    var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n      if (!hooks[entryPoint]) {\n        return;\n      }\n\n      arrayForEach(hooks[entryPoint], function (hook) {\n        hook.call(DOMPurify, currentNode, data, CONFIG);\n      });\n    };\n\n    var _sanitizeElements = function _sanitizeElements(currentNode) {\n      var content = void 0;\n\n      _executeHook('beforeSanitizeElements', currentNode, null);\n\n      if (_isClobbered(currentNode)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n\n      if (regExpTest(/[\\u0080-\\uFFFF]/, currentNode.nodeName)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n\n      var tagName = transformCaseFunc(currentNode.nodeName);\n\n      _executeHook('uponSanitizeElement', currentNode, {\n        tagName: tagName,\n        allowedTags: ALLOWED_TAGS\n      });\n\n      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n\n      if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n\n      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n        if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {\n          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;\n          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;\n        }\n\n        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n          var parentNode = getParentNode(currentNode) || currentNode.parentNode;\n          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n\n          if (childNodes && parentNode) {\n            var childCount = childNodes.length;\n\n            for (var i = childCount - 1; i >= 0; --i) {\n              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n            }\n          }\n        }\n\n        _forceRemove(currentNode);\n\n        return true;\n      }\n\n      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n\n      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n\n      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n        content = currentNode.textContent;\n        content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');\n        content = stringReplace(content, ERB_EXPR$$1, ' ');\n\n        if (currentNode.textContent !== content) {\n          arrayPush(DOMPurify.removed, {\n            element: currentNode.cloneNode()\n          });\n          currentNode.textContent = content;\n        }\n      }\n\n      _executeHook('afterSanitizeElements', currentNode, null);\n\n      return false;\n    };\n\n    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n        return false;\n      }\n\n      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ;else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ;else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n        if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ;else {\n          return false;\n        }\n      } else if (URI_SAFE_ATTRIBUTES[lcName]) ;else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ;else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ;else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ;else if (!value) ;else {\n        return false;\n      }\n      return true;\n    };\n\n    var _basicCustomElementTest = function _basicCustomElementTest(tagName) {\n      return tagName.indexOf('-') > 0;\n    };\n\n    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n      var attr = void 0;\n      var value = void 0;\n      var lcName = void 0;\n      var l = void 0;\n\n      _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n      var attributes = currentNode.attributes;\n\n      if (!attributes) {\n        return;\n      }\n\n      var hookEvent = {\n        attrName: '',\n        attrValue: '',\n        keepAttr: true,\n        allowedAttributes: ALLOWED_ATTR\n      };\n      l = attributes.length;\n\n      while (l--) {\n        attr = attributes[l];\n        var _attr = attr,\n            name = _attr.name,\n            namespaceURI = _attr.namespaceURI;\n        value = stringTrim(attr.value);\n        lcName = transformCaseFunc(name);\n        var initValue = value;\n        hookEvent.attrName = lcName;\n        hookEvent.attrValue = value;\n        hookEvent.keepAttr = true;\n        hookEvent.forceKeepAttr = undefined;\n\n        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n\n        value = hookEvent.attrValue;\n\n        if (hookEvent.forceKeepAttr) {\n          continue;\n        }\n\n        if (!hookEvent.keepAttr) {\n          _removeAttribute(name, currentNode);\n\n          continue;\n        }\n\n        if (regExpTest(/\\/>/i, value)) {\n          _removeAttribute(name, currentNode);\n\n          continue;\n        }\n\n        if (SAFE_FOR_TEMPLATES) {\n          value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');\n          value = stringReplace(value, ERB_EXPR$$1, ' ');\n        }\n\n        var lcTag = transformCaseFunc(currentNode.nodeName);\n\n        if (!_isValidAttribute(lcTag, lcName, value)) {\n          _removeAttribute(name, currentNode);\n\n          continue;\n        }\n\n        if (value !== initValue) {\n          try {\n            if (namespaceURI) {\n              currentNode.setAttributeNS(namespaceURI, name, value);\n            } else {\n              currentNode.setAttribute(name, value);\n            }\n          } catch (_) {\n            _removeAttribute(name, currentNode);\n          }\n        }\n      }\n\n      _executeHook('afterSanitizeAttributes', currentNode, null);\n    };\n\n    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n      var shadowNode = void 0;\n\n      var shadowIterator = _createIterator(fragment);\n\n      _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n      while (shadowNode = shadowIterator.nextNode()) {\n        _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n        if (_sanitizeElements(shadowNode)) {\n          continue;\n        }\n\n        if (shadowNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(shadowNode.content);\n        }\n\n        _sanitizeAttributes(shadowNode);\n      }\n\n      _executeHook('afterSanitizeShadowDOM', fragment, null);\n    };\n\n    DOMPurify.sanitize = function (dirty, cfg) {\n      var body = void 0;\n      var importedNode = void 0;\n      var currentNode = void 0;\n      var oldNode = void 0;\n      var returnNode = void 0;\n      IS_EMPTY_INPUT = !dirty;\n\n      if (IS_EMPTY_INPUT) {\n        dirty = '<!-->';\n      }\n\n      if (typeof dirty !== 'string' && !_isNode(dirty)) {\n        if (typeof dirty.toString !== 'function') {\n          throw typeErrorCreate('toString is not a function');\n        } else {\n          dirty = dirty.toString();\n\n          if (typeof dirty !== 'string') {\n            throw typeErrorCreate('dirty is not a string, aborting');\n          }\n        }\n      }\n\n      if (!DOMPurify.isSupported) {\n        if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\n          if (typeof dirty === 'string') {\n            return window.toStaticHTML(dirty);\n          }\n\n          if (_isNode(dirty)) {\n            return window.toStaticHTML(dirty.outerHTML);\n          }\n        }\n\n        return dirty;\n      }\n\n      if (!SET_CONFIG) {\n        _parseConfig(cfg);\n      }\n\n      DOMPurify.removed = [];\n\n      if (typeof dirty === 'string') {\n        IN_PLACE = false;\n      }\n\n      if (IN_PLACE) {\n        if (dirty.nodeName) {\n          var tagName = transformCaseFunc(dirty.nodeName);\n\n          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n            throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\n          }\n        }\n      } else if (dirty instanceof Node) {\n        body = _initDocument('<!---->');\n        importedNode = body.ownerDocument.importNode(dirty, true);\n\n        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n          body = importedNode;\n        } else if (importedNode.nodeName === 'HTML') {\n          body = importedNode;\n        } else {\n          body.appendChild(importedNode);\n        }\n      } else {\n        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) {\n          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        }\n\n        body = _initDocument(dirty);\n\n        if (!body) {\n          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n        }\n      }\n\n      if (body && FORCE_BODY) {\n        _forceRemove(body.firstChild);\n      }\n\n      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n\n      while (currentNode = nodeIterator.nextNode()) {\n        if (currentNode.nodeType === 3 && currentNode === oldNode) {\n          continue;\n        }\n\n        if (_sanitizeElements(currentNode)) {\n          continue;\n        }\n\n        if (currentNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(currentNode.content);\n        }\n\n        _sanitizeAttributes(currentNode);\n\n        oldNode = currentNode;\n      }\n\n      oldNode = null;\n\n      if (IN_PLACE) {\n        return dirty;\n      }\n\n      if (RETURN_DOM) {\n        if (RETURN_DOM_FRAGMENT) {\n          returnNode = createDocumentFragment.call(body.ownerDocument);\n\n          while (body.firstChild) {\n            returnNode.appendChild(body.firstChild);\n          }\n        } else {\n          returnNode = body;\n        }\n\n        if (ALLOWED_ATTR.shadowroot) {\n          returnNode = importNode.call(originalDocument, returnNode, true);\n        }\n\n        return returnNode;\n      }\n\n      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n      if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n        serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n      }\n\n      if (SAFE_FOR_TEMPLATES) {\n        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');\n        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');\n      }\n\n      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n\n    DOMPurify.setConfig = function (cfg) {\n      _parseConfig(cfg);\n\n      SET_CONFIG = true;\n    };\n\n    DOMPurify.clearConfig = function () {\n      CONFIG = null;\n      SET_CONFIG = false;\n    };\n\n    DOMPurify.isValidAttribute = function (tag, attr, value) {\n      if (!CONFIG) {\n        _parseConfig({});\n      }\n\n      var lcTag = transformCaseFunc(tag);\n      var lcName = transformCaseFunc(attr);\n      return _isValidAttribute(lcTag, lcName, value);\n    };\n\n    DOMPurify.addHook = function (entryPoint, hookFunction) {\n      if (typeof hookFunction !== 'function') {\n        return;\n      }\n\n      hooks[entryPoint] = hooks[entryPoint] || [];\n      arrayPush(hooks[entryPoint], hookFunction);\n    };\n\n    DOMPurify.removeHook = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        arrayPop(hooks[entryPoint]);\n      }\n    };\n\n    DOMPurify.removeHooks = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        hooks[entryPoint] = [];\n      }\n    };\n\n    DOMPurify.removeAllHooks = function () {\n      hooks = {};\n    };\n\n    return DOMPurify;\n  }\n\n  var purify = createDOMPurify();\n\n  const removeAttrs = (node, names) => {\n    each$g(names, name => {\n      node.attr(name, null);\n    });\n  };\n\n  const addFontToSpansFilter = (domParser, styles, fontSizes) => {\n    domParser.addNodeFilter('font', nodes => {\n      each$g(nodes, node => {\n        const props = styles.parse(node.attr('style'));\n        const color = node.attr('color');\n        const face = node.attr('face');\n        const size = node.attr('size');\n\n        if (color) {\n          props.color = color;\n        }\n\n        if (face) {\n          props['font-family'] = face;\n        }\n\n        if (size) {\n          props['font-size'] = fontSizes[parseInt(node.attr('size'), 10) - 1];\n        }\n\n        node.name = 'span';\n        node.attr('style', styles.serialize(props));\n        removeAttrs(node, ['color', 'face', 'size']);\n      });\n    });\n  };\n\n  const addStrikeFilter = (domParser, schema, styles) => {\n    domParser.addNodeFilter('strike', nodes => {\n      const convertToSTag = schema.type !== 'html4';\n      each$g(nodes, node => {\n        if (convertToSTag) {\n          node.name = 's';\n        } else {\n          const props = styles.parse(node.attr('style'));\n          props['text-decoration'] = 'line-through';\n          node.name = 'span';\n          node.attr('style', styles.serialize(props));\n        }\n      });\n    });\n  };\n\n  const addFilters = (domParser, settings, schema) => {\n    const styles = Styles();\n\n    if (settings.convert_fonts_to_spans) {\n      addFontToSpansFilter(domParser, styles, Tools.explode(settings.font_size_legacy_values));\n    }\n\n    addStrikeFilter(domParser, schema, styles);\n  };\n\n  const register$5 = (domParser, settings, schema) => {\n    if (settings.inline_styles) {\n      addFilters(domParser, settings, schema);\n    }\n  };\n\n  const blobUriToBlob = url => {\n    return new Promise((resolve, reject) => {\n      const rejectWithError = () => {\n        reject('Cannot convert ' + url + ' to Blob. Resource might not exist or is inaccessible.');\n      };\n\n      try {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.responseType = 'blob';\n\n        xhr.onload = () => {\n          if (xhr.status === 200) {\n            resolve(xhr.response);\n          } else {\n            rejectWithError();\n          }\n        };\n\n        xhr.onerror = rejectWithError;\n        xhr.send();\n      } catch (ex) {\n        rejectWithError();\n      }\n    });\n  };\n\n  const parseDataUri$1 = uri => {\n    let type;\n    const uriParts = decodeURIComponent(uri).split(',');\n    const matches = /data:([^;]+)/.exec(uriParts[0]);\n\n    if (matches) {\n      type = matches[1];\n    }\n\n    return {\n      type,\n      data: uriParts[1]\n    };\n  };\n\n  const buildBlob = (type, data) => {\n    let str;\n\n    try {\n      str = atob(data);\n    } catch (e) {\n      return Optional.none();\n    }\n\n    const arr = new Uint8Array(str.length);\n\n    for (let i = 0; i < arr.length; i++) {\n      arr[i] = str.charCodeAt(i);\n    }\n\n    return Optional.some(new Blob([arr], {\n      type\n    }));\n  };\n\n  const dataUriToBlob = uri => {\n    return new Promise(resolve => {\n      const {\n        type,\n        data\n      } = parseDataUri$1(uri);\n      buildBlob(type, data).fold(() => resolve(new Blob([])), resolve);\n    });\n  };\n\n  const uriToBlob = url => {\n    if (url.indexOf('blob:') === 0) {\n      return blobUriToBlob(url);\n    }\n\n    if (url.indexOf('data:') === 0) {\n      return dataUriToBlob(url);\n    }\n\n    return null;\n  };\n\n  const blobToDataUri = blob => {\n    return new Promise(resolve => {\n      const reader = new FileReader();\n\n      reader.onloadend = () => {\n        resolve(reader.result);\n      };\n\n      reader.readAsDataURL(blob);\n    });\n  };\n\n  let count$1 = 0;\n\n  const uniqueId$1 = prefix => {\n    return (prefix || 'blobid') + count$1++;\n  };\n\n  const imageToBlobInfo = (blobCache, img, resolve, reject) => {\n    let base64, blobInfo;\n\n    if (img.src.indexOf('blob:') === 0) {\n      blobInfo = blobCache.getByUri(img.src);\n\n      if (blobInfo) {\n        resolve({\n          image: img,\n          blobInfo\n        });\n      } else {\n        uriToBlob(img.src).then(blob => {\n          blobToDataUri(blob).then(dataUri => {\n            base64 = parseDataUri$1(dataUri).data;\n            blobInfo = blobCache.create(uniqueId$1(), blob, base64);\n            blobCache.add(blobInfo);\n            resolve({\n              image: img,\n              blobInfo\n            });\n          });\n        }, err => {\n          reject(err);\n        });\n      }\n\n      return;\n    }\n\n    const {\n      data,\n      type\n    } = parseDataUri$1(img.src);\n    base64 = data;\n    blobInfo = blobCache.getByData(base64, type);\n\n    if (blobInfo) {\n      resolve({\n        image: img,\n        blobInfo\n      });\n    } else {\n      uriToBlob(img.src).then(blob => {\n        blobInfo = blobCache.create(uniqueId$1(), blob, base64);\n        blobCache.add(blobInfo);\n        resolve({\n          image: img,\n          blobInfo\n        });\n      }, err => {\n        reject(err);\n      });\n    }\n  };\n\n  const getAllImages = elm => {\n    return elm ? from(elm.getElementsByTagName('img')) : [];\n  };\n\n  const ImageScanner = (uploadStatus, blobCache) => {\n    const cachedPromises = {};\n\n    const findAll = (elm, predicate) => {\n      if (!predicate) {\n        predicate = always;\n      }\n\n      const images = filter$6(getAllImages(elm), img => {\n        const src = img.src;\n\n        if (img.hasAttribute('data-mce-bogus')) {\n          return false;\n        }\n\n        if (img.hasAttribute('data-mce-placeholder')) {\n          return false;\n        }\n\n        if (!src || src === Env.transparentSrc) {\n          return false;\n        }\n\n        if (src.indexOf('blob:') === 0) {\n          return !uploadStatus.isUploaded(src) && predicate(img);\n        }\n\n        if (src.indexOf('data:') === 0) {\n          return predicate(img);\n        }\n\n        return false;\n      });\n      const promises = map$3(images, img => {\n        if (cachedPromises[img.src] !== undefined) {\n          return new Promise(resolve => {\n            cachedPromises[img.src].then(imageInfo => {\n              if (typeof imageInfo === 'string') {\n                return imageInfo;\n              }\n\n              resolve({\n                image: img,\n                blobInfo: imageInfo.blobInfo\n              });\n            });\n          });\n        }\n\n        const newPromise = new Promise((resolve, reject) => {\n          imageToBlobInfo(blobCache, img, resolve, reject);\n        }).then(result => {\n          delete cachedPromises[result.image.src];\n          return result;\n        }).catch(error => {\n          delete cachedPromises[img.src];\n          return error;\n        });\n        cachedPromises[img.src] = newPromise;\n        return newPromise;\n      });\n      return Promise.all(promises);\n    };\n\n    return {\n      findAll\n    };\n  };\n\n  const parseDataUri = uri => {\n    const matches = /data:([^;]+);base64,([a-z0-9\\+\\/=\\s]+)/i.exec(uri);\n\n    if (matches) {\n      return Optional.some({\n        type: matches[1],\n        data: decodeURIComponent(matches[2])\n      });\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const isBogusImage = img => isNonNullable(img.attr('data-mce-bogus'));\n\n  const isInternalImageSource = img => img.attr('src') === Env.transparentSrc || isNonNullable(img.attr('data-mce-placeholder'));\n\n  const registerBase64ImageFilter = (parser, settings) => {\n    const {\n      blob_cache: blobCache\n    } = settings;\n\n    const processImage = img => {\n      const inputSrc = img.attr('src');\n\n      if (isInternalImageSource(img) || isBogusImage(img)) {\n        return;\n      }\n\n      parseDataUri(inputSrc).bind(_ref11 => {\n        let {\n          type,\n          data\n        } = _ref11;\n        return Optional.from(blobCache.getByData(data, type)).orThunk(() => buildBlob(type, data).map(blob => {\n          const blobInfo = blobCache.create(uniqueId$1(), blob, data);\n          blobCache.add(blobInfo);\n          return blobInfo;\n        }));\n      }).each(blobInfo => {\n        img.attr('src', blobInfo.blobUri());\n      });\n    };\n\n    if (blobCache) {\n      parser.addAttributeFilter('src', nodes => each$g(nodes, processImage));\n    }\n  };\n\n  const register$4 = (parser, settings) => {\n    const schema = parser.schema;\n\n    if (settings.remove_trailing_brs) {\n      parser.addNodeFilter('br', (nodes, _, args) => {\n        const blockElements = Tools.extend({}, schema.getBlockElements());\n        const nonEmptyElements = schema.getNonEmptyElements();\n        const whitespaceElements = schema.getWhitespaceElements();\n        blockElements.body = 1;\n\n        for (let i = 0, l = nodes.length; i < l; i++) {\n          let node = nodes[i];\n          let parent = node.parent;\n\n          if (blockElements[node.parent.name] && node === parent.lastChild) {\n            let prev = node.prev;\n\n            while (prev) {\n              const prevName = prev.name;\n\n              if (prevName !== 'span' || prev.attr('data-mce-type') !== 'bookmark') {\n                if (prevName === 'br') {\n                  node = null;\n                }\n\n                break;\n              }\n\n              prev = prev.prev;\n            }\n\n            if (node) {\n              node.remove();\n\n              if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent)) {\n                const elementRule = schema.getElementRule(parent.name);\n\n                if (elementRule) {\n                  if (elementRule.removeEmpty) {\n                    parent.remove();\n                  } else if (elementRule.paddEmpty) {\n                    paddEmptyNode(settings, args, blockElements, parent);\n                  }\n                }\n              }\n            }\n          } else {\n            let lastParent = node;\n\n            while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {\n              lastParent = parent;\n\n              if (blockElements[parent.name]) {\n                break;\n              }\n\n              parent = parent.parent;\n            }\n\n            if (lastParent === parent) {\n              const textNode = new AstNode('#text', 3);\n              textNode.value = nbsp;\n              node.replace(textNode);\n            }\n          }\n        }\n      });\n    }\n\n    parser.addAttributeFilter('href', nodes => {\n      let i = nodes.length;\n\n      const appendRel = rel => {\n        const parts = rel.split(' ').filter(p => p.length > 0);\n        return parts.concat(['noopener']).sort().join(' ');\n      };\n\n      const addNoOpener = rel => {\n        const newRel = rel ? Tools.trim(rel) : '';\n\n        if (!/\\b(noopener)\\b/g.test(newRel)) {\n          return appendRel(newRel);\n        } else {\n          return newRel;\n        }\n      };\n\n      if (!settings.allow_unsafe_link_target) {\n        while (i--) {\n          const node = nodes[i];\n\n          if (node.name === 'a' && node.attr('target') === '_blank') {\n            node.attr('rel', addNoOpener(node.attr('rel')));\n          }\n        }\n      }\n    });\n\n    if (!settings.allow_html_in_named_anchor) {\n      parser.addAttributeFilter('id,name', nodes => {\n        let i = nodes.length,\n            sibling,\n            prevSibling,\n            parent,\n            node;\n\n        while (i--) {\n          node = nodes[i];\n\n          if (node.name === 'a' && node.firstChild && !node.attr('href')) {\n            parent = node.parent;\n            sibling = node.lastChild;\n\n            do {\n              prevSibling = sibling.prev;\n              parent.insert(sibling, node);\n              sibling = prevSibling;\n            } while (sibling);\n          }\n        }\n      });\n    }\n\n    if (settings.fix_list_elements) {\n      parser.addNodeFilter('ul,ol', nodes => {\n        let i = nodes.length,\n            node,\n            parentNode;\n\n        while (i--) {\n          node = nodes[i];\n          parentNode = node.parent;\n\n          if (parentNode.name === 'ul' || parentNode.name === 'ol') {\n            if (node.prev && node.prev.name === 'li') {\n              node.prev.append(node);\n            } else {\n              const li = new AstNode('li', 1);\n              li.attr('style', 'list-style-type: none');\n              node.wrap(li);\n            }\n          }\n        }\n      });\n    }\n\n    if (settings.validate && schema.getValidClasses()) {\n      parser.addAttributeFilter('class', nodes => {\n        const validClasses = schema.getValidClasses();\n        let i = nodes.length;\n\n        while (i--) {\n          const node = nodes[i];\n          const classList = node.attr('class').split(' ');\n          let classValue = '';\n\n          for (let ci = 0; ci < classList.length; ci++) {\n            const className = classList[ci];\n            let valid = false;\n            let validClassesMap = validClasses['*'];\n\n            if (validClassesMap && validClassesMap[className]) {\n              valid = true;\n            }\n\n            validClassesMap = validClasses[node.name];\n\n            if (!valid && validClassesMap && validClassesMap[className]) {\n              valid = true;\n            }\n\n            if (valid) {\n              if (classValue) {\n                classValue += ' ';\n              }\n\n              classValue += className;\n            }\n          }\n\n          if (!classValue.length) {\n            classValue = null;\n          }\n\n          node.attr('class', classValue);\n        }\n      });\n    }\n\n    registerBase64ImageFilter(parser, settings);\n  };\n\n  const each$5 = Tools.each,\n        trim = Tools.trim;\n  const queryParts = 'source protocol authority userInfo user password host port relative path directory file query anchor'.split(' ');\n  const DEFAULT_PORTS = {\n    ftp: 21,\n    http: 80,\n    https: 443,\n    mailto: 25\n  };\n  const safeSvgDataUrlElements = ['img', 'video'];\n\n  const blockSvgDataUris = (allowSvgDataUrls, tagName) => {\n    if (isNonNullable(allowSvgDataUrls)) {\n      return !allowSvgDataUrls;\n    } else {\n      return isNonNullable(tagName) ? !contains$2(safeSvgDataUrlElements, tagName) : true;\n    }\n  };\n\n  const decodeUri = encodedUri => {\n    try {\n      return decodeURIComponent(encodedUri);\n    } catch (ex) {\n      return unescape(encodedUri);\n    }\n  };\n\n  const isInvalidUri = (settings, uri, tagName) => {\n    const decodedUri = decodeUri(uri);\n\n    if (settings.allow_script_urls) {\n      return false;\n    } else if (/((java|vb)script|mhtml):/i.test(decodedUri)) {\n      return true;\n    } else if (settings.allow_html_data_urls) {\n      return false;\n    } else if (/^data:image\\//i.test(decodedUri)) {\n      return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\\/svg\\+xml/i.test(decodedUri);\n    } else {\n      return /^data:/i.test(decodedUri);\n    }\n  };\n\n  class URI {\n    constructor(url, settings) {\n      url = trim(url);\n      this.settings = settings || {};\n      const baseUri = this.settings.base_uri;\n      const self = this;\n\n      if (/^([\\w\\-]+):([^\\/]{2})/i.test(url) || /^\\s*#/.test(url)) {\n        self.source = url;\n        return;\n      }\n\n      const isProtocolRelative = url.indexOf('//') === 0;\n\n      if (url.indexOf('/') === 0 && !isProtocolRelative) {\n        url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;\n      }\n\n      if (!/^[\\w\\-]*:?\\/\\//.test(url)) {\n        const baseUrl = this.settings.base_uri ? this.settings.base_uri.path : new URI(document.location.href).directory;\n\n        if (this.settings.base_uri && this.settings.base_uri.protocol == '') {\n          url = '//mce_host' + self.toAbsPath(baseUrl, url);\n        } else {\n          const match = /([^#?]*)([#?]?.*)/.exec(url);\n          url = (baseUri && baseUri.protocol || 'http') + '://mce_host' + self.toAbsPath(baseUrl, match[1]) + match[2];\n        }\n      }\n\n      url = url.replace(/@@/g, '(mce_at)');\n      const urlMatch = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@\\/]*):?([^:@\\/]*))?@)?(\\[[a-zA-Z0-9:.%]+\\]|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/.exec(url);\n      each$5(queryParts, (v, i) => {\n        let part = urlMatch[i];\n\n        if (part) {\n          part = part.replace(/\\(mce_at\\)/g, '@@');\n        }\n\n        self[v] = part;\n      });\n\n      if (baseUri) {\n        if (!self.protocol) {\n          self.protocol = baseUri.protocol;\n        }\n\n        if (!self.userInfo) {\n          self.userInfo = baseUri.userInfo;\n        }\n\n        if (!self.port && self.host === 'mce_host') {\n          self.port = baseUri.port;\n        }\n\n        if (!self.host || self.host === 'mce_host') {\n          self.host = baseUri.host;\n        }\n\n        self.source = '';\n      }\n\n      if (isProtocolRelative) {\n        self.protocol = '';\n      }\n    }\n\n    static parseDataUri(uri) {\n      let type;\n      const uriComponents = decodeURIComponent(uri).split(',');\n      const matches = /data:([^;]+)/.exec(uriComponents[0]);\n\n      if (matches) {\n        type = matches[1];\n      }\n\n      return {\n        type,\n        data: uriComponents[1]\n      };\n    }\n\n    static isDomSafe(uri, context) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (options.allow_script_urls) {\n        return true;\n      } else {\n        const decodedUri = Entities.decode(uri).replace(/[\\s\\u0000-\\u001F]+/g, '');\n        return !isInvalidUri(options, decodedUri, context);\n      }\n    }\n\n    static getDocumentBaseUrl(loc) {\n      let baseUrl;\n\n      if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {\n        baseUrl = loc.href;\n      } else {\n        baseUrl = loc.protocol + '//' + loc.host + loc.pathname;\n      }\n\n      if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(baseUrl)) {\n        baseUrl = baseUrl.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\n\n        if (!/[\\/\\\\]$/.test(baseUrl)) {\n          baseUrl += '/';\n        }\n      }\n\n      return baseUrl;\n    }\n\n    setPath(path) {\n      const pathMatch = /^(.*?)\\/?(\\w+)?$/.exec(path);\n      this.path = pathMatch[0];\n      this.directory = pathMatch[1];\n      this.file = pathMatch[2];\n      this.source = '';\n      this.getURI();\n    }\n\n    toRelative(uri) {\n      let output;\n\n      if (uri === './') {\n        return uri;\n      }\n\n      const relativeUri = new URI(uri, {\n        base_uri: this\n      });\n\n      if (relativeUri.host !== 'mce_host' && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== '') {\n        return relativeUri.getURI();\n      }\n\n      const tu = this.getURI(),\n            uu = relativeUri.getURI();\n\n      if (tu === uu || tu.charAt(tu.length - 1) === '/' && tu.substr(0, tu.length - 1) === uu) {\n        return tu;\n      }\n\n      output = this.toRelPath(this.path, relativeUri.path);\n\n      if (relativeUri.query) {\n        output += '?' + relativeUri.query;\n      }\n\n      if (relativeUri.anchor) {\n        output += '#' + relativeUri.anchor;\n      }\n\n      return output;\n    }\n\n    toAbsolute(uri, noHost) {\n      const absoluteUri = new URI(uri, {\n        base_uri: this\n      });\n      return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));\n    }\n\n    isSameOrigin(uri) {\n      if (this.host == uri.host && this.protocol == uri.protocol) {\n        if (this.port == uri.port) {\n          return true;\n        }\n\n        const defaultPort = DEFAULT_PORTS[this.protocol];\n\n        if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    toRelPath(base, path) {\n      let breakPoint = 0,\n          out = '',\n          i,\n          l;\n      const normalizedBase = base.substring(0, base.lastIndexOf('/')).split('/');\n      const items = path.split('/');\n\n      if (normalizedBase.length >= items.length) {\n        for (i = 0, l = normalizedBase.length; i < l; i++) {\n          if (i >= items.length || normalizedBase[i] !== items[i]) {\n            breakPoint = i + 1;\n            break;\n          }\n        }\n      }\n\n      if (normalizedBase.length < items.length) {\n        for (i = 0, l = items.length; i < l; i++) {\n          if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {\n            breakPoint = i + 1;\n            break;\n          }\n        }\n      }\n\n      if (breakPoint === 1) {\n        return path;\n      }\n\n      for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {\n        out += '../';\n      }\n\n      for (i = breakPoint - 1, l = items.length; i < l; i++) {\n        if (i !== breakPoint - 1) {\n          out += '/' + items[i];\n        } else {\n          out += items[i];\n        }\n      }\n\n      return out;\n    }\n\n    toAbsPath(base, path) {\n      let i,\n          nb = 0,\n          o = [],\n          outPath;\n      const tr = /\\/$/.test(path) ? '/' : '';\n      let normalizedBase = base.split('/');\n      const normalizedPath = path.split('/');\n      each$5(normalizedBase, k => {\n        if (k) {\n          o.push(k);\n        }\n      });\n      normalizedBase = o;\n\n      for (i = normalizedPath.length - 1, o = []; i >= 0; i--) {\n        if (normalizedPath[i].length === 0 || normalizedPath[i] === '.') {\n          continue;\n        }\n\n        if (normalizedPath[i] === '..') {\n          nb++;\n          continue;\n        }\n\n        if (nb > 0) {\n          nb--;\n          continue;\n        }\n\n        o.push(normalizedPath[i]);\n      }\n\n      i = normalizedBase.length - nb;\n\n      if (i <= 0) {\n        outPath = reverse(o).join('/');\n      } else {\n        outPath = normalizedBase.slice(0, i).join('/') + '/' + reverse(o).join('/');\n      }\n\n      if (outPath.indexOf('/') !== 0) {\n        outPath = '/' + outPath;\n      }\n\n      if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {\n        outPath += tr;\n      }\n\n      return outPath;\n    }\n\n    getURI() {\n      let noProtoHost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      let s;\n\n      if (!this.source || noProtoHost) {\n        s = '';\n\n        if (!noProtoHost) {\n          if (this.protocol) {\n            s += this.protocol + '://';\n          } else {\n            s += '//';\n          }\n\n          if (this.userInfo) {\n            s += this.userInfo + '@';\n          }\n\n          if (this.host) {\n            s += this.host;\n          }\n\n          if (this.port) {\n            s += ':' + this.port;\n          }\n        }\n\n        if (this.path) {\n          s += this.path;\n        }\n\n        if (this.query) {\n          s += '?' + this.query;\n        }\n\n        if (this.anchor) {\n          s += '#' + this.anchor;\n        }\n\n        this.source = s;\n      }\n\n      return this.source;\n    }\n\n  }\n\n  const makeMap = Tools.makeMap,\n        each$4 = Tools.each,\n        explode$1 = Tools.explode,\n        extend$1 = Tools.extend;\n  const basePurifyConfig = {\n    IN_PLACE: true,\n    ALLOW_UNKNOWN_PROTOCOLS: true,\n    ALLOWED_TAGS: ['#comment', '#cdata-section', 'body'],\n    ALLOWED_ATTR: []\n  };\n  const filteredUrlAttrs = Tools.makeMap('src,href,data,background,action,formaction,poster,xlink:href');\n  const internalElementAttr = 'data-mce-type';\n\n  const getPurifyConfig = (settings, mimeType) => {\n    const config = { ...basePurifyConfig\n    };\n    config.PARSER_MEDIA_TYPE = mimeType;\n\n    if (settings.allow_script_urls) {\n      config.ALLOWED_URI_REGEXP = /.*/;\n    } else if (settings.allow_html_data_urls) {\n      config.ALLOWED_URI_REGEXP = /^(?!(\\w+script|mhtml):)/i;\n    }\n\n    return config;\n  };\n\n  const setupPurify = (settings, schema) => {\n    const purify$1 = purify();\n    const validate = settings.validate;\n    let uid = 0;\n    purify$1.addHook('uponSanitizeElement', (ele, evt) => {\n      var _a, _b;\n\n      if (ele.nodeType === COMMENT && !settings.allow_conditional_comments && /^\\[if/i.test(ele.nodeValue)) {\n        ele.nodeValue = ' ' + ele.nodeValue;\n      }\n\n      const tagName = evt.tagName;\n\n      if (ele.nodeType !== ELEMENT || tagName === 'body') {\n        return;\n      }\n\n      const element = SugarElement.fromDom(ele);\n      const isInternalElement = has$1(element, internalElementAttr);\n      const bogus = get$9(element, 'data-mce-bogus');\n\n      if (!isInternalElement && isString(bogus)) {\n        if (bogus === 'all') {\n          remove$5(element);\n        } else {\n          unwrap(element);\n        }\n\n        return;\n      }\n\n      const rule = schema.getElementRule(tagName.toLowerCase());\n\n      if (validate && !rule) {\n        unwrap(element);\n        return;\n      } else {\n        evt.allowedTags[tagName] = true;\n      }\n\n      if (validate && !isInternalElement) {\n        each$g((_a = rule.attributesForced) !== null && _a !== void 0 ? _a : [], attr => {\n          set$2(element, attr.name, attr.value === '{$uid}' ? `mce_${uid++}` : attr.value);\n        });\n        each$g((_b = rule.attributesDefault) !== null && _b !== void 0 ? _b : [], attr => {\n          if (!has$1(element, attr.name)) {\n            set$2(element, attr.name, attr.value === '{$uid}' ? `mce_${uid++}` : attr.value);\n          }\n        });\n\n        if (rule.attributesRequired && !exists(rule.attributesRequired, attr => has$1(element, attr))) {\n          unwrap(element);\n          return;\n        }\n\n        if (rule.removeEmptyAttrs && hasNone(element)) {\n          unwrap(element);\n          return;\n        }\n\n        if (rule.outputName && rule.outputName !== tagName.toLowerCase()) {\n          mutate(element, rule.outputName);\n        }\n      }\n    });\n    purify$1.addHook('uponSanitizeAttribute', (ele, evt) => {\n      const tagName = ele.tagName.toLowerCase();\n      const {\n        attrName,\n        attrValue\n      } = evt;\n      evt.keepAttr = !validate || schema.isValid(tagName, attrName) || startsWith(attrName, 'data-') || startsWith(attrName, 'aria-');\n\n      if (attrName in filteredUrlAttrs && isInvalidUri(settings, attrValue, tagName)) {\n        evt.keepAttr = false;\n      }\n\n      if (evt.keepAttr) {\n        evt.allowedAttributes[attrName] = true;\n\n        if (attrName in schema.getBoolAttrs()) {\n          evt.attrValue = attrName;\n        }\n\n        if (settings.allow_svg_data_urls && startsWith(attrValue, 'data:image/svg+xml')) {\n          evt.forceKeepAttr = true;\n        }\n      } else if (ele.hasAttribute(internalElementAttr) && (attrName === 'id' || attrName === 'class' || attrName === 'style')) {\n        evt.forceKeepAttr = true;\n      }\n    });\n    return purify$1;\n  };\n\n  const transferChildren = (parent, nativeParent, specialElements) => {\n    const parentName = parent.name;\n    const isSpecial = parentName in specialElements && parentName !== 'title' && parentName !== 'textarea';\n    const childNodes = nativeParent.childNodes;\n\n    for (let ni = 0, nl = childNodes.length; ni < nl; ni++) {\n      const nativeChild = childNodes[ni];\n      const child = new AstNode(nativeChild.nodeName.toLowerCase(), nativeChild.nodeType);\n\n      if (isElement$6(nativeChild)) {\n        const attributes = nativeChild.attributes;\n\n        for (let ai = 0, al = attributes.length; ai < al; ai++) {\n          const attr = attributes[ai];\n          child.attr(attr.name, attr.value);\n        }\n      } else if (isText$8(nativeChild)) {\n        child.value = nativeChild.data;\n\n        if (isSpecial) {\n          child.raw = true;\n        }\n      } else if (isComment(nativeChild) || isCData(nativeChild) || isPi(nativeChild)) {\n        child.value = nativeChild.data;\n      }\n\n      transferChildren(child, nativeChild, specialElements);\n      parent.append(child);\n    }\n  };\n\n  const walkTree = (root, preprocessors, postprocessors) => {\n    const traverseOrder = [];\n\n    for (let node = root, lastNode = node; isNonNullable(node); lastNode = node, node = node.walk()) {\n      each$g(preprocessors, preprocess => preprocess(node));\n\n      if (isNullable(node.parent) && node !== root) {\n        node = lastNode;\n      } else {\n        traverseOrder.push(node);\n      }\n    }\n\n    for (let i = traverseOrder.length - 1; i >= 0; i--) {\n      const node = traverseOrder[i];\n      each$g(postprocessors, postprocess => postprocess(node));\n    }\n  };\n\n  const whitespaceCleaner = (root, schema, settings, args) => {\n    const validate = settings.validate;\n    const nonEmptyElements = schema.getNonEmptyElements();\n    const whitespaceElements = schema.getWhitespaceElements();\n    const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\n    const allWhiteSpaceRegExp = /[ \\t\\r\\n]+/g;\n    const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n    const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n\n    const hasWhitespaceParent = node => {\n      node = node.parent;\n\n      while (isNonNullable(node)) {\n        if (node.name in whitespaceElements) {\n          return true;\n        } else {\n          node = node.parent;\n        }\n      }\n\n      return false;\n    };\n\n    const isAtEdgeOfBlock = (node, start) => {\n      const neighbour = start ? node.prev : node.next;\n\n      if (isNonNullable(neighbour)) {\n        return false;\n      }\n\n      return node.parent.name in blockElements && (node.parent !== root || args.isRootContent);\n    };\n\n    const preprocess = node => {\n      if (node.type === 3) {\n        if (!hasWhitespaceParent(node)) {\n          let text = node.value;\n          text = text.replace(allWhiteSpaceRegExp, ' ');\n\n          if (isLineBreakNode(node.prev, blockElements) || isAtEdgeOfBlock(node, true)) {\n            text = text.replace(startWhiteSpaceRegExp, '');\n          }\n\n          if (text.length === 0) {\n            node.remove();\n          } else {\n            node.value = text;\n          }\n        }\n      }\n    };\n\n    const postprocess = node => {\n      var _a;\n\n      if (node.type === 1) {\n        const elementRule = schema.getElementRule(node.name);\n\n        if (validate && elementRule) {\n          const isNodeEmpty = isEmpty(schema, nonEmptyElements, whitespaceElements, node);\n\n          if (elementRule.removeEmpty && isNodeEmpty) {\n            if (blockElements[node.name]) {\n              node.remove();\n            } else {\n              node.unwrap();\n            }\n          } else if (elementRule.paddEmpty && (isNodeEmpty || isPaddedWithNbsp(node))) {\n            paddEmptyNode(settings, args, blockElements, node);\n          }\n        }\n      } else if (node.type === 3) {\n        if (!hasWhitespaceParent(node)) {\n          let text = node.value;\n\n          if (blockElements[(_a = node.next) === null || _a === void 0 ? void 0 : _a.name] || isAtEdgeOfBlock(node, false)) {\n            text = text.replace(endWhiteSpaceRegExp, '');\n          }\n\n          if (text.length === 0) {\n            node.remove();\n          } else {\n            node.value = text;\n          }\n        }\n      }\n    };\n\n    return [preprocess, postprocess];\n  };\n\n  const getRootBlockName = (settings, args) => {\n    var _a;\n\n    const name = (_a = args.forced_root_block) !== null && _a !== void 0 ? _a : settings.forced_root_block;\n\n    if (name === false) {\n      return '';\n    } else if (name === true) {\n      return 'p';\n    } else {\n      return name;\n    }\n  };\n\n  const DomParser = function () {\n    let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Schema();\n    const nodeFilters = {};\n    const attributeFilters = [];\n    const defaultedSettings = {\n      validate: true,\n      root_name: 'body',\n      ...settings\n    };\n    const parser = new DOMParser();\n    const purify = setupPurify(defaultedSettings, schema);\n\n    const parseAndSanitizeWithContext = function (html, rootName) {\n      let format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'html';\n      const mimeType = format === 'xhtml' ? 'application/xhtml+xml' : 'text/html';\n      const isSpecialRoot = has$2(schema.getSpecialElements(), rootName.toLowerCase());\n      const content = isSpecialRoot ? `<${rootName}>${html}</${rootName}>` : html;\n      const wrappedHtml = format === 'xhtml' ? `<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>${content}</body></html>` : `<body>${content}</body>`;\n      const body = parser.parseFromString(wrappedHtml, mimeType).body;\n      purify.sanitize(body, getPurifyConfig(defaultedSettings, mimeType));\n      purify.removed = [];\n      return isSpecialRoot ? body.firstChild : body;\n    };\n\n    const addNodeFilter = (name, callback) => {\n      each$4(explode$1(name), name => {\n        let list = nodeFilters[name];\n\n        if (!list) {\n          nodeFilters[name] = list = [];\n        }\n\n        list.push(callback);\n      });\n    };\n\n    const getNodeFilters = () => {\n      const out = [];\n\n      for (const name in nodeFilters) {\n        if (has$2(nodeFilters, name)) {\n          out.push({\n            name,\n            callbacks: nodeFilters[name]\n          });\n        }\n      }\n\n      return out;\n    };\n\n    const addAttributeFilter = (name, callback) => {\n      each$4(explode$1(name), name => {\n        let i;\n\n        for (i = 0; i < attributeFilters.length; i++) {\n          if (attributeFilters[i].name === name) {\n            attributeFilters[i].callbacks.push(callback);\n            return;\n          }\n        }\n\n        attributeFilters.push({\n          name,\n          callbacks: [callback]\n        });\n      });\n    };\n\n    const getAttributeFilters = () => [].concat(attributeFilters);\n\n    const findInvalidChildren = (node, invalidChildren) => {\n      const parent = node.parent;\n\n      if (parent && schema.children[node.name] && !schema.isValidChild(parent.name, node.name)) {\n        invalidChildren.push(node);\n      }\n    };\n\n    const addRootBlocks = (rootNode, rootBlockName) => {\n      const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\n      const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n      const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n      let node = rootNode.firstChild,\n          rootBlockNode = null;\n\n      const trim = rootBlock => {\n        if (rootBlock) {\n          node = rootBlock.firstChild;\n\n          if (node && node.type === 3) {\n            node.value = node.value.replace(startWhiteSpaceRegExp, '');\n          }\n\n          node = rootBlock.lastChild;\n\n          if (node && node.type === 3) {\n            node.value = node.value.replace(endWhiteSpaceRegExp, '');\n          }\n        }\n      };\n\n      if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {\n        return;\n      }\n\n      while (node) {\n        const next = node.next;\n\n        if (node.type === 3 || node.type === 1 && node.name !== 'p' && !blockElements[node.name] && !node.attr(internalElementAttr)) {\n          if (!rootBlockNode) {\n            rootBlockNode = new AstNode(rootBlockName, 1);\n            rootBlockNode.attr(defaultedSettings.forced_root_block_attrs);\n            rootNode.insert(rootBlockNode, node);\n            rootBlockNode.append(node);\n          } else {\n            rootBlockNode.append(node);\n          }\n        } else {\n          trim(rootBlockNode);\n          rootBlockNode = null;\n        }\n\n        node = next;\n      }\n\n      trim(rootBlockNode);\n    };\n\n    const parse = function (html) {\n      let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _a;\n\n      const validate = defaultedSettings.validate;\n      const rootName = (_a = args.context) !== null && _a !== void 0 ? _a : defaultedSettings.root_name;\n      const element = parseAndSanitizeWithContext(html, rootName, args.format);\n      const rootNode = new AstNode(rootName, 11);\n      transferChildren(rootNode, element, schema.getSpecialElements());\n      const [whitespacePre, whitespacePost] = whitespaceCleaner(rootNode, schema, defaultedSettings, args);\n      const invalidChildren = [];\n      const invalidFinder = validate ? node => findInvalidChildren(node, invalidChildren) : noop;\n      const nodeFilters = getNodeFilters();\n      const matches = {\n        nodes: {},\n        attributes: {}\n      };\n\n      const matchFinder = node => matchNode$1(nodeFilters, attributeFilters, node, matches);\n\n      walkTree(rootNode, [whitespacePre, matchFinder], [whitespacePost, invalidFinder]);\n      invalidChildren.reverse();\n\n      if (validate && invalidChildren.length > 0) {\n        if (args.context) {\n          const {\n            pass: topLevelChildren,\n            fail: otherChildren\n          } = partition$2(invalidChildren, child => child.parent === rootNode);\n          cleanInvalidNodes(otherChildren, schema, matchFinder);\n          args.invalid = topLevelChildren.length > 0;\n        } else {\n          cleanInvalidNodes(invalidChildren, schema, matchFinder);\n        }\n      }\n\n      const rootBlockName = getRootBlockName(defaultedSettings, args);\n\n      if (rootBlockName && (rootNode.name === 'body' || args.isRootContent)) {\n        addRootBlocks(rootNode, rootBlockName);\n      }\n\n      if (!args.invalid) {\n        runFilters(matches, args);\n      }\n\n      return rootNode;\n    };\n\n    const exports = {\n      schema,\n      addAttributeFilter,\n      getAttributeFilters,\n      addNodeFilter,\n      getNodeFilters,\n      parse\n    };\n    register$4(exports, defaultedSettings);\n    register$5(exports, defaultedSettings, schema);\n    return exports;\n  };\n\n  const serializeContent = content => isTreeNode(content) ? HtmlSerializer({\n    validate: false\n  }).serialize(content) : content;\n\n  const withSerializedContent = (content, fireEvent) => {\n    const serializedContent = serializeContent(content);\n    const eventArgs = fireEvent(serializedContent);\n\n    if (eventArgs.isDefaultPrevented()) {\n      return eventArgs;\n    } else if (isTreeNode(content)) {\n      if (eventArgs.content !== serializedContent) {\n        const rootNode = DomParser({\n          validate: false,\n          forced_root_block: false\n        }).parse(eventArgs.content, {\n          context: content.name\n        });\n        return { ...eventArgs,\n          content: rootNode\n        };\n      } else {\n        return { ...eventArgs,\n          content\n        };\n      }\n    } else {\n      return eventArgs;\n    }\n  };\n\n  const preProcessGetContent = (editor, args) => {\n    if (args.no_events) {\n      return Result.value(args);\n    } else {\n      const eventArgs = fireBeforeGetContent(editor, args);\n\n      if (eventArgs.isDefaultPrevented()) {\n        return Result.error(fireGetContent(editor, {\n          content: '',\n          ...eventArgs\n        }).content);\n      } else {\n        return Result.value(eventArgs);\n      }\n    }\n  };\n\n  const postProcessGetContent = (editor, content, args) => {\n    if (args.no_events) {\n      return content;\n    } else {\n      const processedEventArgs = withSerializedContent(content, c => fireGetContent(editor, { ...args,\n        content: c\n      }));\n      return processedEventArgs.content;\n    }\n  };\n\n  const preProcessSetContent = (editor, args) => {\n    if (args.no_events) {\n      return Result.value(args);\n    } else {\n      const processedEventArgs = withSerializedContent(args.content, content => fireBeforeSetContent(editor, { ...args,\n        content\n      }));\n\n      if (processedEventArgs.isDefaultPrevented()) {\n        fireSetContent(editor, processedEventArgs);\n        return Result.error(undefined);\n      } else {\n        return Result.value(processedEventArgs);\n      }\n    }\n  };\n\n  const postProcessSetContent = (editor, content, args) => {\n    if (!args.no_events) {\n      fireSetContent(editor, { ...args,\n        content\n      });\n    }\n  };\n\n  const tableModel = (element, width, rows) => ({\n    element,\n    width,\n    rows\n  });\n\n  const tableRow = (element, cells) => ({\n    element,\n    cells\n  });\n\n  const cellPosition = (x, y) => ({\n    x,\n    y\n  });\n\n  const getSpan = (td, key) => {\n    const value = parseInt(get$9(td, key), 10);\n    return isNaN(value) ? 1 : value;\n  };\n\n  const fillout = (table, x, y, tr, td) => {\n    const rowspan = getSpan(td, 'rowspan');\n    const colspan = getSpan(td, 'colspan');\n    const rows = table.rows;\n\n    for (let y2 = y; y2 < y + rowspan; y2++) {\n      if (!rows[y2]) {\n        rows[y2] = tableRow(deep$1(tr), []);\n      }\n\n      for (let x2 = x; x2 < x + colspan; x2++) {\n        const cells = rows[y2].cells;\n        cells[x2] = y2 === y && x2 === x ? td : shallow$1(td);\n      }\n    }\n  };\n\n  const cellExists = (table, x, y) => {\n    const rows = table.rows;\n    const cells = rows[y] ? rows[y].cells : [];\n    return !!cells[x];\n  };\n\n  const skipCellsX = (table, x, y) => {\n    while (cellExists(table, x, y)) {\n      x++;\n    }\n\n    return x;\n  };\n\n  const getWidth = rows => {\n    return foldl(rows, (acc, row) => {\n      return row.cells.length > acc ? row.cells.length : acc;\n    }, 0);\n  };\n\n  const findElementPos = (table, element) => {\n    const rows = table.rows;\n\n    for (let y = 0; y < rows.length; y++) {\n      const cells = rows[y].cells;\n\n      for (let x = 0; x < cells.length; x++) {\n        if (eq(cells[x], element)) {\n          return Optional.some(cellPosition(x, y));\n        }\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const extractRows = (table, sx, sy, ex, ey) => {\n    const newRows = [];\n    const rows = table.rows;\n\n    for (let y = sy; y <= ey; y++) {\n      const cells = rows[y].cells;\n      const slice = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);\n      newRows.push(tableRow(rows[y].element, slice));\n    }\n\n    return newRows;\n  };\n\n  const subTable = (table, startPos, endPos) => {\n    const sx = startPos.x,\n          sy = startPos.y;\n    const ex = endPos.x,\n          ey = endPos.y;\n    const newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);\n    return tableModel(table.element, getWidth(newRows), newRows);\n  };\n\n  const createDomTable = (table, rows) => {\n    const tableElement = shallow$1(table.element);\n    const tableBody = SugarElement.fromTag('tbody');\n    append(tableBody, rows);\n    append$1(tableElement, tableBody);\n    return tableElement;\n  };\n\n  const modelRowsToDomRows = table => {\n    return map$3(table.rows, row => {\n      const cells = map$3(row.cells, cell => {\n        const td = deep$1(cell);\n        remove$a(td, 'colspan');\n        remove$a(td, 'rowspan');\n        return td;\n      });\n      const tr = shallow$1(row.element);\n      append(tr, cells);\n      return tr;\n    });\n  };\n\n  const fromDom = tableElm => {\n    const table = tableModel(shallow$1(tableElm), 0, []);\n    each$g(descendants(tableElm, 'tr'), (tr, y) => {\n      each$g(descendants(tr, 'td,th'), (td, x) => {\n        fillout(table, skipCellsX(table, x, y), y, tr, td);\n      });\n    });\n    return tableModel(table.element, getWidth(table.rows), table.rows);\n  };\n\n  const toDom = table => {\n    return createDomTable(table, modelRowsToDomRows(table));\n  };\n\n  const subsection = (table, startElement, endElement) => {\n    return findElementPos(table, startElement).bind(startPos => {\n      return findElementPos(table, endElement).map(endPos => {\n        return subTable(table, startPos, endPos);\n      });\n    });\n  };\n\n  const findParentListContainer = parents => find$2(parents, elm => name(elm) === 'ul' || name(elm) === 'ol');\n\n  const getFullySelectedListWrappers = (parents, rng) => find$2(parents, elm => name(elm) === 'li' && hasAllContentsSelected(elm, rng)).fold(constant([]), _li => findParentListContainer(parents).map(listCont => {\n    const listElm = SugarElement.fromTag(name(listCont));\n    const listStyles = filter$5(getAllRaw(listCont), (_style, name) => startsWith(name, 'list-style'));\n    setAll(listElm, listStyles);\n    return [SugarElement.fromTag('li'), listElm];\n  }).getOr([]));\n\n  const wrap = (innerElm, elms) => {\n    const wrapped = foldl(elms, (acc, elm) => {\n      append$1(elm, acc);\n      return elm;\n    }, innerElm);\n    return elms.length > 0 ? fromElements([wrapped]) : wrapped;\n  };\n\n  const directListWrappers = commonAnchorContainer => {\n    if (isListItem(commonAnchorContainer)) {\n      return parent(commonAnchorContainer).filter(isList).fold(constant([]), listElm => [commonAnchorContainer, listElm]);\n    } else {\n      return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];\n    }\n  };\n\n  const getWrapElements = (rootNode, rng) => {\n    const commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);\n    const parents = parentsAndSelf(commonAnchorContainer, rootNode);\n    const wrapElements = filter$6(parents, elm => isInline$1(elm) || isHeading(elm));\n    const listWrappers = getFullySelectedListWrappers(parents, rng);\n    const allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));\n    return map$3(allWrappers, shallow$1);\n  };\n\n  const emptyFragment = () => fromElements([]);\n\n  const getFragmentFromRange = (rootNode, rng) => wrap(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng));\n\n  const getParentTable = (rootElm, cell) => ancestor$2(cell, 'table', curry(eq, rootElm));\n\n  const getTableFragment = (rootNode, selectedTableCells) => getParentTable(rootNode, selectedTableCells[0]).bind(tableElm => {\n    const firstCell = selectedTableCells[0];\n    const lastCell = selectedTableCells[selectedTableCells.length - 1];\n    const fullTableModel = fromDom(tableElm);\n    return subsection(fullTableModel, firstCell, lastCell).map(sectionedTableModel => fromElements([toDom(sectionedTableModel)]));\n  }).getOrThunk(emptyFragment);\n\n  const getSelectionFragment = (rootNode, ranges) => ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0]);\n\n  const read$3 = (rootNode, ranges) => {\n    const selectedCells = getCellsFromElementOrRanges(ranges, rootNode);\n    return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges);\n  };\n\n  const isCollapsibleWhitespace = (text, index) => index >= 0 && index < text.length && isWhiteSpace(text.charAt(index));\n\n  const getInnerText = bin => {\n    return trim$1(bin.innerText);\n  };\n\n  const getContextNodeName = parentBlockOpt => parentBlockOpt.map(block => block.nodeName).getOr('div').toLowerCase();\n\n  const getTextContent = editor => Optional.from(editor.selection.getRng()).map(rng => {\n    const parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));\n    const body = editor.getBody();\n    const contextNodeName = getContextNodeName(parentBlockOpt);\n    const bin = editor.dom.add(body, contextNodeName, {\n      'data-mce-bogus': 'all',\n      'style': 'overflow: hidden; opacity: 0;'\n    }, rng.cloneContents());\n    const text = getInnerText(bin);\n    const nonRenderedText = trim$1(bin.textContent);\n    editor.dom.remove(bin);\n\n    if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {\n      const parentBlock = parentBlockOpt.getOr(body);\n      const parentBlockText = getInnerText(parentBlock);\n      const textIndex = parentBlockText.indexOf(text);\n\n      if (textIndex === -1) {\n        return text;\n      } else {\n        const hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);\n        const hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text.length);\n        return (hasProceedingSpace ? ' ' : '') + text + (hasTrailingSpace ? ' ' : '');\n      }\n    } else {\n      return text;\n    }\n  }).getOr('');\n\n  const getSerializedContent = (editor, args) => {\n    const rng = editor.selection.getRng(),\n          tmpElm = editor.dom.create('body');\n    const sel = editor.selection.getSel();\n    const ranges = processRanges(editor, getRanges$1(sel));\n    const fragment = args.contextual ? read$3(SugarElement.fromDom(editor.getBody()), ranges).dom : rng.cloneContents();\n\n    if (fragment) {\n      tmpElm.appendChild(fragment);\n    }\n\n    return editor.selection.serializer.serialize(tmpElm, args);\n  };\n\n  const extractSelectedContent = (editor, args) => {\n    if (args.format === 'text') {\n      return getTextContent(editor);\n    } else {\n      const content = getSerializedContent(editor, args);\n\n      if (args.format === 'tree') {\n        return content;\n      } else {\n        return editor.selection.isCollapsed() ? '' : content;\n      }\n    }\n  };\n\n  const setupArgs$3 = (args, format) => ({ ...args,\n    format,\n    get: true,\n    selection: true,\n    getInner: true\n  });\n\n  const getSelectedContentInternal = function (editor, format) {\n    let args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const defaultedArgs = setupArgs$3(args, format);\n    return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\n      const content = extractSelectedContent(editor, updatedArgs);\n      return postProcessGetContent(editor, content, updatedArgs);\n    });\n  };\n\n  const KEEP = 0,\n        INSERT = 1,\n        DELETE = 2;\n\n  const diff = (left, right) => {\n    const size = left.length + right.length + 2;\n    const vDown = new Array(size);\n    const vUp = new Array(size);\n\n    const snake = (start, end, diag) => {\n      return {\n        start,\n        end,\n        diag\n      };\n    };\n\n    const buildScript = (start1, end1, start2, end2, script) => {\n      const middle = getMiddleSnake(start1, end1, start2, end2);\n\n      if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {\n        let i = start1;\n        let j = start2;\n\n        while (i < end1 || j < end2) {\n          if (i < end1 && j < end2 && left[i] === right[j]) {\n            script.push([KEEP, left[i]]);\n            ++i;\n            ++j;\n          } else {\n            if (end1 - start1 > end2 - start2) {\n              script.push([DELETE, left[i]]);\n              ++i;\n            } else {\n              script.push([INSERT, right[j]]);\n              ++j;\n            }\n          }\n        }\n      } else {\n        buildScript(start1, middle.start, start2, middle.start - middle.diag, script);\n\n        for (let i2 = middle.start; i2 < middle.end; ++i2) {\n          script.push([KEEP, left[i2]]);\n        }\n\n        buildScript(middle.end, end1, middle.end - middle.diag, end2, script);\n      }\n    };\n\n    const buildSnake = (start, diag, end1, end2) => {\n      let end = start;\n\n      while (end - diag < end2 && end < end1 && left[end] === right[end - diag]) {\n        ++end;\n      }\n\n      return snake(start, end, diag);\n    };\n\n    const getMiddleSnake = (start1, end1, start2, end2) => {\n      const m = end1 - start1;\n      const n = end2 - start2;\n\n      if (m === 0 || n === 0) {\n        return null;\n      }\n\n      const delta = m - n;\n      const sum = n + m;\n      const offset = (sum % 2 === 0 ? sum : sum + 1) / 2;\n      vDown[1 + offset] = start1;\n      vUp[1 + offset] = end1 + 1;\n      let d, k, i, x, y;\n\n      for (d = 0; d <= offset; ++d) {\n        for (k = -d; k <= d; k += 2) {\n          i = k + offset;\n\n          if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {\n            vDown[i] = vDown[i + 1];\n          } else {\n            vDown[i] = vDown[i - 1] + 1;\n          }\n\n          x = vDown[i];\n          y = x - start1 + start2 - k;\n\n          while (x < end1 && y < end2 && left[x] === right[y]) {\n            vDown[i] = ++x;\n            ++y;\n          }\n\n          if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {\n            if (vUp[i - delta] <= vDown[i]) {\n              return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);\n            }\n          }\n        }\n\n        for (k = delta - d; k <= delta + d; k += 2) {\n          i = k + offset - delta;\n\n          if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {\n            vUp[i] = vUp[i + 1] - 1;\n          } else {\n            vUp[i] = vUp[i - 1];\n          }\n\n          x = vUp[i] - 1;\n          y = x - start1 + start2 - k;\n\n          while (x >= start1 && y >= start2 && left[x] === right[y]) {\n            vUp[i] = x--;\n            y--;\n          }\n\n          if (delta % 2 === 0 && -d <= k && k <= d) {\n            if (vUp[i] <= vDown[i + delta]) {\n              return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n            }\n          }\n        }\n      }\n    };\n\n    const script = [];\n    buildScript(0, left.length, 0, right.length, script);\n    return script;\n  };\n\n  const getOuterHtml = elm => {\n    if (isElement$6(elm)) {\n      return elm.outerHTML;\n    } else if (isText$8(elm)) {\n      return Entities.encodeRaw(elm.data, false);\n    } else if (isComment(elm)) {\n      return '<!--' + elm.data + '-->';\n    }\n\n    return '';\n  };\n\n  const createFragment = html => {\n    let node;\n    const container = document.createElement('div');\n    const frag = document.createDocumentFragment();\n\n    if (html) {\n      container.innerHTML = html;\n    }\n\n    while (node = container.firstChild) {\n      frag.appendChild(node);\n    }\n\n    return frag;\n  };\n\n  const insertAt = (elm, html, index) => {\n    const fragment = createFragment(html);\n\n    if (elm.hasChildNodes() && index < elm.childNodes.length) {\n      const target = elm.childNodes[index];\n      target.parentNode.insertBefore(fragment, target);\n    } else {\n      elm.appendChild(fragment);\n    }\n  };\n\n  const removeAt = (elm, index) => {\n    if (elm.hasChildNodes() && index < elm.childNodes.length) {\n      const target = elm.childNodes[index];\n      target.parentNode.removeChild(target);\n    }\n  };\n\n  const applyDiff = (diff, elm) => {\n    let index = 0;\n    each$g(diff, action => {\n      if (action[0] === KEEP) {\n        index++;\n      } else if (action[0] === INSERT) {\n        insertAt(elm, action[1], index);\n        index++;\n      } else if (action[0] === DELETE) {\n        removeAt(elm, index);\n      }\n    });\n  };\n\n  const read$2 = elm => {\n    return filter$6(map$3(from(elm.childNodes), getOuterHtml), item => {\n      return item.length > 0;\n    });\n  };\n\n  const write = (fragments, elm) => {\n    const currentFragments = map$3(from(elm.childNodes), getOuterHtml);\n    applyDiff(diff(currentFragments, fragments), elm);\n    return elm;\n  };\n\n  const lazyTempDocument = cached(() => document.implementation.createHTMLDocument('undo'));\n\n  const hasIframes = html => {\n    return html.indexOf('</iframe>') !== -1;\n  };\n\n  const createFragmentedLevel = fragments => {\n    return {\n      type: 'fragmented',\n      fragments,\n      content: '',\n      bookmark: null,\n      beforeBookmark: null\n    };\n  };\n\n  const createCompleteLevel = content => {\n    return {\n      type: 'complete',\n      fragments: null,\n      content,\n      bookmark: null,\n      beforeBookmark: null\n    };\n  };\n\n  const createFromEditor = editor => {\n    const fragments = read$2(editor.getBody());\n    const trimmedFragments = bind$3(fragments, html => {\n      const trimmed = trimInternal(editor.serializer, html);\n      return trimmed.length > 0 ? [trimmed] : [];\n    });\n    const content = trimmedFragments.join('');\n    return hasIframes(content) ? createFragmentedLevel(trimmedFragments) : createCompleteLevel(content);\n  };\n\n  const applyToEditor = (editor, level, before) => {\n    const bookmark = before ? level.beforeBookmark : level.bookmark;\n\n    if (level.type === 'fragmented') {\n      write(level.fragments, editor.getBody());\n    } else {\n      editor.setContent(level.content, {\n        format: 'raw',\n        no_selection: isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true\n      });\n    }\n\n    editor.selection.moveToBookmark(bookmark);\n  };\n\n  const getLevelContent = level => {\n    return level.type === 'fragmented' ? level.fragments.join('') : level.content;\n  };\n\n  const getCleanLevelContent = level => {\n    const elm = SugarElement.fromTag('body', lazyTempDocument());\n    set(elm, getLevelContent(level));\n    each$g(descendants(elm, '*[data-mce-bogus]'), unwrap);\n    return get$6(elm);\n  };\n\n  const hasEqualContent = (level1, level2) => getLevelContent(level1) === getLevelContent(level2);\n\n  const hasEqualCleanedContent = (level1, level2) => getCleanLevelContent(level1) === getCleanLevelContent(level2);\n\n  const isEq$1 = (level1, level2) => {\n    if (!level1 || !level2) {\n      return false;\n    } else if (hasEqualContent(level1, level2)) {\n      return true;\n    } else {\n      return hasEqualCleanedContent(level1, level2);\n    }\n  };\n\n  const isUnlocked = locks => locks.get() === 0;\n\n  const setTyping = (undoManager, typing, locks) => {\n    if (isUnlocked(locks)) {\n      undoManager.typing = typing;\n    }\n  };\n\n  const endTyping = (undoManager, locks) => {\n    if (undoManager.typing) {\n      setTyping(undoManager, false, locks);\n      undoManager.add();\n    }\n  };\n\n  const endTypingLevelIgnoreLocks = undoManager => {\n    if (undoManager.typing) {\n      undoManager.typing = false;\n      undoManager.add();\n    }\n  };\n\n  const beforeChange$1 = (editor, locks, beforeBookmark) => {\n    if (isUnlocked(locks)) {\n      beforeBookmark.set(getUndoBookmark(editor.selection));\n    }\n  };\n\n  const addUndoLevel$1 = (editor, undoManager, index, locks, beforeBookmark, level, event) => {\n    const currentLevel = createFromEditor(editor);\n    level = level || {};\n    level = Tools.extend(level, currentLevel);\n\n    if (isUnlocked(locks) === false || editor.removed) {\n      return null;\n    }\n\n    const lastLevel = undoManager.data[index.get()];\n\n    if (editor.dispatch('BeforeAddUndo', {\n      level,\n      lastLevel,\n      originalEvent: event\n    }).isDefaultPrevented()) {\n      return null;\n    }\n\n    if (lastLevel && isEq$1(lastLevel, level)) {\n      return null;\n    }\n\n    if (undoManager.data[index.get()]) {\n      beforeBookmark.get().each(bm => {\n        undoManager.data[index.get()].beforeBookmark = bm;\n      });\n    }\n\n    const customUndoRedoLevels = getCustomUndoRedoLevels(editor);\n\n    if (customUndoRedoLevels) {\n      if (undoManager.data.length > customUndoRedoLevels) {\n        for (let i = 0; i < undoManager.data.length - 1; i++) {\n          undoManager.data[i] = undoManager.data[i + 1];\n        }\n\n        undoManager.data.length--;\n        index.set(undoManager.data.length);\n      }\n    }\n\n    level.bookmark = getUndoBookmark(editor.selection);\n\n    if (index.get() < undoManager.data.length - 1) {\n      undoManager.data.length = index.get() + 1;\n    }\n\n    undoManager.data.push(level);\n    index.set(undoManager.data.length - 1);\n    const args = {\n      level,\n      lastLevel,\n      originalEvent: event\n    };\n\n    if (index.get() > 0) {\n      editor.setDirty(true);\n      editor.dispatch('AddUndo', args);\n      editor.dispatch('change', args);\n    } else {\n      editor.dispatch('AddUndo', args);\n    }\n\n    return level;\n  };\n\n  const clear$1 = (editor, undoManager, index) => {\n    undoManager.data = [];\n    index.set(0);\n    undoManager.typing = false;\n    editor.dispatch('ClearUndos');\n  };\n\n  const extra$1 = (editor, undoManager, index, callback1, callback2) => {\n    if (undoManager.transact(callback1)) {\n      const bookmark = undoManager.data[index.get()].bookmark;\n      const lastLevel = undoManager.data[index.get() - 1];\n      applyToEditor(editor, lastLevel, true);\n\n      if (undoManager.transact(callback2)) {\n        undoManager.data[index.get() - 1].beforeBookmark = bookmark;\n      }\n    }\n  };\n\n  const redo$1 = (editor, index, data) => {\n    let level;\n\n    if (index.get() < data.length - 1) {\n      index.set(index.get() + 1);\n      level = data[index.get()];\n      applyToEditor(editor, level, false);\n      editor.setDirty(true);\n      editor.dispatch('Redo', {\n        level\n      });\n    }\n\n    return level;\n  };\n\n  const undo$1 = (editor, undoManager, locks, index) => {\n    let level;\n\n    if (undoManager.typing) {\n      undoManager.add();\n      undoManager.typing = false;\n      setTyping(undoManager, false, locks);\n    }\n\n    if (index.get() > 0) {\n      index.set(index.get() - 1);\n      level = undoManager.data[index.get()];\n      applyToEditor(editor, level, true);\n      editor.setDirty(true);\n      editor.dispatch('Undo', {\n        level\n      });\n    }\n\n    return level;\n  };\n\n  const reset$1 = undoManager => {\n    undoManager.clear();\n    undoManager.add();\n  };\n\n  const hasUndo$1 = (editor, undoManager, index) => index.get() > 0 || undoManager.typing && undoManager.data[0] && !isEq$1(createFromEditor(editor), undoManager.data[0]);\n\n  const hasRedo$1 = (undoManager, index) => index.get() < undoManager.data.length - 1 && !undoManager.typing;\n\n  const transact$1 = (undoManager, locks, callback) => {\n    endTyping(undoManager, locks);\n    undoManager.beforeChange();\n    undoManager.ignore(callback);\n    return undoManager.add();\n  };\n\n  const ignore$1 = (locks, callback) => {\n    try {\n      locks.set(locks.get() + 1);\n      callback();\n    } finally {\n      locks.set(locks.get() - 1);\n    }\n  };\n\n  const addVisualInternal = (editor, elm) => {\n    const dom = editor.dom;\n    const scope = isNonNullable(elm) ? elm : editor.getBody();\n\n    if (isUndefined(editor.hasVisual)) {\n      editor.hasVisual = isVisualAidsEnabled(editor);\n    }\n\n    each$g(dom.select('table,a', scope), matchedElm => {\n      switch (matchedElm.nodeName) {\n        case 'TABLE':\n          const cls = getVisualAidsTableClass(editor);\n          const value = dom.getAttrib(matchedElm, 'border');\n\n          if ((!value || value === '0') && editor.hasVisual) {\n            dom.addClass(matchedElm, cls);\n          } else {\n            dom.removeClass(matchedElm, cls);\n          }\n\n          break;\n\n        case 'A':\n          if (!dom.getAttrib(matchedElm, 'href')) {\n            const value = dom.getAttrib(matchedElm, 'name') || matchedElm.id;\n            const cls = getVisualAidsAnchorClass(editor);\n\n            if (value && editor.hasVisual) {\n              dom.addClass(matchedElm, cls);\n            } else {\n              dom.removeClass(matchedElm, cls);\n            }\n          }\n\n          break;\n      }\n    });\n    editor.dispatch('VisualAid', {\n      element: elm,\n      hasVisual: editor.hasVisual\n    });\n  };\n\n  const makePlainAdaptor = editor => ({\n    init: {\n      bindEvents: noop\n    },\n    undoManager: {\n      beforeChange: (locks, beforeBookmark) => beforeChange$1(editor, locks, beforeBookmark),\n      add: (undoManager, index, locks, beforeBookmark, level, event) => addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event),\n      undo: (undoManager, locks, index) => undo$1(editor, undoManager, locks, index),\n      redo: (index, data) => redo$1(editor, index, data),\n      clear: (undoManager, index) => clear$1(editor, undoManager, index),\n      reset: undoManager => reset$1(undoManager),\n      hasUndo: (undoManager, index) => hasUndo$1(editor, undoManager, index),\n      hasRedo: (undoManager, index) => hasRedo$1(undoManager, index),\n      transact: (undoManager, locks, callback) => transact$1(undoManager, locks, callback),\n      ignore: (locks, callback) => ignore$1(locks, callback),\n      extra: (undoManager, index, callback1, callback2) => extra$1(editor, undoManager, index, callback1, callback2)\n    },\n    formatter: {\n      match: (name, vars, node, similar) => match$2(editor, name, vars, node, similar),\n      matchAll: (names, vars) => matchAll(editor, names, vars),\n      matchNode: (node, name, vars, similar) => matchNode(editor, node, name, vars, similar),\n      canApply: name => canApply(editor, name),\n      closest: names => closest$1(editor, names),\n      apply: (name, vars, node) => applyFormat$1(editor, name, vars, node),\n      remove: (name, vars, node, similar) => remove$2(editor, name, vars, node, similar),\n      toggle: (name, vars, node) => toggle(editor, name, vars, node),\n      formatChanged: (registeredFormatListeners, formats, callback, similar, vars) => formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar, vars)\n    },\n    editor: {\n      getContent: args => getContentInternal(editor, args),\n      setContent: (content, args) => setContentInternal(editor, content, args),\n      insertContent: (value, details) => insertHtmlAtCaret(editor, value, details),\n      addVisual: elm => addVisualInternal(editor, elm)\n    },\n    selection: {\n      getContent: (format, args) => getSelectedContentInternal(editor, format, args)\n    },\n    autocompleter: {\n      addDecoration: range => create$8(editor, range),\n      removeDecoration: () => remove$3(editor, SugarElement.fromDom(editor.getBody()))\n    },\n    raw: {\n      getModel: () => Optional.none()\n    }\n  });\n\n  const makeRtcAdaptor = rtcEditor => {\n    const defaultVars = vars => isObject(vars) ? vars : {};\n\n    const {\n      init,\n      undoManager,\n      formatter,\n      editor,\n      selection,\n      autocompleter,\n      raw\n    } = rtcEditor;\n    return {\n      init: {\n        bindEvents: init.bindEvents\n      },\n      undoManager: {\n        beforeChange: undoManager.beforeChange,\n        add: undoManager.add,\n        undo: undoManager.undo,\n        redo: undoManager.redo,\n        clear: undoManager.clear,\n        reset: undoManager.reset,\n        hasUndo: undoManager.hasUndo,\n        hasRedo: undoManager.hasRedo,\n        transact: (_undoManager, _locks, fn) => undoManager.transact(fn),\n        ignore: (_locks, callback) => undoManager.ignore(callback),\n        extra: (_undoManager, _index, callback1, callback2) => undoManager.extra(callback1, callback2)\n      },\n      formatter: {\n        match: (name, vars, _node, similar) => formatter.match(name, defaultVars(vars), similar),\n        matchAll: formatter.matchAll,\n        matchNode: formatter.matchNode,\n        canApply: name => formatter.canApply(name),\n        closest: names => formatter.closest(names),\n        apply: (name, vars, _node) => formatter.apply(name, defaultVars(vars)),\n        remove: (name, vars, _node, _similar) => formatter.remove(name, defaultVars(vars)),\n        toggle: (name, vars, _node) => formatter.toggle(name, defaultVars(vars)),\n        formatChanged: (_rfl, formats, callback, similar, vars) => formatter.formatChanged(formats, callback, similar, vars)\n      },\n      editor: {\n        getContent: args => editor.getContent(args),\n        setContent: (content, args) => {\n          return {\n            content: editor.setContent(content, args),\n            html: ''\n          };\n        },\n        insertContent: (content, _details) => {\n          editor.insertContent(content);\n          return '';\n        },\n        addVisual: editor.addVisual\n      },\n      selection: {\n        getContent: (_format, args) => selection.getContent(args)\n      },\n      autocompleter: {\n        addDecoration: autocompleter.addDecoration,\n        removeDecoration: autocompleter.removeDecoration\n      },\n      raw: {\n        getModel: () => Optional.some(raw.getRawModel())\n      }\n    };\n  };\n\n  const makeNoopAdaptor = () => {\n    const nul = constant(null);\n    const empty = constant('');\n    return {\n      init: {\n        bindEvents: noop\n      },\n      undoManager: {\n        beforeChange: noop,\n        add: nul,\n        undo: nul,\n        redo: nul,\n        clear: noop,\n        reset: noop,\n        hasUndo: never,\n        hasRedo: never,\n        transact: nul,\n        ignore: noop,\n        extra: noop\n      },\n      formatter: {\n        match: never,\n        matchAll: constant([]),\n        matchNode: constant(undefined),\n        canApply: never,\n        closest: empty,\n        apply: noop,\n        remove: noop,\n        toggle: noop,\n        formatChanged: constant({\n          unbind: noop\n        })\n      },\n      editor: {\n        getContent: empty,\n        setContent: constant({\n          content: '',\n          html: ''\n        }),\n        insertContent: constant(''),\n        addVisual: noop\n      },\n      selection: {\n        getContent: empty\n      },\n      autocompleter: {\n        addDecoration: noop,\n        removeDecoration: noop\n      },\n      raw: {\n        getModel: constant(Optional.none())\n      }\n    };\n  };\n\n  const isRtc = editor => has$2(editor.plugins, 'rtc');\n\n  const getRtcSetup = editor => get$a(editor.plugins, 'rtc').bind(rtcPlugin => Optional.from(rtcPlugin.setup));\n\n  const setup$s = editor => {\n    const editorCast = editor;\n    return getRtcSetup(editor).fold(() => {\n      editorCast.rtcInstance = makePlainAdaptor(editor);\n      return Optional.none();\n    }, setup => {\n      editorCast.rtcInstance = makeNoopAdaptor();\n      return Optional.some(() => setup().then(rtcEditor => {\n        editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);\n        return rtcEditor.rtc.isRemote;\n      }));\n    });\n  };\n\n  const getRtcInstanceWithFallback = editor => editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);\n\n  const getRtcInstanceWithError = editor => {\n    const rtcInstance = editor.rtcInstance;\n\n    if (!rtcInstance) {\n      throw new Error('Failed to get RTC instance not yet initialized.');\n    } else {\n      return rtcInstance;\n    }\n  };\n\n  const beforeChange = (editor, locks, beforeBookmark) => {\n    getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);\n  };\n\n  const addUndoLevel = (editor, undoManager, index, locks, beforeBookmark, level, event) => getRtcInstanceWithError(editor).undoManager.add(undoManager, index, locks, beforeBookmark, level, event);\n\n  const undo = (editor, undoManager, locks, index) => getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);\n\n  const redo = (editor, index, data) => getRtcInstanceWithError(editor).undoManager.redo(index, data);\n\n  const clear = (editor, undoManager, index) => {\n    getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);\n  };\n\n  const reset = (editor, undoManager) => {\n    getRtcInstanceWithError(editor).undoManager.reset(undoManager);\n  };\n\n  const hasUndo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);\n\n  const hasRedo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);\n\n  const transact = (editor, undoManager, locks, callback) => getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);\n\n  const ignore = (editor, locks, callback) => {\n    getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);\n  };\n\n  const extra = (editor, undoManager, index, callback1, callback2) => {\n    getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);\n  };\n\n  const matchFormat = (editor, name, vars, node, similar) => getRtcInstanceWithError(editor).formatter.match(name, vars, node, similar);\n\n  const matchAllFormats = (editor, names, vars) => getRtcInstanceWithError(editor).formatter.matchAll(names, vars);\n\n  const matchNodeFormat = (editor, node, name, vars, similar) => getRtcInstanceWithError(editor).formatter.matchNode(node, name, vars, similar);\n\n  const canApplyFormat = (editor, name) => getRtcInstanceWithError(editor).formatter.canApply(name);\n\n  const closestFormat = (editor, names) => getRtcInstanceWithError(editor).formatter.closest(names);\n\n  const applyFormat = (editor, name, vars, node) => {\n    getRtcInstanceWithError(editor).formatter.apply(name, vars, node);\n  };\n\n  const removeFormat = (editor, name, vars, node, similar) => {\n    getRtcInstanceWithError(editor).formatter.remove(name, vars, node, similar);\n  };\n\n  const toggleFormat = (editor, name, vars, node) => {\n    getRtcInstanceWithError(editor).formatter.toggle(name, vars, node);\n  };\n\n  const formatChanged = (editor, registeredFormatListeners, formats, callback, similar, vars) => getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar, vars);\n\n  const getContent$2 = (editor, args) => getRtcInstanceWithFallback(editor).editor.getContent(args);\n\n  const setContent$2 = (editor, content, args) => getRtcInstanceWithFallback(editor).editor.setContent(content, args);\n\n  const insertContent$1 = (editor, value, details) => getRtcInstanceWithFallback(editor).editor.insertContent(value, details);\n\n  const getSelectedContent = (editor, format, args) => getRtcInstanceWithError(editor).selection.getContent(format, args);\n\n  const addVisual$1 = (editor, elm) => getRtcInstanceWithError(editor).editor.addVisual(elm);\n\n  const bindEvents = editor => getRtcInstanceWithError(editor).init.bindEvents();\n\n  const addAutocompleterDecoration = (editor, range) => getRtcInstanceWithError(editor).autocompleter.addDecoration(range);\n\n  const removeAutocompleterDecoration = editor => getRtcInstanceWithError(editor).autocompleter.removeDecoration();\n\n  const getContent$1 = function (editor) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const format = args.format ? args.format : 'html';\n    return getSelectedContent(editor, format, args);\n  };\n\n  const removeEmpty = text => {\n    if (text.dom.length === 0) {\n      remove$5(text);\n      return Optional.none();\n    } else {\n      return Optional.some(text);\n    }\n  };\n\n  const walkPastBookmark = (node, start) => node.filter(elm => BookmarkManager.isBookmarkNode(elm.dom)).bind(start ? nextSibling : prevSibling);\n\n  const merge$1 = (outer, inner, rng, start) => {\n    const outerElm = outer.dom;\n    const innerElm = inner.dom;\n    const oldLength = start ? outerElm.length : innerElm.length;\n\n    if (start) {\n      mergeTextNodes(outerElm, innerElm, false, !start);\n      rng.setStart(innerElm, oldLength);\n    } else {\n      mergeTextNodes(innerElm, outerElm, false, !start);\n      rng.setEnd(innerElm, oldLength);\n    }\n  };\n\n  const normalizeTextIfRequired = (inner, start) => {\n    parent(inner).each(root => {\n      const text = inner.dom;\n\n      if (start && needsToBeNbspLeft(root, CaretPosition(text, 0))) {\n        normalizeWhitespaceAfter(text, 0);\n      } else if (!start && needsToBeNbspRight(root, CaretPosition(text, text.length))) {\n        normalizeWhitespaceBefore(text, text.length);\n      }\n    });\n  };\n\n  const mergeAndNormalizeText = (outerNode, innerNode, rng, start) => {\n    outerNode.bind(outer => {\n      const normalizer = start ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;\n      normalizer(outer.dom, start ? outer.dom.length : 0);\n      return innerNode.filter(isText$9).map(inner => merge$1(outer, inner, rng, start));\n    }).orThunk(() => {\n      const innerTextNode = walkPastBookmark(innerNode, start).or(innerNode).filter(isText$9);\n      return innerTextNode.map(inner => normalizeTextIfRequired(inner, start));\n    });\n  };\n\n  const rngSetContent = (rng, fragment) => {\n    const firstChild = Optional.from(fragment.firstChild).map(SugarElement.fromDom);\n    const lastChild = Optional.from(fragment.lastChild).map(SugarElement.fromDom);\n    rng.deleteContents();\n    rng.insertNode(fragment);\n    const prevText = firstChild.bind(prevSibling).filter(isText$9).bind(removeEmpty);\n    const nextText = lastChild.bind(nextSibling).filter(isText$9).bind(removeEmpty);\n    mergeAndNormalizeText(prevText, firstChild, rng, true);\n    mergeAndNormalizeText(nextText, lastChild, rng, false);\n    rng.collapse(false);\n  };\n\n  const setupArgs$2 = (args, content) => ({\n    format: 'html',\n    ...args,\n    set: true,\n    selection: true,\n    content\n  });\n\n  const cleanContent = (editor, args) => {\n    if (args.format !== 'raw') {\n      const rng = editor.selection.getRng();\n      const contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);\n      const contextArgs = contextBlock ? {\n        context: contextBlock.nodeName.toLowerCase()\n      } : {};\n      const node = editor.parser.parse(args.content, {\n        forced_root_block: false,\n        ...contextArgs,\n        ...args\n      });\n      return HtmlSerializer({\n        validate: false\n      }, editor.schema).serialize(node);\n    } else {\n      return args.content;\n    }\n  };\n\n  const setContent$1 = function (editor, content) {\n    let args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const defaultedArgs = setupArgs$2(args, content);\n    preProcessSetContent(editor, defaultedArgs).each(updatedArgs => {\n      const cleanedContent = cleanContent(editor, updatedArgs);\n      const rng = editor.selection.getRng();\n      rngSetContent(rng, rng.createContextualFragment(cleanedContent));\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, rng);\n      postProcessSetContent(editor, cleanedContent, updatedArgs);\n    });\n  };\n\n  const deleteFromCallbackMap = (callbackMap, selector, callback) => {\n    if (callbackMap && has$2(callbackMap, selector)) {\n      const newCallbacks = filter$6(callbackMap[selector], cb => cb !== callback);\n\n      if (newCallbacks.length === 0) {\n        delete callbackMap[selector];\n      } else {\n        callbackMap[selector] = newCallbacks;\n      }\n    }\n  };\n\n  var SelectorChanged = (dom, editor) => {\n    let selectorChangedData;\n    let currentSelectors;\n\n    const findMatchingNode = (selector, nodes) => find$2(nodes, node => dom.is(node, selector));\n\n    const getParents = elem => dom.getParents(elem, null, dom.getRoot());\n\n    return {\n      selectorChangedWithUnbind: (selector, callback) => {\n        if (!selectorChangedData) {\n          selectorChangedData = {};\n          currentSelectors = {};\n          editor.on('NodeChange', e => {\n            const node = e.element;\n            const parents = getParents(node);\n            const matchedSelectors = {};\n            Tools.each(selectorChangedData, (callbacks, selector) => {\n              findMatchingNode(selector, parents).each(node => {\n                if (!currentSelectors[selector]) {\n                  each$g(callbacks, callback => {\n                    callback(true, {\n                      node,\n                      selector,\n                      parents\n                    });\n                  });\n                  currentSelectors[selector] = callbacks;\n                }\n\n                matchedSelectors[selector] = callbacks;\n              });\n            });\n            Tools.each(currentSelectors, (callbacks, selector) => {\n              if (!matchedSelectors[selector]) {\n                delete currentSelectors[selector];\n                Tools.each(callbacks, callback => {\n                  callback(false, {\n                    node,\n                    selector,\n                    parents\n                  });\n                });\n              }\n            });\n          });\n        }\n\n        if (!selectorChangedData[selector]) {\n          selectorChangedData[selector] = [];\n        }\n\n        selectorChangedData[selector].push(callback);\n        findMatchingNode(selector, getParents(editor.selection.getStart())).each(() => {\n          currentSelectors[selector] = selectorChangedData[selector];\n        });\n        return {\n          unbind: () => {\n            deleteFromCallbackMap(selectorChangedData, selector, callback);\n            deleteFromCallbackMap(currentSelectors, selector, callback);\n          }\n        };\n      }\n    };\n  };\n\n  const isAttachedToDom = node => {\n    return !!(node && node.ownerDocument) && contains(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));\n  };\n\n  const isValidRange = rng => {\n    if (!rng) {\n      return false;\n    } else {\n      return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);\n    }\n  };\n\n  const EditorSelection = (dom, win, serializer, editor) => {\n    let selectedRange;\n    let explicitRange;\n    const {\n      selectorChangedWithUnbind\n    } = SelectorChanged(dom, editor);\n\n    const setCursorLocation = (node, offset) => {\n      const rng = dom.createRng();\n\n      if (isNonNullable(node) && isNonNullable(offset)) {\n        rng.setStart(node, offset);\n        rng.setEnd(node, offset);\n        setRng(rng);\n        collapse(false);\n      } else {\n        moveEndPoint(dom, rng, editor.getBody(), true);\n        setRng(rng);\n      }\n    };\n\n    const getContent = args => getContent$1(editor, args);\n\n    const setContent = (content, args) => setContent$1(editor, content, args);\n\n    const getStart$1 = real => getStart(editor.getBody(), getRng$1(), real);\n\n    const getEnd = real => getEnd$1(editor.getBody(), getRng$1(), real);\n\n    const getBookmark = (type, normalized) => bookmarkManager.getBookmark(type, normalized);\n\n    const moveToBookmark = bookmark => bookmarkManager.moveToBookmark(bookmark);\n\n    const select$1 = (node, content) => {\n      select(dom, node, content).each(setRng);\n      return node;\n    };\n\n    const isCollapsed = () => {\n      const rng = getRng$1(),\n            sel = getSel();\n\n      if (!rng || rng.item) {\n        return false;\n      }\n\n      if (rng.compareEndPoints) {\n        return rng.compareEndPoints('StartToEnd', rng) === 0;\n      }\n\n      return !sel || rng.collapsed;\n    };\n\n    const collapse = toStart => {\n      const rng = getRng$1();\n      rng.collapse(!!toStart);\n      setRng(rng);\n    };\n\n    const getSel = () => win.getSelection ? win.getSelection() : win.document.selection;\n\n    const getRng$1 = () => {\n      let selection, rng, elm;\n\n      const tryCompareBoundaryPoints = (how, sourceRange, destinationRange) => {\n        try {\n          return sourceRange.compareBoundaryPoints(how, destinationRange);\n        } catch (ex) {\n          return -1;\n        }\n      };\n\n      const doc = win.document;\n\n      if (editor.bookmark !== undefined && hasFocus(editor) === false) {\n        const bookmark = getRng(editor);\n\n        if (bookmark.isSome()) {\n          return bookmark.map(r => processRanges(editor, [r])[0]).getOr(doc.createRange());\n        }\n      }\n\n      try {\n        if ((selection = getSel()) && !isRestrictedNode(selection.anchorNode)) {\n          if (selection.rangeCount > 0) {\n            rng = selection.getRangeAt(0);\n          } else {\n            rng = selection.createRange ? selection.createRange() : doc.createRange();\n          }\n\n          rng = processRanges(editor, [rng])[0];\n        }\n      } catch (ex) {}\n\n      if (!rng) {\n        rng = doc.createRange();\n      }\n\n      if (rng.setStart && rng.startContainer.nodeType === 9 && rng.collapsed) {\n        elm = dom.getRoot();\n        rng.setStart(elm, 0);\n        rng.setEnd(elm, 0);\n      }\n\n      if (selectedRange && explicitRange) {\n        if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {\n          rng = explicitRange;\n        } else {\n          selectedRange = null;\n          explicitRange = null;\n        }\n      }\n\n      return rng;\n    };\n\n    const setRng = (rng, forward) => {\n      let node;\n\n      if (!isValidRange(rng)) {\n        return;\n      }\n\n      const sel = getSel();\n      const evt = editor.dispatch('SetSelectionRange', {\n        range: rng,\n        forward\n      });\n      rng = evt.range;\n\n      if (sel) {\n        explicitRange = rng;\n\n        try {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        } catch (ex) {}\n\n        if (forward === false && sel.extend) {\n          sel.collapse(rng.endContainer, rng.endOffset);\n          sel.extend(rng.startContainer, rng.startOffset);\n        }\n\n        selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;\n      }\n\n      if (!rng.collapsed && rng.startContainer === rng.endContainer && sel.setBaseAndExtent) {\n        if (rng.endOffset - rng.startOffset < 2) {\n          if (rng.startContainer.hasChildNodes()) {\n            node = rng.startContainer.childNodes[rng.startOffset];\n\n            if (node && node.tagName === 'IMG') {\n              sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);\n\n              if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {\n                sel.setBaseAndExtent(node, 0, node, 1);\n              }\n            }\n          }\n        }\n      }\n\n      editor.dispatch('AfterSetSelectionRange', {\n        range: rng,\n        forward\n      });\n    };\n\n    const setNode = elm => {\n      setContent(dom.getOuterHTML(elm));\n      return elm;\n    };\n\n    const getNode$1 = () => getNode(editor.getBody(), getRng$1());\n\n    const getSelectedBlocks$1 = (startElm, endElm) => getSelectedBlocks(dom, getRng$1(), startElm, endElm);\n\n    const isForward = () => {\n      const sel = getSel();\n      const anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;\n      const focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;\n\n      if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {\n        return true;\n      }\n\n      const anchorRange = dom.createRng();\n      anchorRange.setStart(anchorNode, sel.anchorOffset);\n      anchorRange.collapse(true);\n      const focusRange = dom.createRng();\n      focusRange.setStart(focusNode, sel.focusOffset);\n      focusRange.collapse(true);\n      return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;\n    };\n\n    const normalize = () => {\n      const rng = getRng$1();\n      const sel = getSel();\n\n      if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {\n        const normRng = normalize$2(dom, rng);\n        normRng.each(normRng => {\n          setRng(normRng, isForward());\n        });\n        return normRng.getOr(rng);\n      }\n\n      return rng;\n    };\n\n    const selectorChanged = (selector, callback) => {\n      selectorChangedWithUnbind(selector, callback);\n      return exports;\n    };\n\n    const getScrollContainer = () => {\n      let scrollContainer;\n      let node = dom.getRoot();\n\n      while (node && node.nodeName !== 'BODY') {\n        if (node.scrollHeight > node.clientHeight) {\n          scrollContainer = node;\n          break;\n        }\n\n        node = node.parentNode;\n      }\n\n      return scrollContainer;\n    };\n\n    const scrollIntoView = (elm, alignToTop) => {\n      if (isNonNullable(elm)) {\n        scrollElementIntoView(editor, elm, alignToTop);\n      } else {\n        scrollRangeIntoView(editor, getRng$1(), alignToTop);\n      }\n    };\n\n    const placeCaretAt = (clientX, clientY) => setRng(fromPoint(clientX, clientY, editor.getDoc()));\n\n    const getBoundingClientRect = () => {\n      const rng = getRng$1();\n      return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();\n    };\n\n    const destroy = () => {\n      win = selectedRange = explicitRange = null;\n      controlSelection.destroy();\n    };\n\n    const exports = {\n      bookmarkManager: null,\n      controlSelection: null,\n      dom,\n      win,\n      serializer,\n      editor,\n      collapse,\n      setCursorLocation,\n      getContent,\n      setContent,\n      getBookmark,\n      moveToBookmark,\n      select: select$1,\n      isCollapsed,\n      isForward,\n      setNode,\n      getNode: getNode$1,\n      getSel,\n      setRng,\n      getRng: getRng$1,\n      getStart: getStart$1,\n      getEnd,\n      getSelectedBlocks: getSelectedBlocks$1,\n      normalize,\n      selectorChanged,\n      selectorChangedWithUnbind,\n      getScrollContainer,\n      scrollIntoView,\n      placeCaretAt,\n      getBoundingClientRect,\n      destroy\n    };\n    const bookmarkManager = BookmarkManager(exports);\n    const controlSelection = ControlSelection(exports, editor);\n    exports.bookmarkManager = bookmarkManager;\n    exports.controlSelection = controlSelection;\n    return exports;\n  };\n\n  const register$3 = (htmlParser, settings, dom) => {\n    htmlParser.addAttributeFilter('data-mce-tabindex', (nodes, name) => {\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n        node.attr('tabindex', node.attr('data-mce-tabindex'));\n        node.attr(name, null);\n      }\n    });\n    htmlParser.addAttributeFilter('src,href,style', (nodes, name) => {\n      const internalName = 'data-mce-' + name;\n      const urlConverter = settings.url_converter;\n      const urlConverterScope = settings.url_converter_scope;\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n        let value = node.attr(internalName);\n\n        if (value !== undefined) {\n          node.attr(name, value.length > 0 ? value : null);\n          node.attr(internalName, null);\n        } else {\n          value = node.attr(name);\n\n          if (name === 'style') {\n            value = dom.serializeStyle(dom.parseStyle(value), node.name);\n          } else if (urlConverter) {\n            value = urlConverter.call(urlConverterScope, value, name, node.name);\n          }\n\n          node.attr(name, value.length > 0 ? value : null);\n        }\n      }\n    });\n    htmlParser.addAttributeFilter('class', nodes => {\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n        let value = node.attr('class');\n\n        if (value) {\n          value = node.attr('class').replace(/(?:^|\\s)mce-item-\\w+(?!\\S)/g, '');\n          node.attr('class', value.length > 0 ? value : null);\n        }\n      }\n    });\n    htmlParser.addAttributeFilter('data-mce-type', (nodes, name, args) => {\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n\n        if (node.attr('data-mce-type') === 'bookmark' && !args.cleanup) {\n          const hasChildren = Optional.from(node.firstChild).exists(firstChild => !isZwsp(firstChild.value));\n\n          if (hasChildren) {\n            node.unwrap();\n          } else {\n            node.remove();\n          }\n        }\n      }\n    });\n    htmlParser.addNodeFilter('noscript', nodes => {\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i].firstChild;\n\n        if (node) {\n          node.value = Entities.decode(node.value);\n        }\n      }\n    });\n    htmlParser.addNodeFilter('script,style', (nodes, name) => {\n      const trim = value => {\n        return value.replace(/(<!--\\[CDATA\\[|\\]\\]-->)/g, '\\n').replace(/^[\\r\\n]*|[\\r\\n]*$/g, '').replace(/^\\s*((<!--)?(\\s*\\/\\/)?\\s*<!\\[CDATA\\[|(<!--\\s*)?\\/\\*\\s*<!\\[CDATA\\[\\s*\\*\\/|(\\/\\/)?\\s*<!--|\\/\\*\\s*<!--\\s*\\*\\/)\\s*[\\r\\n]*/gi, '').replace(/\\s*(\\/\\*\\s*\\]\\]>\\s*\\*\\/(-->)?|\\s*\\/\\/\\s*\\]\\]>(-->)?|\\/\\/\\s*(-->)?|\\]\\]>|\\/\\*\\s*-->\\s*\\*\\/|\\s*-->\\s*)\\s*$/g, '');\n      };\n\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n        const value = node.firstChild ? node.firstChild.value : '';\n\n        if (name === 'script') {\n          const type = node.attr('type');\n\n          if (type) {\n            node.attr('type', type === 'mce-no/type' ? null : type.replace(/^mce\\-/, ''));\n          }\n\n          if (settings.element_format === 'xhtml' && value.length > 0) {\n            node.firstChild.value = '// <![CDATA[\\n' + trim(value) + '\\n// ]]>';\n          }\n        } else {\n          if (settings.element_format === 'xhtml' && value.length > 0) {\n            node.firstChild.value = '<!--\\n' + trim(value) + '\\n-->';\n          }\n        }\n      }\n    });\n    htmlParser.addNodeFilter('#comment', nodes => {\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n\n        if (settings.preserve_cdata && node.value.indexOf('[CDATA[') === 0) {\n          node.name = '#cdata';\n          node.type = 4;\n          node.value = dom.decode(node.value.replace(/^\\[CDATA\\[|\\]\\]$/g, ''));\n        } else if (node.value.indexOf('mce:protected ') === 0) {\n          node.name = '#text';\n          node.type = 3;\n          node.raw = true;\n          node.value = unescape(node.value).substr(14);\n        }\n      }\n    });\n    htmlParser.addNodeFilter('xml:namespace,input', (nodes, name) => {\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n\n        if (node.type === 7) {\n          node.remove();\n        } else if (node.type === 1) {\n          if (name === 'input' && !node.attr('type')) {\n            node.attr('type', 'text');\n          }\n        }\n      }\n    });\n    htmlParser.addAttributeFilter('data-mce-type', nodes => {\n      each$g(nodes, node => {\n        if (node.attr('data-mce-type') === 'format-caret') {\n          if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {\n            node.remove();\n          } else {\n            node.unwrap();\n          }\n        }\n      });\n    });\n    htmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style,' + 'data-mce-selected,data-mce-expando,' + 'data-mce-type,data-mce-resize,data-mce-placeholder', (nodes, name) => {\n      let i = nodes.length;\n\n      while (i--) {\n        nodes[i].attr(name, null);\n      }\n    });\n  };\n\n  const trimTrailingBr = rootNode => {\n    const isBr = node => {\n      return node && node.name === 'br';\n    };\n\n    const brNode1 = rootNode.lastChild;\n\n    if (isBr(brNode1)) {\n      const brNode2 = brNode1.prev;\n\n      if (isBr(brNode2)) {\n        brNode1.remove();\n        brNode2.remove();\n      }\n    }\n  };\n\n  const preProcess$1 = (editor, node, args) => {\n    let oldDoc;\n    const dom = editor.dom;\n    let clonedNode = node.cloneNode(true);\n    const impl = document.implementation;\n\n    if (impl.createHTMLDocument) {\n      const doc = impl.createHTMLDocument('');\n      Tools.each(clonedNode.nodeName === 'BODY' ? clonedNode.childNodes : [clonedNode], node => {\n        doc.body.appendChild(doc.importNode(node, true));\n      });\n\n      if (clonedNode.nodeName !== 'BODY') {\n        clonedNode = doc.body.firstChild;\n      } else {\n        clonedNode = doc.body;\n      }\n\n      oldDoc = dom.doc;\n      dom.doc = doc;\n    }\n\n    firePreProcess(editor, { ...args,\n      node: clonedNode\n    });\n\n    if (oldDoc) {\n      dom.doc = oldDoc;\n    }\n\n    return clonedNode;\n  };\n\n  const shouldFireEvent = (editor, args) => {\n    return editor && editor.hasEventListeners('PreProcess') && !args.no_events;\n  };\n\n  const process$1 = (editor, node, args) => {\n    return shouldFireEvent(editor, args) ? preProcess$1(editor, node, args) : node;\n  };\n\n  const addTempAttr = (htmlParser, tempAttrs, name) => {\n    if (Tools.inArray(tempAttrs, name) === -1) {\n      htmlParser.addAttributeFilter(name, (nodes, name) => {\n        let i = nodes.length;\n\n        while (i--) {\n          nodes[i].attr(name, null);\n        }\n      });\n      tempAttrs.push(name);\n    }\n  };\n\n  const postProcess = (editor, args, content) => {\n    if (!args.no_events && editor) {\n      const outArgs = firePostProcess(editor, { ...args,\n        content\n      });\n      return outArgs.content;\n    } else {\n      return content;\n    }\n  };\n\n  const getHtmlFromNode = (dom, node, args) => {\n    const html = trim$1(args.getInner ? node.innerHTML : dom.getOuterHTML(node));\n    return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html : Tools.trim(html);\n  };\n\n  const parseHtml = (htmlParser, html, args) => {\n    const parserArgs = args.selection ? {\n      forced_root_block: false,\n      ...args\n    } : args;\n    const rootNode = htmlParser.parse(html, parserArgs);\n    trimTrailingBr(rootNode);\n    return rootNode;\n  };\n\n  const serializeNode = (settings, schema, node) => {\n    const htmlSerializer = HtmlSerializer(settings, schema);\n    return htmlSerializer.serialize(node);\n  };\n\n  const toHtml = (editor, settings, schema, rootNode, args) => {\n    const content = serializeNode(settings, schema, rootNode);\n    return postProcess(editor, args, content);\n  };\n\n  const DomSerializerImpl = (settings, editor) => {\n    const tempAttrs = ['data-mce-selected'];\n    const dom = editor && editor.dom ? editor.dom : DOMUtils.DOM;\n    const schema = editor && editor.schema ? editor.schema : Schema(settings);\n    settings.entity_encoding = settings.entity_encoding || 'named';\n    settings.remove_trailing_brs = 'remove_trailing_brs' in settings ? settings.remove_trailing_brs : true;\n    const htmlParser = DomParser(settings, schema);\n    register$3(htmlParser, settings, dom);\n\n    const serialize = function (node) {\n      let parserArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const args = {\n        format: 'html',\n        ...parserArgs\n      };\n      const targetNode = process$1(editor, node, args);\n      const html = getHtmlFromNode(dom, targetNode, args);\n      const rootNode = parseHtml(htmlParser, html, args);\n      return args.format === 'tree' ? rootNode : toHtml(editor, settings, schema, rootNode, args);\n    };\n\n    return {\n      schema,\n      addNodeFilter: htmlParser.addNodeFilter,\n      addAttributeFilter: htmlParser.addAttributeFilter,\n      serialize: serialize,\n      addRules: schema.addValidElements,\n      setRules: schema.setValidElements,\n      addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),\n      getTempAttrs: constant(tempAttrs),\n      getNodeFilters: htmlParser.getNodeFilters,\n      getAttributeFilters: htmlParser.getAttributeFilters\n    };\n  };\n\n  const DomSerializer = (settings, editor) => {\n    const domSerializer = DomSerializerImpl(settings, editor);\n    return {\n      schema: domSerializer.schema,\n      addNodeFilter: domSerializer.addNodeFilter,\n      addAttributeFilter: domSerializer.addAttributeFilter,\n      serialize: domSerializer.serialize,\n      addRules: domSerializer.addRules,\n      setRules: domSerializer.setRules,\n      addTempAttr: domSerializer.addTempAttr,\n      getTempAttrs: domSerializer.getTempAttrs,\n      getNodeFilters: domSerializer.getNodeFilters,\n      getAttributeFilters: domSerializer.getAttributeFilters\n    };\n  };\n\n  const defaultFormat$1 = 'html';\n\n  const setupArgs$1 = (args, format) => ({ ...args,\n    format,\n    get: true,\n    getInner: true\n  });\n\n  const getContent = function (editor) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const format = args.format ? args.format : defaultFormat$1;\n    const defaultedArgs = setupArgs$1(args, format);\n    return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\n      const content = getContent$2(editor, updatedArgs);\n      return postProcessGetContent(editor, content, updatedArgs);\n    });\n  };\n\n  const defaultFormat = 'html';\n\n  const setupArgs = (args, content) => ({\n    format: defaultFormat,\n    ...args,\n    set: true,\n    content\n  });\n\n  const setContent = function (editor, content) {\n    let args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const defaultedArgs = setupArgs(args, content);\n    return preProcessSetContent(editor, defaultedArgs).map(updatedArgs => {\n      const result = setContent$2(editor, updatedArgs.content, updatedArgs);\n      postProcessSetContent(editor, result.html, updatedArgs);\n      return result.content;\n    }).getOr(content);\n  };\n\n  const removedOptions = ('autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,' + 'boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,' + 'force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,' + 'non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,' + 'tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,' + 'paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists').split(',');\n  const removedPlugins = 'bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor'.split(',');\n\n  const getRemovedOptions = options => {\n    const settingNames = filter$6(removedOptions, setting => has$2(options, setting));\n    const forcedRootBlock = options.forced_root_block;\n\n    if (forcedRootBlock === false || forcedRootBlock === '') {\n      settingNames.push('forced_root_block (false only)');\n    }\n\n    return sort(settingNames);\n  };\n\n  const getRemovedPlugins = options => {\n    const plugins = Tools.makeMap(options.plugins, ' ');\n\n    const hasPlugin = plugin => has$2(plugins, plugin);\n\n    const pluginNames = filter$6(removedPlugins, hasPlugin);\n    return sort(pluginNames);\n  };\n\n  const logRemovedWarnings = (rawOptions, normalizedOptions) => {\n    const removedOptions = getRemovedOptions(rawOptions);\n    const removedPlugins = getRemovedPlugins(normalizedOptions);\n    const hasRemovedPlugins = removedPlugins.length > 0;\n    const hasRemovedOptions = removedOptions.length > 0;\n    const isLegacyMobileTheme = normalizedOptions.theme === 'mobile';\n\n    if (hasRemovedPlugins || hasRemovedOptions || isLegacyMobileTheme) {\n      const listJoiner = '\\n- ';\n      const themesMessage = isLegacyMobileTheme ? `\\n\\nThemes:${listJoiner}mobile` : '';\n      const pluginsMessage = hasRemovedPlugins ? `\\n\\nPlugins:${listJoiner}${removedPlugins.join(listJoiner)}` : '';\n      const optionsMessage = hasRemovedOptions ? `\\n\\nOptions:${listJoiner}${removedOptions.join(listJoiner)}` : '';\n      console.warn('The following deprecated features are currently enabled and have been removed in TinyMCE 6.0. These features will no longer work and should be removed from the TinyMCE configuration. ' + 'See https://www.tiny.cloud/docs/tinymce/6/migration-from-5x/ for more information.' + themesMessage + pluginsMessage + optionsMessage);\n    }\n  };\n\n  const logWarnings = (rawOptions, normalizedOptions) => {\n    logRemovedWarnings(rawOptions, normalizedOptions);\n  };\n\n  const DOM$8 = DOMUtils.DOM;\n\n  const restoreOriginalStyles = editor => {\n    DOM$8.setStyle(editor.id, 'display', editor.orgDisplay);\n  };\n\n  const safeDestroy = x => Optional.from(x).each(x => x.destroy());\n\n  const clearDomReferences = editor => {\n    editor.contentAreaContainer = editor.formElement = editor.container = editor.editorContainer = null;\n    editor.bodyElement = editor.contentDocument = editor.contentWindow = null;\n    editor.iframeElement = editor.targetElm = null;\n\n    if (editor.selection) {\n      editor.selection = editor.selection.win = editor.selection.dom = editor.selection.dom.doc = null;\n    }\n  };\n\n  const restoreForm = editor => {\n    const form = editor.formElement;\n\n    if (form) {\n      if (form._mceOldSubmit) {\n        form.submit = form._mceOldSubmit;\n        form._mceOldSubmit = null;\n      }\n\n      DOM$8.unbind(form, 'submit reset', editor.formEventDelegate);\n    }\n  };\n\n  const remove$1 = editor => {\n    if (!editor.removed) {\n      const {\n        _selectionOverrides,\n        editorUpload\n      } = editor;\n      const body = editor.getBody();\n      const element = editor.getElement();\n\n      if (body) {\n        editor.save({\n          is_removing: true\n        });\n      }\n\n      editor.removed = true;\n      editor.unbindAllNativeEvents();\n\n      if (editor.hasHiddenInput && element) {\n        DOM$8.remove(element.nextSibling);\n      }\n\n      fireRemove(editor);\n      editor.editorManager.remove(editor);\n\n      if (!editor.inline && body) {\n        restoreOriginalStyles(editor);\n      }\n\n      fireDetach(editor);\n      DOM$8.remove(editor.getContainer());\n      safeDestroy(_selectionOverrides);\n      safeDestroy(editorUpload);\n      editor.destroy();\n    }\n  };\n\n  const destroy = (editor, automatic) => {\n    const {\n      selection,\n      dom\n    } = editor;\n\n    if (editor.destroyed) {\n      return;\n    }\n\n    if (!automatic && !editor.removed) {\n      editor.remove();\n      return;\n    }\n\n    if (!automatic) {\n      editor.editorManager.off('beforeunload', editor._beforeUnload);\n\n      if (editor.theme && editor.theme.destroy) {\n        editor.theme.destroy();\n      }\n\n      safeDestroy(selection);\n      safeDestroy(dom);\n    }\n\n    restoreForm(editor);\n    clearDomReferences(editor);\n    editor.destroyed = true;\n  };\n\n  const CreateIconManager = () => {\n    const lookup = {};\n\n    const add = (id, iconPack) => {\n      lookup[id] = iconPack;\n    };\n\n    const get = id => {\n      if (lookup[id]) {\n        return lookup[id];\n      }\n\n      return {\n        icons: {}\n      };\n    };\n\n    const has = id => has$2(lookup, id);\n\n    return {\n      add,\n      get,\n      has\n    };\n  };\n\n  const IconManager = CreateIconManager();\n  const ModelManager = AddOnManager.ModelManager;\n\n  const getProp = (propName, elm) => {\n    const rawElm = elm.dom;\n    return rawElm[propName];\n  };\n\n  const getComputedSizeProp = (propName, elm) => parseInt(get$7(elm, propName), 10);\n\n  const getClientWidth = curry(getProp, 'clientWidth');\n  const getClientHeight = curry(getProp, 'clientHeight');\n  const getMarginTop = curry(getComputedSizeProp, 'margin-top');\n  const getMarginLeft = curry(getComputedSizeProp, 'margin-left');\n\n  const getBoundingClientRect = elm => elm.dom.getBoundingClientRect();\n\n  const isInsideElementContentArea = (bodyElm, clientX, clientY) => {\n    const clientWidth = getClientWidth(bodyElm);\n    const clientHeight = getClientHeight(bodyElm);\n    return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;\n  };\n\n  const transpose = (inline, elm, clientX, clientY) => {\n    const clientRect = getBoundingClientRect(elm);\n    const deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;\n    const deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;\n    const x = clientX - deltaX;\n    const y = clientY - deltaY;\n    return {\n      x,\n      y\n    };\n  };\n\n  const isXYInContentArea = (editor, clientX, clientY) => {\n    const bodyElm = SugarElement.fromDom(editor.getBody());\n    const targetElm = editor.inline ? bodyElm : documentElement(bodyElm);\n    const transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);\n    return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);\n  };\n\n  const fromDomSafe = node => Optional.from(node).map(SugarElement.fromDom);\n\n  const isEditorAttachedToDom = editor => {\n    const rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();\n    return fromDomSafe(rawContainer).map(inBody).getOr(false);\n  };\n\n  const NotificationManagerImpl = () => {\n    const unimplemented = () => {\n      throw new Error('Theme did not provide a NotificationManager implementation.');\n    };\n\n    return {\n      open: unimplemented,\n      close: unimplemented,\n      getArgs: unimplemented\n    };\n  };\n\n  const NotificationManager = editor => {\n    const notifications = [];\n\n    const getImplementation = () => {\n      const theme = editor.theme;\n      return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();\n    };\n\n    const getTopNotification = () => {\n      return Optional.from(notifications[0]);\n    };\n\n    const isEqual = (a, b) => {\n      return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;\n    };\n\n    const reposition = () => {\n      each$g(notifications, notification => {\n        notification.reposition();\n      });\n    };\n\n    const addNotification = notification => {\n      notifications.push(notification);\n    };\n\n    const closeNotification = notification => {\n      findIndex$2(notifications, otherNotification => {\n        return otherNotification === notification;\n      }).each(index => {\n        notifications.splice(index, 1);\n      });\n    };\n\n    const open = function (spec) {\n      let fireEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (editor.removed || !isEditorAttachedToDom(editor)) {\n        return;\n      }\n\n      if (fireEvent) {\n        editor.dispatch('BeforeOpenNotification', {\n          notification: spec\n        });\n      }\n\n      return find$2(notifications, notification => {\n        return isEqual(getImplementation().getArgs(notification), spec);\n      }).getOrThunk(() => {\n        editor.editorManager.setActive(editor);\n        const notification = getImplementation().open(spec, () => {\n          closeNotification(notification);\n          reposition();\n          getTopNotification().fold(() => editor.focus(), top => focus$1(SugarElement.fromDom(top.getEl())));\n        });\n        addNotification(notification);\n        reposition();\n        editor.dispatch('OpenNotification', {\n          notification: { ...notification\n          }\n        });\n        return notification;\n      });\n    };\n\n    const close = () => {\n      getTopNotification().each(notification => {\n        getImplementation().close(notification);\n        closeNotification(notification);\n        reposition();\n      });\n    };\n\n    const getNotifications = constant(notifications);\n\n    const registerEvents = editor => {\n      editor.on('SkinLoaded', () => {\n        const serviceMessage = getServiceMessage(editor);\n\n        if (serviceMessage) {\n          open({\n            text: serviceMessage,\n            type: 'warning',\n            timeout: 0\n          }, false);\n        }\n\n        reposition();\n      });\n      editor.on('show ResizeEditor ResizeWindow NodeChange', () => {\n        requestAnimationFrame(reposition);\n      });\n      editor.on('remove', () => {\n        each$g(notifications.slice(), notification => {\n          getImplementation().close(notification);\n        });\n      });\n    };\n\n    registerEvents(editor);\n    return {\n      open,\n      close,\n      getNotifications\n    };\n  };\n\n  const PluginManager = AddOnManager.PluginManager;\n  const ThemeManager = AddOnManager.ThemeManager;\n\n  var WindowManagerImpl = () => {\n    const unimplemented = () => {\n      throw new Error('Theme did not provide a WindowManager implementation.');\n    };\n\n    return {\n      open: unimplemented,\n      openUrl: unimplemented,\n      alert: unimplemented,\n      confirm: unimplemented,\n      close: unimplemented,\n      getParams: unimplemented,\n      setParams: unimplemented\n    };\n  };\n\n  const WindowManager = editor => {\n    let dialogs = [];\n\n    const getImplementation = () => {\n      const theme = editor.theme;\n      return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();\n    };\n\n    const funcBind = (scope, f) => {\n      return function () {\n        for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n          args[_key13] = arguments[_key13];\n        }\n\n        return f ? f.apply(scope, args) : undefined;\n      };\n    };\n\n    const fireOpenEvent = dialog => {\n      editor.dispatch('OpenWindow', {\n        dialog\n      });\n    };\n\n    const fireCloseEvent = dialog => {\n      editor.dispatch('CloseWindow', {\n        dialog\n      });\n    };\n\n    const addDialog = dialog => {\n      dialogs.push(dialog);\n      fireOpenEvent(dialog);\n    };\n\n    const closeDialog = dialog => {\n      fireCloseEvent(dialog);\n      dialogs = filter$6(dialogs, otherDialog => {\n        return otherDialog !== dialog;\n      });\n\n      if (dialogs.length === 0) {\n        editor.focus();\n      }\n    };\n\n    const getTopDialog = () => {\n      return Optional.from(dialogs[dialogs.length - 1]);\n    };\n\n    const storeSelectionAndOpenDialog = openDialog => {\n      editor.editorManager.setActive(editor);\n      store(editor);\n      editor.ui.show();\n      const dialog = openDialog();\n      addDialog(dialog);\n      return dialog;\n    };\n\n    const open = (args, params) => {\n      return storeSelectionAndOpenDialog(() => getImplementation().open(args, params, closeDialog));\n    };\n\n    const openUrl = args => {\n      return storeSelectionAndOpenDialog(() => getImplementation().openUrl(args, closeDialog));\n    };\n\n    const alert = (message, callback, scope) => {\n      const windowManagerImpl = getImplementation();\n      windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));\n    };\n\n    const confirm = (message, callback, scope) => {\n      const windowManagerImpl = getImplementation();\n      windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));\n    };\n\n    const close = () => {\n      getTopDialog().each(dialog => {\n        getImplementation().close(dialog);\n        closeDialog(dialog);\n      });\n    };\n\n    editor.on('remove', () => {\n      each$g(dialogs, dialog => {\n        getImplementation().close(dialog);\n      });\n    });\n    return {\n      open,\n      openUrl,\n      alert,\n      confirm,\n      close\n    };\n  };\n\n  const displayNotification = (editor, message) => {\n    editor.notificationManager.open({\n      type: 'error',\n      text: message\n    });\n  };\n\n  const displayError = (editor, message) => {\n    if (editor._skinLoaded) {\n      displayNotification(editor, message);\n    } else {\n      editor.on('SkinLoaded', () => {\n        displayNotification(editor, message);\n      });\n    }\n  };\n\n  const uploadError = (editor, message) => {\n    displayError(editor, I18n.translate(['Failed to upload image: {0}', message]));\n  };\n\n  const logError = (editor, errorType, msg) => {\n    fireError(editor, errorType, {\n      message: msg\n    });\n    console.error(msg);\n  };\n\n  const createLoadError = (type, url, name) => name ? `Failed to load ${type}: ${name} from url ${url}` : `Failed to load ${type} url: ${url}`;\n\n  const pluginLoadError = (editor, url, name) => {\n    logError(editor, 'PluginLoadError', createLoadError('plugin', url, name));\n  };\n\n  const iconsLoadError = (editor, url, name) => {\n    logError(editor, 'IconsLoadError', createLoadError('icons', url, name));\n  };\n\n  const languageLoadError = (editor, url, name) => {\n    logError(editor, 'LanguageLoadError', createLoadError('language', url, name));\n  };\n\n  const themeLoadError = (editor, url, name) => {\n    logError(editor, 'ThemeLoadError', createLoadError('theme', url, name));\n  };\n\n  const modelLoadError = (editor, url, name) => {\n    logError(editor, 'ModelLoadError', createLoadError('model', url, name));\n  };\n\n  const pluginInitError = (editor, name, err) => {\n    const message = I18n.translate(['Failed to initialize plugin: {0}', name]);\n    fireError(editor, 'PluginLoadError', {\n      message\n    });\n    initError(message, err);\n    displayError(editor, message);\n  };\n\n  const initError = function (message) {\n    const console = window.console;\n\n    if (console) {\n      for (var _len14 = arguments.length, x = new Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) {\n        x[_key14 - 1] = arguments[_key14];\n      }\n\n      if (console.error) {\n        console.error(message, ...x);\n      } else {\n        console.log(message, ...x);\n      }\n    }\n  };\n\n  const isContentCssSkinName = url => /^[a-z0-9\\-]+$/i.test(url);\n\n  const getContentCssUrls = editor => {\n    return transformToUrls(editor, getContentCss(editor));\n  };\n\n  const getFontCssUrls = editor => {\n    return transformToUrls(editor, getFontCss(editor));\n  };\n\n  const transformToUrls = (editor, cssLinks) => {\n    const skinUrl = editor.editorManager.baseURL + '/skins/content';\n    const suffix = editor.editorManager.suffix;\n    const contentCssFile = `content${suffix}.css`;\n    const inline = editor.inline === true;\n    return map$3(cssLinks, url => {\n      if (isContentCssSkinName(url) && !inline) {\n        return `${skinUrl}/${url}/${contentCssFile}`;\n      } else {\n        return editor.documentBaseURI.toAbsolute(url);\n      }\n    });\n  };\n\n  const appendContentCssFromSettings = editor => {\n    editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));\n  };\n\n  const filter$1 = always;\n\n  const bind$1 = (element, event, handler) => bind$2(element, event, filter$1, handler);\n\n  const UploadStatus = () => {\n    const PENDING = 1,\n          UPLOADED = 2;\n    let blobUriStatuses = {};\n\n    const createStatus = (status, resultUri) => {\n      return {\n        status,\n        resultUri\n      };\n    };\n\n    const hasBlobUri = blobUri => {\n      return blobUri in blobUriStatuses;\n    };\n\n    const getResultUri = blobUri => {\n      const result = blobUriStatuses[blobUri];\n      return result ? result.resultUri : null;\n    };\n\n    const isPending = blobUri => {\n      return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;\n    };\n\n    const isUploaded = blobUri => {\n      return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;\n    };\n\n    const markPending = blobUri => {\n      blobUriStatuses[blobUri] = createStatus(PENDING, null);\n    };\n\n    const markUploaded = (blobUri, resultUri) => {\n      blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);\n    };\n\n    const removeFailed = blobUri => {\n      delete blobUriStatuses[blobUri];\n    };\n\n    const destroy = () => {\n      blobUriStatuses = {};\n    };\n\n    return {\n      hasBlobUri,\n      getResultUri,\n      isPending,\n      isUploaded,\n      markPending,\n      markUploaded,\n      removeFailed,\n      destroy\n    };\n  };\n\n  let count = 0;\n\n  const seed = () => {\n    const rnd = () => {\n      return Math.round(Math.random() * 4294967295).toString(36);\n    };\n\n    const now = new Date().getTime();\n    return 's' + now.toString(36) + rnd() + rnd() + rnd();\n  };\n\n  const uuid = prefix => {\n    return prefix + count++ + seed();\n  };\n\n  const BlobCache = () => {\n    let cache = [];\n\n    const mimeToExt = mime => {\n      const mimes = {\n        'image/jpeg': 'jpg',\n        'image/jpg': 'jpg',\n        'image/gif': 'gif',\n        'image/png': 'png',\n        'image/apng': 'apng',\n        'image/avif': 'avif',\n        'image/svg+xml': 'svg',\n        'image/webp': 'webp',\n        'image/bmp': 'bmp',\n        'image/tiff': 'tiff'\n      };\n      return mimes[mime.toLowerCase()] || 'dat';\n    };\n\n    const create = (o, blob, base64, name, filename) => {\n      if (isString(o)) {\n        const id = o;\n        return toBlobInfo({\n          id,\n          name,\n          filename,\n          blob,\n          base64\n        });\n      } else if (isObject(o)) {\n        return toBlobInfo(o);\n      } else {\n        throw new Error('Unknown input type');\n      }\n    };\n\n    const toBlobInfo = o => {\n      if (!o.blob || !o.base64) {\n        throw new Error('blob and base64 representations of the image are required for BlobInfo to be created');\n      }\n\n      const id = o.id || uuid('blobid');\n      const name = o.name || id;\n      const blob = o.blob;\n      return {\n        id: constant(id),\n        name: constant(name),\n        filename: constant(o.filename || name + '.' + mimeToExt(blob.type)),\n        blob: constant(blob),\n        base64: constant(o.base64),\n        blobUri: constant(o.blobUri || URL.createObjectURL(blob)),\n        uri: constant(o.uri)\n      };\n    };\n\n    const add = blobInfo => {\n      if (!get(blobInfo.id())) {\n        cache.push(blobInfo);\n      }\n    };\n\n    const findFirst = predicate => find$2(cache, predicate).getOrUndefined();\n\n    const get = id => findFirst(cachedBlobInfo => cachedBlobInfo.id() === id);\n\n    const getByUri = blobUri => findFirst(blobInfo => blobInfo.blobUri() === blobUri);\n\n    const getByData = (base64, type) => findFirst(blobInfo => blobInfo.base64() === base64 && blobInfo.blob().type === type);\n\n    const removeByUri = blobUri => {\n      cache = filter$6(cache, blobInfo => {\n        if (blobInfo.blobUri() === blobUri) {\n          URL.revokeObjectURL(blobInfo.blobUri());\n          return false;\n        }\n\n        return true;\n      });\n    };\n\n    const destroy = () => {\n      each$g(cache, cachedBlobInfo => {\n        URL.revokeObjectURL(cachedBlobInfo.blobUri());\n      });\n      cache = [];\n    };\n\n    return {\n      create,\n      add,\n      get,\n      getByUri,\n      getByData,\n      findFirst,\n      removeByUri,\n      destroy\n    };\n  };\n\n  const Uploader = (uploadStatus, settings) => {\n    const pendingPromises = {};\n\n    const pathJoin = (path1, path2) => {\n      if (path1) {\n        return path1.replace(/\\/$/, '') + '/' + path2.replace(/^\\//, '');\n      }\n\n      return path2;\n    };\n\n    const defaultHandler = (blobInfo, progress) => new Promise((success, failure) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('POST', settings.url);\n      xhr.withCredentials = settings.credentials;\n\n      xhr.upload.onprogress = e => {\n        progress(e.loaded / e.total * 100);\n      };\n\n      xhr.onerror = () => {\n        failure('Image upload failed due to a XHR Transport error. Code: ' + xhr.status);\n      };\n\n      xhr.onload = () => {\n        if (xhr.status < 200 || xhr.status >= 300) {\n          failure('HTTP Error: ' + xhr.status);\n          return;\n        }\n\n        const json = JSON.parse(xhr.responseText);\n\n        if (!json || !isString(json.location)) {\n          failure('Invalid JSON: ' + xhr.responseText);\n          return;\n        }\n\n        success(pathJoin(settings.basePath, json.location));\n      };\n\n      const formData = new FormData();\n      formData.append('file', blobInfo.blob(), blobInfo.filename());\n      xhr.send(formData);\n    });\n\n    const noUpload = () => new Promise(resolve => {\n      resolve([]);\n    });\n\n    const handlerSuccess = (blobInfo, url) => ({\n      url,\n      blobInfo,\n      status: true\n    });\n\n    const handlerFailure = (blobInfo, error) => ({\n      url: '',\n      blobInfo,\n      status: false,\n      error\n    });\n\n    const resolvePending = (blobUri, result) => {\n      Tools.each(pendingPromises[blobUri], resolve => {\n        resolve(result);\n      });\n      delete pendingPromises[blobUri];\n    };\n\n    const uploadBlobInfo = (blobInfo, handler, openNotification) => {\n      uploadStatus.markPending(blobInfo.blobUri());\n      return new Promise(resolve => {\n        let notification;\n        let progress;\n\n        try {\n          const closeNotification = () => {\n            if (notification) {\n              notification.close();\n              progress = noop;\n            }\n          };\n\n          const success = url => {\n            closeNotification();\n            uploadStatus.markUploaded(blobInfo.blobUri(), url);\n            resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));\n            resolve(handlerSuccess(blobInfo, url));\n          };\n\n          const failure = error => {\n            closeNotification();\n            uploadStatus.removeFailed(blobInfo.blobUri());\n            resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error));\n            resolve(handlerFailure(blobInfo, error));\n          };\n\n          progress = percent => {\n            if (percent < 0 || percent > 100) {\n              return;\n            }\n\n            Optional.from(notification).orThunk(() => Optional.from(openNotification).map(apply$1)).each(n => {\n              notification = n;\n              n.progressBar.value(percent);\n            });\n          };\n\n          handler(blobInfo, progress).then(success, err => {\n            failure(isString(err) ? {\n              message: err\n            } : err);\n          });\n        } catch (ex) {\n          resolve(handlerFailure(blobInfo, ex));\n        }\n      });\n    };\n\n    const isDefaultHandler = handler => handler === defaultHandler;\n\n    const pendingUploadBlobInfo = blobInfo => {\n      const blobUri = blobInfo.blobUri();\n      return new Promise(resolve => {\n        pendingPromises[blobUri] = pendingPromises[blobUri] || [];\n        pendingPromises[blobUri].push(resolve);\n      });\n    };\n\n    const uploadBlobs = (blobInfos, openNotification) => {\n      blobInfos = Tools.grep(blobInfos, blobInfo => !uploadStatus.isUploaded(blobInfo.blobUri()));\n      return Promise.all(Tools.map(blobInfos, blobInfo => uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, settings.handler, openNotification)));\n    };\n\n    const upload = (blobInfos, openNotification) => !settings.url && isDefaultHandler(settings.handler) ? noUpload() : uploadBlobs(blobInfos, openNotification);\n\n    if (isFunction(settings.handler) === false) {\n      settings.handler = defaultHandler;\n    }\n\n    return {\n      upload\n    };\n  };\n\n  const openNotification = editor => () => editor.notificationManager.open({\n    text: editor.translate('Image uploading...'),\n    type: 'info',\n    timeout: -1,\n    progressBar: true\n  });\n\n  const createUploader = (editor, uploadStatus) => Uploader(uploadStatus, {\n    url: getImageUploadUrl(editor),\n    basePath: getImageUploadBasePath(editor),\n    credentials: getImagesUploadCredentials(editor),\n    handler: getImagesUploadHandler(editor)\n  });\n\n  const ImageUploader = editor => {\n    const uploadStatus = UploadStatus();\n    const uploader = createUploader(editor, uploadStatus);\n    return {\n      upload: function (blobInfos) {\n        let showNotification = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return uploader.upload(blobInfos, showNotification ? openNotification(editor) : undefined);\n      }\n    };\n  };\n\n  const UploadChangeHandler = editor => {\n    const lastChangedLevel = Cell(null);\n    editor.on('change AddUndo', e => {\n      lastChangedLevel.set({ ...e.level\n      });\n    });\n\n    const fireIfChanged = () => {\n      const data = editor.undoManager.data;\n      last$3(data).filter(level => {\n        return !isEq$1(lastChangedLevel.get(), level);\n      }).each(level => {\n        editor.setDirty(true);\n        editor.dispatch('change', {\n          level,\n          lastLevel: get$b(data, data.length - 2).getOrNull()\n        });\n      });\n    };\n\n    return {\n      fireIfChanged\n    };\n  };\n\n  const EditorUpload = editor => {\n    const blobCache = BlobCache();\n    let uploader, imageScanner;\n    const uploadStatus = UploadStatus();\n    const urlFilters = [];\n    const changeHandler = UploadChangeHandler(editor);\n\n    const aliveGuard = callback => {\n      return result => {\n        if (editor.selection) {\n          return callback(result);\n        }\n\n        return [];\n      };\n    };\n\n    const cacheInvalidator = url => url + (url.indexOf('?') === -1 ? '?' : '&') + new Date().getTime();\n\n    const replaceString = (content, search, replace) => {\n      let index = 0;\n\n      do {\n        index = content.indexOf(search, index);\n\n        if (index !== -1) {\n          content = content.substring(0, index) + replace + content.substr(index + search.length);\n          index += replace.length - search.length + 1;\n        }\n      } while (index !== -1);\n\n      return content;\n    };\n\n    const replaceImageUrl = (content, targetUrl, replacementUrl) => {\n      const replacementString = `src=\"${replacementUrl}\"${replacementUrl === Env.transparentSrc ? ' data-mce-placeholder=\"1\"' : ''}`;\n      content = replaceString(content, `src=\"${targetUrl}\"`, replacementString);\n      content = replaceString(content, 'data-mce-src=\"' + targetUrl + '\"', 'data-mce-src=\"' + replacementUrl + '\"');\n      return content;\n    };\n\n    const replaceUrlInUndoStack = (targetUrl, replacementUrl) => {\n      each$g(editor.undoManager.data, level => {\n        if (level.type === 'fragmented') {\n          level.fragments = map$3(level.fragments, fragment => replaceImageUrl(fragment, targetUrl, replacementUrl));\n        } else {\n          level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);\n        }\n      });\n    };\n\n    const replaceImageUriInView = (image, resultUri) => {\n      const src = editor.convertURL(resultUri, 'src');\n      replaceUrlInUndoStack(image.src, resultUri);\n      setAll$1(SugarElement.fromDom(image), {\n        'src': shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,\n        'data-mce-src': src\n      });\n    };\n\n    const uploadImages = () => {\n      if (!uploader) {\n        uploader = createUploader(editor, uploadStatus);\n      }\n\n      return scanForImages().then(aliveGuard(imageInfos => {\n        const blobInfos = map$3(imageInfos, imageInfo => imageInfo.blobInfo);\n        return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard(result => {\n          const imagesToRemove = [];\n          const filteredResult = map$3(result, (uploadInfo, index) => {\n            const blobInfo = imageInfos[index].blobInfo;\n            const image = imageInfos[index].image;\n            let removed = false;\n\n            if (uploadInfo.status && shouldReplaceBlobUris(editor)) {\n              blobCache.removeByUri(image.src);\n              if (isRtc(editor)) ;else {\n                replaceImageUriInView(image, uploadInfo.url);\n              }\n            } else if (uploadInfo.error) {\n              if (uploadInfo.error.remove) {\n                replaceUrlInUndoStack(image.getAttribute('src'), Env.transparentSrc);\n                imagesToRemove.push(image);\n                removed = true;\n              }\n\n              uploadError(editor, uploadInfo.error.message);\n            }\n\n            return {\n              element: image,\n              status: uploadInfo.status,\n              uploadUri: uploadInfo.url,\n              blobInfo,\n              removed\n            };\n          });\n\n          if (filteredResult.length > 0) {\n            changeHandler.fireIfChanged();\n          }\n\n          if (imagesToRemove.length > 0 && !isRtc(editor)) {\n            editor.undoManager.transact(() => {\n              each$g(imagesToRemove, element => {\n                editor.dom.remove(element);\n                blobCache.removeByUri(element.src);\n              });\n            });\n          }\n\n          return filteredResult;\n        }));\n      }));\n    };\n\n    const uploadImagesAuto = () => isAutomaticUploadsEnabled(editor) ? uploadImages() : Promise.resolve([]);\n\n    const isValidDataUriImage = imgElm => forall(urlFilters, filter => filter(imgElm));\n\n    const addFilter = filter => {\n      urlFilters.push(filter);\n    };\n\n    const scanForImages = () => {\n      if (!imageScanner) {\n        imageScanner = ImageScanner(uploadStatus, blobCache);\n      }\n\n      return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(result => {\n        result = filter$6(result, resultItem => {\n          if (typeof resultItem === 'string') {\n            displayError(editor, resultItem);\n            return false;\n          }\n\n          return true;\n        });\n        if (isRtc(editor)) ;else {\n          each$g(result, resultItem => {\n            replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());\n            resultItem.image.src = resultItem.blobInfo.blobUri();\n            resultItem.image.removeAttribute('data-mce-src');\n          });\n        }\n        return result;\n      }));\n    };\n\n    const destroy = () => {\n      blobCache.destroy();\n      uploadStatus.destroy();\n      imageScanner = uploader = null;\n    };\n\n    const replaceBlobUris = content => {\n      return content.replace(/src=\"(blob:[^\"]+)\"/g, (match, blobUri) => {\n        const resultUri = uploadStatus.getResultUri(blobUri);\n\n        if (resultUri) {\n          return 'src=\"' + resultUri + '\"';\n        }\n\n        let blobInfo = blobCache.getByUri(blobUri);\n\n        if (!blobInfo) {\n          blobInfo = foldl(editor.editorManager.get(), (result, editor) => {\n            return result || editor.editorUpload && editor.editorUpload.blobCache.getByUri(blobUri);\n          }, null);\n        }\n\n        if (blobInfo) {\n          const blob = blobInfo.blob();\n          return 'src=\"data:' + blob.type + ';base64,' + blobInfo.base64() + '\"';\n        }\n\n        return match;\n      });\n    };\n\n    editor.on('SetContent', () => {\n      if (isAutomaticUploadsEnabled(editor)) {\n        uploadImagesAuto();\n      } else {\n        scanForImages();\n      }\n    });\n    editor.on('RawSaveContent', e => {\n      e.content = replaceBlobUris(e.content);\n    });\n    editor.on('GetContent', e => {\n      if (e.source_view || e.format === 'raw' || e.format === 'tree') {\n        return;\n      }\n\n      e.content = replaceBlobUris(e.content);\n    });\n    editor.on('PostRender', () => {\n      editor.parser.addNodeFilter('img', images => {\n        each$g(images, img => {\n          const src = img.attr('src');\n\n          if (blobCache.getByUri(src)) {\n            return;\n          }\n\n          const resultUri = uploadStatus.getResultUri(src);\n\n          if (resultUri) {\n            img.attr('src', resultUri);\n          }\n        });\n      });\n    });\n    return {\n      blobCache,\n      addFilter,\n      uploadImages,\n      uploadImagesAuto,\n      scanForImages,\n      destroy\n    };\n  };\n\n  const get$1 = editor => {\n    const dom = editor.dom;\n    const schemaType = editor.schema.type;\n    const formats = {\n      valigntop: [{\n        selector: 'td,th',\n        styles: {\n          verticalAlign: 'top'\n        }\n      }],\n      valignmiddle: [{\n        selector: 'td,th',\n        styles: {\n          verticalAlign: 'middle'\n        }\n      }],\n      valignbottom: [{\n        selector: 'td,th',\n        styles: {\n          verticalAlign: 'bottom'\n        }\n      }],\n      alignleft: [{\n        selector: 'figure.image',\n        collapsed: false,\n        classes: 'align-left',\n        ceFalseOverride: true,\n        preview: 'font-family font-size'\n      }, {\n        selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',\n        styles: {\n          textAlign: 'left'\n        },\n        inherit: false,\n        preview: false\n      }, {\n        selector: 'img,audio,video',\n        collapsed: false,\n        styles: {\n          float: 'left'\n        },\n        preview: 'font-family font-size'\n      }, {\n        selector: 'table',\n        collapsed: false,\n        styles: {\n          marginLeft: '0px',\n          marginRight: 'auto'\n        },\n        onformat: table => {\n          dom.setStyle(table, 'float', null);\n        },\n        preview: 'font-family font-size'\n      }],\n      aligncenter: [{\n        selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',\n        styles: {\n          textAlign: 'center'\n        },\n        inherit: false,\n        preview: 'font-family font-size'\n      }, {\n        selector: 'figure.image',\n        collapsed: false,\n        classes: 'align-center',\n        ceFalseOverride: true,\n        preview: 'font-family font-size'\n      }, {\n        selector: 'img,audio,video',\n        collapsed: false,\n        styles: {\n          display: 'block',\n          marginLeft: 'auto',\n          marginRight: 'auto'\n        },\n        preview: false\n      }, {\n        selector: 'table',\n        collapsed: false,\n        styles: {\n          marginLeft: 'auto',\n          marginRight: 'auto'\n        },\n        preview: 'font-family font-size'\n      }],\n      alignright: [{\n        selector: 'figure.image',\n        collapsed: false,\n        classes: 'align-right',\n        ceFalseOverride: true,\n        preview: 'font-family font-size'\n      }, {\n        selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',\n        styles: {\n          textAlign: 'right'\n        },\n        inherit: false,\n        preview: 'font-family font-size'\n      }, {\n        selector: 'img,audio,video',\n        collapsed: false,\n        styles: {\n          float: 'right'\n        },\n        preview: 'font-family font-size'\n      }, {\n        selector: 'table',\n        collapsed: false,\n        styles: {\n          marginRight: '0px',\n          marginLeft: 'auto'\n        },\n        onformat: table => {\n          dom.setStyle(table, 'float', null);\n        },\n        preview: 'font-family font-size'\n      }],\n      alignjustify: [{\n        selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',\n        styles: {\n          textAlign: 'justify'\n        },\n        inherit: false,\n        preview: 'font-family font-size'\n      }],\n      bold: [{\n        inline: 'strong',\n        remove: 'all',\n        preserve_attributes: ['class', 'style']\n      }, {\n        inline: 'span',\n        styles: {\n          fontWeight: 'bold'\n        }\n      }, {\n        inline: 'b',\n        remove: 'all',\n        preserve_attributes: ['class', 'style']\n      }],\n      italic: [{\n        inline: 'em',\n        remove: 'all',\n        preserve_attributes: ['class', 'style']\n      }, {\n        inline: 'span',\n        styles: {\n          fontStyle: 'italic'\n        }\n      }, {\n        inline: 'i',\n        remove: 'all',\n        preserve_attributes: ['class', 'style']\n      }],\n      underline: [{\n        inline: 'span',\n        styles: {\n          textDecoration: 'underline'\n        },\n        exact: true\n      }, {\n        inline: 'u',\n        remove: 'all',\n        preserve_attributes: ['class', 'style']\n      }],\n      strikethrough: (() => {\n        const span = {\n          inline: 'span',\n          styles: {\n            textDecoration: 'line-through'\n          },\n          exact: true\n        };\n        const strike = {\n          inline: 'strike',\n          remove: 'all',\n          preserve_attributes: ['class', 'style']\n        };\n        const s = {\n          inline: 's',\n          remove: 'all',\n          preserve_attributes: ['class', 'style']\n        };\n        return schemaType !== 'html4' ? [s, span, strike] : [span, s, strike];\n      })(),\n      forecolor: {\n        inline: 'span',\n        styles: {\n          color: '%value'\n        },\n        links: true,\n        remove_similar: true,\n        clear_child_styles: true\n      },\n      hilitecolor: {\n        inline: 'span',\n        styles: {\n          backgroundColor: '%value'\n        },\n        links: true,\n        remove_similar: true,\n        clear_child_styles: true\n      },\n      fontname: {\n        inline: 'span',\n        toggle: false,\n        styles: {\n          fontFamily: '%value'\n        },\n        clear_child_styles: true\n      },\n      fontsize: {\n        inline: 'span',\n        toggle: false,\n        styles: {\n          fontSize: '%value'\n        },\n        clear_child_styles: true\n      },\n      lineheight: {\n        selector: 'h1,h2,h3,h4,h5,h6,p,li,td,th,div',\n        styles: {\n          lineHeight: '%value'\n        }\n      },\n      fontsize_class: {\n        inline: 'span',\n        attributes: {\n          class: '%value'\n        }\n      },\n      blockquote: {\n        block: 'blockquote',\n        wrapper: true,\n        remove: 'all'\n      },\n      subscript: {\n        inline: 'sub'\n      },\n      superscript: {\n        inline: 'sup'\n      },\n      code: {\n        inline: 'code'\n      },\n      link: {\n        inline: 'a',\n        selector: 'a',\n        remove: 'all',\n        split: true,\n        deep: true,\n        onmatch: (node, _fmt, _itemName) => {\n          return isElement$6(node) && node.hasAttribute('href');\n        },\n        onformat: (elm, _fmt, vars) => {\n          Tools.each(vars, (value, key) => {\n            dom.setAttrib(elm, key, value);\n          });\n        }\n      },\n      lang: {\n        inline: 'span',\n        clear_child_styles: true,\n        remove_similar: true,\n        attributes: {\n          'lang': '%value',\n          'data-mce-lang': vars => {\n            var _a;\n\n            return (_a = vars === null || vars === void 0 ? void 0 : vars.customValue) !== null && _a !== void 0 ? _a : null;\n          }\n        }\n      },\n      removeformat: [{\n        selector: 'b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small',\n        remove: 'all',\n        split: true,\n        expand: false,\n        block_expand: true,\n        deep: true\n      }, {\n        selector: 'span',\n        attributes: ['style', 'class'],\n        remove: 'empty',\n        split: true,\n        expand: false,\n        deep: true\n      }, {\n        selector: '*',\n        attributes: ['style', 'class'],\n        split: false,\n        expand: false,\n        deep: true\n      }]\n    };\n    Tools.each('p h1 h2 h3 h4 h5 h6 div address pre dt dd samp'.split(/\\s/), name => {\n      formats[name] = {\n        block: name,\n        remove: 'all'\n      };\n    });\n    return formats;\n  };\n\n  const genericBase = {\n    remove_similar: true,\n    inherit: false\n  };\n  const cellBase = {\n    selector: 'td,th',\n    ...genericBase\n  };\n  const cellFormats = {\n    tablecellbackgroundcolor: {\n      styles: {\n        backgroundColor: '%value'\n      },\n      ...cellBase\n    },\n    tablecellverticalalign: {\n      styles: {\n        'vertical-align': '%value'\n      },\n      ...cellBase\n    },\n    tablecellbordercolor: {\n      styles: {\n        borderColor: '%value'\n      },\n      ...cellBase\n    },\n    tablecellclass: {\n      classes: ['%value'],\n      ...cellBase\n    },\n    tableclass: {\n      selector: 'table',\n      classes: ['%value'],\n      ...genericBase\n    },\n    tablecellborderstyle: {\n      styles: {\n        borderStyle: '%value'\n      },\n      ...cellBase\n    },\n    tablecellborderwidth: {\n      styles: {\n        borderWidth: '%value'\n      },\n      ...cellBase\n    }\n  };\n  const get = constant(cellFormats);\n\n  const FormatRegistry = editor => {\n    const formats = {};\n\n    const get$2 = name => isNonNullable(name) ? formats[name] : formats;\n\n    const has = name => has$2(formats, name);\n\n    const register = (name, format) => {\n      if (name) {\n        if (!isString(name)) {\n          each$f(name, (format, name) => {\n            register(name, format);\n          });\n        } else {\n          if (!isArray$1(format)) {\n            format = [format];\n          }\n\n          each$g(format, format => {\n            if (isUndefined(format.deep)) {\n              format.deep = !isSelectorFormat(format);\n            }\n\n            if (isUndefined(format.split)) {\n              format.split = !isSelectorFormat(format) || isInlineFormat(format);\n            }\n\n            if (isUndefined(format.remove) && isSelectorFormat(format) && !isInlineFormat(format)) {\n              format.remove = 'none';\n            }\n\n            if (isSelectorFormat(format) && isInlineFormat(format)) {\n              format.mixed = true;\n              format.block_expand = true;\n            }\n\n            if (isString(format.classes)) {\n              format.classes = format.classes.split(/\\s+/);\n            }\n          });\n          formats[name] = format;\n        }\n      }\n    };\n\n    const unregister = name => {\n      if (name && formats[name]) {\n        delete formats[name];\n      }\n\n      return formats;\n    };\n\n    register(get$1(editor));\n    register(get());\n    register(getFormats(editor));\n    return {\n      get: get$2,\n      has,\n      register,\n      unregister\n    };\n  };\n\n  const each$3 = Tools.each;\n  const dom = DOMUtils.DOM;\n\n  const parsedSelectorToHtml = (ancestry, editor) => {\n    let elm, item, fragment;\n    const schema = editor && editor.schema || Schema({});\n\n    const decorate = (elm, item) => {\n      if (item.classes.length) {\n        dom.addClass(elm, item.classes.join(' '));\n      }\n\n      dom.setAttribs(elm, item.attrs);\n    };\n\n    const createElement = sItem => {\n      item = typeof sItem === 'string' ? {\n        name: sItem,\n        classes: [],\n        attrs: {}\n      } : sItem;\n      const elm = dom.create(item.name);\n      decorate(elm, item);\n      return elm;\n    };\n\n    const getRequiredParent = (elm, candidate) => {\n      const name = typeof elm !== 'string' ? elm.nodeName.toLowerCase() : elm;\n      const elmRule = schema.getElementRule(name);\n      const parentsRequired = elmRule && elmRule.parentsRequired;\n\n      if (parentsRequired && parentsRequired.length) {\n        return candidate && Tools.inArray(parentsRequired, candidate) !== -1 ? candidate : parentsRequired[0];\n      } else {\n        return false;\n      }\n    };\n\n    const wrapInHtml = (elm, ancestry, siblings) => {\n      let parent, parentCandidate;\n      const ancestor = ancestry.length > 0 && ancestry[0];\n      const ancestorName = ancestor && ancestor.name;\n      const parentRequired = getRequiredParent(elm, ancestorName);\n\n      if (parentRequired) {\n        if (ancestorName === parentRequired) {\n          parentCandidate = ancestry[0];\n          ancestry = ancestry.slice(1);\n        } else {\n          parentCandidate = parentRequired;\n        }\n      } else if (ancestor) {\n        parentCandidate = ancestry[0];\n        ancestry = ancestry.slice(1);\n      } else if (!siblings) {\n        return elm;\n      }\n\n      if (parentCandidate) {\n        parent = createElement(parentCandidate);\n        parent.appendChild(elm);\n      }\n\n      if (siblings) {\n        if (!parent) {\n          parent = dom.create('div');\n          parent.appendChild(elm);\n        }\n\n        Tools.each(siblings, sibling => {\n          const siblingElm = createElement(sibling);\n          parent.insertBefore(siblingElm, elm);\n        });\n      }\n\n      return wrapInHtml(parent, ancestry, parentCandidate && parentCandidate.siblings);\n    };\n\n    if (ancestry && ancestry.length) {\n      item = ancestry[0];\n      elm = createElement(item);\n      fragment = dom.create('div');\n      fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), item.siblings));\n      return fragment;\n    } else {\n      return '';\n    }\n  };\n\n  const parseSelectorItem = item => {\n    let tagName;\n    const obj = {\n      classes: [],\n      attrs: {}\n    };\n    item = obj.selector = Tools.trim(item);\n\n    if (item !== '*') {\n      tagName = item.replace(/(?:([#\\.]|::?)([\\w\\-]+)|(\\[)([^\\]]+)\\]?)/g, ($0, $1, $2, $3, $4) => {\n        switch ($1) {\n          case '#':\n            obj.attrs.id = $2;\n            break;\n\n          case '.':\n            obj.classes.push($2);\n            break;\n\n          case ':':\n            if (Tools.inArray('checked disabled enabled read-only required'.split(' '), $2) !== -1) {\n              obj.attrs[$2] = $2;\n            }\n\n            break;\n        }\n\n        if ($3 === '[') {\n          const m = $4.match(/([\\w\\-]+)(?:\\=\\\"([^\\\"]+))?/);\n\n          if (m) {\n            obj.attrs[m[1]] = m[2];\n          }\n        }\n\n        return '';\n      });\n    }\n\n    obj.name = tagName || 'div';\n    return obj;\n  };\n\n  const parseSelector = selector => {\n    if (!selector || typeof selector !== 'string') {\n      return [];\n    }\n\n    selector = selector.split(/\\s*,\\s*/)[0];\n    selector = selector.replace(/\\s*(~\\+|~|\\+|>)\\s*/g, '$1');\n    return Tools.map(selector.split(/(?:>|\\s+(?![^\\[\\]]+\\]))/), item => {\n      const siblings = Tools.map(item.split(/(?:~\\+|~|\\+)/), parseSelectorItem);\n      const obj = siblings.pop();\n\n      if (siblings.length) {\n        obj.siblings = siblings;\n      }\n\n      return obj;\n    }).reverse();\n  };\n\n  const getCssText = (editor, format) => {\n    let name, previewFrag;\n    let previewCss = '',\n        parentFontSize;\n    let previewStyles = getPreviewStyles(editor);\n\n    if (previewStyles === '') {\n      return '';\n    }\n\n    const removeVars = val => {\n      return val.replace(/%(\\w+)/g, '');\n    };\n\n    if (typeof format === 'string') {\n      format = editor.formatter.get(format);\n\n      if (!format) {\n        return;\n      }\n\n      format = format[0];\n    }\n\n    if ('preview' in format) {\n      const previewOpt = get$a(format, 'preview');\n\n      if (is$2(previewOpt, false)) {\n        return '';\n      } else {\n        previewStyles = previewOpt.getOr(previewStyles);\n      }\n    }\n\n    name = format.block || format.inline || 'span';\n    const items = parseSelector(format.selector);\n\n    if (items.length) {\n      if (!items[0].name) {\n        items[0].name = name;\n      }\n\n      name = format.selector;\n      previewFrag = parsedSelectorToHtml(items, editor);\n    } else {\n      previewFrag = parsedSelectorToHtml([name], editor);\n    }\n\n    const previewElm = dom.select(name, previewFrag)[0] || previewFrag.firstChild;\n    each$3(format.styles, (value, name) => {\n      const newValue = removeVars(value);\n\n      if (newValue) {\n        dom.setStyle(previewElm, name, newValue);\n      }\n    });\n    each$3(format.attributes, (value, name) => {\n      const newValue = removeVars(value);\n\n      if (newValue) {\n        dom.setAttrib(previewElm, name, newValue);\n      }\n    });\n    each$3(format.classes, value => {\n      const newValue = removeVars(value);\n\n      if (!dom.hasClass(previewElm, newValue)) {\n        dom.addClass(previewElm, newValue);\n      }\n    });\n    editor.dispatch('PreviewFormats');\n    dom.setStyles(previewFrag, {\n      position: 'absolute',\n      left: -65535\n    });\n    editor.getBody().appendChild(previewFrag);\n    parentFontSize = dom.getStyle(editor.getBody(), 'fontSize', true);\n    parentFontSize = /px$/.test(parentFontSize) ? parseInt(parentFontSize, 10) : 0;\n    each$3(previewStyles.split(' '), name => {\n      let value = dom.getStyle(previewElm, name, true);\n\n      if (name === 'background-color' && /transparent|rgba\\s*\\([^)]+,\\s*0\\)/.test(value)) {\n        value = dom.getStyle(editor.getBody(), name, true);\n\n        if (rgbaToHexString(value).toLowerCase() === '#ffffff') {\n          return;\n        }\n      }\n\n      if (name === 'color') {\n        if (rgbaToHexString(value).toLowerCase() === '#000000') {\n          return;\n        }\n      }\n\n      if (name === 'font-size') {\n        if (/em|%$/.test(value)) {\n          if (parentFontSize === 0) {\n            return;\n          }\n\n          const numValue = parseFloat(value) / (/%$/.test(value) ? 100 : 1);\n          value = numValue * parentFontSize + 'px';\n        }\n      }\n\n      if (name === 'border' && value) {\n        previewCss += 'padding:0 2px;';\n      }\n\n      previewCss += name + ':' + value + ';';\n    });\n    editor.dispatch('AfterPreviewFormats');\n    dom.remove(previewFrag);\n    return previewCss;\n  };\n\n  const setup$r = editor => {\n    editor.addShortcut('meta+b', '', 'Bold');\n    editor.addShortcut('meta+i', '', 'Italic');\n    editor.addShortcut('meta+u', '', 'Underline');\n\n    for (let i = 1; i <= 6; i++) {\n      editor.addShortcut('access+' + i, '', ['FormatBlock', false, 'h' + i]);\n    }\n\n    editor.addShortcut('access+7', '', ['FormatBlock', false, 'p']);\n    editor.addShortcut('access+8', '', ['FormatBlock', false, 'div']);\n    editor.addShortcut('access+9', '', ['FormatBlock', false, 'address']);\n  };\n\n  const Formatter = editor => {\n    const formats = FormatRegistry(editor);\n    const formatChangeState = Cell(null);\n    setup$r(editor);\n    setup$u(editor);\n    return {\n      get: formats.get,\n      has: formats.has,\n      register: formats.register,\n      unregister: formats.unregister,\n      apply: (name, vars, node) => {\n        applyFormat(editor, name, vars, node);\n      },\n      remove: (name, vars, node, similar) => {\n        removeFormat(editor, name, vars, node, similar);\n      },\n      toggle: (name, vars, node) => {\n        toggleFormat(editor, name, vars, node);\n      },\n      match: (name, vars, node, similar) => matchFormat(editor, name, vars, node, similar),\n      closest: names => closestFormat(editor, names),\n      matchAll: (names, vars) => matchAllFormats(editor, names, vars),\n      matchNode: (node, name, vars, similar) => matchNodeFormat(editor, node, name, vars, similar),\n      canApply: name => canApplyFormat(editor, name),\n      formatChanged: (formats, callback, similar, vars) => formatChanged(editor, formatChangeState, formats, callback, similar, vars),\n      getCssText: curry(getCssText, editor)\n    };\n  };\n\n  const shouldIgnoreCommand = cmd => {\n    switch (cmd.toLowerCase()) {\n      case 'undo':\n      case 'redo':\n      case 'mcefocus':\n        return true;\n\n      default:\n        return false;\n    }\n  };\n\n  const registerEvents = (editor, undoManager, locks) => {\n    const isFirstTypedCharacter = Cell(false);\n\n    const addNonTypingUndoLevel = e => {\n      setTyping(undoManager, false, locks);\n      undoManager.add({}, e);\n    };\n\n    editor.on('init', () => {\n      undoManager.add();\n    });\n    editor.on('BeforeExecCommand', e => {\n      const cmd = e.command;\n\n      if (!shouldIgnoreCommand(cmd)) {\n        endTyping(undoManager, locks);\n        undoManager.beforeChange();\n      }\n    });\n    editor.on('ExecCommand', e => {\n      const cmd = e.command;\n\n      if (!shouldIgnoreCommand(cmd)) {\n        addNonTypingUndoLevel(e);\n      }\n    });\n    editor.on('ObjectResizeStart cut', () => {\n      undoManager.beforeChange();\n    });\n    editor.on('SaveContent ObjectResized blur', addNonTypingUndoLevel);\n    editor.on('dragend', addNonTypingUndoLevel);\n    editor.on('keyup', e => {\n      const keyCode = e.keyCode;\n\n      if (e.isDefaultPrevented()) {\n        return;\n      }\n\n      if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey) {\n        addNonTypingUndoLevel();\n        editor.nodeChanged();\n      }\n\n      if (keyCode === 46 || keyCode === 8) {\n        editor.nodeChanged();\n      }\n\n      if (isFirstTypedCharacter.get() && undoManager.typing && isEq$1(createFromEditor(editor), undoManager.data[0]) === false) {\n        if (editor.isDirty() === false) {\n          editor.setDirty(true);\n        }\n\n        editor.dispatch('TypingUndo');\n        isFirstTypedCharacter.set(false);\n        editor.nodeChanged();\n      }\n    });\n    editor.on('keydown', e => {\n      const keyCode = e.keyCode;\n\n      if (e.isDefaultPrevented()) {\n        return;\n      }\n\n      if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {\n        if (undoManager.typing) {\n          addNonTypingUndoLevel(e);\n        }\n\n        return;\n      }\n\n      const modKey = e.ctrlKey && !e.altKey || e.metaKey;\n\n      if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {\n        undoManager.beforeChange();\n        setTyping(undoManager, true, locks);\n        undoManager.add({}, e);\n        isFirstTypedCharacter.set(true);\n      }\n    });\n    editor.on('mousedown', e => {\n      if (undoManager.typing) {\n        addNonTypingUndoLevel(e);\n      }\n    });\n\n    const isInsertReplacementText = event => event.inputType === 'insertReplacementText';\n\n    const isInsertTextDataNull = event => event.inputType === 'insertText' && event.data === null;\n\n    const isInsertFromPasteOrDrop = event => event.inputType === 'insertFromPaste' || event.inputType === 'insertFromDrop';\n\n    editor.on('input', e => {\n      if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) {\n        addNonTypingUndoLevel(e);\n      }\n    });\n    editor.on('AddUndo Undo Redo ClearUndos', e => {\n      if (!e.isDefaultPrevented()) {\n        editor.nodeChanged();\n      }\n    });\n  };\n\n  const addKeyboardShortcuts = editor => {\n    editor.addShortcut('meta+z', '', 'Undo');\n    editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');\n  };\n\n  const UndoManager = editor => {\n    const beforeBookmark = value$2();\n    const locks = Cell(0);\n    const index = Cell(0);\n    const undoManager = {\n      data: [],\n      typing: false,\n      beforeChange: () => {\n        beforeChange(editor, locks, beforeBookmark);\n      },\n      add: (level, event) => {\n        return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);\n      },\n      undo: () => {\n        return undo(editor, undoManager, locks, index);\n      },\n      redo: () => {\n        return redo(editor, index, undoManager.data);\n      },\n      clear: () => {\n        clear(editor, undoManager, index);\n      },\n      reset: () => {\n        reset(editor, undoManager);\n      },\n      hasUndo: () => {\n        return hasUndo(editor, undoManager, index);\n      },\n      hasRedo: () => {\n        return hasRedo(editor, undoManager, index);\n      },\n      transact: callback => {\n        return transact(editor, undoManager, locks, callback);\n      },\n      ignore: callback => {\n        ignore(editor, locks, callback);\n      },\n      extra: (callback1, callback2) => {\n        extra(editor, undoManager, index, callback1, callback2);\n      }\n    };\n\n    if (!isRtc(editor)) {\n      registerEvents(editor, undoManager, locks);\n    }\n\n    addKeyboardShortcuts(editor);\n    return undoManager;\n  };\n\n  const nonTypingKeycodes = [9, 27, VK.HOME, VK.END, 19, 20, 44, 144, 145, 33, 34, 45, 16, 17, 18, 91, 92, 93, VK.DOWN, VK.UP, VK.LEFT, VK.RIGHT].concat(Env.browser.isFirefox() ? [224] : []);\n  const placeholderAttr = 'data-mce-placeholder';\n\n  const isKeyboardEvent = e => e.type === 'keydown' || e.type === 'keyup';\n\n  const isDeleteEvent = e => {\n    const keyCode = e.keyCode;\n    return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;\n  };\n\n  const isNonTypingKeyboardEvent = e => {\n    if (isKeyboardEvent(e)) {\n      const keyCode = e.keyCode;\n      return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains$2(nonTypingKeycodes, keyCode));\n    } else {\n      return false;\n    }\n  };\n\n  const isTypingKeyboardEvent = e => isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === 'keyup' && e.keyCode === 229);\n\n  const isVisuallyEmpty = (dom, rootElm, forcedRootBlock) => {\n    if (isEmpty$2(SugarElement.fromDom(rootElm), false)) {\n      const firstElement = rootElm.firstElementChild;\n\n      if (!firstElement) {\n        return true;\n      } else if (dom.getStyle(rootElm.firstElementChild, 'padding-left') || dom.getStyle(rootElm.firstElementChild, 'padding-right')) {\n        return false;\n      } else {\n        return forcedRootBlock === firstElement.nodeName.toLowerCase();\n      }\n    } else {\n      return false;\n    }\n  };\n\n  const setup$q = editor => {\n    const dom = editor.dom;\n    const rootBlock = getForcedRootBlock(editor);\n    const placeholder = getPlaceholder(editor);\n\n    const updatePlaceholder = (e, initial) => {\n      if (isNonTypingKeyboardEvent(e)) {\n        return;\n      }\n\n      const body = editor.getBody();\n      const showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom, body, rootBlock);\n      const isPlaceholderShown = dom.getAttrib(body, placeholderAttr) !== '';\n\n      if (isPlaceholderShown !== showPlaceholder || initial) {\n        dom.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);\n        dom.setAttrib(body, 'aria-placeholder', showPlaceholder ? placeholder : null);\n        firePlaceholderToggle(editor, showPlaceholder);\n        editor.on(showPlaceholder ? 'keydown' : 'keyup', updatePlaceholder);\n        editor.off(showPlaceholder ? 'keyup' : 'keydown', updatePlaceholder);\n      }\n    };\n\n    if (placeholder) {\n      editor.on('init', e => {\n        updatePlaceholder(e, true);\n        editor.on('change SetContent ExecCommand', updatePlaceholder);\n        editor.on('paste', e => Delay.setEditorTimeout(editor, () => updatePlaceholder(e)));\n      });\n    }\n  };\n\n  const strongRtl = /[\\u0591-\\u07FF\\uFB1D-\\uFDFF\\uFE70-\\uFEFC]/;\n\n  const hasStrongRtl = text => strongRtl.test(text);\n\n  const isInlineTarget = (editor, elm) => is$1(SugarElement.fromDom(elm), getInlineBoundarySelector(editor));\n\n  const isRtl = element => DOMUtils.DOM.getStyle(element, 'direction', true) === 'rtl' || hasStrongRtl(element.textContent);\n\n  const findInlineParents = (isInlineTarget, rootNode, pos) => filter$6(DOMUtils.DOM.getParents(pos.container(), '*', rootNode), isInlineTarget);\n\n  const findRootInline = (isInlineTarget, rootNode, pos) => {\n    const parents = findInlineParents(isInlineTarget, rootNode, pos);\n    return Optional.from(parents[parents.length - 1]);\n  };\n\n  const hasSameParentBlock = (rootNode, node1, node2) => {\n    const block1 = getParentBlock$3(node1, rootNode);\n    const block2 = getParentBlock$3(node2, rootNode);\n    return block1 && block1 === block2;\n  };\n\n  const isAtZwsp = pos => isBeforeInline(pos) || isAfterInline(pos);\n\n  const normalizePosition = (forward, pos) => {\n    if (!pos) {\n      return pos;\n    }\n\n    const container = pos.container(),\n          offset = pos.offset();\n\n    if (forward) {\n      if (isCaretContainerInline(container)) {\n        if (isText$8(container.nextSibling)) {\n          return CaretPosition(container.nextSibling, 0);\n        } else {\n          return CaretPosition.after(container);\n        }\n      } else {\n        return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;\n      }\n    } else {\n      if (isCaretContainerInline(container)) {\n        if (isText$8(container.previousSibling)) {\n          return CaretPosition(container.previousSibling, container.previousSibling.data.length);\n        } else {\n          return CaretPosition.before(container);\n        }\n      } else {\n        return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;\n      }\n    }\n  };\n\n  const normalizeForwards = curry(normalizePosition, true);\n  const normalizeBackwards = curry(normalizePosition, false);\n\n  const execCommandIgnoreInputEvents = (editor, command) => {\n    const inputBlocker = e => e.stopImmediatePropagation();\n\n    editor.on('beforeinput input', inputBlocker, true);\n    editor.getDoc().execCommand(command);\n    editor.off('beforeinput input', inputBlocker);\n  };\n\n  const execDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'Delete');\n\n  const execForwardDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'ForwardDelete');\n\n  const isBeforeRoot = rootNode => elm => eq(rootNode, SugarElement.fromDom(elm.dom.parentNode));\n\n  const isTextBlockOrListItem = element => isTextBlock$2(element) || isListItem(element);\n\n  const getParentBlock$2 = (rootNode, elm) => {\n    if (contains(rootNode, elm)) {\n      return closest$4(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const placeCaretInEmptyBody = editor => {\n    const body = editor.getBody();\n    const node = body.firstChild && editor.dom.isBlock(body.firstChild) ? body.firstChild : body;\n    editor.selection.setCursorLocation(node, 0);\n  };\n\n  const paddEmptyBody = editor => {\n    if (editor.dom.isEmpty(editor.getBody())) {\n      editor.setContent('');\n      placeCaretInEmptyBody(editor);\n    }\n  };\n\n  const willDeleteLastPositionInElement = (forward, fromPos, elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\n    const normalizedFirstPos = normalizePosition(true, firstPos);\n    const normalizedLastPos = normalizePosition(false, lastPos);\n    const normalizedFromPos = normalizePosition(false, fromPos);\n\n    if (forward) {\n      return nextPosition(elm, normalizedFromPos).exists(nextPos => nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos));\n    } else {\n      return prevPosition(elm, normalizedFromPos).exists(prevPos => prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos));\n    }\n  }).getOr(true);\n\n  const blockPosition = (block, position) => ({\n    block,\n    position\n  });\n\n  const blockBoundary = (from, to) => ({\n    from,\n    to\n  });\n\n  const getBlockPosition = (rootNode, pos) => {\n    const rootElm = SugarElement.fromDom(rootNode);\n    const containerElm = SugarElement.fromDom(pos.container());\n    return getParentBlock$2(rootElm, containerElm).map(block => blockPosition(block, pos));\n  };\n\n  const isDifferentBlocks = blockBoundary => eq(blockBoundary.from.block, blockBoundary.to.block) === false;\n\n  const hasSameParent = blockBoundary => parent(blockBoundary.from.block).bind(parent1 => parent(blockBoundary.to.block).filter(parent2 => eq(parent1, parent2))).isSome();\n\n  const isEditable$2 = blockBoundary => isContentEditableFalse$a(blockBoundary.from.block.dom) === false && isContentEditableFalse$a(blockBoundary.to.block.dom) === false;\n\n  const skipLastBr = (rootNode, forward, blockPosition) => {\n    if (isBr$5(blockPosition.position.getNode()) && isEmpty$2(blockPosition.block) === false) {\n      return positionIn(false, blockPosition.block.dom).bind(lastPositionInBlock => {\n        if (lastPositionInBlock.isEqual(blockPosition.position)) {\n          return fromPosition(forward, rootNode, lastPositionInBlock).bind(to => getBlockPosition(rootNode, to));\n        } else {\n          return Optional.some(blockPosition);\n        }\n      }).getOr(blockPosition);\n    } else {\n      return blockPosition;\n    }\n  };\n\n  const readFromRange = (rootNode, forward, rng) => {\n    const fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));\n    const toBlockPos = fromBlockPos.bind(blockPos => fromPosition(forward, rootNode, blockPos.position).bind(to => getBlockPosition(rootNode, to).map(blockPos => skipLastBr(rootNode, forward, blockPos))));\n    return lift2(fromBlockPos, toBlockPos, blockBoundary).filter(blockBoundary => isDifferentBlocks(blockBoundary) && hasSameParent(blockBoundary) && isEditable$2(blockBoundary));\n  };\n\n  const read$1 = (rootNode, forward, rng) => rng.collapsed ? readFromRange(rootNode, forward, rng) : Optional.none();\n\n  const getChildrenUntilBlockBoundary = block => {\n    const children$1 = children(block);\n    return findIndex$2(children$1, isBlock$2).fold(constant(children$1), index => children$1.slice(0, index));\n  };\n\n  const extractChildren = block => {\n    const children = getChildrenUntilBlockBoundary(block);\n    each$g(children, remove$5);\n    return children;\n  };\n\n  const removeEmptyRoot = (rootNode, block) => {\n    const parents = parentsAndSelf(block, rootNode);\n    return find$2(parents.reverse(), element => isEmpty$2(element)).each(remove$5);\n  };\n\n  const isEmptyBefore = el => filter$6(prevSiblings(el), el => !isEmpty$2(el)).length === 0;\n\n  const nestedBlockMerge = (rootNode, fromBlock, toBlock, insertionPoint) => {\n    if (isEmpty$2(toBlock)) {\n      fillWithPaddingBr(toBlock);\n      return firstPositionIn(toBlock.dom);\n    }\n\n    if (isEmptyBefore(insertionPoint) && isEmpty$2(fromBlock)) {\n      before$3(insertionPoint, SugarElement.fromTag('br'));\n    }\n\n    const position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));\n    each$g(extractChildren(fromBlock), child => {\n      before$3(insertionPoint, child);\n    });\n    removeEmptyRoot(rootNode, fromBlock);\n    return position;\n  };\n\n  const sidelongBlockMerge = (rootNode, fromBlock, toBlock) => {\n    if (isEmpty$2(toBlock)) {\n      remove$5(toBlock);\n\n      if (isEmpty$2(fromBlock)) {\n        fillWithPaddingBr(fromBlock);\n      }\n\n      return firstPositionIn(fromBlock.dom);\n    }\n\n    const position = lastPositionIn(toBlock.dom);\n    each$g(extractChildren(fromBlock), child => {\n      append$1(toBlock, child);\n    });\n    removeEmptyRoot(rootNode, fromBlock);\n    return position;\n  };\n\n  const findInsertionPoint = (toBlock, block) => {\n    const parentsAndSelf$1 = parentsAndSelf(block, toBlock);\n    return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);\n  };\n\n  const getInsertionPoint = (fromBlock, toBlock) => contains(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();\n\n  const trimBr = (first, block) => {\n    positionIn(first, block.dom).map(position => position.getNode()).map(SugarElement.fromDom).filter(isBr$4).each(remove$5);\n  };\n\n  const mergeBlockInto = (rootNode, fromBlock, toBlock) => {\n    trimBr(true, fromBlock);\n    trimBr(false, toBlock);\n    return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock), curry(nestedBlockMerge, rootNode, fromBlock, toBlock));\n  };\n\n  const mergeBlocks = (rootNode, forward, block1, block2) => forward ? mergeBlockInto(rootNode, block2, block1) : mergeBlockInto(rootNode, block1, block2);\n\n  const backspaceDelete$8 = (editor, forward) => {\n    const rootNode = SugarElement.fromDom(editor.getBody());\n    const position = read$1(rootNode.dom, forward, editor.selection.getRng()).map(blockBoundary => () => {\n      mergeBlocks(rootNode, forward, blockBoundary.from.block, blockBoundary.to.block).each(pos => {\n        editor.selection.setRng(pos.toRange());\n      });\n    });\n    return position;\n  };\n\n  const deleteRangeMergeBlocks = (rootNode, selection) => {\n    const rng = selection.getRng();\n    return lift2(getParentBlock$2(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$2(rootNode, SugarElement.fromDom(rng.endContainer)), (block1, block2) => {\n      if (eq(block1, block2) === false) {\n        return Optional.some(() => {\n          rng.deleteContents();\n          mergeBlocks(rootNode, true, block1, block2).each(pos => {\n            selection.setRng(pos.toRange());\n          });\n        });\n      } else {\n        return Optional.none();\n      }\n    }).getOr(Optional.none());\n  };\n\n  const isRawNodeInTable = (root, rawNode) => {\n    const node = SugarElement.fromDom(rawNode);\n    const isRoot = curry(eq, root);\n    return ancestor$3(node, isTableCell$4, isRoot).isSome();\n  };\n\n  const isSelectionInTable = (root, rng) => isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);\n\n  const isEverythingSelected = (root, rng) => {\n    const noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();\n    const noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();\n    return !isSelectionInTable(root, rng) && noPrevious && noNext;\n  };\n\n  const emptyEditor = editor => {\n    return Optional.some(() => {\n      editor.setContent('');\n      editor.selection.setCursorLocation();\n    });\n  };\n\n  const deleteRange$1 = editor => {\n    const rootNode = SugarElement.fromDom(editor.getBody());\n    const rng = editor.selection.getRng();\n    return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection);\n  };\n\n  const backspaceDelete$7 = (editor, _forward) => editor.selection.isCollapsed() ? Optional.none() : deleteRange$1(editor);\n\n  const isContentEditableTrue$1 = isContentEditableTrue$4;\n  const isContentEditableFalse$4 = isContentEditableFalse$a;\n\n  const showCaret = (direction, editor, node, before, scrollIntoView) => Optional.from(editor._selectionOverrides.showCaret(direction, node, before, scrollIntoView));\n\n  const getNodeRange = node => {\n    const rng = node.ownerDocument.createRange();\n    rng.selectNode(node);\n    return rng;\n  };\n\n  const selectNode = (editor, node) => {\n    const e = editor.dispatch('BeforeObjectSelected', {\n      target: node\n    });\n\n    if (e.isDefaultPrevented()) {\n      return Optional.none();\n    }\n\n    return Optional.some(getNodeRange(node));\n  };\n\n  const renderCaretAtRange = (editor, range, scrollIntoView) => {\n    const normalizedRange = normalizeRange(1, editor.getBody(), range);\n    const caretPosition = CaretPosition.fromRangeStart(normalizedRange);\n    const caretPositionNode = caretPosition.getNode();\n\n    if (isInlineFakeCaretTarget(caretPositionNode)) {\n      return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);\n    }\n\n    const caretPositionBeforeNode = caretPosition.getNode(true);\n\n    if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {\n      return showCaret(1, editor, caretPositionBeforeNode, false, false);\n    }\n\n    const ceRoot = editor.dom.getParent(caretPosition.getNode(), node => isContentEditableFalse$4(node) || isContentEditableTrue$1(node));\n\n    if (isInlineFakeCaretTarget(ceRoot)) {\n      return showCaret(1, editor, ceRoot, false, scrollIntoView);\n    }\n\n    return Optional.none();\n  };\n\n  const renderRangeCaret = (editor, range, scrollIntoView) => range.collapsed ? renderCaretAtRange(editor, range, scrollIntoView).getOr(range) : range;\n\n  const isBeforeBoundary = pos => isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);\n\n  const isAfterBoundary = pos => isAfterContentEditableFalse(pos) || isAfterMedia(pos);\n\n  const trimEmptyTextNode = (dom, node) => {\n    if (isText$8(node) && node.data.length === 0) {\n      dom.remove(node);\n    }\n  };\n\n  const deleteContentAndShowCaret = (editor, range, node, direction, forward, peekCaretPosition) => {\n    showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each(caretRange => {\n      if (range.collapsed) {\n        const deleteRange = range.cloneRange();\n\n        if (forward) {\n          deleteRange.setEnd(caretRange.startContainer, caretRange.startOffset);\n        } else {\n          deleteRange.setStart(caretRange.endContainer, caretRange.endOffset);\n        }\n\n        deleteRange.deleteContents();\n      } else {\n        range.deleteContents();\n      }\n\n      editor.selection.setRng(caretRange);\n    });\n    trimEmptyTextNode(editor.dom, node);\n  };\n\n  const deleteBoundaryText = (editor, forward) => {\n    const range = editor.selection.getRng();\n\n    if (!isText$8(range.commonAncestorContainer)) {\n      return Optional.none();\n    }\n\n    const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n    const caretWalker = CaretWalker(editor.getBody());\n    const getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);\n    const isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;\n    const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n    const nextCaretPosition = normalizePosition(forward, getNextPosFn(caretPosition));\n\n    if (!nextCaretPosition || !isMoveInsideSameBlock(caretPosition, nextCaretPosition)) {\n      return Optional.none();\n    } else if (isBeforeFn(nextCaretPosition)) {\n      return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, nextCaretPosition));\n    }\n\n    const peekCaretPosition = getNextPosFn(nextCaretPosition);\n\n    if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\n      if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {\n        return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, peekCaretPosition));\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const backspaceDelete$6 = (editor, forward) => deleteBoundaryText(editor, forward);\n\n  const isCompoundElement = node => isTableCell$4(SugarElement.fromDom(node)) || isListItem(SugarElement.fromDom(node));\n\n  const DeleteAction = Adt.generate([{\n    remove: ['element']\n  }, {\n    moveToElement: ['element']\n  }, {\n    moveToPosition: ['position']\n  }]);\n\n  const isAtContentEditableBlockCaret = (forward, from) => {\n    const elm = from.getNode(forward === false);\n    const caretLocation = forward ? 'after' : 'before';\n    return isElement$6(elm) && elm.getAttribute('data-mce-caret') === caretLocation;\n  };\n\n  const isDeleteFromCefDifferentBlocks = (root, forward, from, to) => {\n    const inSameBlock = elm => isInline$1(SugarElement.fromDom(elm)) && !isInSameBlock(from, to, root);\n\n    return getRelativeCefElm(!forward, from).fold(() => getRelativeCefElm(forward, to).fold(never, inSameBlock), inSameBlock);\n  };\n\n  const deleteEmptyBlockOrMoveToCef = (root, forward, from, to) => {\n    const toCefElm = to.getNode(forward === false);\n    return getParentBlock$2(SugarElement.fromDom(root), SugarElement.fromDom(from.getNode())).map(blockElm => isEmpty$2(blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm)).orThunk(() => Optional.some(DeleteAction.moveToElement(toCefElm)));\n  };\n\n  const findCefPosition = (root, forward, from) => fromPosition(forward, root, from).bind(to => {\n    if (isCompoundElement(to.getNode())) {\n      return Optional.none();\n    } else if (isDeleteFromCefDifferentBlocks(root, forward, from, to)) {\n      return Optional.none();\n    } else if (forward && isContentEditableFalse$a(to.getNode())) {\n      return deleteEmptyBlockOrMoveToCef(root, forward, from, to);\n    } else if (forward === false && isContentEditableFalse$a(to.getNode(true))) {\n      return deleteEmptyBlockOrMoveToCef(root, forward, from, to);\n    } else if (forward && isAfterContentEditableFalse(from)) {\n      return Optional.some(DeleteAction.moveToPosition(to));\n    } else if (forward === false && isBeforeContentEditableFalse(from)) {\n      return Optional.some(DeleteAction.moveToPosition(to));\n    } else {\n      return Optional.none();\n    }\n  });\n\n  const getContentEditableBlockAction = (forward, elm) => {\n    if (forward && isContentEditableFalse$a(elm.nextSibling)) {\n      return Optional.some(DeleteAction.moveToElement(elm.nextSibling));\n    } else if (forward === false && isContentEditableFalse$a(elm.previousSibling)) {\n      return Optional.some(DeleteAction.moveToElement(elm.previousSibling));\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const skipMoveToActionFromInlineCefToContent = (root, from, deleteAction) => deleteAction.fold(elm => Optional.some(DeleteAction.remove(elm)), elm => Optional.some(DeleteAction.moveToElement(elm)), to => {\n    if (isInSameBlock(from, to, root)) {\n      return Optional.none();\n    } else {\n      return Optional.some(DeleteAction.moveToPosition(to));\n    }\n  });\n\n  const getContentEditableAction = (root, forward, from) => {\n    if (isAtContentEditableBlockCaret(forward, from)) {\n      return getContentEditableBlockAction(forward, from.getNode(forward === false)).fold(() => findCefPosition(root, forward, from), Optional.some);\n    } else {\n      return findCefPosition(root, forward, from).bind(deleteAction => skipMoveToActionFromInlineCefToContent(root, from, deleteAction));\n    }\n  };\n\n  const read = (root, forward, rng) => {\n    const normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);\n    const from = CaretPosition.fromRangeStart(normalizedRange);\n    const rootElement = SugarElement.fromDom(root);\n\n    if (forward === false && isAfterContentEditableFalse(from)) {\n      return Optional.some(DeleteAction.remove(from.getNode(true)));\n    } else if (forward && isBeforeContentEditableFalse(from)) {\n      return Optional.some(DeleteAction.remove(from.getNode()));\n    } else if (forward === false && isBeforeContentEditableFalse(from) && isAfterBr(rootElement, from)) {\n      return findPreviousBr(rootElement, from).map(br => DeleteAction.remove(br.getNode()));\n    } else if (forward && isAfterContentEditableFalse(from) && isBeforeBr$1(rootElement, from)) {\n      return findNextBr(rootElement, from).map(br => DeleteAction.remove(br.getNode()));\n    } else {\n      return getContentEditableAction(root, forward, from);\n    }\n  };\n\n  const deleteElement$1 = (editor, forward) => element => {\n    editor._selectionOverrides.hideFakeCaret();\n\n    deleteElement$2(editor, forward, SugarElement.fromDom(element));\n    return true;\n  };\n\n  const moveToElement = (editor, forward) => element => {\n    const pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);\n    editor.selection.setRng(pos.toRange());\n    return true;\n  };\n\n  const moveToPosition = editor => pos => {\n    editor.selection.setRng(pos.toRange());\n    return true;\n  };\n\n  const getAncestorCe = (editor, node) => Optional.from(getContentEditableRoot$1(editor.getBody(), node));\n\n  const backspaceDeleteCaret = (editor, forward) => {\n    const selectedNode = editor.selection.getNode();\n    return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse$a).fold(() => read(editor.getBody(), forward, editor.selection.getRng()).map(deleteAction => () => deleteAction.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor))), () => Optional.some(noop));\n  };\n\n  const deleteOffscreenSelection = rootElement => {\n    each$g(descendants(rootElement, '.mce-offscreen-selection'), remove$5);\n  };\n\n  const backspaceDeleteRange = (editor, forward) => {\n    const selectedNode = editor.selection.getNode();\n\n    if (isContentEditableFalse$a(selectedNode) && !isTableCell$5(selectedNode)) {\n      const hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse$a);\n      return hasCefAncestor.fold(() => Optional.some(() => {\n        deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));\n        deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode()));\n        paddEmptyBody(editor);\n      }), () => Optional.some(noop));\n    }\n\n    return Optional.none();\n  };\n\n  const paddEmptyElement = editor => {\n    const dom = editor.dom,\n          selection = editor.selection;\n    const ceRoot = getContentEditableRoot$1(editor.getBody(), selection.getNode());\n\n    if (isContentEditableTrue$4(ceRoot) && dom.isBlock(ceRoot) && dom.isEmpty(ceRoot)) {\n      const br = dom.create('br', {\n        'data-mce-bogus': '1'\n      });\n      dom.setHTML(ceRoot, '');\n      ceRoot.appendChild(br);\n      selection.setRng(CaretPosition.before(br).toRange());\n    }\n\n    return true;\n  };\n\n  const backspaceDelete$5 = (editor, forward) => {\n    if (editor.selection.isCollapsed()) {\n      return backspaceDeleteCaret(editor, forward);\n    } else {\n      return backspaceDeleteRange(editor, forward);\n    }\n  };\n\n  const deleteCaret$2 = (editor, forward) => {\n    const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n    return fromPosition(forward, editor.getBody(), fromPos).filter(pos => forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos)).bind(pos => Optional.from(getChildNodeAtRelativeOffset(forward ? 0 : -1, pos))).map(elm => () => editor.selection.select(elm));\n  };\n\n  const backspaceDelete$4 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : Optional.none();\n\n  const isText$1 = isText$8;\n\n  const startsWithCaretContainer = node => isText$1(node) && node.data[0] === ZWSP$1;\n\n  const endsWithCaretContainer = node => isText$1(node) && node.data[node.data.length - 1] === ZWSP$1;\n\n  const createZwsp = node => node.ownerDocument.createTextNode(ZWSP$1);\n\n  const insertBefore = node => {\n    if (isText$1(node.previousSibling)) {\n      if (endsWithCaretContainer(node.previousSibling)) {\n        return node.previousSibling;\n      } else {\n        node.previousSibling.appendData(ZWSP$1);\n        return node.previousSibling;\n      }\n    } else if (isText$1(node)) {\n      if (startsWithCaretContainer(node)) {\n        return node;\n      } else {\n        node.insertData(0, ZWSP$1);\n        return node;\n      }\n    } else {\n      const newNode = createZwsp(node);\n      node.parentNode.insertBefore(newNode, node);\n      return newNode;\n    }\n  };\n\n  const insertAfter = node => {\n    if (isText$1(node.nextSibling)) {\n      if (startsWithCaretContainer(node.nextSibling)) {\n        return node.nextSibling;\n      } else {\n        node.nextSibling.insertData(0, ZWSP$1);\n        return node.nextSibling;\n      }\n    } else if (isText$1(node)) {\n      if (endsWithCaretContainer(node)) {\n        return node;\n      } else {\n        node.appendData(ZWSP$1);\n        return node;\n      }\n    } else {\n      const newNode = createZwsp(node);\n\n      if (node.nextSibling) {\n        node.parentNode.insertBefore(newNode, node.nextSibling);\n      } else {\n        node.parentNode.appendChild(newNode);\n      }\n\n      return newNode;\n    }\n  };\n\n  const insertInline = (before, node) => before ? insertBefore(node) : insertAfter(node);\n\n  const insertInlineBefore = curry(insertInline, true);\n  const insertInlineAfter = curry(insertInline, false);\n\n  const insertInlinePos = (pos, before) => {\n    if (isText$8(pos.container())) {\n      return insertInline(before, pos.container());\n    } else {\n      return insertInline(before, pos.getNode());\n    }\n  };\n\n  const isPosCaretContainer = (pos, caret) => {\n    const caretNode = caret.get();\n    return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);\n  };\n\n  const renderCaret = (caret, location) => location.fold(element => {\n    remove$4(caret.get());\n    const text = insertInlineBefore(element);\n    caret.set(text);\n    return Optional.some(CaretPosition(text, text.length - 1));\n  }, element => firstPositionIn(element).map(pos => {\n    if (!isPosCaretContainer(pos, caret)) {\n      remove$4(caret.get());\n      const text = insertInlinePos(pos, true);\n      caret.set(text);\n      return CaretPosition(text, 1);\n    } else {\n      return CaretPosition(caret.get(), 1);\n    }\n  }), element => lastPositionIn(element).map(pos => {\n    if (!isPosCaretContainer(pos, caret)) {\n      remove$4(caret.get());\n      const text = insertInlinePos(pos, false);\n      caret.set(text);\n      return CaretPosition(text, text.length - 1);\n    } else {\n      return CaretPosition(caret.get(), caret.get().length - 1);\n    }\n  }), element => {\n    remove$4(caret.get());\n    const text = insertInlineAfter(element);\n    caret.set(text);\n    return Optional.some(CaretPosition(text, 1));\n  });\n\n  const evaluateUntil = (fns, args) => {\n    for (let i = 0; i < fns.length; i++) {\n      const result = fns[i].apply(null, args);\n\n      if (result.isSome()) {\n        return result;\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const Location = Adt.generate([{\n    before: ['element']\n  }, {\n    start: ['element']\n  }, {\n    end: ['element']\n  }, {\n    after: ['element']\n  }]);\n\n  const rescope$1 = (rootNode, node) => {\n    const parentBlock = getParentBlock$3(node, rootNode);\n    return parentBlock ? parentBlock : rootNode;\n  };\n\n  const before = (isInlineTarget, rootNode, pos) => {\n    const nPos = normalizeForwards(pos);\n    const scope = rescope$1(rootNode, nPos.container());\n    return findRootInline(isInlineTarget, scope, nPos).fold(() => nextPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.before(inline)), Optional.none);\n  };\n\n  const isNotInsideFormatCaretContainer = (rootNode, elm) => getParentCaretContainer(rootNode, elm) === null;\n\n  const findInsideRootInline = (isInlineTarget, rootNode, pos) => findRootInline(isInlineTarget, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));\n\n  const start$1 = (isInlineTarget, rootNode, pos) => {\n    const nPos = normalizeBackwards(pos);\n    return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\n      const prevPos = prevPosition(inline, nPos);\n      return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();\n    });\n  };\n\n  const end = (isInlineTarget, rootNode, pos) => {\n    const nPos = normalizeForwards(pos);\n    return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\n      const nextPos = nextPosition(inline, nPos);\n      return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();\n    });\n  };\n\n  const after = (isInlineTarget, rootNode, pos) => {\n    const nPos = normalizeBackwards(pos);\n    const scope = rescope$1(rootNode, nPos.container());\n    return findRootInline(isInlineTarget, scope, nPos).fold(() => prevPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.after(inline)), Optional.none);\n  };\n\n  const isValidLocation = location => isRtl(getElement(location)) === false;\n\n  const readLocation = (isInlineTarget, rootNode, pos) => {\n    const location = evaluateUntil([before, start$1, end, after], [isInlineTarget, rootNode, pos]);\n    return location.filter(isValidLocation);\n  };\n\n  const getElement = location => location.fold(identity, identity, identity, identity);\n\n  const getName = location => location.fold(constant('before'), constant('start'), constant('end'), constant('after'));\n\n  const outside = location => location.fold(Location.before, Location.before, Location.after, Location.after);\n\n  const inside = location => location.fold(Location.start, Location.start, Location.end, Location.end);\n\n  const isEq = (location1, location2) => getName(location1) === getName(location2) && getElement(location1) === getElement(location2);\n\n  const betweenInlines = (forward, isInlineTarget, rootNode, from, to, location) => lift2(findRootInline(isInlineTarget, rootNode, from), findRootInline(isInlineTarget, rootNode, to), (fromInline, toInline) => {\n    if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {\n      return Location.after(forward ? fromInline : toInline);\n    } else {\n      return location;\n    }\n  }).getOr(location);\n\n  const skipNoMovement = (fromLocation, toLocation) => fromLocation.fold(always, fromLocation => !isEq(fromLocation, toLocation));\n\n  const findLocationTraverse = (forward, isInlineTarget, rootNode, fromLocation, pos) => {\n    const from = normalizePosition(forward, pos);\n    const to = fromPosition(forward, rootNode, from).map(curry(normalizePosition, forward));\n    const location = to.fold(() => fromLocation.map(outside), to => readLocation(isInlineTarget, rootNode, to).map(curry(betweenInlines, forward, isInlineTarget, rootNode, from, to)).filter(curry(skipNoMovement, fromLocation)));\n    return location.filter(isValidLocation);\n  };\n\n  const findLocationSimple = (forward, location) => {\n    if (forward) {\n      return location.fold(compose(Optional.some, Location.start), Optional.none, compose(Optional.some, Location.after), Optional.none);\n    } else {\n      return location.fold(Optional.none, compose(Optional.some, Location.before), Optional.none, compose(Optional.some, Location.end));\n    }\n  };\n\n  const findLocation$1 = (forward, isInlineTarget, rootNode, pos) => {\n    const from = normalizePosition(forward, pos);\n    const fromLocation = readLocation(isInlineTarget, rootNode, from);\n    return readLocation(isInlineTarget, rootNode, from).bind(curry(findLocationSimple, forward)).orThunk(() => findLocationTraverse(forward, isInlineTarget, rootNode, fromLocation, pos));\n  };\n\n  const hasSelectionModifyApi = editor => {\n    return isFunction(editor.selection.getSel().modify);\n  };\n\n  const moveRel = (forward, selection, pos) => {\n    const delta = forward ? 1 : -1;\n    selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());\n    selection.getSel().modify('move', forward ? 'forward' : 'backward', 'word');\n    return true;\n  };\n\n  const moveByWord = (forward, editor) => {\n    const rng = editor.selection.getRng();\n    const pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n\n    if (!hasSelectionModifyApi(editor)) {\n      return false;\n    } else if (forward && isBeforeInline(pos)) {\n      return moveRel(true, editor.selection, pos);\n    } else if (!forward && isAfterInline(pos)) {\n      return moveRel(false, editor.selection, pos);\n    } else {\n      return false;\n    }\n  };\n\n  var BreakType;\n\n  (function (BreakType) {\n    BreakType[BreakType['Br'] = 0] = 'Br';\n    BreakType[BreakType['Block'] = 1] = 'Block';\n    BreakType[BreakType['Wrap'] = 2] = 'Wrap';\n    BreakType[BreakType['Eol'] = 3] = 'Eol';\n  })(BreakType || (BreakType = {}));\n\n  const flip = (direction, positions) => direction === HDirection.Backwards ? reverse(positions) : positions;\n\n  const walk$1 = (direction, caretWalker, pos) => direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);\n\n  const getBreakType = (scope, direction, currentPos, nextPos) => {\n    if (isBr$5(nextPos.getNode(direction === HDirection.Forwards))) {\n      return BreakType.Br;\n    } else if (isInSameBlock(currentPos, nextPos) === false) {\n      return BreakType.Block;\n    } else {\n      return BreakType.Wrap;\n    }\n  };\n\n  const getPositionsUntil = (predicate, direction, scope, start) => {\n    const caretWalker = CaretWalker(scope);\n    let currentPos = start;\n    const positions = [];\n\n    while (currentPos) {\n      const nextPos = walk$1(direction, caretWalker, currentPos);\n\n      if (!nextPos) {\n        break;\n      }\n\n      if (isBr$5(nextPos.getNode(false))) {\n        if (direction === HDirection.Forwards) {\n          return {\n            positions: flip(direction, positions).concat([nextPos]),\n            breakType: BreakType.Br,\n            breakAt: Optional.some(nextPos)\n          };\n        } else {\n          return {\n            positions: flip(direction, positions),\n            breakType: BreakType.Br,\n            breakAt: Optional.some(nextPos)\n          };\n        }\n      }\n\n      if (!nextPos.isVisible()) {\n        currentPos = nextPos;\n        continue;\n      }\n\n      if (predicate(currentPos, nextPos)) {\n        const breakType = getBreakType(scope, direction, currentPos, nextPos);\n        return {\n          positions: flip(direction, positions),\n          breakType,\n          breakAt: Optional.some(nextPos)\n        };\n      }\n\n      positions.push(nextPos);\n      currentPos = nextPos;\n    }\n\n    return {\n      positions: flip(direction, positions),\n      breakType: BreakType.Eol,\n      breakAt: Optional.none()\n    };\n  };\n\n  const getAdjacentLinePositions = (direction, getPositionsUntilBreak, scope, start) => getPositionsUntilBreak(scope, start).breakAt.map(pos => {\n    const positions = getPositionsUntilBreak(scope, pos).positions;\n    return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);\n  }).getOr([]);\n\n  const findClosestHorizontalPositionFromPoint = (positions, x) => foldl(positions, (acc, newPos) => acc.fold(() => Optional.some(newPos), lastPos => lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), (lastRect, newRect) => {\n    const lastDist = Math.abs(x - lastRect.left);\n    const newDist = Math.abs(x - newRect.left);\n    return newDist <= lastDist ? newPos : lastPos;\n  }).or(acc)), Optional.none());\n\n  const findClosestHorizontalPosition = (positions, pos) => head(pos.getClientRects()).bind(targetRect => findClosestHorizontalPositionFromPoint(positions, targetRect.left));\n\n  const getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);\n  const getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);\n  const getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);\n  const getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);\n\n  const isAtFirstLine = (scope, pos) => getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();\n\n  const isAtLastLine = (scope, pos) => getPositionsUntilNextLine(scope, pos).breakAt.isNone();\n\n  const getFirstLinePositions = scope => firstPositionIn(scope).map(pos => [pos].concat(getPositionsUntilNextLine(scope, pos).positions)).getOr([]);\n\n  const getLastLinePositions = scope => lastPositionIn(scope).map(pos => getPositionsUntilPreviousLine(scope, pos).positions.concat(pos)).getOr([]);\n\n  const isContentEditableFalse$3 = isContentEditableFalse$a;\n\n  const distanceToRectLeft$1 = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\n\n  const distanceToRectRight$1 = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\n\n  const isNodeClientRect = rect => hasNonNullableKey(rect, 'node');\n\n  const findClosestClientRect = (clientRects, clientX) => reduce(clientRects, (oldClientRect, clientRect) => {\n    const oldDistance = Math.min(distanceToRectLeft$1(oldClientRect, clientX), distanceToRectRight$1(oldClientRect, clientX));\n    const newDistance = Math.min(distanceToRectLeft$1(clientRect, clientX), distanceToRectRight$1(clientRect, clientX));\n\n    if (newDistance === oldDistance && isNodeClientRect(clientRect) && isContentEditableFalse$3(clientRect.node)) {\n      return clientRect;\n    }\n\n    if (newDistance < oldDistance) {\n      return clientRect;\n    }\n\n    return oldClientRect;\n  });\n\n  const getNodeClientRects = node => {\n    const toArrayWithNode = clientRects => {\n      return map$3(clientRects, rect => {\n        const clientRect = clone$1(rect);\n        clientRect.node = node;\n        return clientRect;\n      });\n    };\n\n    if (isElement$6(node)) {\n      return toArrayWithNode(node.getClientRects());\n    } else if (isText$8(node)) {\n      const rng = node.ownerDocument.createRange();\n      rng.setStart(node, 0);\n      rng.setEnd(node, node.data.length);\n      return toArrayWithNode(rng.getClientRects());\n    } else {\n      return [];\n    }\n  };\n\n  const getClientRects = nodes => bind$3(nodes, getNodeClientRects);\n\n  var VDirection;\n\n  (function (VDirection) {\n    VDirection[VDirection['Up'] = -1] = 'Up';\n    VDirection[VDirection['Down'] = 1] = 'Down';\n  })(VDirection || (VDirection = {}));\n\n  const findUntil = (direction, root, predicateFn, node) => {\n    while (node = findNode(node, direction, isEditableCaretCandidate$1, root)) {\n      if (predicateFn(node)) {\n        return;\n      }\n    }\n  };\n\n  const walkUntil = (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) => {\n    let line = 0;\n    const result = [];\n\n    const add = node => {\n      let clientRects = getClientRects([node]);\n\n      if (direction === -1) {\n        clientRects = clientRects.reverse();\n      }\n\n      for (let i = 0; i < clientRects.length; i++) {\n        const clientRect = clientRects[i];\n\n        if (isBeflowFn(clientRect, targetClientRect)) {\n          continue;\n        }\n\n        if (result.length > 0 && isAboveFn(clientRect, last$2(result))) {\n          line++;\n        }\n\n        clientRect.line = line;\n\n        if (predicateFn(clientRect)) {\n          return true;\n        }\n\n        result.push(clientRect);\n      }\n    };\n\n    const targetClientRect = last$2(caretPosition.getClientRects());\n\n    if (!targetClientRect) {\n      return result;\n    }\n\n    const node = caretPosition.getNode();\n    add(node);\n    findUntil(direction, root, add, node);\n    return result;\n  };\n\n  const aboveLineNumber = (lineNumber, clientRect) => clientRect.line > lineNumber;\n\n  const isLineNumber = (lineNumber, clientRect) => clientRect.line === lineNumber;\n\n  const upUntil = curry(walkUntil, VDirection.Up, isAbove$1, isBelow$1);\n  const downUntil = curry(walkUntil, VDirection.Down, isBelow$1, isAbove$1);\n\n  const positionsUntil = (direction, root, predicateFn, node) => {\n    const caretWalker = CaretWalker(root);\n    let walkFn;\n    let isBelowFn;\n    let isAboveFn;\n    let caretPosition;\n    const result = [];\n    let line = 0;\n\n    const getClientRect = caretPosition => {\n      if (direction === 1) {\n        return last$2(caretPosition.getClientRects());\n      }\n\n      return last$2(caretPosition.getClientRects());\n    };\n\n    if (direction === 1) {\n      walkFn = caretWalker.next;\n      isBelowFn = isBelow$1;\n      isAboveFn = isAbove$1;\n      caretPosition = CaretPosition.after(node);\n    } else {\n      walkFn = caretWalker.prev;\n      isBelowFn = isAbove$1;\n      isAboveFn = isBelow$1;\n      caretPosition = CaretPosition.before(node);\n    }\n\n    const targetClientRect = getClientRect(caretPosition);\n\n    do {\n      if (!caretPosition.isVisible()) {\n        continue;\n      }\n\n      const rect = getClientRect(caretPosition);\n\n      if (isAboveFn(rect, targetClientRect)) {\n        continue;\n      }\n\n      if (result.length > 0 && isBelowFn(rect, last$2(result))) {\n        line++;\n      }\n\n      const clientRect = clone$1(rect);\n      clientRect.position = caretPosition;\n      clientRect.line = line;\n\n      if (predicateFn(clientRect)) {\n        return result;\n      }\n\n      result.push(clientRect);\n    } while (caretPosition = walkFn(caretPosition));\n\n    return result;\n  };\n\n  const isAboveLine = lineNumber => clientRect => aboveLineNumber(lineNumber, clientRect);\n\n  const isLine = lineNumber => clientRect => isLineNumber(lineNumber, clientRect);\n\n  const moveToRange = (editor, rng) => {\n    editor.selection.setRng(rng);\n    scrollRangeIntoView(editor, editor.selection.getRng());\n  };\n\n  const renderRangeCaretOpt = (editor, range, scrollIntoView) => Optional.some(renderRangeCaret(editor, range, scrollIntoView));\n\n  const moveHorizontally = (editor, direction, range, isBefore, isAfter, isElement) => {\n    const forwards = direction === HDirection.Forwards;\n    const caretWalker = CaretWalker(editor.getBody());\n    const getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);\n    const isBeforeFn = forwards ? isBefore : isAfter;\n\n    if (!range.collapsed) {\n      const node = getSelectedNode(range);\n\n      if (isElement(node)) {\n        return showCaret(direction, editor, node, direction === HDirection.Backwards, false);\n      }\n    }\n\n    const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n\n    if (isBeforeFn(caretPosition)) {\n      return selectNode(editor, caretPosition.getNode(!forwards));\n    }\n\n    const nextCaretPosition = normalizePosition(forwards, getNextPosFn(caretPosition));\n    const rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);\n\n    if (!nextCaretPosition) {\n      return rangeIsInContainerBlock ? Optional.some(range) : Optional.none();\n    }\n\n    if (isBeforeFn(nextCaretPosition)) {\n      return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);\n    }\n\n    const peekCaretPosition = getNextPosFn(nextCaretPosition);\n\n    if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\n      if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {\n        return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);\n      }\n    }\n\n    if (rangeIsInContainerBlock) {\n      return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);\n    }\n\n    return Optional.none();\n  };\n\n  const moveVertically = (editor, direction, range, isBefore, isAfter, isElement) => {\n    const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n    const caretClientRect = last$2(caretPosition.getClientRects());\n    const forwards = direction === VDirection.Down;\n\n    if (!caretClientRect) {\n      return Optional.none();\n    }\n\n    const walkerFn = forwards ? downUntil : upUntil;\n    const linePositions = walkerFn(editor.getBody(), isAboveLine(1), caretPosition);\n    const nextLinePositions = filter$6(linePositions, isLine(1));\n    const clientX = caretClientRect.left;\n    const nextLineRect = findClosestClientRect(nextLinePositions, clientX);\n\n    if (nextLineRect && isElement(nextLineRect.node)) {\n      const dist1 = Math.abs(clientX - nextLineRect.left);\n      const dist2 = Math.abs(clientX - nextLineRect.right);\n      return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);\n    }\n\n    let currentNode;\n\n    if (isBefore(caretPosition)) {\n      currentNode = caretPosition.getNode();\n    } else if (isAfter(caretPosition)) {\n      currentNode = caretPosition.getNode(true);\n    } else {\n      currentNode = getSelectedNode(range);\n    }\n\n    if (currentNode) {\n      const caretPositions = positionsUntil(direction, editor.getBody(), isAboveLine(1), currentNode);\n      let closestNextLineRect = findClosestClientRect(filter$6(caretPositions, isLine(1)), clientX);\n\n      if (closestNextLineRect) {\n        return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\n      }\n\n      closestNextLineRect = last$2(filter$6(caretPositions, isLine(0)));\n\n      if (closestNextLineRect) {\n        return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\n      }\n    }\n\n    if (nextLinePositions.length === 0) {\n      return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore).map(pos => renderRangeCaret(editor, pos.toRange(), false));\n    }\n\n    return Optional.none();\n  };\n\n  const getLineEndPoint = (editor, forward) => {\n    const rng = editor.selection.getRng();\n    const from = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n    const host = getEditingHost(from.container(), editor.getBody());\n\n    if (forward) {\n      const lineInfo = getPositionsUntilNextLine(host, from);\n      return last$3(lineInfo.positions);\n    } else {\n      const lineInfo = getPositionsUntilPreviousLine(host, from);\n      return head(lineInfo.positions);\n    }\n  };\n\n  const moveToLineEndPoint$3 = (editor, forward, isElementPosition) => getLineEndPoint(editor, forward).filter(isElementPosition).exists(pos => {\n    editor.selection.setRng(pos.toRange());\n    return true;\n  });\n\n  const setCaretPosition = (editor, pos) => {\n    const rng = editor.dom.createRng();\n    rng.setStart(pos.container(), pos.offset());\n    rng.setEnd(pos.container(), pos.offset());\n    editor.selection.setRng(rng);\n  };\n\n  const setSelected = (state, elm) => {\n    if (state) {\n      elm.setAttribute('data-mce-selected', 'inline-boundary');\n    } else {\n      elm.removeAttribute('data-mce-selected');\n    }\n  };\n\n  const renderCaretLocation = (editor, caret, location) => renderCaret(caret, location).map(pos => {\n    setCaretPosition(editor, pos);\n    return location;\n  });\n\n  const findLocation = (editor, caret, forward) => {\n    const rootNode = editor.getBody();\n    const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n    const isInlineTarget$1 = curry(isInlineTarget, editor);\n    const location = findLocation$1(forward, isInlineTarget$1, rootNode, from);\n    return location.bind(location => renderCaretLocation(editor, caret, location));\n  };\n\n  const toggleInlines = (isInlineTarget, dom, elms) => {\n    const inlineBoundaries = map$3(descendants(SugarElement.fromDom(dom.getRoot()), '*[data-mce-selected=\"inline-boundary\"]'), e => e.dom);\n    const selectedInlines = filter$6(inlineBoundaries, isInlineTarget);\n    const targetInlines = filter$6(elms, isInlineTarget);\n    each$g(difference(selectedInlines, targetInlines), curry(setSelected, false));\n    each$g(difference(targetInlines, selectedInlines), curry(setSelected, true));\n  };\n\n  const safeRemoveCaretContainer = (editor, caret) => {\n    if (editor.selection.isCollapsed() && editor.composing !== true && caret.get()) {\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n\n      if (CaretPosition.isTextPosition(pos) && isAtZwsp(pos) === false) {\n        setCaretPosition(editor, removeAndReposition(caret.get(), pos));\n        caret.set(null);\n      }\n    }\n  };\n\n  const renderInsideInlineCaret = (isInlineTarget, editor, caret, elms) => {\n    if (editor.selection.isCollapsed()) {\n      const inlines = filter$6(elms, isInlineTarget);\n      each$g(inlines, _inline => {\n        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        readLocation(isInlineTarget, editor.getBody(), pos).bind(location => renderCaretLocation(editor, caret, location));\n      });\n    }\n  };\n\n  const move$2 = (editor, caret, forward) => isInlineBoundariesEnabled(editor) ? findLocation(editor, caret, forward).isSome() : false;\n\n  const moveWord = (forward, editor, _caret) => isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;\n\n  const setupSelectedState = editor => {\n    const caret = Cell(null);\n    const isInlineTarget$1 = curry(isInlineTarget, editor);\n    editor.on('NodeChange', e => {\n      if (isInlineBoundariesEnabled(editor)) {\n        toggleInlines(isInlineTarget$1, editor.dom, e.parents);\n        safeRemoveCaretContainer(editor, caret);\n        renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);\n      }\n    });\n    return caret;\n  };\n\n  const moveNextWord = curry(moveWord, true);\n  const movePrevWord = curry(moveWord, false);\n\n  const moveToLineEndPoint$2 = (editor, forward, caret) => {\n    if (isInlineBoundariesEnabled(editor)) {\n      const linePoint = getLineEndPoint(editor, forward).getOrThunk(() => {\n        const rng = editor.selection.getRng();\n        return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n      });\n      return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists(loc => {\n        const outsideLoc = outside(loc);\n        return renderCaret(caret, outsideLoc).exists(pos => {\n          setCaretPosition(editor, pos);\n          return true;\n        });\n      });\n    } else {\n      return false;\n    }\n  };\n\n  const rangeFromPositions = (from, to) => {\n    const range = document.createRange();\n    range.setStart(from.container(), from.offset());\n    range.setEnd(to.container(), to.offset());\n    return range;\n  };\n\n  const hasOnlyTwoOrLessPositionsLeft = elm => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\n    const normalizedFirstPos = normalizePosition(true, firstPos);\n    const normalizedLastPos = normalizePosition(false, lastPos);\n    return nextPosition(elm, normalizedFirstPos).forall(pos => pos.isEqual(normalizedLastPos));\n  }).getOr(true);\n\n  const setCaretLocation = (editor, caret) => location => renderCaret(caret, location).map(pos => () => setCaretPosition(editor, pos));\n\n  const deleteFromTo = (editor, caret, from, to) => {\n    const rootNode = editor.getBody();\n    const isInlineTarget$1 = curry(isInlineTarget, editor);\n    editor.undoManager.ignore(() => {\n      editor.selection.setRng(rangeFromPositions(from, to));\n      execDeleteCommand(editor);\n      readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng())).map(inside).bind(setCaretLocation(editor, caret)).each(call);\n    });\n    editor.nodeChanged();\n  };\n\n  const rescope = (rootNode, node) => {\n    const parentBlock = getParentBlock$3(node, rootNode);\n    return parentBlock ? parentBlock : rootNode;\n  };\n\n  const backspaceDeleteCollapsed = (editor, caret, forward, from) => {\n    const rootNode = rescope(editor.getBody(), from.container());\n    const isInlineTarget$1 = curry(isInlineTarget, editor);\n    const fromLocation = readLocation(isInlineTarget$1, rootNode, from);\n    const location = fromLocation.bind(location => {\n      if (forward) {\n        return location.fold(constant(Optional.some(inside(location))), Optional.none, constant(Optional.some(outside(location))), Optional.none);\n      } else {\n        return location.fold(Optional.none, constant(Optional.some(outside(location))), Optional.none, constant(Optional.some(inside(location))));\n      }\n    });\n    return location.map(setCaretLocation(editor, caret)).getOrThunk(() => {\n      const toPosition = navigate(forward, rootNode, from);\n      const toLocation = toPosition.bind(pos => readLocation(isInlineTarget$1, rootNode, pos));\n      return lift2(fromLocation, toLocation, () => findRootInline(isInlineTarget$1, rootNode, from).bind(elm => {\n        if (hasOnlyTwoOrLessPositionsLeft(elm)) {\n          return Optional.some(() => {\n            deleteElement$2(editor, forward, SugarElement.fromDom(elm));\n          });\n        } else {\n          return Optional.none();\n        }\n      })).getOrThunk(() => toLocation.bind(() => toPosition.map(to => {\n        return () => {\n          if (forward) {\n            deleteFromTo(editor, caret, from, to);\n          } else {\n            deleteFromTo(editor, caret, to, from);\n          }\n        };\n      })));\n    });\n  };\n\n  const backspaceDelete$3 = (editor, caret, forward) => {\n    if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return backspaceDeleteCollapsed(editor, caret, forward, from);\n    }\n\n    return Optional.none();\n  };\n\n  const getParentInlines = (rootElm, startElm) => {\n    const parents = parentsAndSelf(startElm, rootElm);\n    return findIndex$2(parents, isBlock$2).fold(constant(parents), index => parents.slice(0, index));\n  };\n\n  const hasOnlyOneChild = elm => childNodesCount(elm) === 1;\n\n  const deleteLastPosition = (forward, editor, target, parentInlines) => {\n    const isFormatElement$1 = curry(isFormatElement, editor);\n    const formatNodes = map$3(filter$6(parentInlines, isFormatElement$1), elm => elm.dom);\n\n    if (formatNodes.length === 0) {\n      deleteElement$2(editor, forward, target);\n    } else {\n      const pos = replaceWithCaretFormat(target.dom, formatNodes);\n      editor.selection.setRng(pos.toRange());\n    }\n  };\n\n  const deleteCaret$1 = (editor, forward) => {\n    const rootElm = SugarElement.fromDom(editor.getBody());\n    const startElm = SugarElement.fromDom(editor.selection.getStart());\n    const parentInlines = filter$6(getParentInlines(rootElm, startElm), hasOnlyOneChild);\n    return last$3(parentInlines).bind(target => {\n      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n\n      if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {\n        return Optional.some(() => deleteLastPosition(forward, editor, target, parentInlines));\n      } else {\n        return Optional.none();\n      }\n    });\n  };\n\n  const backspaceDelete$2 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : Optional.none();\n\n  const deleteElement = (editor, forward, element) => {\n    return Optional.some(() => {\n      editor._selectionOverrides.hideFakeCaret();\n\n      deleteElement$2(editor, forward, SugarElement.fromDom(element));\n    });\n  };\n\n  const deleteCaret = (editor, forward) => {\n    const isNearMedia = forward ? isBeforeMedia : isAfterMedia;\n    const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n    const fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());\n\n    if (isNearMedia(fromPos)) {\n      return deleteElement(editor, forward, fromPos.getNode(!forward));\n    } else {\n      return Optional.from(normalizePosition(forward, fromPos)).filter(pos => isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos)).map(pos => () => deleteElement(editor, forward, pos.getNode(!forward)));\n    }\n  };\n\n  const deleteRange = (editor, forward) => {\n    const selectedNode = editor.selection.getNode();\n    return isMedia$2(selectedNode) ? deleteElement(editor, forward, selectedNode) : Optional.none();\n  };\n\n  const backspaceDelete$1 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret(editor, forward) : deleteRange(editor, forward);\n\n  const isEditable$1 = target => closest$4(target, elm => isContentEditableTrue$4(elm.dom) || isContentEditableFalse$a(elm.dom)).exists(elm => isContentEditableTrue$4(elm.dom));\n\n  const parseIndentValue = value => {\n    const number = parseInt(value, 10);\n    return isNaN(number) ? 0 : number;\n  };\n\n  const getIndentStyleName = (useMargin, element) => {\n    const indentStyleName = useMargin || isTable$2(element) ? 'margin' : 'padding';\n    const suffix = get$7(element, 'direction') === 'rtl' ? '-right' : '-left';\n    return indentStyleName + suffix;\n  };\n\n  const indentElement = (dom, command, useMargin, value, unit, element) => {\n    const indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));\n\n    if (command === 'outdent') {\n      const styleValue = Math.max(0, parseIndentValue(element.style[indentStyleName]) - value);\n      dom.setStyle(element, indentStyleName, styleValue ? styleValue + unit : '');\n    } else {\n      const styleValue = parseIndentValue(element.style[indentStyleName]) + value + unit;\n      dom.setStyle(element, indentStyleName, styleValue);\n    }\n  };\n\n  const validateBlocks = (editor, blocks) => forall(blocks, block => {\n    const indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);\n    const intentValue = getRaw$1(block, indentStyleName).map(parseIndentValue).getOr(0);\n    const contentEditable = editor.dom.getContentEditable(block.dom);\n    return contentEditable !== 'false' && intentValue > 0;\n  });\n\n  const canOutdent = editor => {\n    const blocks = getBlocksToIndent(editor);\n    return !editor.mode.isReadOnly() && (blocks.length > 1 || validateBlocks(editor, blocks));\n  };\n\n  const isListComponent = el => isList(el) || isListItem(el);\n\n  const parentIsListComponent = el => parent(el).exists(isListComponent);\n\n  const getBlocksToIndent = editor => filter$6(fromDom$1(editor.selection.getSelectedBlocks()), el => !isListComponent(el) && !parentIsListComponent(el) && isEditable$1(el));\n\n  const handle = (editor, command) => {\n    const {\n      dom\n    } = editor;\n    const indentation = getIndentation(editor);\n    const indentUnit = /[a-z%]+$/i.exec(indentation)[0];\n    const indentValue = parseInt(indentation, 10);\n    const useMargin = shouldIndentUseMargin(editor);\n    each$g(getBlocksToIndent(editor), block => {\n      indentElement(dom, command, useMargin, indentValue, indentUnit, block.dom);\n    });\n  };\n\n  const indent = editor => handle(editor, 'indent');\n\n  const outdent = editor => handle(editor, 'outdent');\n\n  const backspaceDelete = editor => {\n    if (editor.selection.isCollapsed() && canOutdent(editor)) {\n      const dom = editor.dom;\n      const rng = editor.selection.getRng();\n      const pos = CaretPosition.fromRangeStart(rng);\n      const block = dom.getParent(rng.startContainer, dom.isBlock);\n\n      if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos)) {\n        return Optional.some(() => outdent(editor));\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const findAction = (editor, caret, forward) => findMap([backspaceDelete, backspaceDelete$5, backspaceDelete$6, (editor, forward) => backspaceDelete$3(editor, caret, forward), backspaceDelete$8, backspaceDelete$9, backspaceDelete$4, backspaceDelete$1, backspaceDelete$7, backspaceDelete$2], item => item(editor, forward));\n\n  const deleteCommand = (editor, caret) => {\n    const result = findAction(editor, caret, false);\n    result.fold(() => {\n      execDeleteCommand(editor);\n      paddEmptyBody(editor);\n    }, call);\n  };\n\n  const forwardDeleteCommand = (editor, caret) => {\n    const result = findAction(editor, caret, true);\n    result.fold(() => execForwardDeleteCommand(editor), call);\n  };\n\n  const setup$p = (editor, caret) => {\n    editor.addCommand('delete', () => {\n      deleteCommand(editor, caret);\n    });\n    editor.addCommand('forwardDelete', () => {\n      forwardDeleteCommand(editor, caret);\n    });\n  };\n\n  const SIGNIFICANT_MOVE = 5;\n  const LONGPRESS_DELAY = 400;\n\n  const getTouch = event => {\n    if (event.touches === undefined || event.touches.length !== 1) {\n      return Optional.none();\n    }\n\n    return Optional.some(event.touches[0]);\n  };\n\n  const isFarEnough = (touch, data) => {\n    const distX = Math.abs(touch.clientX - data.x);\n    const distY = Math.abs(touch.clientY - data.y);\n    return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;\n  };\n\n  const setup$o = editor => {\n    const startData = value$2();\n    const longpressFired = Cell(false);\n    const debounceLongpress = last$1(e => {\n      editor.dispatch('longpress', { ...e,\n        type: 'longpress'\n      });\n      longpressFired.set(true);\n    }, LONGPRESS_DELAY);\n    editor.on('touchstart', e => {\n      getTouch(e).each(touch => {\n        debounceLongpress.cancel();\n        const data = {\n          x: touch.clientX,\n          y: touch.clientY,\n          target: e.target\n        };\n        debounceLongpress.throttle(e);\n        longpressFired.set(false);\n        startData.set(data);\n      });\n    }, true);\n    editor.on('touchmove', e => {\n      debounceLongpress.cancel();\n      getTouch(e).each(touch => {\n        startData.on(data => {\n          if (isFarEnough(touch, data)) {\n            startData.clear();\n            longpressFired.set(false);\n            editor.dispatch('longpresscancel');\n          }\n        });\n      });\n    }, true);\n    editor.on('touchend touchcancel', e => {\n      debounceLongpress.cancel();\n\n      if (e.type === 'touchcancel') {\n        return;\n      }\n\n      startData.get().filter(data => data.target.isEqualNode(e.target)).each(() => {\n        if (longpressFired.get()) {\n          e.preventDefault();\n        } else {\n          editor.dispatch('tap', { ...e,\n            type: 'tap'\n          });\n        }\n      });\n    }, true);\n  };\n\n  const isBlockElement = (blockElements, node) => has$2(blockElements, node.nodeName);\n\n  const isValidTarget = (blockElements, node) => {\n    if (isText$8(node)) {\n      return true;\n    } else if (isElement$6(node)) {\n      return !isBlockElement(blockElements, node) && !isBookmarkNode$1(node);\n    } else {\n      return false;\n    }\n  };\n\n  const hasBlockParent = (blockElements, root, node) => {\n    return exists(parents(SugarElement.fromDom(node), SugarElement.fromDom(root)), elm => {\n      return isBlockElement(blockElements, elm.dom);\n    });\n  };\n\n  const shouldRemoveTextNode = (blockElements, node) => {\n    if (isText$8(node)) {\n      if (node.nodeValue.length === 0) {\n        return true;\n      } else if (/^\\s+$/.test(node.nodeValue) && (!node.nextSibling || isBlockElement(blockElements, node.nextSibling))) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  const addRootBlocks = editor => {\n    const dom = editor.dom,\n          selection = editor.selection;\n    const schema = editor.schema,\n          blockElements = schema.getBlockElements();\n    let node = selection.getStart();\n    const rootNode = editor.getBody();\n    let rootBlockNode, tempNode, wrapped;\n    const forcedRootBlock = getForcedRootBlock(editor);\n\n    if (!node || !isElement$6(node)) {\n      return;\n    }\n\n    const rootNodeName = rootNode.nodeName.toLowerCase();\n\n    if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, node)) {\n      return;\n    }\n\n    const rng = selection.getRng();\n    const startContainer = rng.startContainer;\n    const startOffset = rng.startOffset;\n    const endContainer = rng.endContainer;\n    const endOffset = rng.endOffset;\n    const restoreSelection = hasFocus(editor);\n    node = rootNode.firstChild;\n\n    while (node) {\n      if (isValidTarget(blockElements, node)) {\n        if (shouldRemoveTextNode(blockElements, node)) {\n          tempNode = node;\n          node = node.nextSibling;\n          dom.remove(tempNode);\n          continue;\n        }\n\n        if (!rootBlockNode) {\n          rootBlockNode = dom.create(forcedRootBlock, getForcedRootBlockAttrs(editor));\n          node.parentNode.insertBefore(rootBlockNode, node);\n          wrapped = true;\n        }\n\n        tempNode = node;\n        node = node.nextSibling;\n        rootBlockNode.appendChild(tempNode);\n      } else {\n        rootBlockNode = null;\n        node = node.nextSibling;\n      }\n    }\n\n    if (wrapped && restoreSelection) {\n      rng.setStart(startContainer, startOffset);\n      rng.setEnd(endContainer, endOffset);\n      selection.setRng(rng);\n      editor.nodeChanged();\n    }\n  };\n\n  const setup$n = editor => {\n    editor.on('NodeChange', curry(addRootBlocks, editor));\n  };\n\n  const hasClass = checkClassName => node => (' ' + node.attr('class') + ' ').indexOf(checkClassName) !== -1;\n\n  const replaceMatchWithSpan = (editor, content, cls) => {\n    return function (match) {\n      const args = arguments,\n            index = args[args.length - 2];\n      const prevChar = index > 0 ? content.charAt(index - 1) : '';\n\n      if (prevChar === '\"') {\n        return match;\n      }\n\n      if (prevChar === '>') {\n        const findStartTagIndex = content.lastIndexOf('<', index);\n\n        if (findStartTagIndex !== -1) {\n          const tagHtml = content.substring(findStartTagIndex, index);\n\n          if (tagHtml.indexOf('contenteditable=\"false\"') !== -1) {\n            return match;\n          }\n        }\n      }\n\n      return '<span class=\"' + cls + '\" data-mce-content=\"' + editor.dom.encode(args[0]) + '\">' + editor.dom.encode(typeof args[1] === 'string' ? args[1] : args[0]) + '</span>';\n    };\n  };\n\n  const convertRegExpsToNonEditable = (editor, nonEditableRegExps, e) => {\n    let i = nonEditableRegExps.length,\n        content = e.content;\n\n    if (e.format === 'raw') {\n      return;\n    }\n\n    while (i--) {\n      content = content.replace(nonEditableRegExps[i], replaceMatchWithSpan(editor, content, getNonEditableClass(editor)));\n    }\n\n    e.content = content;\n  };\n\n  const setup$m = editor => {\n    const contentEditableAttrName = 'contenteditable';\n    const editClass = ' ' + Tools.trim(getEditableClass(editor)) + ' ';\n    const nonEditClass = ' ' + Tools.trim(getNonEditableClass(editor)) + ' ';\n    const hasEditClass = hasClass(editClass);\n    const hasNonEditClass = hasClass(nonEditClass);\n    const nonEditableRegExps = getNonEditableRegExps(editor);\n\n    if (nonEditableRegExps.length > 0) {\n      editor.on('BeforeSetContent', e => {\n        convertRegExpsToNonEditable(editor, nonEditableRegExps, e);\n      });\n    }\n\n    editor.parser.addAttributeFilter('class', nodes => {\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n\n        if (hasEditClass(node)) {\n          node.attr(contentEditableAttrName, 'true');\n        } else if (hasNonEditClass(node)) {\n          node.attr(contentEditableAttrName, 'false');\n        }\n      }\n    });\n    editor.serializer.addAttributeFilter(contentEditableAttrName, nodes => {\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n\n        if (!hasEditClass(node) && !hasNonEditClass(node)) {\n          continue;\n        }\n\n        if (nonEditableRegExps.length > 0 && node.attr('data-mce-content')) {\n          node.name = '#text';\n          node.type = 3;\n          node.raw = true;\n          node.value = node.attr('data-mce-content');\n        } else {\n          node.attr(contentEditableAttrName, null);\n        }\n      }\n    });\n  };\n\n  const findBlockCaretContainer = editor => descendant(SugarElement.fromDom(editor.getBody()), '*[data-mce-caret]').map(elm => elm.dom).getOrNull();\n\n  const showBlockCaretContainer = (editor, blockCaretContainer) => {\n    if (blockCaretContainer.hasAttribute('data-mce-caret')) {\n      showCaretContainerBlock(blockCaretContainer);\n      editor.selection.setRng(editor.selection.getRng());\n      editor.selection.scrollIntoView(blockCaretContainer);\n    }\n  };\n\n  const handleBlockContainer = (editor, e) => {\n    const blockCaretContainer = findBlockCaretContainer(editor);\n\n    if (!blockCaretContainer) {\n      return;\n    }\n\n    if (e.type === 'compositionstart') {\n      e.preventDefault();\n      e.stopPropagation();\n      showBlockCaretContainer(editor, blockCaretContainer);\n      return;\n    }\n\n    if (hasContent(blockCaretContainer)) {\n      showBlockCaretContainer(editor, blockCaretContainer);\n      editor.undoManager.add();\n    }\n  };\n\n  const setup$l = editor => {\n    editor.on('keyup compositionstart', curry(handleBlockContainer, editor));\n  };\n\n  const isContentEditableFalse$2 = isContentEditableFalse$a;\n\n  const moveToCeFalseHorizontally = (direction, editor, range) => moveHorizontally(editor, direction, range, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$2);\n\n  const moveToCeFalseVertically = (direction, editor, range) => {\n    const isBefore = caretPosition => isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);\n\n    const isAfter = caretPosition => isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);\n\n    return moveVertically(editor, direction, range, isBefore, isAfter, isContentEditableFalse$2);\n  };\n\n  const createTextBlock = editor => {\n    const textBlock = editor.dom.create(getForcedRootBlock(editor));\n    textBlock.innerHTML = '<br data-mce-bogus=\"1\">';\n    return textBlock;\n  };\n\n  const exitPreBlock = (editor, direction, range) => {\n    const caretWalker = CaretWalker(editor.getBody());\n    const getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 ? caretWalker.next : caretWalker.prev);\n\n    if (range.collapsed) {\n      const pre = editor.dom.getParent(range.startContainer, 'PRE');\n\n      if (!pre) {\n        return;\n      }\n\n      const caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range));\n\n      if (!caretPos) {\n        const newBlock = SugarElement.fromDom(createTextBlock(editor));\n\n        if (direction === 1) {\n          after$4(SugarElement.fromDom(pre), newBlock);\n        } else {\n          before$3(SugarElement.fromDom(pre), newBlock);\n        }\n\n        editor.selection.select(newBlock.dom, true);\n        editor.selection.collapse();\n      }\n    }\n  };\n\n  const getHorizontalRange = (editor, forward) => {\n    const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n    const range = editor.selection.getRng();\n    return moveToCeFalseHorizontally(direction, editor, range).orThunk(() => {\n      exitPreBlock(editor, direction, range);\n      return Optional.none();\n    });\n  };\n\n  const getVerticalRange = (editor, down) => {\n    const direction = down ? 1 : -1;\n    const range = editor.selection.getRng();\n    return moveToCeFalseVertically(direction, editor, range).orThunk(() => {\n      exitPreBlock(editor, direction, range);\n      return Optional.none();\n    });\n  };\n\n  const moveH$2 = (editor, forward) => getHorizontalRange(editor, forward).exists(newRange => {\n    moveToRange(editor, newRange);\n    return true;\n  });\n\n  const moveV$3 = (editor, down) => getVerticalRange(editor, down).exists(newRange => {\n    moveToRange(editor, newRange);\n    return true;\n  });\n\n  const moveToLineEndPoint$1 = (editor, forward) => {\n    const isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;\n    return moveToLineEndPoint$3(editor, forward, isCefPosition);\n  };\n\n  const isTarget = node => contains$2(['figcaption'], name(node));\n\n  const rangeBefore = target => {\n    const rng = document.createRange();\n    rng.setStartBefore(target.dom);\n    rng.setEndBefore(target.dom);\n    return rng;\n  };\n\n  const insertElement = (root, elm, forward) => {\n    if (forward) {\n      append$1(root, elm);\n    } else {\n      prepend(root, elm);\n    }\n  };\n\n  const insertEmptyLine = (root, forward, blockName, attrs) => {\n    const block = SugarElement.fromTag(blockName);\n    const br = SugarElement.fromTag('br');\n    setAll$1(block, attrs);\n    append$1(block, br);\n    insertElement(root, block, forward);\n    return rangeBefore(br);\n  };\n\n  const getClosestTargetBlock = (pos, root) => {\n    const isRoot = curry(eq, root);\n    return closest$4(SugarElement.fromDom(pos.container()), isBlock$2, isRoot).filter(isTarget);\n  };\n\n  const isAtFirstOrLastLine = (root, forward, pos) => forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);\n\n  const moveCaretToNewEmptyLine = (editor, forward) => {\n    const root = SugarElement.fromDom(editor.getBody());\n    const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n    const rootBlock = getForcedRootBlock(editor);\n    const rootBlockAttrs = getForcedRootBlockAttrs(editor);\n    return getClosestTargetBlock(pos, root).exists(() => {\n      if (isAtFirstOrLastLine(root, forward, pos)) {\n        const rng = insertEmptyLine(root, forward, rootBlock, rootBlockAttrs);\n        editor.selection.setRng(rng);\n        return true;\n      } else {\n        return false;\n      }\n    });\n  };\n\n  const moveV$2 = (editor, forward) => {\n    if (editor.selection.isCollapsed()) {\n      return moveCaretToNewEmptyLine(editor, forward);\n    } else {\n      return false;\n    }\n  };\n\n  const baseKeyPattern = {\n    shiftKey: false,\n    altKey: false,\n    ctrlKey: false,\n    metaKey: false,\n    keyCode: 0\n  };\n\n  const defaultPatterns = patterns => map$3(patterns, pattern => ({ ...baseKeyPattern,\n    action: noop,\n    ...pattern\n  }));\n\n  const defaultDelayedPatterns = patterns => map$3(patterns, pattern => ({ ...baseKeyPattern,\n    action: () => Optional.none(),\n    ...pattern\n  }));\n\n  const matchesEvent = (pattern, evt) => evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;\n\n  const match$1 = (patterns, evt) => bind$3(defaultPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\n\n  const matchDelayed = (patterns, evt) => bind$3(defaultDelayedPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\n\n  const action = function (f) {\n    for (var _len15 = arguments.length, x = new Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {\n      x[_key15 - 1] = arguments[_key15];\n    }\n\n    return () => f.apply(null, x);\n  };\n\n  const execute = (patterns, evt) => find$2(match$1(patterns, evt), pattern => pattern.action());\n\n  const executeWithDelayedAction = (patterns, evt) => findMap(matchDelayed(patterns, evt), pattern => pattern.action());\n\n  const moveH$1 = (editor, forward) => {\n    const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n    const range = editor.selection.getRng();\n    return moveHorizontally(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\n      moveToRange(editor, newRange);\n      return true;\n    });\n  };\n\n  const moveV$1 = (editor, down) => {\n    const direction = down ? 1 : -1;\n    const range = editor.selection.getRng();\n    return moveVertically(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\n      moveToRange(editor, newRange);\n      return true;\n    });\n  };\n\n  const moveToLineEndPoint = (editor, forward) => {\n    const isNearMedia = forward ? isAfterMedia : isBeforeMedia;\n    return moveToLineEndPoint$3(editor, forward, isNearMedia);\n  };\n\n  const adt = Adt.generate([{\n    none: ['current']\n  }, {\n    first: ['current']\n  }, {\n    middle: ['current', 'target']\n  }, {\n    last: ['current']\n  }]);\n\n  const none = current => adt.none(current);\n\n  const CellLocation = { ...adt,\n    none\n  };\n\n  const firstLayer = (scope, selector) => {\n    return filterFirstLayer(scope, selector, always);\n  };\n\n  const filterFirstLayer = (scope, selector, predicate) => {\n    return bind$3(children(scope), x => {\n      if (is$1(x, selector)) {\n        return predicate(x) ? [x] : [];\n      } else {\n        return filterFirstLayer(x, selector, predicate);\n      }\n    });\n  };\n\n  const lookup$1 = function (tags, element) {\n    let isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : never;\n\n    if (isRoot(element)) {\n      return Optional.none();\n    }\n\n    if (contains$2(tags, name(element))) {\n      return Optional.some(element);\n    }\n\n    const isRootOrUpperTable = elm => is$1(elm, 'table') || isRoot(elm);\n\n    return ancestor$2(element, tags.join(','), isRootOrUpperTable);\n  };\n\n  const cell = (element, isRoot) => lookup$1(['td', 'th'], element, isRoot);\n\n  const cells = ancestor => firstLayer(ancestor, 'th,td');\n\n  const table = (element, isRoot) => closest$3(element, 'table', isRoot);\n\n  const walk = function (all, current, index, direction) {\n    let isEligible = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : always;\n    const forwards = direction === 1;\n\n    if (!forwards && index <= 0) {\n      return CellLocation.first(all[0]);\n    } else if (forwards && index >= all.length - 1) {\n      return CellLocation.last(all[all.length - 1]);\n    } else {\n      const newIndex = index + direction;\n      const elem = all[newIndex];\n      return isEligible(elem) ? CellLocation.middle(current, elem) : walk(all, current, newIndex, direction, isEligible);\n    }\n  };\n\n  const detect = (current, isRoot) => {\n    return table(current, isRoot).bind(table => {\n      const all = cells(table);\n      const index = findIndex$2(all, x => eq(current, x));\n      return index.map(index => ({\n        index,\n        all\n      }));\n    });\n  };\n\n  const next = (current, isEligible, isRoot) => {\n    const detection = detect(current, isRoot);\n    return detection.fold(() => {\n      return CellLocation.none(current);\n    }, info => {\n      return walk(info.all, current, info.index, 1, isEligible);\n    });\n  };\n\n  const prev = (current, isEligible, isRoot) => {\n    const detection = detect(current, isRoot);\n    return detection.fold(() => {\n      return CellLocation.none();\n    }, info => {\n      return walk(info.all, current, info.index, -1, isEligible);\n    });\n  };\n\n  const closest = target => closest$3(target, '[contenteditable]');\n\n  const isEditable = function (element) {\n    let assumeEditable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (inBody(element)) {\n      return element.dom.isContentEditable;\n    } else {\n      return closest(element).fold(constant(assumeEditable), editable => getRaw(editable) === 'true');\n    }\n  };\n\n  const getRaw = element => element.dom.contentEditable;\n\n  const deflate = (rect, delta) => ({\n    left: rect.left - delta,\n    top: rect.top - delta,\n    right: rect.right + delta * 2,\n    bottom: rect.bottom + delta * 2,\n    width: rect.width + delta,\n    height: rect.height + delta\n  });\n\n  const getCorners = (getYAxisValue, tds) => bind$3(tds, td => {\n    const rect = deflate(clone$1(td.getBoundingClientRect()), -1);\n    return [{\n      x: rect.left,\n      y: getYAxisValue(rect),\n      cell: td\n    }, {\n      x: rect.right,\n      y: getYAxisValue(rect),\n      cell: td\n    }];\n  });\n\n  const findClosestCorner = (corners, x, y) => foldl(corners, (acc, newCorner) => acc.fold(() => Optional.some(newCorner), oldCorner => {\n    const oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));\n    const newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));\n    return Optional.some(newDist < oldDist ? newCorner : oldCorner);\n  }), Optional.none());\n\n  const getClosestCell = (getYAxisValue, isTargetCorner, table, x, y) => {\n    const cells = descendants(SugarElement.fromDom(table), 'td,th,caption').map(e => e.dom);\n    const corners = filter$6(getCorners(getYAxisValue, cells), corner => isTargetCorner(corner, y));\n    return findClosestCorner(corners, x, y).map(corner => corner.cell);\n  };\n\n  const getBottomValue = rect => rect.bottom;\n\n  const getTopValue = rect => rect.top;\n\n  const isAbove = (corner, y) => corner.y < y;\n\n  const isBelow = (corner, y) => corner.y > y;\n\n  const getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);\n  const getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);\n\n  const findClosestPositionInAboveCell = (table, pos) => head(pos.getClientRects()).bind(rect => getClosestCellAbove(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getLastLinePositions(cell), pos));\n\n  const findClosestPositionInBelowCell = (table, pos) => last$3(pos.getClientRects()).bind(rect => getClosestCellBelow(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getFirstLinePositions(cell), pos));\n\n  const hasNextBreak = (getPositionsUntil, scope, lineInfo) => lineInfo.breakAt.exists(breakPos => getPositionsUntil(scope, breakPos).breakAt.isSome());\n\n  const startsWithWrapBreak = lineInfo => lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;\n\n  const startsWithBrBreak = lineInfo => lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;\n\n  const isAtTableCellLine = (getPositionsUntil, scope, pos) => {\n    const lineInfo = getPositionsUntil(scope, pos);\n\n    if (startsWithWrapBreak(lineInfo) || !isBr$5(pos.getNode()) && startsWithBrBreak(lineInfo)) {\n      return !hasNextBreak(getPositionsUntil, scope, lineInfo);\n    } else {\n      return lineInfo.breakAt.isNone();\n    }\n  };\n\n  const isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);\n  const isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);\n\n  const isCaretAtStartOrEndOfTable = (forward, rng, table) => {\n    const caretPos = CaretPosition.fromRangeStart(rng);\n    return positionIn(!forward, table).exists(pos => pos.isEqual(caretPos));\n  };\n\n  const navigateHorizontally = (editor, forward, table, _td) => {\n    const rng = editor.selection.getRng();\n    const direction = forward ? 1 : -1;\n\n    if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {\n      showCaret(direction, editor, table, !forward, false).each(newRng => {\n        moveToRange(editor, newRng);\n      });\n      return true;\n    }\n\n    return false;\n  };\n\n  const getClosestAbovePosition = (root, table, start) => findClosestPositionInAboveCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table)), rect.left))).getOr(CaretPosition.before(table));\n\n  const getClosestBelowPosition = (root, table, start) => findClosestPositionInBelowCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table)), rect.left))).getOr(CaretPosition.after(table));\n\n  const getTable = (previous, pos) => {\n    const node = pos.getNode(previous);\n    return isElement$6(node) && node.nodeName === 'TABLE' ? Optional.some(node) : Optional.none();\n  };\n\n  const renderBlock = (down, editor, table) => {\n    const forcedRootBlock = getForcedRootBlock(editor);\n    editor.undoManager.transact(() => {\n      const element = SugarElement.fromTag(forcedRootBlock);\n      setAll$1(element, getForcedRootBlockAttrs(editor));\n      append$1(element, SugarElement.fromTag('br'));\n\n      if (down) {\n        after$4(SugarElement.fromDom(table), element);\n      } else {\n        before$3(SugarElement.fromDom(table), element);\n      }\n\n      const rng = editor.dom.createRng();\n      rng.setStart(element.dom, 0);\n      rng.setEnd(element.dom, 0);\n      moveToRange(editor, rng);\n    });\n  };\n\n  const moveCaret = (editor, down, pos) => {\n    const table = down ? getTable(true, pos) : getTable(false, pos);\n    const last = down === false;\n    table.fold(() => moveToRange(editor, pos.toRange()), table => positionIn(last, editor.getBody()).filter(lastPos => lastPos.isEqual(pos)).fold(() => moveToRange(editor, pos.toRange()), _ => renderBlock(down, editor, table)));\n  };\n\n  const navigateVertically = (editor, down, table, td) => {\n    const rng = editor.selection.getRng();\n    const pos = CaretPosition.fromRangeStart(rng);\n    const root = editor.getBody();\n\n    if (!down && isAtFirstTableCellLine(td, pos)) {\n      const newPos = getClosestAbovePosition(root, table, pos);\n      moveCaret(editor, down, newPos);\n      return true;\n    } else if (down && isAtLastTableCellLine(td, pos)) {\n      const newPos = getClosestBelowPosition(root, table, pos);\n      moveCaret(editor, down, newPos);\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  const move$1 = (editor, forward, mover) => Optional.from(editor.dom.getParent(editor.selection.getNode(), 'td,th')).bind(td => Optional.from(editor.dom.getParent(td, 'table')).map(table => mover(editor, forward, table, td))).getOr(false);\n\n  const moveH = (editor, forward) => move$1(editor, forward, navigateHorizontally);\n\n  const moveV = (editor, forward) => move$1(editor, forward, navigateVertically);\n\n  const getCellFirstCursorPosition = cell => {\n    const selection = SimSelection.exact(cell, 0, cell, 0);\n    return toNative(selection);\n  };\n\n  const tabGo = (editor, isRoot, cell) => {\n    return cell.fold(Optional.none, Optional.none, (_current, next) => {\n      return first(next).map(cell => {\n        return getCellFirstCursorPosition(cell);\n      });\n    }, current => {\n      editor.execCommand('mceTableInsertRowAfter');\n      return tabForward(editor, isRoot, current);\n    });\n  };\n\n  const tabForward = (editor, isRoot, cell) => tabGo(editor, isRoot, next(cell, isEditable));\n\n  const tabBackward = (editor, isRoot, cell) => tabGo(editor, isRoot, prev(cell, isEditable));\n\n  const handleTab = (editor, forward) => {\n    const rootElements = ['table', 'li', 'dl'];\n    const body = SugarElement.fromDom(editor.getBody());\n\n    const isRoot = element => {\n      const name$1 = name(element);\n      return eq(element, body) || contains$2(rootElements, name$1);\n    };\n\n    const rng = editor.selection.getRng();\n    const container = SugarElement.fromDom(!forward ? rng.startContainer : rng.endContainer);\n    return cell(container, isRoot).map(cell => {\n      table(cell, isRoot).each(table => {\n        editor.model.table.clearSelectedCells(table.dom);\n      });\n      editor.selection.collapse(!forward);\n      const navigation = !forward ? tabBackward : tabForward;\n      const rng = navigation(editor, isRoot, cell);\n      rng.each(range => {\n        editor.selection.setRng(range);\n      });\n      return true;\n    }).getOr(false);\n  };\n\n  const executeKeydownOverride$4 = (editor, caret, evt) => {\n    const os = detect$2().os;\n    execute([{\n      keyCode: VK.RIGHT,\n      action: action(moveH$2, editor, true)\n    }, {\n      keyCode: VK.LEFT,\n      action: action(moveH$2, editor, false)\n    }, {\n      keyCode: VK.UP,\n      action: action(moveV$3, editor, false)\n    }, {\n      keyCode: VK.DOWN,\n      action: action(moveV$3, editor, true)\n    }, {\n      keyCode: VK.RIGHT,\n      action: action(moveH, editor, true)\n    }, {\n      keyCode: VK.LEFT,\n      action: action(moveH, editor, false)\n    }, {\n      keyCode: VK.UP,\n      action: action(moveV, editor, false)\n    }, {\n      keyCode: VK.DOWN,\n      action: action(moveV, editor, true)\n    }, {\n      keyCode: VK.RIGHT,\n      action: action(moveH$1, editor, true)\n    }, {\n      keyCode: VK.LEFT,\n      action: action(moveH$1, editor, false)\n    }, {\n      keyCode: VK.UP,\n      action: action(moveV$1, editor, false)\n    }, {\n      keyCode: VK.DOWN,\n      action: action(moveV$1, editor, true)\n    }, {\n      keyCode: VK.RIGHT,\n      action: action(move$2, editor, caret, true)\n    }, {\n      keyCode: VK.LEFT,\n      action: action(move$2, editor, caret, false)\n    }, {\n      keyCode: VK.RIGHT,\n      ctrlKey: !os.isMacOS(),\n      altKey: os.isMacOS(),\n      action: action(moveNextWord, editor, caret)\n    }, {\n      keyCode: VK.LEFT,\n      ctrlKey: !os.isMacOS(),\n      altKey: os.isMacOS(),\n      action: action(movePrevWord, editor, caret)\n    }, {\n      keyCode: VK.UP,\n      action: action(moveV$2, editor, false)\n    }, {\n      keyCode: VK.DOWN,\n      action: action(moveV$2, editor, true)\n    }], evt).each(_ => {\n      evt.preventDefault();\n    });\n  };\n\n  const setup$k = (editor, caret) => {\n    editor.on('keydown', evt => {\n      if (evt.isDefaultPrevented() === false) {\n        executeKeydownOverride$4(editor, caret, evt);\n      }\n    });\n  };\n\n  const point = (container, offset) => ({\n    container,\n    offset\n  });\n\n  const DOM$7 = DOMUtils.DOM;\n\n  const alwaysNext = startNode => node => startNode === node ? -1 : 0;\n\n  const isBoundary = dom => node => dom.isBlock(node) || contains$2(['BR', 'IMG', 'HR', 'INPUT'], node.nodeName) || dom.getContentEditable(node) === 'false';\n\n  const textBefore = (node, offset, rootNode) => {\n    if (isText$8(node) && offset >= 0) {\n      return Optional.some(point(node, offset));\n    } else {\n      const textSeeker = TextSeeker(DOM$7);\n      return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, prev.container.data.length));\n    }\n  };\n\n  const textAfter = (node, offset, rootNode) => {\n    if (isText$8(node) && offset >= node.length) {\n      return Optional.some(point(node, offset));\n    } else {\n      const textSeeker = TextSeeker(DOM$7);\n      return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, 0));\n    }\n  };\n\n  const scanLeft = (node, offset, rootNode) => {\n    if (!isText$8(node)) {\n      return Optional.none();\n    }\n\n    const text = node.textContent;\n\n    if (offset >= 0 && offset <= text.length) {\n      return Optional.some(point(node, offset));\n    } else {\n      const textSeeker = TextSeeker(DOM$7);\n      return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).bind(prev => {\n        const prevText = prev.container.data;\n        return scanLeft(prev.container, offset + prevText.length, rootNode);\n      });\n    }\n  };\n\n  const scanRight = (node, offset, rootNode) => {\n    if (!isText$8(node)) {\n      return Optional.none();\n    }\n\n    const text = node.textContent;\n\n    if (offset <= text.length) {\n      return Optional.some(point(node, offset));\n    } else {\n      const textSeeker = TextSeeker(DOM$7);\n      return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).bind(next => scanRight(next.container, offset - text.length, rootNode));\n    }\n  };\n\n  const repeatLeft = (dom, node, offset, process, rootNode) => {\n    const search = TextSeeker(dom, isBoundary(dom));\n    return Optional.from(search.backwards(node, offset, process, rootNode));\n  };\n\n  const isValidTextRange = rng => rng.collapsed && rng.startContainer.nodeType === 3;\n\n  const getText = rng => rng.toString().replace(/\\u00A0/g, ' ').replace(/\\uFEFF/g, '');\n\n  const isWhitespace = chr => chr !== '' && ' \\xA0\\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\n\n  const stripTriggerChar = (text, triggerCh) => text.substring(triggerCh.length);\n\n  const findChar = (text, index, ch) => {\n    let i;\n\n    for (i = index - 1; i >= 0; i--) {\n      const char = text.charAt(i);\n\n      if (isWhitespace(char)) {\n        return Optional.none();\n      }\n\n      if (char === ch) {\n        break;\n      }\n    }\n\n    return Optional.some(i);\n  };\n\n  const findStart = function (dom, initRange, ch) {\n    let minChars = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n    if (!isValidTextRange(initRange)) {\n      return Optional.none();\n    }\n\n    const findTriggerChIndex = (element, offset, text) => findChar(text, offset, ch).getOr(offset);\n\n    const root = dom.getParent(initRange.startContainer, dom.isBlock) || dom.getRoot();\n    return repeatLeft(dom, initRange.startContainer, initRange.startOffset, findTriggerChIndex, root).bind(spot => {\n      const range = initRange.cloneRange();\n      range.setStart(spot.container, spot.offset);\n      range.setEnd(initRange.endContainer, initRange.endOffset);\n\n      if (range.collapsed) {\n        return Optional.none();\n      }\n\n      const text = getText(range);\n      const triggerCharIndex = text.lastIndexOf(ch);\n\n      if (triggerCharIndex !== 0 || stripTriggerChar(text, ch).length < minChars) {\n        return Optional.none();\n      } else {\n        return Optional.some({\n          text: stripTriggerChar(text, ch),\n          range,\n          triggerChar: ch\n        });\n      }\n    });\n  };\n\n  const getContext = function (dom, initRange, ch) {\n    let minChars = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    return detect$1(SugarElement.fromDom(initRange.startContainer)).fold(() => findStart(dom, initRange, ch, minChars), elm => {\n      const range = dom.createRng();\n      range.selectNode(elm.dom);\n      const text = getText(range);\n      return Optional.some({\n        range,\n        text: stripTriggerChar(text, ch),\n        triggerChar: ch\n      });\n    });\n  };\n\n  const isText = node => node.nodeType === TEXT;\n\n  const isElement = node => node.nodeType === ELEMENT;\n\n  const toLast = node => {\n    if (isText(node)) {\n      return point(node, node.data.length);\n    } else {\n      const children = node.childNodes;\n      return children.length > 0 ? toLast(children[children.length - 1]) : point(node, children.length);\n    }\n  };\n\n  const toLeaf = (node, offset) => {\n    const children = node.childNodes;\n\n    if (children.length > 0 && offset < children.length) {\n      return toLeaf(children[offset], 0);\n    } else if (children.length > 0 && isElement(node) && children.length === offset) {\n      return toLast(children[children.length - 1]);\n    } else {\n      return point(node, offset);\n    }\n  };\n\n  const isPreviousCharContent = (dom, leaf) => repeatLeft(dom, leaf.container, leaf.offset, (element, offset) => offset === 0 ? -1 : offset, dom.getRoot()).filter(spot => {\n    const char = spot.container.data.charAt(spot.offset - 1);\n    return !isWhitespace(char);\n  }).isSome();\n\n  const isStartOfWord = dom => rng => {\n    const leaf = toLeaf(rng.startContainer, rng.startOffset);\n    return !isPreviousCharContent(dom, leaf);\n  };\n\n  const getTriggerContext = (dom, initRange, database) => findMap(database.triggerChars, ch => getContext(dom, initRange, ch));\n\n  const lookup = (editor, getDatabase) => {\n    const database = getDatabase();\n    const rng = editor.selection.getRng();\n    return getTriggerContext(editor.dom, rng, database).bind(context => lookupWithContext(editor, getDatabase, context));\n  };\n\n  const lookupWithContext = function (editor, getDatabase, context) {\n    let fetchOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const database = getDatabase();\n    const rng = editor.selection.getRng();\n    const startText = rng.startContainer.nodeValue;\n    const autocompleters = filter$6(database.lookupByChar(context.triggerChar), autocompleter => context.text.length >= autocompleter.minChars && autocompleter.matches.getOrThunk(() => isStartOfWord(editor.dom))(context.range, startText, context.text));\n\n    if (autocompleters.length === 0) {\n      return Optional.none();\n    }\n\n    const lookupData = Promise.all(map$3(autocompleters, ac => {\n      const fetchResult = ac.fetch(context.text, ac.maxResults, fetchOptions);\n      return fetchResult.then(results => ({\n        matchText: context.text,\n        items: results,\n        columns: ac.columns,\n        onAction: ac.onAction,\n        highlightOn: ac.highlightOn\n      }));\n    }));\n    return Optional.some({\n      lookupData,\n      context\n    });\n  };\n\n  var SimpleResultType;\n\n  (function (SimpleResultType) {\n    SimpleResultType[SimpleResultType['Error'] = 0] = 'Error';\n    SimpleResultType[SimpleResultType['Value'] = 1] = 'Value';\n  })(SimpleResultType || (SimpleResultType = {}));\n\n  const fold$1 = (res, onError, onValue) => res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);\n\n  const partition = results => {\n    const values = [];\n    const errors = [];\n    each$g(results, obj => {\n      fold$1(obj, err => errors.push(err), val => values.push(val));\n    });\n    return {\n      values,\n      errors\n    };\n  };\n\n  const mapError = (res, f) => {\n    if (res.stype === SimpleResultType.Error) {\n      return {\n        stype: SimpleResultType.Error,\n        serror: f(res.serror)\n      };\n    } else {\n      return res;\n    }\n  };\n\n  const map = (res, f) => {\n    if (res.stype === SimpleResultType.Value) {\n      return {\n        stype: SimpleResultType.Value,\n        svalue: f(res.svalue)\n      };\n    } else {\n      return res;\n    }\n  };\n\n  const bind = (res, f) => {\n    if (res.stype === SimpleResultType.Value) {\n      return f(res.svalue);\n    } else {\n      return res;\n    }\n  };\n\n  const bindError = (res, f) => {\n    if (res.stype === SimpleResultType.Error) {\n      return f(res.serror);\n    } else {\n      return res;\n    }\n  };\n\n  const svalue = v => ({\n    stype: SimpleResultType.Value,\n    svalue: v\n  });\n\n  const serror = e => ({\n    stype: SimpleResultType.Error,\n    serror: e\n  });\n\n  const toResult = res => fold$1(res, Result.error, Result.value);\n\n  const fromResult = res => res.fold(serror, svalue);\n\n  const SimpleResult = {\n    fromResult,\n    toResult,\n    svalue,\n    partition,\n    serror,\n    bind,\n    bindError,\n    map,\n    mapError,\n    fold: fold$1\n  };\n\n  const formatObj = input => {\n    return isObject(input) && keys(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);\n  };\n\n  const formatErrors = errors => {\n    const es = errors.length > 10 ? errors.slice(0, 10).concat([{\n      path: [],\n      getErrorInfo: constant('... (only showing first ten failures)')\n    }]) : errors;\n    return map$3(es, e => {\n      return 'Failed path: (' + e.path.join(' > ') + ')\\n' + e.getErrorInfo();\n    });\n  };\n\n  const nu = (path, getErrorInfo) => {\n    return SimpleResult.serror([{\n      path,\n      getErrorInfo\n    }]);\n  };\n\n  const missingRequired = (path, key, obj) => nu(path, () => 'Could not find valid *required* value for \"' + key + '\" in ' + formatObj(obj));\n\n  const missingKey = (path, key) => nu(path, () => 'Choice schema did not contain choice key: \"' + key + '\"');\n\n  const missingBranch = (path, branches, branch) => nu(path, () => 'The chosen schema: \"' + branch + '\" did not exist in branches: ' + formatObj(branches));\n\n  const custom = (path, err) => nu(path, constant(err));\n\n  const chooseFrom = (path, input, branches, ch) => {\n    const fields = get$a(branches, ch);\n    return fields.fold(() => missingBranch(path, branches, ch), vp => vp.extract(path.concat(['branch: ' + ch]), input));\n  };\n\n  const choose$1 = (key, branches) => {\n    const extract = (path, input) => {\n      const choice = get$a(input, key);\n      return choice.fold(() => missingKey(path, key), chosen => chooseFrom(path, input, branches, chosen));\n    };\n\n    const toString = () => 'chooseOn(' + key + '). Possible values: ' + keys(branches);\n\n    return {\n      extract,\n      toString\n    };\n  };\n\n  const shallow = (old, nu) => {\n    return nu;\n  };\n\n  const deep = (old, nu) => {\n    const bothObjects = isPlainObject(old) && isPlainObject(nu);\n    return bothObjects ? deepMerge(old, nu) : nu;\n  };\n\n  const baseMerge = merger => {\n    return function () {\n      if (arguments.length === 0) {\n        throw new Error(`Can't merge zero objects`);\n      }\n\n      const ret = {};\n\n      for (let j = 0; j < arguments.length; j++) {\n        const curObject = j < 0 || arguments.length <= j ? undefined : arguments[j];\n\n        for (const key in curObject) {\n          if (has$2(curObject, key)) {\n            ret[key] = merger(ret[key], curObject[key]);\n          }\n        }\n      }\n\n      return ret;\n    };\n  };\n\n  const deepMerge = baseMerge(deep);\n  const merge = baseMerge(shallow);\n\n  const required = () => ({\n    tag: 'required',\n    process: {}\n  });\n\n  const defaultedThunk = fallbackThunk => ({\n    tag: 'defaultedThunk',\n    process: fallbackThunk\n  });\n\n  const defaulted$1 = fallback => defaultedThunk(constant(fallback));\n\n  const asOption = () => ({\n    tag: 'option',\n    process: {}\n  });\n\n  const mergeValues = (values, base) => values.length > 0 ? SimpleResult.svalue(deepMerge(base, merge.apply(undefined, values))) : SimpleResult.svalue(base);\n\n  const mergeErrors = errors => compose(SimpleResult.serror, flatten)(errors);\n\n  const consolidateObj = (objects, base) => {\n    const partition = SimpleResult.partition(objects);\n    return partition.errors.length > 0 ? mergeErrors(partition.errors) : mergeValues(partition.values, base);\n  };\n\n  const consolidateArr = objects => {\n    const partitions = SimpleResult.partition(objects);\n    return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : SimpleResult.svalue(partitions.values);\n  };\n\n  const ResultCombine = {\n    consolidateObj,\n    consolidateArr\n  };\n\n  const field$1 = (key, newKey, presence, prop) => ({\n    tag: 'field',\n    key,\n    newKey,\n    presence,\n    prop\n  });\n\n  const customField$1 = (newKey, instantiator) => ({\n    tag: 'custom',\n    newKey,\n    instantiator\n  });\n\n  const fold = (value, ifField, ifCustom) => {\n    switch (value.tag) {\n      case 'field':\n        return ifField(value.key, value.newKey, value.presence, value.prop);\n\n      case 'custom':\n        return ifCustom(value.newKey, value.instantiator);\n    }\n  };\n\n  const value = validator => {\n    const extract = (path, val) => {\n      return SimpleResult.bindError(validator(val), err => custom(path, err));\n    };\n\n    const toString = constant('val');\n    return {\n      extract,\n      toString\n    };\n  };\n\n  const anyValue$1 = value(SimpleResult.svalue);\n\n  const requiredAccess = (path, obj, key, bundle) => get$a(obj, key).fold(() => missingRequired(path, key, obj), bundle);\n\n  const fallbackAccess = (obj, key, fallback, bundle) => {\n    const v = get$a(obj, key).getOrThunk(() => fallback(obj));\n    return bundle(v);\n  };\n\n  const optionAccess = (obj, key, bundle) => bundle(get$a(obj, key));\n\n  const optionDefaultedAccess = (obj, key, fallback, bundle) => {\n    const opt = get$a(obj, key).map(val => val === true ? fallback(obj) : val);\n    return bundle(opt);\n  };\n\n  const extractField = (field, path, obj, key, prop) => {\n    const bundle = av => prop.extract(path.concat([key]), av);\n\n    const bundleAsOption = optValue => optValue.fold(() => SimpleResult.svalue(Optional.none()), ov => {\n      const result = prop.extract(path.concat([key]), ov);\n      return SimpleResult.map(result, Optional.some);\n    });\n\n    switch (field.tag) {\n      case 'required':\n        return requiredAccess(path, obj, key, bundle);\n\n      case 'defaultedThunk':\n        return fallbackAccess(obj, key, field.process, bundle);\n\n      case 'option':\n        return optionAccess(obj, key, bundleAsOption);\n\n      case 'defaultedOptionThunk':\n        return optionDefaultedAccess(obj, key, field.process, bundleAsOption);\n\n      case 'mergeWithThunk':\n        {\n          return fallbackAccess(obj, key, constant({}), v => {\n            const result = deepMerge(field.process(obj), v);\n            return bundle(result);\n          });\n        }\n    }\n  };\n\n  const extractFields = (path, obj, fields) => {\n    const success = {};\n    const errors = [];\n\n    for (const field of fields) {\n      fold(field, (key, newKey, presence, prop) => {\n        const result = extractField(presence, path, obj, key, prop);\n        SimpleResult.fold(result, err => {\n          errors.push(...err);\n        }, res => {\n          success[newKey] = res;\n        });\n      }, (newKey, instantiator) => {\n        success[newKey] = instantiator(obj);\n      });\n    }\n\n    return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);\n  };\n\n  const objOf = values => {\n    const extract = (path, o) => extractFields(path, o, values);\n\n    const toString = () => {\n      const fieldStrings = map$3(values, value => fold(value, (key, _okey, _presence, prop) => key + ' -> ' + prop.toString(), (newKey, _instantiator) => 'state(' + newKey + ')'));\n      return 'obj{\\n' + fieldStrings.join('\\n') + '}';\n    };\n\n    return {\n      extract,\n      toString\n    };\n  };\n\n  const arrOf = prop => {\n    const extract = (path, array) => {\n      const results = map$3(array, (a, i) => prop.extract(path.concat(['[' + i + ']']), a));\n      return ResultCombine.consolidateArr(results);\n    };\n\n    const toString = () => 'array(' + prop.toString() + ')';\n\n    return {\n      extract,\n      toString\n    };\n  };\n\n  const valueOf = validator => value(v => validator(v).fold(SimpleResult.serror, SimpleResult.svalue));\n\n  const extractValue = (label, prop, obj) => {\n    const res = prop.extract([label], obj);\n    return SimpleResult.mapError(res, errs => ({\n      input: obj,\n      errors: errs\n    }));\n  };\n\n  const asRaw = (label, prop, obj) => SimpleResult.toResult(extractValue(label, prop, obj));\n\n  const formatError = errInfo => {\n    return 'Errors: \\n' + formatErrors(errInfo.errors).join('\\n') + '\\n\\nInput object: ' + formatObj(errInfo.input);\n  };\n\n  const choose = (key, branches) => choose$1(key, map$2(branches, objOf));\n\n  const anyValue = constant(anyValue$1);\n\n  const typedValue = (validator, expectedType) => value(a => {\n    const actualType = typeof a;\n    return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${expectedType} but got: ${actualType}`);\n  });\n\n  const number = typedValue(isNumber, 'number');\n  const string = typedValue(isString, 'string');\n  const boolean = typedValue(isBoolean, 'boolean');\n  const functionProcessor = typedValue(isFunction, 'function');\n  const field = field$1;\n  const customField = customField$1;\n\n  const validateEnum = values => valueOf(value => contains$2(values, value) ? Result.value(value) : Result.error(`Unsupported value: \"${value}\", choose one of \"${values.join(', ')}\".`));\n\n  const requiredOf = (key, schema) => field(key, key, required(), schema);\n\n  const requiredString = key => requiredOf(key, string);\n\n  const requiredFunction = key => requiredOf(key, functionProcessor);\n\n  const requiredArrayOf = (key, schema) => field(key, key, required(), arrOf(schema));\n\n  const optionOf = (key, schema) => field(key, key, asOption(), schema);\n\n  const optionString = key => optionOf(key, string);\n\n  const optionFunction = key => optionOf(key, functionProcessor);\n\n  const defaulted = (key, fallback) => field(key, key, defaulted$1(fallback), anyValue());\n\n  const defaultedOf = (key, fallback, schema) => field(key, key, defaulted$1(fallback), schema);\n\n  const defaultedNumber = (key, fallback) => defaultedOf(key, fallback, number);\n\n  const defaultedString = (key, fallback) => defaultedOf(key, fallback, string);\n\n  const defaultedStringEnum = (key, fallback, values) => defaultedOf(key, fallback, validateEnum(values));\n\n  const defaultedBoolean = (key, fallback) => defaultedOf(key, fallback, boolean);\n\n  const defaultedFunction = (key, fallback) => defaultedOf(key, fallback, functionProcessor);\n\n  const defaultedArrayOf = (key, fallback, schema) => defaultedOf(key, fallback, arrOf(schema));\n\n  const type = requiredString('type');\n  const fetch = requiredFunction('fetch');\n  const onAction = requiredFunction('onAction');\n  const onSetup = defaultedFunction('onSetup', () => noop);\n  const optionalText = optionString('text');\n  const optionalIcon = optionString('icon');\n  const optionalTooltip = optionString('tooltip');\n  const optionalLabel = optionString('label');\n  const active = defaultedBoolean('active', false);\n  const enabled = defaultedBoolean('enabled', true);\n  const primary = defaultedBoolean('primary', false);\n\n  const defaultedColumns = num => defaulted('columns', num);\n\n  const defaultedType = type => defaultedString('type', type);\n\n  const autocompleterSchema = objOf([type, requiredString('ch'), defaultedNumber('minChars', 1), defaultedColumns(1), defaultedNumber('maxResults', 10), optionFunction('matches'), fetch, onAction, defaultedArrayOf('highlightOn', [], string)]);\n\n  const createAutocompleter = spec => asRaw('Autocompleter', autocompleterSchema, spec);\n\n  const baseToolbarButtonFields = [enabled, optionalTooltip, optionalIcon, optionalText, onSetup];\n  const baseToolbarToggleButtonFields = [active].concat(baseToolbarButtonFields);\n  const contextBarFields = [defaultedFunction('predicate', never), defaultedStringEnum('scope', 'node', ['node', 'editor']), defaultedStringEnum('position', 'selection', ['node', 'selection', 'line'])];\n  const contextButtonFields = baseToolbarButtonFields.concat([defaultedType('contextformbutton'), primary, onAction, customField('original', identity)]);\n  const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType('contextformbutton'), primary, onAction, customField('original', identity)]);\n  const launchButtonFields = baseToolbarButtonFields.concat([defaultedType('contextformbutton')]);\n  const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType('contextformtogglebutton')]);\n  const toggleOrNormal = choose('type', {\n    contextformbutton: contextButtonFields,\n    contextformtogglebutton: contextToggleButtonFields\n  });\n  objOf([defaultedType('contextform'), defaultedFunction('initValue', constant('')), optionalLabel, requiredArrayOf('commands', toggleOrNormal), optionOf('launch', choose('type', {\n    contextformbutton: launchButtonFields,\n    contextformtogglebutton: launchToggleButtonFields\n  }))].concat(contextBarFields));\n\n  const register$2 = editor => {\n    const popups = editor.ui.registry.getAll().popups;\n    const dataset = map$2(popups, popup => createAutocompleter(popup).fold(err => {\n      throw new Error(formatError(err));\n    }, identity));\n    const triggerChars = stringArray(mapToArray(dataset, v => v.ch));\n    const datasetValues = values(dataset);\n\n    const lookupByChar = ch => filter$6(datasetValues, dv => dv.ch === ch);\n\n    return {\n      dataset,\n      triggerChars,\n      lookupByChar\n    };\n  };\n\n  const setupEditorInput = (editor, api) => {\n    const update = last$1(api.load, 50);\n    editor.on('keypress compositionend', e => {\n      if (e.which === 27) {\n        return;\n      }\n\n      update.throttle();\n    });\n    editor.on('keydown', e => {\n      const keyCode = e.which;\n\n      if (keyCode === 8) {\n        update.throttle();\n      } else if (keyCode === 27) {\n        api.cancelIfNecessary();\n      }\n    });\n    editor.on('remove', update.cancel);\n  };\n\n  const setup$j = editor => {\n    const activeAutocompleter = value$2();\n    const uiActive = Cell(false);\n    const isActive = activeAutocompleter.isSet;\n\n    const cancelIfNecessary = () => {\n      if (isActive()) {\n        removeAutocompleterDecoration(editor);\n        fireAutocompleterEnd(editor);\n        uiActive.set(false);\n        activeAutocompleter.clear();\n      }\n    };\n\n    const commenceIfNecessary = context => {\n      if (!isActive()) {\n        addAutocompleterDecoration(editor, context.range);\n        activeAutocompleter.set({\n          triggerChar: context.triggerChar,\n          matchLength: context.text.length\n        });\n      }\n    };\n\n    const getAutocompleters = cached(() => register$2(editor));\n\n    const doLookup = fetchOptions => activeAutocompleter.get().map(ac => getContext(editor.dom, editor.selection.getRng(), ac.triggerChar).bind(newContext => lookupWithContext(editor, getAutocompleters, newContext, fetchOptions))).getOrThunk(() => lookup(editor, getAutocompleters));\n\n    const load = fetchOptions => {\n      doLookup(fetchOptions).fold(cancelIfNecessary, lookupInfo => {\n        commenceIfNecessary(lookupInfo.context);\n        lookupInfo.lookupData.then(lookupData => {\n          activeAutocompleter.get().map(ac => {\n            const context = lookupInfo.context;\n\n            if (ac.triggerChar === context.triggerChar) {\n              if (context.text.length - ac.matchLength >= 10) {\n                cancelIfNecessary();\n              } else {\n                activeAutocompleter.set({ ...ac,\n                  matchLength: context.text.length\n                });\n\n                if (uiActive.get()) {\n                  fireAutocompleterUpdate(editor, {\n                    lookupData\n                  });\n                } else {\n                  uiActive.set(true);\n                  fireAutocompleterStart(editor, {\n                    lookupData\n                  });\n                }\n              }\n            }\n          });\n        });\n      });\n    };\n\n    editor.addCommand('mceAutocompleterReload', (_ui, value) => {\n      const fetchOptions = isObject(value) ? value.fetchOptions : {};\n      load(fetchOptions);\n    });\n    editor.addCommand('mceAutocompleterClose', cancelIfNecessary);\n    setupEditorInput(editor, {\n      cancelIfNecessary,\n      load\n    });\n  };\n\n  const createAndFireInputEvent = eventType => function (editor, inputType) {\n    let specifics = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const target = editor.getBody();\n    const overrides = {\n      bubbles: true,\n      composed: true,\n      data: null,\n      isComposing: false,\n      detail: 0,\n      view: null,\n      target,\n      currentTarget: target,\n      eventPhase: Event.AT_TARGET,\n      originalTarget: target,\n      explicitOriginalTarget: target,\n      isTrusted: false,\n      srcElement: target,\n      cancelable: false,\n      preventDefault: noop,\n      inputType\n    };\n    const input = clone$3(new InputEvent(eventType));\n    return editor.dispatch(eventType, { ...input,\n      ...overrides,\n      ...specifics\n    });\n  };\n\n  const fireFakeInputEvent = createAndFireInputEvent('input');\n  const fireFakeBeforeInputEvent = createAndFireInputEvent('beforeinput');\n\n  const executeKeydownOverride$3 = (editor, caret, evt) => {\n    const inputType = evt.keyCode === VK.BACKSPACE ? 'deleteContentBackward' : 'deleteContentForward';\n    executeWithDelayedAction([{\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete, editor)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$5, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$5, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$6, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$6, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$3, editor, caret, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$3, editor, caret, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$9, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$9, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$4, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$4, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$1, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$1, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$7, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$7, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$8, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$8, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$2, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$2, editor, true)\n    }], evt).each(applyAction => {\n      evt.preventDefault();\n      const beforeInput = fireFakeBeforeInputEvent(editor, inputType);\n\n      if (!beforeInput.isDefaultPrevented()) {\n        applyAction();\n        fireFakeInputEvent(editor, inputType);\n      }\n    });\n  };\n\n  const executeKeyupOverride = (editor, evt) => {\n    execute([{\n      keyCode: VK.BACKSPACE,\n      action: action(paddEmptyElement, editor)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(paddEmptyElement, editor)\n    }], evt);\n  };\n\n  const setup$i = (editor, caret) => {\n    editor.on('keydown', evt => {\n      if (evt.isDefaultPrevented() === false) {\n        executeKeydownOverride$3(editor, caret, evt);\n      }\n    });\n    editor.on('keyup', evt => {\n      if (evt.isDefaultPrevented() === false) {\n        executeKeyupOverride(editor, evt);\n      }\n    });\n  };\n\n  const firstNonWhiteSpaceNodeSibling = node => {\n    while (node) {\n      if (node.nodeType === 1 || node.nodeType === 3 && node.data && /[\\r\\n\\s]/.test(node.data)) {\n        return node;\n      }\n\n      node = node.nextSibling;\n    }\n  };\n\n  const moveToCaretPosition = (editor, root) => {\n    let node,\n        lastNode = root;\n    const dom = editor.dom;\n    const moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();\n\n    if (!root) {\n      return;\n    }\n\n    if (/^(LI|DT|DD)$/.test(root.nodeName)) {\n      const firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);\n\n      if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {\n        root.insertBefore(dom.doc.createTextNode(nbsp), root.firstChild);\n      }\n    }\n\n    const rng = dom.createRng();\n    root.normalize();\n\n    if (root.hasChildNodes()) {\n      const walker = new DomTreeWalker(root, root);\n\n      while (node = walker.current()) {\n        if (isText$8(node)) {\n          rng.setStart(node, 0);\n          rng.setEnd(node, 0);\n          break;\n        }\n\n        if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {\n          rng.setStartBefore(node);\n          rng.setEndBefore(node);\n          break;\n        }\n\n        lastNode = node;\n        node = walker.next();\n      }\n\n      if (!node) {\n        rng.setStart(lastNode, 0);\n        rng.setEnd(lastNode, 0);\n      }\n    } else {\n      if (isBr$5(root)) {\n        if (root.nextSibling && dom.isBlock(root.nextSibling)) {\n          rng.setStartBefore(root);\n          rng.setEndBefore(root);\n        } else {\n          rng.setStartAfter(root);\n          rng.setEndAfter(root);\n        }\n      } else {\n        rng.setStart(root, 0);\n        rng.setEnd(root, 0);\n      }\n    }\n\n    editor.selection.setRng(rng);\n    scrollRangeIntoView(editor, rng);\n  };\n\n  const getEditableRoot$1 = (dom, node) => {\n    const root = dom.getRoot();\n    let parent, editableRoot;\n    parent = node;\n\n    while (parent !== root && dom.getContentEditable(parent) !== 'false') {\n      if (dom.getContentEditable(parent) === 'true') {\n        editableRoot = parent;\n      }\n\n      parent = parent.parentNode;\n    }\n\n    return parent !== root ? editableRoot : root;\n  };\n\n  const getParentBlock$1 = editor => {\n    return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));\n  };\n\n  const getParentBlockName = editor => {\n    return getParentBlock$1(editor).fold(constant(''), parentBlock => {\n      return parentBlock.nodeName.toUpperCase();\n    });\n  };\n\n  const isListItemParentBlock = editor => {\n    return getParentBlock$1(editor).filter(elm => {\n      return isListItem(SugarElement.fromDom(elm));\n    }).isSome();\n  };\n\n  const hasFirstChild = (elm, name) => {\n    return elm.firstChild && elm.firstChild.nodeName === name;\n  };\n\n  const isFirstChild = elm => {\n    var _a;\n\n    return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;\n  };\n\n  const hasParent = (elm, parentName) => {\n    return elm && elm.parentNode && elm.parentNode.nodeName === parentName;\n  };\n\n  const isListBlock = elm => {\n    return elm && /^(OL|UL|LI)$/.test(elm.nodeName);\n  };\n\n  const isNestedList = elm => {\n    return isListBlock(elm) && isListBlock(elm.parentNode);\n  };\n\n  const getContainerBlock = containerBlock => {\n    const containerBlockParent = containerBlock.parentNode;\n\n    if (/^(LI|DT|DD)$/.test(containerBlockParent.nodeName)) {\n      return containerBlockParent;\n    }\n\n    return containerBlock;\n  };\n\n  const isFirstOrLastLi = (containerBlock, parentBlock, first) => {\n    let node = containerBlock[first ? 'firstChild' : 'lastChild'];\n\n    while (node) {\n      if (isElement$6(node)) {\n        break;\n      }\n\n      node = node[first ? 'nextSibling' : 'previousSibling'];\n    }\n\n    return node === parentBlock;\n  };\n\n  const insert$3 = (editor, createNewBlock, containerBlock, parentBlock, newBlockName) => {\n    const dom = editor.dom;\n    const rng = editor.selection.getRng();\n\n    if (containerBlock === editor.getBody()) {\n      return;\n    }\n\n    if (isNestedList(containerBlock)) {\n      newBlockName = 'LI';\n    }\n\n    let newBlock = createNewBlock(newBlockName);\n\n    if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {\n      if (hasParent(containerBlock, 'LI')) {\n        const containerBlockParent = getContainerBlock(containerBlock);\n        dom.insertAfter(newBlock, containerBlockParent);\n\n        if (isFirstChild(containerBlock)) {\n          dom.remove(containerBlockParent);\n        } else {\n          dom.remove(containerBlock);\n        }\n      } else {\n        dom.replace(newBlock, containerBlock);\n      }\n    } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {\n      if (hasParent(containerBlock, 'LI')) {\n        dom.insertAfter(newBlock, getContainerBlock(containerBlock));\n        newBlock.appendChild(dom.doc.createTextNode(' '));\n        newBlock.appendChild(containerBlock);\n      } else {\n        containerBlock.parentNode.insertBefore(newBlock, containerBlock);\n      }\n\n      dom.remove(parentBlock);\n    } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {\n      dom.insertAfter(newBlock, getContainerBlock(containerBlock));\n      dom.remove(parentBlock);\n    } else {\n      containerBlock = getContainerBlock(containerBlock);\n      const tmpRng = rng.cloneRange();\n      tmpRng.setStartAfter(parentBlock);\n      tmpRng.setEndAfter(containerBlock);\n      const fragment = tmpRng.extractContents();\n\n      if (newBlockName === 'LI' && hasFirstChild(fragment, 'LI')) {\n        newBlock = fragment.firstChild;\n        dom.insertAfter(fragment, containerBlock);\n      } else {\n        dom.insertAfter(fragment, containerBlock);\n        dom.insertAfter(newBlock, containerBlock);\n      }\n\n      dom.remove(parentBlock);\n    }\n\n    moveToCaretPosition(editor, newBlock);\n  };\n\n  const trimZwsp = fragment => {\n    each$g(descendants$1(SugarElement.fromDom(fragment), isText$9), text => {\n      const rawNode = text.dom;\n      rawNode.nodeValue = trim$1(rawNode.nodeValue);\n    });\n  };\n\n  const isEmptyAnchor = (dom, elm) => {\n    return elm && elm.nodeName === 'A' && dom.isEmpty(elm);\n  };\n\n  const isTableCell = node => {\n    return node && /^(TD|TH|CAPTION)$/.test(node.nodeName);\n  };\n\n  const emptyBlock = elm => {\n    elm.innerHTML = '<br data-mce-bogus=\"1\">';\n  };\n\n  const containerAndSiblingName = (container, nodeName) => {\n    return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;\n  };\n\n  const canSplitBlock = (dom, node) => {\n    return node && dom.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom.getContentEditable(node) !== 'true';\n  };\n\n  const trimInlineElementsOnLeftSideOfBlock = (dom, nonEmptyElementsMap, block) => {\n    let node = block;\n    const firstChilds = [];\n    let i;\n\n    if (!node) {\n      return;\n    }\n\n    while (node = node.firstChild) {\n      if (dom.isBlock(node)) {\n        return;\n      }\n\n      if (isElement$6(node) && !nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\n        firstChilds.push(node);\n      }\n    }\n\n    i = firstChilds.length;\n\n    while (i--) {\n      node = firstChilds[i];\n\n      if (!node.hasChildNodes() || node.firstChild === node.lastChild && node.firstChild.nodeValue === '') {\n        dom.remove(node);\n      } else {\n        if (isEmptyAnchor(dom, node)) {\n          dom.remove(node);\n        }\n      }\n    }\n  };\n\n  const normalizeZwspOffset = (start, container, offset) => {\n    if (isText$8(container) === false) {\n      return offset;\n    } else if (start) {\n      return offset === 1 && container.data.charAt(offset - 1) === ZWSP$1 ? 0 : offset;\n    } else {\n      return offset === container.data.length - 1 && container.data.charAt(offset) === ZWSP$1 ? container.data.length : offset;\n    }\n  };\n\n  const includeZwspInRange = rng => {\n    const newRng = rng.cloneRange();\n    newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));\n    newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));\n    return newRng;\n  };\n\n  const trimLeadingLineBreaks = node => {\n    do {\n      if (isText$8(node)) {\n        node.nodeValue = node.nodeValue.replace(/^[\\r\\n]+/, '');\n      }\n\n      node = node.firstChild;\n    } while (node);\n  };\n\n  const getEditableRoot = (dom, node) => {\n    const root = dom.getRoot();\n    let parent, editableRoot;\n    parent = node;\n\n    while (parent !== root && dom.getContentEditable(parent) !== 'false') {\n      if (dom.getContentEditable(parent) === 'true') {\n        editableRoot = parent;\n      }\n\n      parent = parent.parentNode;\n    }\n\n    return parent !== root ? editableRoot : root;\n  };\n\n  const applyAttributes = (editor, node, forcedRootBlockAttrs) => {\n    const dom = editor.dom;\n    Optional.from(forcedRootBlockAttrs.style).map(dom.parseStyle).each(attrStyles => {\n      const currentStyles = getAllRaw(SugarElement.fromDom(node));\n      const newStyles = { ...currentStyles,\n        ...attrStyles\n      };\n      dom.setStyles(node, newStyles);\n    });\n    const attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map(attrClasses => attrClasses.split(/\\s+/));\n    const currentClassesOpt = Optional.from(node.className).map(currentClasses => filter$6(currentClasses.split(/\\s+/), clazz => clazz !== ''));\n    lift2(attrClassesOpt, currentClassesOpt, (attrClasses, currentClasses) => {\n      const filteredClasses = filter$6(currentClasses, clazz => !contains$2(attrClasses, clazz));\n      const newClasses = [...attrClasses, ...filteredClasses];\n      dom.setAttrib(node, 'class', newClasses.join(' '));\n    });\n    const appliedAttrs = ['style', 'class'];\n    const remainingAttrs = filter$5(forcedRootBlockAttrs, (_, attrs) => !contains$2(appliedAttrs, attrs));\n    dom.setAttribs(node, remainingAttrs);\n  };\n\n  const setForcedBlockAttrs = (editor, node) => {\n    const forcedRootBlockName = getForcedRootBlock(editor);\n\n    if (forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {\n      const forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);\n      applyAttributes(editor, node, forcedRootBlockAttrs);\n    }\n  };\n\n  const wrapSelfAndSiblingsInDefaultBlock = (editor, newBlockName, rng, container, offset) => {\n    let newBlock, parentBlock, startNode, node, next, rootBlockName;\n    const dom = editor.dom,\n          editableRoot = getEditableRoot(dom, container);\n    parentBlock = dom.getParent(container, dom.isBlock);\n\n    if (!parentBlock || !canSplitBlock(dom, parentBlock)) {\n      parentBlock = parentBlock || editableRoot;\n\n      if (parentBlock === editor.getBody() || isTableCell(parentBlock)) {\n        rootBlockName = parentBlock.nodeName.toLowerCase();\n      } else {\n        rootBlockName = parentBlock.parentNode.nodeName.toLowerCase();\n      }\n\n      if (!parentBlock.hasChildNodes()) {\n        newBlock = dom.create(newBlockName);\n        setForcedBlockAttrs(editor, newBlock);\n        parentBlock.appendChild(newBlock);\n        rng.setStart(newBlock, 0);\n        rng.setEnd(newBlock, 0);\n        return newBlock;\n      }\n\n      node = container;\n\n      while (node.parentNode !== parentBlock) {\n        node = node.parentNode;\n      }\n\n      while (node && !dom.isBlock(node)) {\n        startNode = node;\n        node = node.previousSibling;\n      }\n\n      if (startNode && editor.schema.isValidChild(rootBlockName, newBlockName.toLowerCase())) {\n        newBlock = dom.create(newBlockName);\n        setForcedBlockAttrs(editor, newBlock);\n        startNode.parentNode.insertBefore(newBlock, startNode);\n        node = startNode;\n\n        while (node && !dom.isBlock(node)) {\n          next = node.nextSibling;\n          newBlock.appendChild(node);\n          node = next;\n        }\n\n        rng.setStart(container, offset);\n        rng.setEnd(container, offset);\n      }\n    }\n\n    return container;\n  };\n\n  const addBrToBlockIfNeeded = (dom, block) => {\n    block.normalize();\n    const lastChild = block.lastChild;\n\n    if (!lastChild || /^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true))) {\n      dom.add(block, 'br');\n    }\n  };\n\n  const insert$2 = (editor, evt) => {\n    let tmpRng, container, offset, parentBlock;\n    let newBlock, fragment, containerBlock, parentBlockName, isAfterLastNodeInContainer;\n    const dom = editor.dom;\n    const schema = editor.schema,\n          nonEmptyElementsMap = schema.getNonEmptyElements();\n    const rng = editor.selection.getRng();\n    const newBlockName = getForcedRootBlock(editor);\n\n    const createNewBlock = name => {\n      let node = container,\n          block,\n          clonedNode,\n          caretNode;\n      const textInlineElements = schema.getTextInlineElements();\n\n      if (name || parentBlockName === 'TABLE' || parentBlockName === 'HR') {\n        block = dom.create(name || newBlockName);\n      } else {\n        block = parentBlock.cloneNode(false);\n      }\n\n      caretNode = block;\n\n      if (shouldKeepStyles(editor) === false) {\n        dom.setAttrib(block, 'style', null);\n        dom.setAttrib(block, 'class', null);\n      } else {\n        do {\n          if (textInlineElements[node.nodeName]) {\n            if (isCaretNode(node) || isBookmarkNode$1(node)) {\n              continue;\n            }\n\n            clonedNode = node.cloneNode(false);\n            dom.setAttrib(clonedNode, 'id', '');\n\n            if (block.hasChildNodes()) {\n              clonedNode.appendChild(block.firstChild);\n              block.appendChild(clonedNode);\n            } else {\n              caretNode = clonedNode;\n              block.appendChild(clonedNode);\n            }\n          }\n        } while ((node = node.parentNode) && node !== editableRoot);\n      }\n\n      setForcedBlockAttrs(editor, block);\n      emptyBlock(caretNode);\n      return block;\n    };\n\n    const isCaretAtStartOrEndOfBlock = start => {\n      let node, name;\n      const normalizedOffset = normalizeZwspOffset(start, container, offset);\n\n      if (isText$8(container) && (start ? normalizedOffset > 0 : normalizedOffset < container.nodeValue.length)) {\n        return false;\n      }\n\n      if (container.parentNode === parentBlock && isAfterLastNodeInContainer && !start) {\n        return true;\n      }\n\n      if (start && isElement$6(container) && container === parentBlock.firstChild) {\n        return true;\n      }\n\n      if (containerAndSiblingName(container, 'TABLE') || containerAndSiblingName(container, 'HR')) {\n        return isAfterLastNodeInContainer && !start || !isAfterLastNodeInContainer && start;\n      }\n\n      const walker = new DomTreeWalker(container, parentBlock);\n\n      if (isText$8(container)) {\n        if (start && normalizedOffset === 0) {\n          walker.prev();\n        } else if (!start && normalizedOffset === container.nodeValue.length) {\n          walker.next();\n        }\n      }\n\n      while (node = walker.current()) {\n        if (isElement$6(node)) {\n          if (!node.getAttribute('data-mce-bogus')) {\n            name = node.nodeName.toLowerCase();\n\n            if (nonEmptyElementsMap[name] && name !== 'br') {\n              return false;\n            }\n          }\n        } else if (isText$8(node) && !isWhitespaceText(node.nodeValue)) {\n          return false;\n        }\n\n        if (start) {\n          walker.prev();\n        } else {\n          walker.next();\n        }\n      }\n\n      return true;\n    };\n\n    const insertNewBlockAfter = () => {\n      if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== 'HGROUP') {\n        newBlock = createNewBlock(newBlockName);\n      } else {\n        newBlock = createNewBlock();\n      }\n\n      if (shouldEndContainerOnEmptyBlock(editor) && canSplitBlock(dom, containerBlock) && dom.isEmpty(parentBlock)) {\n        newBlock = dom.split(containerBlock, parentBlock);\n      } else {\n        dom.insertAfter(newBlock, parentBlock);\n      }\n\n      moveToCaretPosition(editor, newBlock);\n    };\n\n    normalize$2(dom, rng).each(normRng => {\n      rng.setStart(normRng.startContainer, normRng.startOffset);\n      rng.setEnd(normRng.endContainer, normRng.endOffset);\n    });\n    container = rng.startContainer;\n    offset = rng.startOffset;\n    const shiftKey = !!(evt && evt.shiftKey);\n    const ctrlKey = !!(evt && evt.ctrlKey);\n\n    if (isElement$6(container) && container.hasChildNodes()) {\n      isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n      container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n\n      if (isAfterLastNodeInContainer && isText$8(container)) {\n        offset = container.nodeValue.length;\n      } else {\n        offset = 0;\n      }\n    }\n\n    const editableRoot = getEditableRoot(dom, container);\n\n    if (!editableRoot) {\n      return;\n    }\n\n    if (!shiftKey) {\n      container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);\n    }\n\n    parentBlock = dom.getParent(container, dom.isBlock);\n    containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n    parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';\n    const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\n\n    if (containerBlockName === 'LI' && !ctrlKey) {\n      parentBlock = containerBlock;\n      containerBlock = containerBlock.parentNode;\n      parentBlockName = containerBlockName;\n    }\n\n    if (/^(LI|DT|DD)$/.test(parentBlockName)) {\n      if (dom.isEmpty(parentBlock)) {\n        insert$3(editor, createNewBlock, containerBlock, parentBlock, newBlockName);\n        return;\n      }\n    }\n\n    if (parentBlock === editor.getBody()) {\n      return;\n    }\n\n    if (isCaretContainerBlock$1(parentBlock)) {\n      newBlock = showCaretContainerBlock(parentBlock);\n\n      if (dom.isEmpty(parentBlock)) {\n        emptyBlock(parentBlock);\n      }\n\n      setForcedBlockAttrs(editor, newBlock);\n      moveToCaretPosition(editor, newBlock);\n    } else if (isCaretAtStartOrEndOfBlock()) {\n      insertNewBlockAfter();\n    } else if (isCaretAtStartOrEndOfBlock(true)) {\n      newBlock = parentBlock.parentNode.insertBefore(createNewBlock(), parentBlock);\n      moveToCaretPosition(editor, containerAndSiblingName(parentBlock, 'HR') ? newBlock : parentBlock);\n    } else {\n      tmpRng = includeZwspInRange(rng).cloneRange();\n      tmpRng.setEndAfter(parentBlock);\n      fragment = tmpRng.extractContents();\n      trimZwsp(fragment);\n      trimLeadingLineBreaks(fragment);\n      newBlock = fragment.firstChild;\n      dom.insertAfter(fragment, parentBlock);\n      trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);\n      addBrToBlockIfNeeded(dom, parentBlock);\n\n      if (dom.isEmpty(parentBlock)) {\n        emptyBlock(parentBlock);\n      }\n\n      newBlock.normalize();\n\n      if (dom.isEmpty(newBlock)) {\n        dom.remove(newBlock);\n        insertNewBlockAfter();\n      } else {\n        setForcedBlockAttrs(editor, newBlock);\n        moveToCaretPosition(editor, newBlock);\n      }\n    }\n\n    dom.setAttrib(newBlock, 'id', '');\n    editor.dispatch('NewBlock', {\n      newBlock\n    });\n  };\n\n  const hasRightSideContent = (schema, container, parentBlock) => {\n    const walker = new DomTreeWalker(container, parentBlock);\n    let node;\n    const nonEmptyElementsMap = schema.getNonEmptyElements();\n\n    while (node = walker.next()) {\n      if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || node.length > 0) {\n        return true;\n      }\n    }\n  };\n\n  const moveSelectionToBr = (editor, brElm, extraBr) => {\n    const rng = editor.dom.createRng();\n\n    if (!extraBr) {\n      rng.setStartAfter(brElm);\n      rng.setEndAfter(brElm);\n    } else {\n      rng.setStartBefore(brElm);\n      rng.setEndBefore(brElm);\n    }\n\n    editor.selection.setRng(rng);\n    scrollRangeIntoView(editor, rng);\n  };\n\n  const insertBrAtCaret = (editor, evt) => {\n    const selection = editor.selection;\n    const dom = editor.dom;\n    const rng = selection.getRng();\n    let brElm;\n    let extraBr;\n    normalize$2(dom, rng).each(normRng => {\n      rng.setStart(normRng.startContainer, normRng.startOffset);\n      rng.setEnd(normRng.endContainer, normRng.endOffset);\n    });\n    let offset = rng.startOffset;\n    let container = rng.startContainer;\n\n    if (container.nodeType === 1 && container.hasChildNodes()) {\n      const isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n      container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n\n      if (isAfterLastNodeInContainer && container.nodeType === 3) {\n        offset = container.nodeValue.length;\n      } else {\n        offset = 0;\n      }\n    }\n\n    let parentBlock = dom.getParent(container, dom.isBlock);\n    const containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n    const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\n    const isControlKey = !!(evt && evt.ctrlKey);\n\n    if (containerBlockName === 'LI' && !isControlKey) {\n      parentBlock = containerBlock;\n    }\n\n    if (container && container.nodeType === 3 && offset >= container.nodeValue.length) {\n      if (!hasRightSideContent(editor.schema, container, parentBlock)) {\n        brElm = dom.create('br');\n        rng.insertNode(brElm);\n        rng.setStartAfter(brElm);\n        rng.setEndAfter(brElm);\n        extraBr = true;\n      }\n    }\n\n    brElm = dom.create('br');\n    rangeInsertNode(dom, rng, brElm);\n    moveSelectionToBr(editor, brElm, extraBr);\n    editor.undoManager.add();\n  };\n\n  const insertBrBefore = (editor, inline) => {\n    const br = SugarElement.fromTag('br');\n    before$3(SugarElement.fromDom(inline), br);\n    editor.undoManager.add();\n  };\n\n  const insertBrAfter = (editor, inline) => {\n    if (!hasBrAfter(editor.getBody(), inline)) {\n      after$4(SugarElement.fromDom(inline), SugarElement.fromTag('br'));\n    }\n\n    const br = SugarElement.fromTag('br');\n    after$4(SugarElement.fromDom(inline), br);\n    moveSelectionToBr(editor, br.dom, false);\n    editor.undoManager.add();\n  };\n\n  const isBeforeBr = pos => {\n    return isBr$5(pos.getNode());\n  };\n\n  const hasBrAfter = (rootNode, startNode) => {\n    if (isBeforeBr(CaretPosition.after(startNode))) {\n      return true;\n    } else {\n      return nextPosition(rootNode, CaretPosition.after(startNode)).map(pos => {\n        return isBr$5(pos.getNode());\n      }).getOr(false);\n    }\n  };\n\n  const isAnchorLink = elm => {\n    return elm && elm.nodeName === 'A' && 'href' in elm;\n  };\n\n  const isInsideAnchor = location => {\n    return location.fold(never, isAnchorLink, isAnchorLink, never);\n  };\n\n  const readInlineAnchorLocation = editor => {\n    const isInlineTarget$1 = curry(isInlineTarget, editor);\n    const position = CaretPosition.fromRangeStart(editor.selection.getRng());\n    return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);\n  };\n\n  const insertBrOutsideAnchor = (editor, location) => {\n    location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);\n  };\n\n  const insert$1 = (editor, evt) => {\n    const anchorLocation = readInlineAnchorLocation(editor);\n\n    if (anchorLocation.isSome()) {\n      anchorLocation.each(curry(insertBrOutsideAnchor, editor));\n    } else {\n      insertBrAtCaret(editor, evt);\n    }\n  };\n\n  const matchesSelector = (editor, selector) => {\n    return getParentBlock$1(editor).filter(parentBlock => {\n      return selector.length > 0 && is$1(SugarElement.fromDom(parentBlock), selector);\n    }).isSome();\n  };\n\n  const shouldInsertBr = editor => {\n    return matchesSelector(editor, getBrNewLineSelector(editor));\n  };\n\n  const shouldBlockNewLine$1 = editor => {\n    return matchesSelector(editor, getNoNewLineSelector(editor));\n  };\n\n  const newLineAction = Adt.generate([{\n    br: []\n  }, {\n    block: []\n  }, {\n    none: []\n  }]);\n\n  const shouldBlockNewLine = (editor, _shiftKey) => {\n    return shouldBlockNewLine$1(editor);\n  };\n\n  const inListBlock = requiredState => {\n    return (editor, _shiftKey) => {\n      return isListItemParentBlock(editor) === requiredState;\n    };\n  };\n\n  const inBlock = (blockName, requiredState) => (editor, _shiftKey) => {\n    const state = getParentBlockName(editor) === blockName.toUpperCase();\n    return state === requiredState;\n  };\n\n  const inPreBlock = requiredState => inBlock('pre', requiredState);\n\n  const inSummaryBlock = () => inBlock('summary', true);\n\n  const shouldPutBrInPre = requiredState => {\n    return (editor, _shiftKey) => {\n      return shouldPutBrInPre$1(editor) === requiredState;\n    };\n  };\n\n  const inBrContext = (editor, _shiftKey) => {\n    return shouldInsertBr(editor);\n  };\n\n  const hasShiftKey = (_editor, shiftKey) => {\n    return shiftKey;\n  };\n\n  const canInsertIntoEditableRoot = editor => {\n    const forcedRootBlock = getForcedRootBlock(editor);\n    const rootEditable = getEditableRoot$1(editor.dom, editor.selection.getStart());\n    return rootEditable && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock);\n  };\n\n  const match = (predicates, action) => {\n    return (editor, shiftKey) => {\n      const isMatch = foldl(predicates, (res, p) => {\n        return res && p(editor, shiftKey);\n      }, true);\n      return isMatch ? Optional.some(action) : Optional.none();\n    };\n  };\n\n  const getAction = (editor, evt) => {\n    return evaluateUntil([match([shouldBlockNewLine], newLineAction.none()), match([inSummaryBlock()], newLineAction.br()), match([inPreBlock(true), shouldPutBrInPre(false), hasShiftKey], newLineAction.br()), match([inPreBlock(true), shouldPutBrInPre(false)], newLineAction.block()), match([inPreBlock(true), shouldPutBrInPre(true), hasShiftKey], newLineAction.block()), match([inPreBlock(true), shouldPutBrInPre(true)], newLineAction.br()), match([inListBlock(true), hasShiftKey], newLineAction.br()), match([inListBlock(true)], newLineAction.block()), match([inBrContext], newLineAction.br()), match([hasShiftKey], newLineAction.br()), match([canInsertIntoEditableRoot], newLineAction.block())], [editor, !!(evt && evt.shiftKey)]).getOr(newLineAction.none());\n  };\n\n  const insert = (editor, evt) => {\n    getAction(editor, evt).fold(() => {\n      if (isNonNullable(evt)) {\n        const event = fireFakeBeforeInputEvent(editor, 'insertLineBreak');\n\n        if (event.isDefaultPrevented()) {\n          return;\n        }\n      }\n\n      insert$1(editor, evt);\n\n      if (isNonNullable(evt)) {\n        fireFakeInputEvent(editor, 'insertLineBreak');\n      }\n    }, () => {\n      if (isNonNullable(evt)) {\n        const event = fireFakeBeforeInputEvent(editor, 'insertParagraph');\n\n        if (event.isDefaultPrevented()) {\n          return;\n        }\n      }\n\n      insert$2(editor, evt);\n\n      if (isNonNullable(evt)) {\n        fireFakeInputEvent(editor, 'insertParagraph');\n      }\n    }, noop);\n  };\n\n  const handleEnterKeyEvent = (editor, event) => {\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n\n    event.preventDefault();\n    endTypingLevelIgnoreLocks(editor.undoManager);\n    editor.undoManager.transact(() => {\n      if (editor.selection.isCollapsed() === false) {\n        execDeleteCommand(editor);\n      }\n\n      insert(editor, event);\n    });\n  };\n\n  const setup$h = editor => {\n    editor.on('keydown', event => {\n      if (event.keyCode === VK.ENTER) {\n        handleEnterKeyEvent(editor, event);\n      }\n    });\n  };\n\n  const executeKeydownOverride$2 = (editor, caret, evt) => {\n    execute([{\n      keyCode: VK.END,\n      action: action(moveToLineEndPoint$1, editor, true)\n    }, {\n      keyCode: VK.HOME,\n      action: action(moveToLineEndPoint$1, editor, false)\n    }, {\n      keyCode: VK.END,\n      action: action(moveToLineEndPoint, editor, true)\n    }, {\n      keyCode: VK.HOME,\n      action: action(moveToLineEndPoint, editor, false)\n    }, {\n      keyCode: VK.END,\n      action: action(moveToLineEndPoint$2, editor, true, caret)\n    }, {\n      keyCode: VK.HOME,\n      action: action(moveToLineEndPoint$2, editor, false, caret)\n    }], evt).each(_ => {\n      evt.preventDefault();\n    });\n  };\n\n  const setup$g = (editor, caret) => {\n    editor.on('keydown', evt => {\n      if (evt.isDefaultPrevented() === false) {\n        executeKeydownOverride$2(editor, caret, evt);\n      }\n    });\n  };\n\n  const setup$f = editor => {\n    editor.on('input', e => {\n      if (e.isComposing === false) {\n        normalizeNbspsInEditor(editor);\n      }\n    });\n  };\n\n  const platform = detect$2();\n\n  const executeKeyupAction = (editor, caret, evt) => {\n    execute([{\n      keyCode: VK.PAGE_UP,\n      action: action(moveToLineEndPoint$2, editor, false, caret)\n    }, {\n      keyCode: VK.PAGE_DOWN,\n      action: action(moveToLineEndPoint$2, editor, true, caret)\n    }], evt);\n  };\n\n  const stopImmediatePropagation = e => e.stopImmediatePropagation();\n\n  const isPageUpDown = evt => evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;\n\n  const setNodeChangeBlocker = (blocked, editor, block) => {\n    if (block && !blocked.get()) {\n      editor.on('NodeChange', stopImmediatePropagation, true);\n    } else if (!block && blocked.get()) {\n      editor.off('NodeChange', stopImmediatePropagation);\n    }\n\n    blocked.set(block);\n  };\n\n  const setup$e = (editor, caret) => {\n    if (platform.os.isMacOS()) {\n      return;\n    }\n\n    const blocked = Cell(false);\n    editor.on('keydown', evt => {\n      if (isPageUpDown(evt)) {\n        setNodeChangeBlocker(blocked, editor, true);\n      }\n    });\n    editor.on('keyup', evt => {\n      if (evt.isDefaultPrevented() === false) {\n        executeKeyupAction(editor, caret, evt);\n      }\n\n      if (isPageUpDown(evt) && blocked.get()) {\n        setNodeChangeBlocker(blocked, editor, false);\n        editor.nodeChanged();\n      }\n    });\n  };\n\n  const insertTextAtPosition = (text, pos) => {\n    const container = pos.container();\n    const offset = pos.offset();\n\n    if (isText$8(container)) {\n      container.insertData(offset, text);\n      return Optional.some(CaretPosition(container, offset + text.length));\n    } else {\n      return getElementFromPosition(pos).map(elm => {\n        const textNode = SugarElement.fromText(text);\n\n        if (pos.isAtEnd()) {\n          after$4(elm, textNode);\n        } else {\n          before$3(elm, textNode);\n        }\n\n        return CaretPosition(textNode.dom, text.length);\n      });\n    }\n  };\n\n  const insertNbspAtPosition = curry(insertTextAtPosition, nbsp);\n  const insertSpaceAtPosition = curry(insertTextAtPosition, ' ');\n\n  const locationToCaretPosition = root => location => location.fold(element => prevPosition(root.dom, CaretPosition.before(element)), element => firstPositionIn(element), element => lastPositionIn(element), element => nextPosition(root.dom, CaretPosition.after(element)));\n\n  const insertInlineBoundarySpaceOrNbsp = (root, pos) => checkPos => needsToHaveNbsp(root, checkPos) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);\n\n  const setSelection = editor => pos => {\n    editor.selection.setRng(pos.toRange());\n    editor.nodeChanged();\n    return true;\n  };\n\n  const insertSpaceOrNbspAtSelection = editor => {\n    const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n    const root = SugarElement.fromDom(editor.getBody());\n\n    if (editor.selection.isCollapsed()) {\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return readLocation(isInlineTarget$1, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).map(checkPos => () => insertInlineBoundarySpaceOrNbsp(root, pos)(checkPos).each(setSelection(editor)));\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const executeKeydownOverride$1 = (editor, evt) => {\n    executeWithDelayedAction([{\n      keyCode: VK.SPACEBAR,\n      action: action(insertSpaceOrNbspAtSelection, editor)\n    }], evt).each(applyAction => {\n      evt.preventDefault();\n      const event = fireFakeBeforeInputEvent(editor, 'insertText', {\n        data: ' '\n      });\n\n      if (!event.isDefaultPrevented()) {\n        applyAction();\n        fireFakeInputEvent(editor, 'insertText', {\n          data: ' '\n        });\n      }\n    });\n  };\n\n  const setup$d = editor => {\n    editor.on('keydown', evt => {\n      if (evt.isDefaultPrevented() === false) {\n        executeKeydownOverride$1(editor, evt);\n      }\n    });\n  };\n\n  const tableTabNavigation = editor => {\n    if (hasTableTabNavigation(editor)) {\n      return [{\n        keyCode: VK.TAB,\n        action: action(handleTab, editor, true)\n      }, {\n        keyCode: VK.TAB,\n        shiftKey: true,\n        action: action(handleTab, editor, false)\n      }];\n    } else {\n      return [];\n    }\n  };\n\n  const executeKeydownOverride = (editor, evt) => {\n    execute([...tableTabNavigation(editor)], evt).each(_ => {\n      evt.preventDefault();\n    });\n  };\n\n  const setup$c = editor => {\n    editor.on('keydown', evt => {\n      if (evt.isDefaultPrevented() === false) {\n        executeKeydownOverride(editor, evt);\n      }\n    });\n  };\n\n  const setup$b = editor => {\n    editor.addShortcut('Meta+P', '', 'mcePrint');\n    setup$j(editor);\n\n    if (isRtc(editor)) {\n      return Cell(null);\n    } else {\n      const caret = setupSelectedState(editor);\n      setup$l(editor);\n      setup$k(editor, caret);\n      setup$i(editor, caret);\n      setup$h(editor);\n      setup$d(editor);\n      setup$f(editor);\n      setup$c(editor);\n      setup$g(editor, caret);\n      setup$e(editor, caret);\n      return caret;\n    }\n  };\n\n  class NodeChange {\n    constructor(editor) {\n      this.lastPath = [];\n      this.editor = editor;\n      let lastRng;\n      const self = this;\n\n      if (!('onselectionchange' in editor.getDoc())) {\n        editor.on('NodeChange click mouseup keyup focus', e => {\n          const nativeRng = editor.selection.getRng();\n          const fakeRng = {\n            startContainer: nativeRng.startContainer,\n            startOffset: nativeRng.startOffset,\n            endContainer: nativeRng.endContainer,\n            endOffset: nativeRng.endOffset\n          };\n\n          if (e.type === 'nodechange' || !isEq$4(fakeRng, lastRng)) {\n            editor.dispatch('SelectionChange');\n          }\n\n          lastRng = fakeRng;\n        });\n      }\n\n      editor.on('contextmenu', () => {\n        editor.dispatch('SelectionChange');\n      });\n      editor.on('SelectionChange', () => {\n        const startElm = editor.selection.getStart(true);\n\n        if (!startElm) {\n          return;\n        }\n\n        if (hasAnyRanges(editor) && !self.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {\n          editor.nodeChanged({\n            selectionChange: true\n          });\n        }\n      });\n      editor.on('mouseup', e => {\n        if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {\n          if (editor.selection.getNode().nodeName === 'IMG') {\n            Delay.setEditorTimeout(editor, () => {\n              editor.nodeChanged();\n            });\n          } else {\n            editor.nodeChanged();\n          }\n        }\n      });\n    }\n\n    nodeChanged(args) {\n      const selection = this.editor.selection;\n      let node, parents, root;\n\n      if (this.editor.initialized && selection && !shouldDisableNodeChange(this.editor) && !this.editor.mode.isReadOnly()) {\n        root = this.editor.getBody();\n        node = selection.getStart(true) || root;\n\n        if (node.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(node, root)) {\n          node = root;\n        }\n\n        parents = [];\n        this.editor.dom.getParent(node, node => {\n          if (node === root) {\n            return true;\n          }\n\n          parents.push(node);\n        });\n        args = args || {};\n        args.element = node;\n        args.parents = parents;\n        this.editor.dispatch('NodeChange', args);\n      }\n    }\n\n    isSameElementPath(startElm) {\n      let i;\n      const editor = this.editor;\n      const currentPath = reverse(editor.dom.getParents(startElm, always, editor.getBody()));\n\n      if (currentPath.length === this.lastPath.length) {\n        for (i = currentPath.length; i >= 0; i--) {\n          if (currentPath[i] !== this.lastPath[i]) {\n            break;\n          }\n        }\n\n        if (i === -1) {\n          this.lastPath = currentPath;\n          return true;\n        }\n      }\n\n      this.lastPath = currentPath;\n      return false;\n    }\n\n  }\n\n  const internalMimeType = 'x-tinymce/html';\n  const internalHtmlMime = constant(internalMimeType);\n  const internalMark = '<!-- ' + internalMimeType + ' -->';\n\n  const mark = html => internalMark + html;\n\n  const unmark = html => html.replace(internalMark, '');\n\n  const isMarked = html => html.indexOf(internalMark) !== -1;\n\n  const isPlainText = text => {\n    return !/<(?:\\/?(?!(?:div|p|br|span)>)\\w+|(?:(?!(?:span style=\"white-space:\\s?pre;?\">)|br\\s?\\/>))\\w+\\s[^>]+)>/i.test(text);\n  };\n\n  const openContainer = (rootTag, rootAttrs) => {\n    let tag = '<' + rootTag;\n    const attrs = mapToArray(rootAttrs, (value, key) => key + '=\"' + Entities.encodeAllRaw(value) + '\"');\n\n    if (attrs.length) {\n      tag += ' ' + attrs.join(' ');\n    }\n\n    return tag + '>';\n  };\n\n  const toBlockElements = (text, rootTag, rootAttrs) => {\n    const blocks = text.split(/\\n\\n/);\n    const tagOpen = openContainer(rootTag, rootAttrs);\n    const tagClose = '</' + rootTag + '>';\n    const paragraphs = map$3(blocks, p => {\n      return p.split(/\\n/).join('<br />');\n    });\n\n    const stitch = p => {\n      return tagOpen + p + tagClose;\n    };\n\n    return paragraphs.length === 1 ? paragraphs[0] : map$3(paragraphs, stitch).join('');\n  };\n\n  const pasteBinDefaultContent = '%MCEPASTEBIN%';\n\n  const create$6 = (editor, lastRngCell) => {\n    const {\n      dom,\n      selection\n    } = editor;\n    const body = editor.getBody();\n    lastRngCell.set(selection.getRng());\n    const pasteBinElm = dom.add(editor.getBody(), 'div', {\n      'id': 'mcepastebin',\n      'class': 'mce-pastebin',\n      'contentEditable': true,\n      'data-mce-bogus': 'all',\n      'style': 'position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0'\n    }, pasteBinDefaultContent);\n\n    if (Env.browser.isFirefox()) {\n      dom.setStyle(pasteBinElm, 'left', dom.getStyle(body, 'direction', true) === 'rtl' ? 65535 : -65535);\n    }\n\n    dom.bind(pasteBinElm, 'beforedeactivate focusin focusout', e => {\n      e.stopPropagation();\n    });\n    pasteBinElm.focus();\n    selection.select(pasteBinElm, true);\n  };\n\n  const remove = (editor, lastRngCell) => {\n    const dom = editor.dom;\n\n    if (getEl(editor)) {\n      let pasteBinClone;\n      const lastRng = lastRngCell.get();\n\n      while (pasteBinClone = getEl(editor)) {\n        dom.remove(pasteBinClone);\n        dom.unbind(pasteBinClone);\n      }\n\n      if (lastRng) {\n        editor.selection.setRng(lastRng);\n      }\n    }\n\n    lastRngCell.set(null);\n  };\n\n  const getEl = editor => editor.dom.get('mcepastebin');\n\n  const isPasteBin = elm => elm && elm.id === 'mcepastebin';\n\n  const getHtml = editor => {\n    const dom = editor.dom;\n\n    const copyAndRemove = (toElm, fromElm) => {\n      toElm.appendChild(fromElm);\n      dom.remove(fromElm, true);\n    };\n\n    const [pasteBinElm, ...pasteBinClones] = filter$6(editor.getBody().childNodes, isPasteBin);\n    each$g(pasteBinClones, pasteBinClone => {\n      copyAndRemove(pasteBinElm, pasteBinClone);\n    });\n    const dirtyWrappers = dom.select('div[id=mcepastebin]', pasteBinElm);\n\n    for (let i = dirtyWrappers.length - 1; i >= 0; i--) {\n      const cleanWrapper = dom.create('div');\n      pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i]);\n      copyAndRemove(cleanWrapper, dirtyWrappers[i]);\n    }\n\n    return pasteBinElm ? pasteBinElm.innerHTML : '';\n  };\n\n  const isDefaultPasteBinContent = content => content === pasteBinDefaultContent;\n\n  const PasteBin = editor => {\n    const lastRng = Cell(null);\n    return {\n      create: () => create$6(editor, lastRng),\n      remove: () => remove(editor, lastRng),\n      getEl: () => getEl(editor),\n      getHtml: () => getHtml(editor),\n      getLastRng: lastRng.get\n    };\n  };\n\n  const filter = (content, items) => {\n    Tools.each(items, v => {\n      if (is$4(v, RegExp)) {\n        content = content.replace(v, '');\n      } else {\n        content = content.replace(v[0], v[1]);\n      }\n    });\n    return content;\n  };\n\n  const innerText = html => {\n    const schema = Schema();\n    const domParser = DomParser({}, schema);\n    let text = '';\n    const voidElements = schema.getVoidElements();\n    const ignoreElements = Tools.makeMap('script noscript style textarea video audio iframe object', ' ');\n    const blockElements = schema.getBlockElements();\n\n    const walk = node => {\n      const name = node.name,\n            currentNode = node;\n\n      if (name === 'br') {\n        text += '\\n';\n        return;\n      }\n\n      if (name === 'wbr') {\n        return;\n      }\n\n      if (voidElements[name]) {\n        text += ' ';\n      }\n\n      if (ignoreElements[name]) {\n        text += ' ';\n        return;\n      }\n\n      if (node.type === 3) {\n        text += node.value;\n      }\n\n      if (!(node.name in schema.getVoidElements())) {\n        if (node = node.firstChild) {\n          do {\n            walk(node);\n          } while (node = node.next);\n        }\n      }\n\n      if (blockElements[name] && currentNode.next) {\n        text += '\\n';\n\n        if (name === 'p') {\n          text += '\\n';\n        }\n      }\n    };\n\n    html = filter(html, [/<!\\[[^\\]]+\\]>/g]);\n    walk(domParser.parse(html));\n    return text;\n  };\n\n  const trimHtml = html => {\n    const trimSpaces = (all, s1, s2) => {\n      if (!s1 && !s2) {\n        return ' ';\n      }\n\n      return nbsp;\n    };\n\n    html = filter(html, [/^[\\s\\S]*<body[^>]*>\\s*|\\s*<\\/body[^>]*>[\\s\\S]*$/ig, /<!--StartFragment-->|<!--EndFragment-->/g, [/( ?)<span class=\"Apple-converted-space\">\\u00a0<\\/span>( ?)/g, trimSpaces], /<br class=\"Apple-interchange-newline\">/g, /<br>$/i]);\n    return html;\n  };\n\n  const createIdGenerator = prefix => {\n    let count = 0;\n    return () => {\n      return prefix + count++;\n    };\n  };\n\n  const getImageMimeType = ext => {\n    const lowerExt = ext.toLowerCase();\n    const mimeOverrides = {\n      jpg: 'jpeg',\n      jpe: 'jpeg',\n      jfi: 'jpeg',\n      jif: 'jpeg',\n      jfif: 'jpeg',\n      pjpeg: 'jpeg',\n      pjp: 'jpeg',\n      svg: 'svg+xml'\n    };\n    return Tools.hasOwn(mimeOverrides, lowerExt) ? 'image/' + mimeOverrides[lowerExt] : 'image/' + lowerExt;\n  };\n\n  const preProcess = (editor, html) => {\n    const parser = DomParser({}, editor.schema);\n    parser.addNodeFilter('meta', nodes => {\n      Tools.each(nodes, node => {\n        node.remove();\n      });\n    });\n    const fragment = parser.parse(html, {\n      forced_root_block: false,\n      isRootContent: true\n    });\n    return HtmlSerializer({\n      validate: true\n    }, editor.schema).serialize(fragment);\n  };\n\n  const processResult = (content, cancelled) => ({\n    content,\n    cancelled\n  });\n\n  const postProcessFilter = (editor, html, internal) => {\n    const tempBody = editor.dom.create('div', {\n      style: 'display:none'\n    }, html);\n    const postProcessArgs = firePastePostProcess(editor, tempBody, internal);\n    return processResult(postProcessArgs.node.innerHTML, postProcessArgs.isDefaultPrevented());\n  };\n\n  const filterContent = (editor, content, internal) => {\n    const preProcessArgs = firePastePreProcess(editor, content, internal);\n    const filteredContent = preProcess(editor, preProcessArgs.content);\n\n    if (editor.hasEventListeners('PastePostProcess') && !preProcessArgs.isDefaultPrevented()) {\n      return postProcessFilter(editor, filteredContent, internal);\n    } else {\n      return processResult(filteredContent, preProcessArgs.isDefaultPrevented());\n    }\n  };\n\n  const process = (editor, html, internal) => {\n    return filterContent(editor, html, internal);\n  };\n\n  const pasteHtml$1 = (editor, html) => {\n    editor.insertContent(html, {\n      merge: shouldPasteMergeFormats(editor),\n      paste: true\n    });\n    return true;\n  };\n\n  const isAbsoluteUrl = url => /^https?:\\/\\/[\\w\\?\\-\\/+=.&%@~#]+$/i.test(url);\n\n  const isImageUrl = (editor, url) => {\n    return isAbsoluteUrl(url) && exists(getAllowedImageFileTypes(editor), type => endsWith(url.toLowerCase(), `.${type.toLowerCase()}`));\n  };\n\n  const createImage = (editor, url, pasteHtmlFn) => {\n    editor.undoManager.extra(() => {\n      pasteHtmlFn(editor, url);\n    }, () => {\n      editor.insertContent('<img src=\"' + url + '\">');\n    });\n    return true;\n  };\n\n  const createLink = (editor, url, pasteHtmlFn) => {\n    editor.undoManager.extra(() => {\n      pasteHtmlFn(editor, url);\n    }, () => {\n      editor.execCommand('mceInsertLink', false, url);\n    });\n    return true;\n  };\n\n  const linkSelection = (editor, html, pasteHtmlFn) => !editor.selection.isCollapsed() && isAbsoluteUrl(html) ? createLink(editor, html, pasteHtmlFn) : false;\n\n  const insertImage = (editor, html, pasteHtmlFn) => isImageUrl(editor, html) ? createImage(editor, html, pasteHtmlFn) : false;\n\n  const smartInsertContent = (editor, html) => {\n    Tools.each([linkSelection, insertImage, pasteHtml$1], action => {\n      return action(editor, html, pasteHtml$1) !== true;\n    });\n  };\n\n  const insertContent = (editor, html, pasteAsText) => {\n    if (pasteAsText || !isSmartPasteEnabled(editor)) {\n      pasteHtml$1(editor, html);\n    } else {\n      smartInsertContent(editor, html);\n    }\n  };\n\n  const uniqueId = createIdGenerator('mceclip');\n\n  const doPaste = (editor, content, internal, pasteAsText) => {\n    const args = process(editor, content, internal);\n\n    if (args.cancelled === false) {\n      insertContent(editor, args.content, pasteAsText);\n    }\n  };\n\n  const pasteHtml = (editor, html, internalFlag) => {\n    const internal = internalFlag ? internalFlag : isMarked(html);\n    doPaste(editor, unmark(html), internal, false);\n  };\n\n  const pasteText = (editor, text) => {\n    const encodedText = editor.dom.encode(text).replace(/\\r\\n/g, '\\n');\n    const normalizedText = normalize$4(encodedText, getPasteTabSpaces(editor));\n    const html = toBlockElements(normalizedText, getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));\n    doPaste(editor, html, false, true);\n  };\n\n  const getDataTransferItems = dataTransfer => {\n    const items = {};\n\n    if (dataTransfer && dataTransfer.types) {\n      for (let i = 0; i < dataTransfer.types.length; i++) {\n        const contentType = dataTransfer.types[i];\n\n        try {\n          items[contentType] = dataTransfer.getData(contentType);\n        } catch (ex) {\n          items[contentType] = '';\n        }\n      }\n    }\n\n    return items;\n  };\n\n  const hasContentType = (clipboardContent, mimeType) => mimeType in clipboardContent && clipboardContent[mimeType].length > 0;\n\n  const hasHtmlOrText = content => hasContentType(content, 'text/html') || hasContentType(content, 'text/plain');\n\n  const extractFilename = (editor, str) => {\n    const m = str.match(/([\\s\\S]+?)(?:\\.[a-z0-9.]+)$/i);\n    return isNonNullable(m) ? editor.dom.encode(m[1]) : null;\n  };\n\n  const createBlobInfo = (editor, blobCache, file, base64) => {\n    const id = uniqueId();\n    const useFileName = shouldReuseFileName(editor) && isNonNullable(file.name);\n    const name = useFileName ? extractFilename(editor, file.name) : id;\n    const filename = useFileName ? file.name : undefined;\n    const blobInfo = blobCache.create(id, file, base64, name, filename);\n    blobCache.add(blobInfo);\n    return blobInfo;\n  };\n\n  const pasteImage = (editor, imageItem) => {\n    const {\n      data: base64,\n      type\n    } = parseDataUri$1(imageItem.uri);\n    const file = imageItem.file;\n    const blobCache = editor.editorUpload.blobCache;\n    const existingBlobInfo = blobCache.getByData(base64, type);\n    const blobInfo = existingBlobInfo !== null && existingBlobInfo !== void 0 ? existingBlobInfo : createBlobInfo(editor, blobCache, file, base64);\n    pasteHtml(editor, `<img src=\"${blobInfo.blobUri()}\">`, false);\n  };\n\n  const isClipboardEvent = event => event.type === 'paste';\n\n  const readFilesAsDataUris = items => Promise.all(map$3(items, file => {\n    return blobToDataUri(file).then(uri => ({\n      file,\n      uri\n    }));\n  }));\n\n  const isImage = editor => {\n    const allowedExtensions = getAllowedImageFileTypes(editor);\n    return file => startsWith(file.type, 'image/') && exists(allowedExtensions, extension => {\n      return getImageMimeType(extension) === file.type;\n    });\n  };\n\n  const getImagesFromDataTransfer = (editor, dataTransfer) => {\n    const items = dataTransfer.items ? bind$3(from(dataTransfer.items), item => {\n      return item.kind === 'file' ? [item.getAsFile()] : [];\n    }) : [];\n    const files = dataTransfer.files ? from(dataTransfer.files) : [];\n    return filter$6(items.length > 0 ? items : files, isImage(editor));\n  };\n\n  const pasteImageData = (editor, e, rng) => {\n    const dataTransfer = isClipboardEvent(e) ? e.clipboardData : e.dataTransfer;\n\n    if (shouldPasteDataImages(editor) && dataTransfer) {\n      const images = getImagesFromDataTransfer(editor, dataTransfer);\n\n      if (images.length > 0) {\n        e.preventDefault();\n        readFilesAsDataUris(images).then(fileResults => {\n          if (rng) {\n            editor.selection.setRng(rng);\n          }\n\n          each$g(fileResults, result => {\n            pasteImage(editor, result);\n          });\n        });\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  const isBrokenAndroidClipboardEvent = e => {\n    var _a, _b;\n\n    return Env.os.isAndroid() && ((_b = (_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.length) === 0;\n  };\n\n  const isKeyboardPasteEvent = e => VK.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45;\n\n  const insertClipboardContent = (editor, clipboardContent, html, plainTextMode) => {\n    let content = trimHtml(html);\n    const isInternal = hasContentType(clipboardContent, internalHtmlMime()) || isMarked(html);\n    const isPlainTextHtml = !isInternal && isPlainText(content);\n    const isAbsoluteUrl$1 = isAbsoluteUrl(content);\n\n    if (isDefaultPasteBinContent(content) || !content.length || isPlainTextHtml && !isAbsoluteUrl$1) {\n      plainTextMode = true;\n    }\n\n    if (plainTextMode || isAbsoluteUrl$1) {\n      if (hasContentType(clipboardContent, 'text/plain') && isPlainTextHtml) {\n        content = clipboardContent['text/plain'];\n      } else {\n        content = innerText(content);\n      }\n    }\n\n    if (isDefaultPasteBinContent(content)) {\n      return;\n    }\n\n    if (plainTextMode) {\n      pasteText(editor, content);\n    } else {\n      pasteHtml(editor, content, isInternal);\n    }\n  };\n\n  const registerEventHandlers = (editor, pasteBin, pasteFormat) => {\n    let keyboardPastePlainTextState;\n\n    const getLastRng = () => pasteBin.getLastRng() || editor.selection.getRng();\n\n    editor.on('keydown', e => {\n      if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {\n        keyboardPastePlainTextState = e.shiftKey && e.keyCode === 86;\n      }\n    });\n    editor.on('paste', e => {\n      if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {\n        return;\n      }\n\n      const plainTextMode = pasteFormat.get() === 'text' || keyboardPastePlainTextState;\n      keyboardPastePlainTextState = false;\n      const clipboardContent = getDataTransferItems(e.clipboardData);\n\n      if (!hasHtmlOrText(clipboardContent) && pasteImageData(editor, e, getLastRng())) {\n        return;\n      }\n\n      if (hasContentType(clipboardContent, 'text/html')) {\n        e.preventDefault();\n        insertClipboardContent(editor, clipboardContent, clipboardContent['text/html'], plainTextMode);\n      } else {\n        pasteBin.create();\n        Delay.setEditorTimeout(editor, () => {\n          const html = pasteBin.getHtml();\n          pasteBin.remove();\n          insertClipboardContent(editor, clipboardContent, html, plainTextMode);\n        }, 0);\n      }\n    });\n  };\n\n  const registerDataImageFilter = editor => {\n    const isWebKitFakeUrl = src => startsWith(src, 'webkit-fake-url');\n\n    const isDataUri = src => startsWith(src, 'data:');\n\n    const isPasteInsert = args => {\n      var _a;\n\n      return ((_a = args.data) === null || _a === void 0 ? void 0 : _a.paste) === true;\n    };\n\n    editor.parser.addNodeFilter('img', (nodes, name, args) => {\n      if (!shouldPasteDataImages(editor) && isPasteInsert(args)) {\n        for (const node of nodes) {\n          const src = node.attr('src');\n\n          if (isString(src) && !node.attr('data-mce-object') && src !== Env.transparentSrc) {\n            if (isWebKitFakeUrl(src)) {\n              node.remove();\n            } else if (!shouldAllowHtmlDataUrls(editor) && isDataUri(src)) {\n              node.remove();\n            }\n          }\n        }\n      }\n    });\n  };\n\n  const registerEventsAndFilters = (editor, pasteBin, pasteFormat) => {\n    registerEventHandlers(editor, pasteBin, pasteFormat);\n    registerDataImageFilter(editor);\n  };\n\n  const togglePlainTextPaste = (editor, pasteFormat) => {\n    if (pasteFormat.get() === 'text') {\n      pasteFormat.set('html');\n      firePastePlainTextToggle(editor, false);\n    } else {\n      pasteFormat.set('text');\n      firePastePlainTextToggle(editor, true);\n    }\n\n    editor.focus();\n  };\n\n  const register$1 = (editor, pasteFormat) => {\n    editor.addCommand('mceTogglePlainTextPaste', () => {\n      togglePlainTextPaste(editor, pasteFormat);\n    });\n    editor.addCommand('mceInsertClipboardContent', (ui, value) => {\n      if (value.html) {\n        pasteHtml(editor, value.html, value.internal);\n      }\n\n      if (value.text) {\n        pasteText(editor, value.text);\n      }\n    });\n  };\n\n  const setHtml5Clipboard = (clipboardData, html, text) => {\n    try {\n      clipboardData.clearData();\n      clipboardData.setData('text/html', html);\n      clipboardData.setData('text/plain', text);\n      clipboardData.setData(internalHtmlMime(), html);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  const setClipboardData = (evt, data, fallback, done) => {\n    if (setHtml5Clipboard(evt.clipboardData, data.html, data.text)) {\n      evt.preventDefault();\n      done();\n    } else {\n      fallback(data.html, done);\n    }\n  };\n\n  const fallback = editor => (html, done) => {\n    const {\n      dom,\n      selection\n    } = editor;\n    const outer = dom.create('div', {\n      'contenteditable': 'false',\n      'data-mce-bogus': 'all'\n    });\n    const inner = dom.create('div', {\n      contenteditable: 'true'\n    }, html);\n    dom.setStyles(outer, {\n      position: 'fixed',\n      top: '0',\n      left: '-3000px',\n      width: '1000px',\n      overflow: 'hidden'\n    });\n    outer.appendChild(inner);\n    dom.add(editor.getBody(), outer);\n    const range = selection.getRng();\n    inner.focus();\n    const offscreenRange = dom.createRng();\n    offscreenRange.selectNodeContents(inner);\n    selection.setRng(offscreenRange);\n    Delay.setEditorTimeout(editor, () => {\n      selection.setRng(range);\n      dom.remove(outer);\n      done();\n    }, 0);\n  };\n\n  const getData = editor => ({\n    html: mark(editor.selection.getContent({\n      contextual: true\n    })),\n    text: editor.selection.getContent({\n      format: 'text'\n    })\n  });\n\n  const isTableSelection = editor => !!editor.dom.getParent(editor.selection.getStart(), 'td[data-mce-selected],th[data-mce-selected]', editor.getBody());\n\n  const hasSelectedContent = editor => !editor.selection.isCollapsed() || isTableSelection(editor);\n\n  const cut = editor => evt => {\n    if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {\n      setClipboardData(evt, getData(editor), fallback(editor), () => {\n        if (Env.browser.isChromium() || Env.browser.isFirefox()) {\n          const rng = editor.selection.getRng();\n          Delay.setEditorTimeout(editor, () => {\n            editor.selection.setRng(rng);\n            editor.execCommand('Delete');\n          }, 0);\n        } else {\n          editor.execCommand('Delete');\n        }\n      });\n    }\n  };\n\n  const copy = editor => evt => {\n    if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {\n      setClipboardData(evt, getData(editor), fallback(editor), noop);\n    }\n  };\n\n  const register = editor => {\n    editor.on('cut', cut(editor));\n    editor.on('copy', copy(editor));\n  };\n\n  const getCaretRangeFromEvent = (editor, e) => {\n    var _a, _b;\n\n    return RangeUtils.getCaretRangeFromPoint((_a = e.clientX) !== null && _a !== void 0 ? _a : 0, (_b = e.clientY) !== null && _b !== void 0 ? _b : 0, editor.getDoc());\n  };\n\n  const isPlainTextFileUrl = content => {\n    const plainTextContent = content['text/plain'];\n    return plainTextContent ? plainTextContent.indexOf('file://') === 0 : false;\n  };\n\n  const setFocusedRange = (editor, rng) => {\n    editor.focus();\n\n    if (rng) {\n      editor.selection.setRng(rng);\n    }\n  };\n\n  const hasImage = dataTransfer => exists(dataTransfer.files, file => /^image\\//.test(file.type));\n\n  const setup$a = (editor, draggingInternallyState) => {\n    if (shouldPasteBlockDrop(editor)) {\n      editor.on('dragend dragover draggesture dragdrop drop drag', e => {\n        e.preventDefault();\n        e.stopPropagation();\n      });\n    }\n\n    if (!shouldPasteDataImages(editor)) {\n      editor.on('drop', e => {\n        const dataTransfer = e.dataTransfer;\n\n        if (dataTransfer && hasImage(dataTransfer)) {\n          e.preventDefault();\n        }\n      });\n    }\n\n    editor.on('drop', e => {\n      if (e.isDefaultPrevented() || draggingInternallyState.get()) {\n        return;\n      }\n\n      const rng = getCaretRangeFromEvent(editor, e);\n\n      if (isNullable(rng)) {\n        return;\n      }\n\n      const dropContent = getDataTransferItems(e.dataTransfer);\n      const internal = hasContentType(dropContent, internalHtmlMime());\n\n      if ((!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && pasteImageData(editor, e, rng)) {\n        return;\n      }\n\n      const internalContent = dropContent[internalHtmlMime()];\n      const content = internalContent || dropContent['text/html'] || dropContent['text/plain'];\n\n      if (content) {\n        e.preventDefault();\n        Delay.setEditorTimeout(editor, () => {\n          editor.undoManager.transact(() => {\n            if (internalContent) {\n              editor.execCommand('Delete');\n            }\n\n            setFocusedRange(editor, rng);\n            const trimmedContent = trimHtml(content);\n\n            if (dropContent['text/html']) {\n              pasteHtml(editor, trimmedContent, internal);\n            } else {\n              pasteText(editor, trimmedContent);\n            }\n          });\n        });\n      }\n    });\n    editor.on('dragstart', _e => {\n      draggingInternallyState.set(true);\n    });\n    editor.on('dragover dragend', e => {\n      if (shouldPasteDataImages(editor) && draggingInternallyState.get() === false) {\n        e.preventDefault();\n        setFocusedRange(editor, getCaretRangeFromEvent(editor, e));\n      }\n\n      if (e.type === 'dragend') {\n        draggingInternallyState.set(false);\n      }\n    });\n  };\n\n  const setup$9 = editor => {\n    const processEvent = f => e => {\n      f(editor, e);\n    };\n\n    const preProcess = getPastePreProcess(editor);\n\n    if (isFunction(preProcess)) {\n      editor.on('PastePreProcess', processEvent(preProcess));\n    }\n\n    const postProcess = getPastePostProcess(editor);\n\n    if (isFunction(postProcess)) {\n      editor.on('PastePostProcess', processEvent(postProcess));\n    }\n  };\n\n  const addPreProcessFilter = (editor, filterFunc) => {\n    editor.on('PastePreProcess', e => {\n      e.content = filterFunc(editor, e.content, e.internal);\n    });\n  };\n\n  const rgbRegExp = /rgb\\s*\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)/gi;\n\n  const rgbToHex = value => Tools.trim(value).replace(rgbRegExp, rgbaToHexString).toLowerCase();\n\n  const removeWebKitStyles = (editor, content, internal) => {\n    const webKitStylesOption = getPasteWebkitStyles(editor);\n\n    if (internal || webKitStylesOption === 'all' || !shouldPasteRemoveWebKitStyles(editor)) {\n      return content;\n    }\n\n    const webKitStyles = webKitStylesOption ? webKitStylesOption.split(/[, ]/) : [];\n\n    if (webKitStyles && webKitStylesOption !== 'none') {\n      const dom = editor.dom,\n            node = editor.selection.getNode();\n      content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, (all, before, value, after) => {\n        const inputStyles = dom.parseStyle(dom.decode(value));\n        const outputStyles = {};\n\n        for (let i = 0; i < webKitStyles.length; i++) {\n          const inputValue = inputStyles[webKitStyles[i]];\n          let compareInput = inputValue;\n          let currentValue = dom.getStyle(node, webKitStyles[i], true);\n\n          if (/color/.test(webKitStyles[i])) {\n            compareInput = rgbToHex(compareInput);\n            currentValue = rgbToHex(currentValue);\n          }\n\n          if (currentValue !== compareInput) {\n            outputStyles[webKitStyles[i]] = inputValue;\n          }\n        }\n\n        const outputStyle = dom.serializeStyle(outputStyles, 'span');\n\n        if (outputStyle) {\n          return before + ' style=\"' + outputStyle + '\"' + after;\n        }\n\n        return before + after;\n      });\n    } else {\n      content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, '$1$3');\n    }\n\n    content = content.replace(/(<[^>]+) data-mce-style=\"([^\"]+)\"([^>]*>)/gi, (all, before, value, after) => {\n      return before + ' style=\"' + value + '\"' + after;\n    });\n    return content;\n  };\n\n  const setup$8 = editor => {\n    if (Env.browser.isChromium() || Env.browser.isSafari()) {\n      addPreProcessFilter(editor, removeWebKitStyles);\n    }\n  };\n\n  const setup$7 = editor => {\n    const draggingInternallyState = Cell(false);\n    const pasteFormat = Cell(isPasteAsTextEnabled(editor) ? 'text' : 'html');\n    const pasteBin = PasteBin(editor);\n    setup$8(editor);\n    register$1(editor, pasteFormat);\n    setup$9(editor);\n    editor.on('PreInit', () => {\n      register(editor);\n      setup$a(editor, draggingInternallyState);\n      registerEventsAndFilters(editor, pasteBin, pasteFormat);\n    });\n  };\n\n  const preventSummaryToggle = editor => {\n    editor.on('click', e => {\n      if (editor.dom.getParent(e.target, 'details')) {\n        e.preventDefault();\n      }\n    });\n  };\n\n  const filterDetails = editor => {\n    editor.parser.addNodeFilter('details', elms => {\n      each$g(elms, details => {\n        details.attr('data-mce-open', details.attr('open'));\n        details.attr('open', 'open');\n      });\n    });\n    editor.serializer.addNodeFilter('details', elms => {\n      each$g(elms, details => {\n        const open = details.attr('data-mce-open');\n        details.attr('open', isString(open) ? open : null);\n        details.attr('data-mce-open', null);\n      });\n    });\n  };\n\n  const setup$6 = editor => {\n    preventSummaryToggle(editor);\n    filterDetails(editor);\n  };\n\n  const isTextBlockNode = node => isElement$6(node) && isTextBlock$2(SugarElement.fromDom(node));\n\n  const normalizeSelection = editor => {\n    const rng = editor.selection.getRng();\n    const startPos = CaretPosition.fromRangeStart(rng);\n    const endPos = CaretPosition.fromRangeEnd(rng);\n\n    if (CaretPosition.isElementPosition(startPos)) {\n      const container = startPos.container();\n\n      if (isTextBlockNode(container)) {\n        firstPositionIn(container).each(pos => rng.setStart(pos.container(), pos.offset()));\n      }\n    }\n\n    if (CaretPosition.isElementPosition(endPos)) {\n      const container = startPos.container();\n\n      if (isTextBlockNode(container)) {\n        lastPositionIn(container).each(pos => rng.setEnd(pos.container(), pos.offset()));\n      }\n    }\n\n    editor.selection.setRng(normalize(rng));\n  };\n\n  const setup$5 = editor => {\n    editor.on('click', e => {\n      if (e.detail >= 3) {\n        normalizeSelection(editor);\n      }\n    });\n  };\n\n  var FakeCaretPosition;\n\n  (function (FakeCaretPosition) {\n    FakeCaretPosition['Before'] = 'before';\n    FakeCaretPosition['After'] = 'after';\n  })(FakeCaretPosition || (FakeCaretPosition = {}));\n\n  const distanceToRectLeft = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\n\n  const distanceToRectRight = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\n\n  const isInsideY = (clientY, clientRect) => clientY >= clientRect.top && clientY <= clientRect.bottom;\n\n  const collidesY = (r1, r2) => r1.top < r2.bottom && r1.bottom > r2.top;\n\n  const isOverlapping = (r1, r2) => {\n    const overlap = overlapY(r1, r2) / Math.min(r1.height, r2.height);\n    return collidesY(r1, r2) && overlap > 0.5;\n  };\n\n  const splitRectsPerAxis = (rects, y) => {\n    const intersectingRects = filter$6(rects, rect => isInsideY(y, rect));\n    return boundingClientRectFromRects(intersectingRects).fold(() => [[], rects], boundingRect => {\n      const {\n        pass: horizontal,\n        fail: vertical\n      } = partition$2(rects, rect => isOverlapping(rect, boundingRect));\n      return [horizontal, vertical];\n    });\n  };\n\n  const clientInfo = (rect, clientX) => {\n    return {\n      node: rect.node,\n      position: distanceToRectLeft(rect, clientX) < distanceToRectRight(rect, clientX) ? FakeCaretPosition.Before : FakeCaretPosition.After\n    };\n  };\n\n  const horizontalDistance = (rect, x, _y) => x > rect.left && x < rect.right ? 0 : Math.min(Math.abs(rect.left - x), Math.abs(rect.right - x));\n\n  const closestChildCaretCandidateNodeRect = (children, clientX, clientY) => {\n    const caretCandidateRect = rect => {\n      if (isCaretCandidate$3(rect.node)) {\n        return Optional.some(rect);\n      } else if (isElement$6(rect.node)) {\n        return closestChildCaretCandidateNodeRect(from(rect.node.childNodes), clientX, clientY);\n      } else {\n        return Optional.none();\n      }\n    };\n\n    const getClosestTextNode = (rects, distance) => {\n      if (rects.length >= 2) {\n        const r1 = caretCandidateRect(rects[0]).getOr(rects[0]);\n        const r2 = caretCandidateRect(rects[1]).getOr(rects[1]);\n        const deltaDistance = Math.abs(distance(r1, clientX, clientY) - distance(r2, clientX, clientY));\n\n        if (deltaDistance < 2) {\n          if (isText$8(r1.node)) {\n            return Optional.some(r1);\n          } else if (isText$8(r2.node)) {\n            return Optional.some(r2);\n          }\n        }\n      }\n\n      return Optional.none();\n    };\n\n    const findClosestCaretCandidateNodeRect = (rects, distance) => {\n      const sortedRects = sort(rects, (r1, r2) => distance(r1, clientX, clientY) - distance(r2, clientX, clientY));\n      return getClosestTextNode(sortedRects, distance).orThunk(() => findMap(sortedRects, caretCandidateRect));\n    };\n\n    const [horizontalRects, verticalRects] = splitRectsPerAxis(getClientRects(children), clientY);\n    const {\n      pass: above,\n      fail: below\n    } = partition$2(verticalRects, rect => rect.top < clientY);\n    return findClosestCaretCandidateNodeRect(horizontalRects, horizontalDistance).orThunk(() => findClosestCaretCandidateNodeRect(below, distanceToRectEdgeFromXY)).orThunk(() => findClosestCaretCandidateNodeRect(above, distanceToRectEdgeFromXY));\n  };\n\n  const traverseUp = (rootElm, scope, clientX, clientY) => {\n    const helper = (scope, prevScope) => {\n      return prevScope.fold(() => closestChildCaretCandidateNodeRect(from(scope.dom.childNodes), clientX, clientY), prevScope => {\n        const uncheckedChildren = filter$6(from(scope.dom.childNodes), node => node !== prevScope.dom);\n        return closestChildCaretCandidateNodeRect(uncheckedChildren, clientX, clientY);\n      }).orThunk(() => {\n        const parent = eq(scope, rootElm) ? Optional.none() : parentElement(scope);\n        return parent.bind(newScope => helper(newScope, Optional.some(scope)));\n      });\n    };\n\n    return helper(scope, Optional.none());\n  };\n\n  const closestCaretCandidateNodeRect = (root, clientX, clientY) => {\n    const rootElm = SugarElement.fromDom(root);\n    const ownerDoc = documentOrOwner(rootElm);\n    const elementAtPoint = SugarElement.fromPoint(ownerDoc, clientX, clientY).filter(elm => contains(rootElm, elm));\n    const element = elementAtPoint.getOr(rootElm);\n    return traverseUp(rootElm, element, clientX, clientY);\n  };\n\n  const closestFakeCaretCandidate = (root, clientX, clientY) => closestCaretCandidateNodeRect(root, clientX, clientY).filter(rect => isFakeCaretTarget(rect.node)).map(rect => clientInfo(rect, clientX));\n\n  const getAbsolutePosition = elm => {\n    const clientRect = elm.getBoundingClientRect();\n    const doc = elm.ownerDocument;\n    const docElem = doc.documentElement;\n    const win = doc.defaultView;\n    return {\n      top: clientRect.top + win.pageYOffset - docElem.clientTop,\n      left: clientRect.left + win.pageXOffset - docElem.clientLeft\n    };\n  };\n\n  const getBodyPosition = editor => editor.inline ? getAbsolutePosition(editor.getBody()) : {\n    left: 0,\n    top: 0\n  };\n\n  const getScrollPosition = editor => {\n    const body = editor.getBody();\n    return editor.inline ? {\n      left: body.scrollLeft,\n      top: body.scrollTop\n    } : {\n      left: 0,\n      top: 0\n    };\n  };\n\n  const getBodyScroll = editor => {\n    const body = editor.getBody(),\n          docElm = editor.getDoc().documentElement;\n    const inlineScroll = {\n      left: body.scrollLeft,\n      top: body.scrollTop\n    };\n    const iframeScroll = {\n      left: body.scrollLeft || docElm.scrollLeft,\n      top: body.scrollTop || docElm.scrollTop\n    };\n    return editor.inline ? inlineScroll : iframeScroll;\n  };\n\n  const getMousePosition = (editor, event) => {\n    if (event.target.ownerDocument !== editor.getDoc()) {\n      const iframePosition = getAbsolutePosition(editor.getContentAreaContainer());\n      const scrollPosition = getBodyScroll(editor);\n      return {\n        left: event.pageX - iframePosition.left + scrollPosition.left,\n        top: event.pageY - iframePosition.top + scrollPosition.top\n      };\n    }\n\n    return {\n      left: event.pageX,\n      top: event.pageY\n    };\n  };\n\n  const calculatePosition = (bodyPosition, scrollPosition, mousePosition) => ({\n    pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,\n    pageY: mousePosition.top - bodyPosition.top + scrollPosition.top\n  });\n\n  const calc = (editor, event) => calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));\n\n  const isContentEditableFalse$1 = isContentEditableFalse$a,\n        isContentEditableTrue = isContentEditableTrue$4;\n\n  const isDraggable = (rootElm, elm) => isContentEditableFalse$1(elm) && elm !== rootElm;\n\n  const isValidDropTarget = (editor, targetElement, dragElement) => {\n    if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {\n      return false;\n    }\n\n    return !isContentEditableFalse$1(targetElement);\n  };\n\n  const cloneElement = elm => {\n    const cloneElm = elm.cloneNode(true);\n    cloneElm.removeAttribute('data-mce-selected');\n    return cloneElm;\n  };\n\n  const createGhost = (editor, elm, width, height) => {\n    const dom = editor.dom;\n    const clonedElm = elm.cloneNode(true);\n    dom.setStyles(clonedElm, {\n      width,\n      height\n    });\n    dom.setAttrib(clonedElm, 'data-mce-selected', null);\n    const ghostElm = dom.create('div', {\n      'class': 'mce-drag-container',\n      'data-mce-bogus': 'all',\n      'unselectable': 'on',\n      'contenteditable': 'false'\n    });\n    dom.setStyles(ghostElm, {\n      position: 'absolute',\n      opacity: 0.5,\n      overflow: 'hidden',\n      border: 0,\n      padding: 0,\n      margin: 0,\n      width,\n      height\n    });\n    dom.setStyles(clonedElm, {\n      margin: 0,\n      boxSizing: 'border-box'\n    });\n    ghostElm.appendChild(clonedElm);\n    return ghostElm;\n  };\n\n  const appendGhostToBody = (ghostElm, bodyElm) => {\n    if (ghostElm.parentNode !== bodyElm) {\n      bodyElm.appendChild(ghostElm);\n    }\n  };\n\n  const moveGhost = (ghostElm, position, width, height, maxX, maxY) => {\n    let overflowX = 0,\n        overflowY = 0;\n    ghostElm.style.left = position.pageX + 'px';\n    ghostElm.style.top = position.pageY + 'px';\n\n    if (position.pageX + width > maxX) {\n      overflowX = position.pageX + width - maxX;\n    }\n\n    if (position.pageY + height > maxY) {\n      overflowY = position.pageY + height - maxY;\n    }\n\n    ghostElm.style.width = width - overflowX + 'px';\n    ghostElm.style.height = height - overflowY + 'px';\n  };\n\n  const removeElement = elm => {\n    if (elm && elm.parentNode) {\n      elm.parentNode.removeChild(elm);\n    }\n  };\n\n  const isLeftMouseButtonPressed = e => e.button === 0;\n\n  const applyRelPos = (state, position) => ({\n    pageX: position.pageX - state.relX,\n    pageY: position.pageY + 5\n  });\n\n  const start = (state, editor) => e => {\n    if (isLeftMouseButtonPressed(e)) {\n      const ceElm = find$2(editor.dom.getParents(e.target), or(isContentEditableFalse$1, isContentEditableTrue)).getOr(null);\n\n      if (isDraggable(editor.getBody(), ceElm)) {\n        const elmPos = editor.dom.getPos(ceElm);\n        const bodyElm = editor.getBody();\n        const docElm = editor.getDoc().documentElement;\n        state.set({\n          element: ceElm,\n          dragging: false,\n          screenX: e.screenX,\n          screenY: e.screenY,\n          maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,\n          maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,\n          relX: e.pageX - elmPos.x,\n          relY: e.pageY - elmPos.y,\n          width: ceElm.offsetWidth,\n          height: ceElm.offsetHeight,\n          ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight)\n        });\n      }\n    }\n  };\n\n  const move = (state, editor) => {\n    const throttledPlaceCaretAt = first$1((clientX, clientY) => {\n      editor._selectionOverrides.hideFakeCaret();\n\n      editor.selection.placeCaretAt(clientX, clientY);\n    }, 0);\n    editor.on('remove', throttledPlaceCaretAt.cancel);\n    return e => state.on(state => {\n      const movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));\n\n      if (!state.dragging && movement > 10) {\n        const args = editor.dispatch('dragstart', {\n          target: state.element\n        });\n\n        if (args.isDefaultPrevented()) {\n          return;\n        }\n\n        state.dragging = true;\n        editor.focus();\n      }\n\n      if (state.dragging) {\n        const targetPos = applyRelPos(state, calc(editor, e));\n        appendGhostToBody(state.ghost, editor.getBody());\n        moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY);\n        throttledPlaceCaretAt.throttle(e.clientX, e.clientY);\n      }\n    });\n  };\n\n  const getRawTarget = selection => {\n    const rng = selection.getSel().getRangeAt(0);\n    const startContainer = rng.startContainer;\n    return startContainer.nodeType === 3 ? startContainer.parentNode : startContainer;\n  };\n\n  const drop = (state, editor) => e => {\n    state.on(state => {\n      if (state.dragging) {\n        if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {\n          const targetClone = cloneElement(state.element);\n          const args = editor.dispatch('drop', {\n            clientX: e.clientX,\n            clientY: e.clientY\n          });\n\n          if (!args.isDefaultPrevented()) {\n            editor.undoManager.transact(() => {\n              removeElement(state.element);\n              editor.insertContent(editor.dom.getOuterHTML(targetClone));\n\n              editor._selectionOverrides.hideFakeCaret();\n            });\n          }\n        }\n\n        editor.dispatch('dragend');\n      }\n    });\n    removeDragState(state);\n  };\n\n  const stop = (state, editor) => () => {\n    state.on(state => {\n      if (state.dragging) {\n        editor.dispatch('dragend');\n      }\n    });\n    removeDragState(state);\n  };\n\n  const removeDragState = state => {\n    state.on(state => {\n      removeElement(state.ghost);\n    });\n    state.clear();\n  };\n\n  const bindFakeDragEvents = editor => {\n    const state = value$2();\n    const pageDom = DOMUtils.DOM;\n    const rootDocument = document;\n    const dragStartHandler = start(state, editor);\n    const dragHandler = move(state, editor);\n    const dropHandler = drop(state, editor);\n    const dragEndHandler = stop(state, editor);\n    editor.on('mousedown', dragStartHandler);\n    editor.on('mousemove', dragHandler);\n    editor.on('mouseup', dropHandler);\n    pageDom.bind(rootDocument, 'mousemove', dragHandler);\n    pageDom.bind(rootDocument, 'mouseup', dragEndHandler);\n    editor.on('remove', () => {\n      pageDom.unbind(rootDocument, 'mousemove', dragHandler);\n      pageDom.unbind(rootDocument, 'mouseup', dragEndHandler);\n    });\n    editor.on('keydown', e => {\n      if (e.keyCode === VK.ESC) {\n        dragEndHandler();\n      }\n    });\n  };\n\n  const blockUnsupportedFileDrop = editor => {\n    const preventFileDrop = e => {\n      if (!e.isDefaultPrevented()) {\n        const dataTransfer = e.dataTransfer;\n\n        if (dataTransfer && (contains$2(dataTransfer.types, 'Files') || dataTransfer.files.length > 0)) {\n          e.preventDefault();\n\n          if (e.type === 'drop') {\n            displayError(editor, 'Dropped file type is not supported');\n          }\n        }\n      }\n    };\n\n    const preventFileDropIfUIElement = e => {\n      if (isUIElement(editor, e.target)) {\n        preventFileDrop(e);\n      }\n    };\n\n    const setup = () => {\n      const pageDom = DOMUtils.DOM;\n      const dom = editor.dom;\n      const doc = document;\n      const editorRoot = editor.inline ? editor.getBody() : editor.getDoc();\n      const eventNames = ['drop', 'dragover'];\n      each$g(eventNames, name => {\n        pageDom.bind(doc, name, preventFileDropIfUIElement);\n        dom.bind(editorRoot, name, preventFileDrop);\n      });\n      editor.on('remove', () => {\n        each$g(eventNames, name => {\n          pageDom.unbind(doc, name, preventFileDropIfUIElement);\n          dom.unbind(editorRoot, name, preventFileDrop);\n        });\n      });\n    };\n\n    editor.on('init', () => {\n      Delay.setEditorTimeout(editor, setup, 0);\n    });\n  };\n\n  const init$2 = editor => {\n    bindFakeDragEvents(editor);\n\n    if (shouldBlockUnsupportedDrop(editor)) {\n      blockUnsupportedFileDrop(editor);\n    }\n  };\n\n  const setup$4 = editor => {\n    const renderFocusCaret = first$1(() => {\n      if (!editor.removed && editor.getBody().contains(document.activeElement)) {\n        const rng = editor.selection.getRng();\n\n        if (rng.collapsed) {\n          const caretRange = renderRangeCaret(editor, rng, false);\n          editor.selection.setRng(caretRange);\n        }\n      }\n    }, 0);\n    editor.on('focus', () => {\n      renderFocusCaret.throttle();\n    });\n    editor.on('blur', () => {\n      renderFocusCaret.cancel();\n    });\n  };\n\n  const setup$3 = editor => {\n    editor.on('init', () => {\n      editor.on('focusin', e => {\n        const target = e.target;\n\n        if (isMedia$2(target)) {\n          const ceRoot = getContentEditableRoot$1(editor.getBody(), target);\n          const node = isContentEditableFalse$a(ceRoot) ? ceRoot : target;\n\n          if (editor.selection.getNode() !== node) {\n            selectNode(editor, node).each(rng => editor.selection.setRng(rng));\n          }\n        }\n      });\n    });\n  };\n\n  const isContentEditableFalse = isContentEditableFalse$a;\n\n  const getContentEditableRoot = (editor, node) => getContentEditableRoot$1(editor.getBody(), node);\n\n  const SelectionOverrides = editor => {\n    const selection = editor.selection,\n          dom = editor.dom;\n    const isBlock = dom.isBlock;\n    const rootNode = editor.getBody();\n    const fakeCaret = FakeCaret(editor, rootNode, isBlock, () => hasFocus(editor));\n    const realSelectionId = 'sel-' + dom.uniqueId();\n    const elementSelectionAttr = 'data-mce-selected';\n    let selectedElement;\n\n    const isFakeSelectionElement = node => dom.hasClass(node, 'mce-offscreen-selection');\n\n    const isFakeSelectionTargetElement = node => node !== rootNode && (isContentEditableFalse(node) || isMedia$2(node)) && dom.isChildOf(node, rootNode);\n\n    const setRange = range => {\n      if (range) {\n        selection.setRng(range);\n      }\n    };\n\n    const showCaret = function (direction, node, before) {\n      let scrollIntoView = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      const e = editor.dispatch('ShowCaret', {\n        target: node,\n        direction,\n        before\n      });\n\n      if (e.isDefaultPrevented()) {\n        return null;\n      }\n\n      if (scrollIntoView) {\n        selection.scrollIntoView(node, direction === -1);\n      }\n\n      return fakeCaret.show(before, node);\n    };\n\n    const showBlockCaretContainer = blockCaretContainer => {\n      if (blockCaretContainer.hasAttribute('data-mce-caret')) {\n        showCaretContainerBlock(blockCaretContainer);\n        selection.scrollIntoView(blockCaretContainer);\n      }\n    };\n\n    const registerEvents = () => {\n      editor.on('click', e => {\n        const contentEditableRoot = getContentEditableRoot(editor, e.target);\n\n        if (contentEditableRoot) {\n          if (isContentEditableFalse(contentEditableRoot)) {\n            e.preventDefault();\n            editor.focus();\n          }\n        }\n      });\n      editor.on('blur NewBlock', removeElementSelection);\n      editor.on('ResizeWindow FullscreenStateChanged', fakeCaret.reposition);\n      editor.on('tap', e => {\n        const targetElm = e.target;\n        const contentEditableRoot = getContentEditableRoot(editor, targetElm);\n\n        if (isContentEditableFalse(contentEditableRoot)) {\n          e.preventDefault();\n          selectNode(editor, contentEditableRoot).each(setElementSelection);\n        } else if (isFakeSelectionTargetElement(targetElm)) {\n          selectNode(editor, targetElm).each(setElementSelection);\n        }\n      }, true);\n      editor.on('mousedown', e => {\n        const targetElm = e.target;\n\n        if (targetElm !== rootNode && targetElm.nodeName !== 'HTML' && !dom.isChildOf(targetElm, rootNode)) {\n          return;\n        }\n\n        if (isXYInContentArea(editor, e.clientX, e.clientY) === false) {\n          return;\n        }\n\n        removeElementSelection();\n        hideFakeCaret();\n        const closestContentEditable = getContentEditableRoot(editor, targetElm);\n\n        if (isContentEditableFalse(closestContentEditable)) {\n          e.preventDefault();\n          selectNode(editor, closestContentEditable).each(setElementSelection);\n        } else {\n          closestFakeCaretCandidate(rootNode, e.clientX, e.clientY).each(caretInfo => {\n            e.preventDefault();\n            const range = showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);\n            setRange(range);\n\n            if (isElement$6(closestContentEditable)) {\n              closestContentEditable.focus();\n            } else {\n              editor.getBody().focus();\n            }\n          });\n        }\n      });\n      editor.on('keypress', e => {\n        if (VK.modifierPressed(e)) {\n          return;\n        }\n\n        if (isContentEditableFalse(selection.getNode())) {\n          e.preventDefault();\n        }\n      });\n      editor.on('GetSelectionRange', e => {\n        let rng = e.range;\n\n        if (selectedElement) {\n          if (!selectedElement.parentNode) {\n            selectedElement = null;\n            return;\n          }\n\n          rng = rng.cloneRange();\n          rng.selectNode(selectedElement);\n          e.range = rng;\n        }\n      });\n      editor.on('SetSelectionRange', e => {\n        e.range = normalizeVoidElementSelection(e.range);\n        const rng = setElementSelection(e.range, e.forward);\n\n        if (rng) {\n          e.range = rng;\n        }\n      });\n\n      const isPasteBin = node => node.id === 'mcepastebin';\n\n      editor.on('AfterSetSelectionRange', e => {\n        const rng = e.range;\n        const parentNode = rng.startContainer.parentNode;\n\n        if (!isRangeInCaretContainer(rng) && !isPasteBin(parentNode)) {\n          hideFakeCaret();\n        }\n\n        if (!isFakeSelectionElement(parentNode)) {\n          removeElementSelection();\n        }\n      });\n      init$2(editor);\n      setup$4(editor);\n      setup$3(editor);\n    };\n\n    const isWithinCaretContainer = node => isCaretContainer$2(node) || startsWithCaretContainer$1(node) || endsWithCaretContainer$1(node);\n\n    const isRangeInCaretContainer = rng => isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);\n\n    const normalizeVoidElementSelection = rng => {\n      const voidElements = editor.schema.getVoidElements();\n      const newRng = dom.createRng();\n      const startContainer = rng.startContainer;\n      const startOffset = rng.startOffset;\n      const endContainer = rng.endContainer;\n      const endOffset = rng.endOffset;\n\n      if (has$2(voidElements, startContainer.nodeName.toLowerCase())) {\n        if (startOffset === 0) {\n          newRng.setStartBefore(startContainer);\n        } else {\n          newRng.setStartAfter(startContainer);\n        }\n      } else {\n        newRng.setStart(startContainer, startOffset);\n      }\n\n      if (has$2(voidElements, endContainer.nodeName.toLowerCase())) {\n        if (endOffset === 0) {\n          newRng.setEndBefore(endContainer);\n        } else {\n          newRng.setEndAfter(endContainer);\n        }\n      } else {\n        newRng.setEnd(endContainer, endOffset);\n      }\n\n      return newRng;\n    };\n\n    const setupOffscreenSelection = (node, targetClone) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const doc = editor.getDoc();\n      const realSelectionContainer = descendant(body, '#' + realSelectionId).getOrThunk(() => {\n        const newContainer = SugarElement.fromHtml('<div data-mce-bogus=\"all\" class=\"mce-offscreen-selection\"></div>', doc);\n        set$2(newContainer, 'id', realSelectionId);\n        append$1(body, newContainer);\n        return newContainer;\n      });\n      const newRange = dom.createRng();\n      empty(realSelectionContainer);\n      append(realSelectionContainer, [SugarElement.fromText(nbsp, doc), SugarElement.fromDom(targetClone), SugarElement.fromText(nbsp, doc)]);\n      newRange.setStart(realSelectionContainer.dom.firstChild, 1);\n      newRange.setEnd(realSelectionContainer.dom.lastChild, 0);\n      setAll(realSelectionContainer, {\n        top: dom.getPos(node, editor.getBody()).y + 'px'\n      });\n      focus$1(realSelectionContainer);\n      const sel = selection.getSel();\n      sel.removeAllRanges();\n      sel.addRange(newRange);\n      return newRange;\n    };\n\n    const selectElement = elm => {\n      const targetClone = elm.cloneNode(true);\n      const e = editor.dispatch('ObjectSelected', {\n        target: elm,\n        targetClone\n      });\n\n      if (e.isDefaultPrevented()) {\n        return null;\n      }\n\n      const range = setupOffscreenSelection(elm, e.targetClone);\n      const nodeElm = SugarElement.fromDom(elm);\n      each$g(descendants(SugarElement.fromDom(editor.getBody()), '*[data-mce-selected]'), elm => {\n        if (!eq(nodeElm, elm)) {\n          remove$a(elm, elementSelectionAttr);\n        }\n      });\n\n      if (!dom.getAttrib(elm, elementSelectionAttr)) {\n        elm.setAttribute(elementSelectionAttr, '1');\n      }\n\n      selectedElement = elm;\n      hideFakeCaret();\n      return range;\n    };\n\n    const setElementSelection = (range, forward) => {\n      if (!range) {\n        return null;\n      }\n\n      if (range.collapsed) {\n        if (!isRangeInCaretContainer(range)) {\n          const dir = forward ? 1 : -1;\n          const caretPosition = getNormalizedRangeEndPoint(dir, rootNode, range);\n          const beforeNode = caretPosition.getNode(!forward);\n\n          if (isFakeCaretTarget(beforeNode)) {\n            return showCaret(dir, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);\n          }\n\n          const afterNode = caretPosition.getNode(forward);\n\n          if (isFakeCaretTarget(afterNode)) {\n            return showCaret(dir, afterNode, forward ? false : !caretPosition.isAtEnd(), false);\n          }\n        }\n\n        return null;\n      }\n\n      let startContainer = range.startContainer;\n      let startOffset = range.startOffset;\n      const endOffset = range.endOffset;\n\n      if (startContainer.nodeType === 3 && startOffset === 0 && isContentEditableFalse(startContainer.parentNode)) {\n        startContainer = startContainer.parentNode;\n        startOffset = dom.nodeIndex(startContainer);\n        startContainer = startContainer.parentNode;\n      }\n\n      if (startContainer.nodeType !== 1) {\n        return null;\n      }\n\n      if (endOffset === startOffset + 1 && startContainer === range.endContainer) {\n        const node = startContainer.childNodes[startOffset];\n\n        if (isFakeSelectionTargetElement(node)) {\n          return selectElement(node);\n        }\n      }\n\n      return null;\n    };\n\n    const removeElementSelection = () => {\n      if (selectedElement) {\n        selectedElement.removeAttribute(elementSelectionAttr);\n      }\n\n      descendant(SugarElement.fromDom(editor.getBody()), '#' + realSelectionId).each(remove$5);\n      selectedElement = null;\n    };\n\n    const destroy = () => {\n      fakeCaret.destroy();\n      selectedElement = null;\n    };\n\n    const hideFakeCaret = () => {\n      fakeCaret.hide();\n    };\n\n    if (!isRtc(editor)) {\n      registerEvents();\n    }\n\n    return {\n      showCaret,\n      showBlockCaretContainer,\n      hideFakeCaret,\n      destroy\n    };\n  };\n\n  const generatePath = (root, node, offset) => {\n    if (isText$8(node) && (offset < 0 || offset > node.data.length)) {\n      return [];\n    }\n\n    const p = [offset];\n    let current = node;\n\n    while (current !== root && current.parentNode) {\n      const parent = current.parentNode;\n\n      for (let i = 0; i < parent.childNodes.length; i++) {\n        if (parent.childNodes[i] === current) {\n          p.push(i);\n          break;\n        }\n      }\n\n      current = parent;\n    }\n\n    return current === root ? p.reverse() : [];\n  };\n\n  const generatePathRange = (root, startNode, startOffset, endNode, endOffset) => {\n    const start = generatePath(root, startNode, startOffset);\n    const end = generatePath(root, endNode, endOffset);\n    return {\n      start,\n      end\n    };\n  };\n\n  const resolvePath = (root, path) => {\n    const nodePath = path.slice();\n    const offset = nodePath.pop();\n    const resolvedNode = foldl(nodePath, (optNode, index) => optNode.bind(node => Optional.from(node.childNodes[index])), Optional.some(root));\n    return resolvedNode.bind(node => {\n      if (isText$8(node) && (offset < 0 || offset > node.data.length)) {\n        return Optional.none();\n      } else {\n        return Optional.some({\n          node,\n          offset\n        });\n      }\n    });\n  };\n\n  const resolvePathRange = (root, range) => resolvePath(root, range.start).bind(_ref12 => {\n    let {\n      node: startNode,\n      offset: startOffset\n    } = _ref12;\n    return resolvePath(root, range.end).map(_ref13 => {\n      let {\n        node: endNode,\n        offset: endOffset\n      } = _ref13;\n      const rng = document.createRange();\n      rng.setStart(startNode, startOffset);\n      rng.setEnd(endNode, endOffset);\n      return rng;\n    });\n  });\n\n  const generatePathRangeFromRange = (root, range) => generatePathRange(root, range.startContainer, range.startOffset, range.endContainer, range.endOffset);\n\n  const cleanEmptyNodes = (dom, node, isRoot) => {\n    if (node && dom.isEmpty(node) && !isRoot(node)) {\n      const parent = node.parentNode;\n      dom.remove(node);\n      cleanEmptyNodes(dom, parent, isRoot);\n    }\n  };\n\n  const deleteRng = function (dom, rng, isRoot) {\n    let clean = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    const startParent = rng.startContainer.parentNode;\n    const endParent = rng.endContainer.parentNode;\n    rng.deleteContents();\n\n    if (clean && !isRoot(rng.startContainer)) {\n      if (isText$8(rng.startContainer) && rng.startContainer.data.length === 0) {\n        dom.remove(rng.startContainer);\n      }\n\n      if (isText$8(rng.endContainer) && rng.endContainer.data.length === 0) {\n        dom.remove(rng.endContainer);\n      }\n\n      cleanEmptyNodes(dom, startParent, isRoot);\n\n      if (startParent !== endParent) {\n        cleanEmptyNodes(dom, endParent, isRoot);\n      }\n    }\n  };\n\n  const getParentBlock = (editor, rng) => Optional.from(editor.dom.getParent(rng.startContainer, editor.dom.isBlock));\n\n  const stripPattern = (dom, block, pattern) => {\n    const firstTextNode = textAfter(block, 0, block);\n    firstTextNode.each(spot => {\n      const node = spot.container;\n      scanRight(node, pattern.start.length, block).each(end => {\n        const rng = dom.createRng();\n        rng.setStart(node, 0);\n        rng.setEnd(end.container, end.offset);\n        deleteRng(dom, rng, e => e === block);\n      });\n    });\n  };\n\n  const applyPattern$1 = (editor, match) => {\n    const dom = editor.dom;\n    const pattern = match.pattern;\n    const rng = resolvePathRange(dom.getRoot(), match.range).getOrDie('Unable to resolve path range');\n\n    const isBlockFormatName = (name, formatter) => {\n      const formatSet = formatter.get(name);\n      return isArray$1(formatSet) && head(formatSet).exists(format => has$2(format, 'block'));\n    };\n\n    getParentBlock(editor, rng).each(block => {\n      if (pattern.type === 'block-format') {\n        if (isBlockFormatName(pattern.format, editor.formatter)) {\n          editor.undoManager.transact(() => {\n            stripPattern(editor.dom, block, pattern);\n            editor.formatter.apply(pattern.format);\n          });\n        }\n      } else if (pattern.type === 'block-command') {\n        editor.undoManager.transact(() => {\n          stripPattern(editor.dom, block, pattern);\n          editor.execCommand(pattern.cmd, false, pattern.value);\n        });\n      }\n    });\n    return true;\n  };\n\n  const findPattern$1 = (patterns, text) => {\n    const nuText = text.replace(nbsp, ' ');\n    return find$2(patterns, pattern => text.indexOf(pattern.start) === 0 || nuText.indexOf(pattern.start) === 0);\n  };\n\n  const findPatterns$1 = (editor, patterns) => {\n    const dom = editor.dom;\n    const rng = editor.selection.getRng();\n    return getParentBlock(editor, rng).filter(block => {\n      const forcedRootBlock = getForcedRootBlock(editor);\n      const matchesForcedRootBlock = dom.is(block, forcedRootBlock);\n      return block !== null && matchesForcedRootBlock;\n    }).bind(block => {\n      const blockText = block.textContent;\n      const matchedPattern = findPattern$1(patterns, blockText);\n      return matchedPattern.map(pattern => {\n        if (Tools.trim(blockText).length === pattern.start.length) {\n          return [];\n        }\n\n        return [{\n          pattern,\n          range: generatePathRange(dom.getRoot(), block, 0, block, 0)\n        }];\n      });\n    }).getOr([]);\n  };\n\n  const applyMatches$1 = (editor, matches) => {\n    if (matches.length === 0) {\n      return;\n    }\n\n    const bookmark = editor.selection.getBookmark();\n    each$g(matches, match => applyPattern$1(editor, match));\n    editor.selection.moveToBookmark(bookmark);\n  };\n\n  const newMarker = (dom, id) => dom.create('span', {\n    'data-mce-type': 'bookmark',\n    id\n  });\n\n  const rangeFromMarker = (dom, marker) => {\n    const rng = dom.createRng();\n    rng.setStartAfter(marker.start);\n    rng.setEndBefore(marker.end);\n    return rng;\n  };\n\n  const createMarker = (dom, markerPrefix, pathRange) => {\n    const rng = resolvePathRange(dom.getRoot(), pathRange).getOrDie('Unable to resolve path range');\n    const startNode = rng.startContainer;\n    const endNode = rng.endContainer;\n    const textEnd = rng.endOffset === 0 ? endNode : endNode.splitText(rng.endOffset);\n    const textStart = rng.startOffset === 0 ? startNode : startNode.splitText(rng.startOffset);\n    return {\n      prefix: markerPrefix,\n      end: textEnd.parentNode.insertBefore(newMarker(dom, markerPrefix + '-end'), textEnd),\n      start: textStart.parentNode.insertBefore(newMarker(dom, markerPrefix + '-start'), textStart)\n    };\n  };\n\n  const removeMarker = (dom, marker, isRoot) => {\n    cleanEmptyNodes(dom, dom.get(marker.prefix + '-end'), isRoot);\n    cleanEmptyNodes(dom, dom.get(marker.prefix + '-start'), isRoot);\n  };\n\n  const isReplacementPattern = pattern => pattern.start.length === 0;\n\n  const matchesPattern = patternContent => (element, offset) => {\n    const text = element.data;\n    const searchText = text.substring(0, offset);\n    const startEndIndex = searchText.lastIndexOf(patternContent.charAt(patternContent.length - 1));\n    const startIndex = searchText.lastIndexOf(patternContent);\n\n    if (startIndex !== -1) {\n      return startIndex + patternContent.length;\n    } else if (startEndIndex !== -1) {\n      return startEndIndex + 1;\n    } else {\n      return -1;\n    }\n  };\n\n  const findPatternStartFromSpot = (dom, pattern, block, spot) => {\n    const startPattern = pattern.start;\n    const startSpot = repeatLeft(dom, spot.container, spot.offset, matchesPattern(startPattern), block);\n    return startSpot.bind(spot => {\n      if (spot.offset >= startPattern.length) {\n        const rng = dom.createRng();\n        rng.setStart(spot.container, spot.offset - startPattern.length);\n        rng.setEnd(spot.container, spot.offset);\n        return Optional.some(rng);\n      } else {\n        const offset = spot.offset - startPattern.length;\n        return scanLeft(spot.container, offset, block).map(nextSpot => {\n          const rng = dom.createRng();\n          rng.setStart(nextSpot.container, nextSpot.offset);\n          rng.setEnd(spot.container, spot.offset);\n          return rng;\n        }).filter(rng => rng.toString() === startPattern).orThunk(() => findPatternStartFromSpot(dom, pattern, block, point(spot.container, 0)));\n      }\n    });\n  };\n\n  const findPatternStart = function (dom, pattern, node, offset, block) {\n    let requireGap = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n    if (pattern.start.length === 0 && !requireGap) {\n      const rng = dom.createRng();\n      rng.setStart(node, offset);\n      rng.setEnd(node, offset);\n      return Optional.some(rng);\n    }\n\n    return textBefore(node, offset, block).bind(spot => {\n      const start = findPatternStartFromSpot(dom, pattern, block, spot);\n      return start.bind(startRange => {\n        if (requireGap) {\n          if (startRange.endContainer === spot.container && startRange.endOffset === spot.offset) {\n            return Optional.none();\n          } else if (spot.offset === 0 && startRange.endContainer.textContent.length === startRange.endOffset) {\n            return Optional.none();\n          }\n        }\n\n        return Optional.some(startRange);\n      });\n    });\n  };\n\n  const findPattern = (editor, block, details) => {\n    const dom = editor.dom;\n    const root = dom.getRoot();\n    const pattern = details.pattern;\n    const endNode = details.position.container;\n    const endOffset = details.position.offset;\n    return scanLeft(endNode, endOffset - details.pattern.end.length, block).bind(spot => {\n      const endPathRng = generatePathRange(root, spot.container, spot.offset, endNode, endOffset);\n\n      if (isReplacementPattern(pattern)) {\n        return Optional.some({\n          matches: [{\n            pattern,\n            startRng: endPathRng,\n            endRng: endPathRng\n          }],\n          position: spot\n        });\n      } else {\n        const resultsOpt = findPatternsRec(editor, details.remainingPatterns, spot.container, spot.offset, block);\n        const results = resultsOpt.getOr({\n          matches: [],\n          position: spot\n        });\n        const pos = results.position;\n        const start = findPatternStart(dom, pattern, pos.container, pos.offset, block, resultsOpt.isNone());\n        return start.map(startRng => {\n          const startPathRng = generatePathRangeFromRange(root, startRng);\n          return {\n            matches: results.matches.concat([{\n              pattern,\n              startRng: startPathRng,\n              endRng: endPathRng\n            }]),\n            position: point(startRng.startContainer, startRng.startOffset)\n          };\n        });\n      }\n    });\n  };\n\n  const findPatternsRec = (editor, patterns, node, offset, block) => {\n    const dom = editor.dom;\n    return textBefore(node, offset, dom.getRoot()).bind(endSpot => {\n      const rng = dom.createRng();\n      rng.setStart(block, 0);\n      rng.setEnd(node, offset);\n      const text = rng.toString();\n\n      for (let i = 0; i < patterns.length; i++) {\n        const pattern = patterns[i];\n\n        if (!endsWith(text, pattern.end)) {\n          continue;\n        }\n\n        const patternsWithoutCurrent = patterns.slice();\n        patternsWithoutCurrent.splice(i, 1);\n        const result = findPattern(editor, block, {\n          pattern,\n          remainingPatterns: patternsWithoutCurrent,\n          position: endSpot\n        });\n\n        if (result.isSome()) {\n          return result;\n        }\n      }\n\n      return Optional.none();\n    });\n  };\n\n  const applyPattern = (editor, pattern, patternRange) => {\n    editor.selection.setRng(patternRange);\n\n    if (pattern.type === 'inline-format') {\n      each$g(pattern.format, format => {\n        editor.formatter.apply(format);\n      });\n    } else {\n      editor.execCommand(pattern.cmd, false, pattern.value);\n    }\n  };\n\n  const applyReplacementPattern = (editor, pattern, marker, isRoot) => {\n    const markerRange = rangeFromMarker(editor.dom, marker);\n    deleteRng(editor.dom, markerRange, isRoot);\n    applyPattern(editor, pattern, markerRange);\n  };\n\n  const applyPatternWithContent = (editor, pattern, startMarker, endMarker, isRoot) => {\n    const dom = editor.dom;\n    const markerEndRange = rangeFromMarker(dom, endMarker);\n    const markerStartRange = rangeFromMarker(dom, startMarker);\n    deleteRng(dom, markerStartRange, isRoot);\n    deleteRng(dom, markerEndRange, isRoot);\n    const patternMarker = {\n      prefix: startMarker.prefix,\n      start: startMarker.end,\n      end: endMarker.start\n    };\n    const patternRange = rangeFromMarker(dom, patternMarker);\n    applyPattern(editor, pattern, patternRange);\n  };\n\n  const addMarkers = (dom, matches) => {\n    const markerPrefix = generate$1('mce_textpattern');\n    const matchesWithEnds = foldr(matches, (acc, match) => {\n      const endMarker = createMarker(dom, markerPrefix + `_end${acc.length}`, match.endRng);\n      return acc.concat([{ ...match,\n        endMarker\n      }]);\n    }, []);\n    return foldr(matchesWithEnds, (acc, match) => {\n      const idx = matchesWithEnds.length - acc.length - 1;\n      const startMarker = isReplacementPattern(match.pattern) ? match.endMarker : createMarker(dom, markerPrefix + `_start${idx}`, match.startRng);\n      return acc.concat([{ ...match,\n        startMarker\n      }]);\n    }, []);\n  };\n\n  const findPatterns = (editor, patterns, space) => {\n    const rng = editor.selection.getRng();\n\n    if (rng.collapsed === false) {\n      return [];\n    }\n\n    return getParentBlock(editor, rng).bind(block => {\n      const offset = Math.max(0, rng.startOffset - (space ? 1 : 0));\n      return findPatternsRec(editor, patterns, rng.startContainer, offset, block);\n    }).fold(() => [], result => result.matches);\n  };\n\n  const applyMatches = (editor, matches) => {\n    if (matches.length === 0) {\n      return;\n    }\n\n    const dom = editor.dom;\n    const bookmark = editor.selection.getBookmark();\n    const matchesWithMarkers = addMarkers(dom, matches);\n    each$g(matchesWithMarkers, match => {\n      const block = dom.getParent(match.startMarker.start, dom.isBlock);\n\n      const isRoot = node => node === block;\n\n      if (isReplacementPattern(match.pattern)) {\n        applyReplacementPattern(editor, match.pattern, match.endMarker, isRoot);\n      } else {\n        applyPatternWithContent(editor, match.pattern, match.startMarker, match.endMarker, isRoot);\n      }\n\n      removeMarker(dom, match.endMarker, isRoot);\n      removeMarker(dom, match.startMarker, isRoot);\n    });\n    editor.selection.moveToBookmark(bookmark);\n  };\n\n  const hasPatterns = patternSet => patternSet.inlinePatterns.length > 0 || patternSet.blockPatterns.length > 0;\n\n  const handleEnter = (editor, patternSet) => {\n    if (!editor.selection.isCollapsed() || !hasPatterns(patternSet)) {\n      return false;\n    }\n\n    const inlineMatches = findPatterns(editor, patternSet.inlinePatterns, false);\n    const blockMatches = findPatterns$1(editor, patternSet.blockPatterns);\n\n    if (blockMatches.length > 0 || inlineMatches.length > 0) {\n      editor.undoManager.add();\n      editor.undoManager.extra(() => {\n        editor.execCommand('mceInsertNewLine');\n      }, () => {\n        editor.insertContent(zeroWidth);\n        applyMatches(editor, inlineMatches);\n        applyMatches$1(editor, blockMatches);\n        const range = editor.selection.getRng();\n        const spot = textBefore(range.startContainer, range.startOffset, editor.dom.getRoot());\n        editor.execCommand('mceInsertNewLine');\n        spot.each(s => {\n          const node = s.container;\n\n          if (node.data.charAt(s.offset - 1) === zeroWidth) {\n            node.deleteData(s.offset - 1, 1);\n            cleanEmptyNodes(editor.dom, node.parentNode, e => e === editor.dom.getRoot());\n          }\n        });\n      });\n      return true;\n    }\n\n    return false;\n  };\n\n  const handleInlineKey = (editor, inlinePatterns) => {\n    if (inlinePatterns.length > 0) {\n      const inlineMatches = findPatterns(editor, inlinePatterns, true);\n\n      if (inlineMatches.length > 0) {\n        editor.undoManager.transact(() => {\n          applyMatches(editor, inlineMatches);\n        });\n      }\n    }\n  };\n\n  const checkKeyEvent = (codes, event, predicate) => {\n    for (let i = 0; i < codes.length; i++) {\n      if (predicate(codes[i], event)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  const checkKeyCode = (codes, event) => checkKeyEvent(codes, event, (code, event) => {\n    return code === event.keyCode && VK.modifierPressed(event) === false;\n  });\n\n  const checkCharCode = (chars, event) => checkKeyEvent(chars, event, (chr, event) => {\n    return chr.charCodeAt(0) === event.charCode;\n  });\n\n  const setup$2 = editor => {\n    const charCodes = [',', '.', ';', ':', '!', '?'];\n    const keyCodes = [32];\n\n    const getPatternSet = () => createPatternSet(getTextPatterns(editor));\n\n    const getInlinePatterns$1 = () => getInlinePatterns(getTextPatterns(editor));\n\n    editor.on('keydown', e => {\n      if (e.keyCode === 13 && !VK.modifierPressed(e)) {\n        if (handleEnter(editor, getPatternSet())) {\n          e.preventDefault();\n        }\n      }\n    }, true);\n    editor.on('keyup', e => {\n      if (checkKeyCode(keyCodes, e)) {\n        handleInlineKey(editor, getInlinePatterns$1());\n      }\n    });\n    editor.on('keypress', e => {\n      if (checkCharCode(charCodes, e)) {\n        Delay.setEditorTimeout(editor, () => {\n          handleInlineKey(editor, getInlinePatterns$1());\n        });\n      }\n    });\n  };\n\n  const setup$1 = editor => {\n    setup$2(editor);\n  };\n\n  const Quirks = editor => {\n    const each = Tools.each;\n    const BACKSPACE = VK.BACKSPACE,\n          DELETE = VK.DELETE,\n          dom = editor.dom,\n          selection = editor.selection,\n          parser = editor.parser;\n    const browser = Env.browser;\n    const isGecko = browser.isFirefox();\n    const isWebKit = browser.isChromium() || browser.isSafari();\n    const isiOS = Env.deviceType.isiPhone() || Env.deviceType.isiPad();\n    const isMac = Env.os.isMacOS() || Env.os.isiOS();\n\n    const setEditorCommandState = (cmd, state) => {\n      try {\n        editor.getDoc().execCommand(cmd, false, state);\n      } catch (ex) {}\n    };\n\n    const isDefaultPrevented = e => {\n      return e.isDefaultPrevented();\n    };\n\n    const emptyEditorWhenDeleting = () => {\n      const serializeRng = rng => {\n        const body = dom.create('body');\n        const contents = rng.cloneContents();\n        body.appendChild(contents);\n        return selection.serializer.serialize(body, {\n          format: 'html'\n        });\n      };\n\n      const allContentsSelected = rng => {\n        const selection = serializeRng(rng);\n        const allRng = dom.createRng();\n        allRng.selectNode(editor.getBody());\n        const allSelection = serializeRng(allRng);\n        return selection === allSelection;\n      };\n\n      editor.on('keydown', e => {\n        const keyCode = e.keyCode;\n        let isCollapsed, body;\n\n        if (!isDefaultPrevented(e) && (keyCode === DELETE || keyCode === BACKSPACE)) {\n          isCollapsed = editor.selection.isCollapsed();\n          body = editor.getBody();\n\n          if (isCollapsed && !dom.isEmpty(body)) {\n            return;\n          }\n\n          if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {\n            return;\n          }\n\n          e.preventDefault();\n          editor.setContent('');\n\n          if (body.firstChild && dom.isBlock(body.firstChild)) {\n            editor.selection.setCursorLocation(body.firstChild, 0);\n          } else {\n            editor.selection.setCursorLocation(body, 0);\n          }\n\n          editor.nodeChanged();\n        }\n      });\n    };\n\n    const selectAll = () => {\n      editor.shortcuts.add('meta+a', null, 'SelectAll');\n    };\n\n    const documentElementEditingFocus = () => {\n      if (!editor.inline) {\n        dom.bind(editor.getDoc(), 'mousedown mouseup', e => {\n          let rng;\n\n          if (e.target === editor.getDoc().documentElement) {\n            rng = selection.getRng();\n            editor.getBody().focus();\n\n            if (e.type === 'mousedown') {\n              if (isCaretContainer$2(rng.startContainer)) {\n                return;\n              }\n\n              selection.placeCaretAt(e.clientX, e.clientY);\n            } else {\n              selection.setRng(rng);\n            }\n          }\n        });\n      }\n    };\n\n    const removeHrOnBackspace = () => {\n      editor.on('keydown', e => {\n        if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n          if (!editor.getBody().getElementsByTagName('hr').length) {\n            return;\n          }\n\n          if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\n            const node = selection.getNode();\n            const previousSibling = node.previousSibling;\n\n            if (node.nodeName === 'HR') {\n              dom.remove(node);\n              e.preventDefault();\n              return;\n            }\n\n            if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'hr') {\n              dom.remove(previousSibling);\n              e.preventDefault();\n            }\n          }\n        }\n      });\n    };\n\n    const focusBody = () => {\n      if (!Range.prototype.getClientRects) {\n        editor.on('mousedown', e => {\n          if (!isDefaultPrevented(e) && e.target.nodeName === 'HTML') {\n            const body = editor.getBody();\n            body.blur();\n            Delay.setEditorTimeout(editor, () => {\n              body.focus();\n            });\n          }\n        });\n      }\n    };\n\n    const selectControlElements = () => {\n      const visualAidsAnchorClass = getVisualAidsAnchorClass(editor);\n      editor.on('click', e => {\n        const target = e.target;\n\n        if (/^(IMG|HR)$/.test(target.nodeName) && dom.getContentEditableParent(target) !== 'false') {\n          e.preventDefault();\n          editor.selection.select(target);\n          editor.nodeChanged();\n        }\n\n        if (target.nodeName === 'A' && dom.hasClass(target, visualAidsAnchorClass) && target.childNodes.length === 0) {\n          e.preventDefault();\n          selection.select(target);\n        }\n      });\n    };\n\n    const removeStylesWhenDeletingAcrossBlockElements = () => {\n      const getAttributeApplyFunction = () => {\n        const template = dom.getAttribs(selection.getStart().cloneNode(false));\n        return () => {\n          const target = selection.getStart();\n\n          if (target !== editor.getBody()) {\n            dom.setAttrib(target, 'style', null);\n            each(template, attr => {\n              target.setAttributeNode(attr.cloneNode(true));\n            });\n          }\n        };\n      };\n\n      const isSelectionAcrossElements = () => {\n        return !selection.isCollapsed() && dom.getParent(selection.getStart(), dom.isBlock) !== dom.getParent(selection.getEnd(), dom.isBlock);\n      };\n\n      editor.on('keypress', e => {\n        let applyAttributes;\n\n        if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {\n          applyAttributes = getAttributeApplyFunction();\n          editor.getDoc().execCommand('delete', false, null);\n          applyAttributes();\n          e.preventDefault();\n          return false;\n        }\n      });\n      dom.bind(editor.getDoc(), 'cut', e => {\n        let applyAttributes;\n\n        if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {\n          applyAttributes = getAttributeApplyFunction();\n          Delay.setEditorTimeout(editor, () => {\n            applyAttributes();\n          });\n        }\n      });\n    };\n\n    const disableBackspaceIntoATable = () => {\n      editor.on('keydown', e => {\n        if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n          if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\n            const previousSibling = selection.getNode().previousSibling;\n\n            if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'table') {\n              e.preventDefault();\n              return false;\n            }\n          }\n        }\n      });\n    };\n\n    const removeBlockQuoteOnBackSpace = () => {\n      editor.on('keydown', e => {\n        let rng, parent;\n\n        if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {\n          return;\n        }\n\n        rng = selection.getRng();\n        const container = rng.startContainer;\n        const offset = rng.startOffset;\n        const root = dom.getRoot();\n        parent = container;\n\n        if (!rng.collapsed || offset !== 0) {\n          return;\n        }\n\n        while (parent && parent.parentNode && parent.parentNode.firstChild === parent && parent.parentNode !== root) {\n          parent = parent.parentNode;\n        }\n\n        if (parent.tagName === 'BLOCKQUOTE') {\n          editor.formatter.toggle('blockquote', null, parent);\n          rng = dom.createRng();\n          rng.setStart(container, 0);\n          rng.setEnd(container, 0);\n          selection.setRng(rng);\n        }\n      });\n    };\n\n    const setGeckoEditingOptions = () => {\n      const setOpts = () => {\n        setEditorCommandState('StyleWithCSS', false);\n        setEditorCommandState('enableInlineTableEditing', false);\n\n        if (!getObjectResizing(editor)) {\n          setEditorCommandState('enableObjectResizing', false);\n        }\n      };\n\n      if (!isReadOnly$1(editor)) {\n        editor.on('BeforeExecCommand mousedown', setOpts);\n      }\n    };\n\n    const addBrAfterLastLinks = () => {\n      const fixLinks = () => {\n        each(dom.select('a'), node => {\n          let parentNode = node.parentNode;\n          const root = dom.getRoot();\n\n          if (parentNode.lastChild === node) {\n            while (parentNode && !dom.isBlock(parentNode)) {\n              if (parentNode.parentNode.lastChild !== parentNode || parentNode === root) {\n                return;\n              }\n\n              parentNode = parentNode.parentNode;\n            }\n\n            dom.add(parentNode, 'br', {\n              'data-mce-bogus': 1\n            });\n          }\n        });\n      };\n\n      editor.on('SetContent ExecCommand', e => {\n        if (e.type === 'setcontent' || e.command === 'mceInsertLink') {\n          fixLinks();\n        }\n      });\n    };\n\n    const setDefaultBlockType = () => {\n      editor.on('init', () => {\n        setEditorCommandState('DefaultParagraphSeparator', getForcedRootBlock(editor));\n      });\n    };\n\n    const normalizeSelection = () => {\n      editor.on('keyup focusin mouseup', e => {\n        if (!VK.modifierPressed(e)) {\n          selection.normalize();\n        }\n      }, true);\n    };\n\n    const showBrokenImageIcon = () => {\n      editor.contentStyles.push('img:-moz-broken {' + '-moz-force-broken-image-icon:1;' + 'min-width:24px;' + 'min-height:24px' + '}');\n    };\n\n    const restoreFocusOnKeyDown = () => {\n      if (!editor.inline) {\n        editor.on('keydown', () => {\n          if (document.activeElement === document.body) {\n            editor.getWin().focus();\n          }\n        });\n      }\n    };\n\n    const bodyHeight = () => {\n      if (!editor.inline) {\n        editor.contentStyles.push('body {min-height: 150px}');\n        editor.on('click', e => {\n          let rng;\n\n          if (e.target.nodeName === 'HTML') {\n            rng = editor.selection.getRng();\n            editor.getBody().focus();\n            editor.selection.setRng(rng);\n            editor.selection.normalize();\n            editor.nodeChanged();\n          }\n        });\n      }\n    };\n\n    const blockCmdArrowNavigation = () => {\n      if (isMac) {\n        editor.on('keydown', e => {\n          if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {\n            e.preventDefault();\n            const selection = editor.selection.getSel();\n            selection.modify('move', e.keyCode === 37 ? 'backward' : 'forward', 'lineboundary');\n          }\n        });\n      }\n    };\n\n    const tapLinksAndImages = () => {\n      editor.on('click', e => {\n        let elm = e.target;\n\n        do {\n          if (elm.tagName === 'A') {\n            e.preventDefault();\n            return;\n          }\n        } while (elm = elm.parentNode);\n      });\n      editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');\n    };\n\n    const blockFormSubmitInsideEditor = () => {\n      editor.on('init', () => {\n        editor.dom.bind(editor.getBody(), 'submit', e => {\n          e.preventDefault();\n        });\n      });\n    };\n\n    const removeAppleInterchangeBrs = () => {\n      parser.addNodeFilter('br', nodes => {\n        let i = nodes.length;\n\n        while (i--) {\n          if (nodes[i].attr('class') === 'Apple-interchange-newline') {\n            nodes[i].remove();\n          }\n        }\n      });\n    };\n\n    const refreshContentEditable = noop;\n\n    const isHidden = () => {\n      if (!isGecko || editor.removed) {\n        return false;\n      }\n\n      const sel = editor.selection.getSel();\n      return !sel || !sel.rangeCount || sel.rangeCount === 0;\n    };\n\n    const setupRtc = () => {\n      if (isWebKit) {\n        documentElementEditingFocus();\n        selectControlElements();\n        blockFormSubmitInsideEditor();\n        selectAll();\n\n        if (isiOS) {\n          restoreFocusOnKeyDown();\n          bodyHeight();\n          tapLinksAndImages();\n        }\n      }\n\n      if (isGecko) {\n        focusBody();\n        setGeckoEditingOptions();\n        showBrokenImageIcon();\n        blockCmdArrowNavigation();\n      }\n    };\n\n    const setup = () => {\n      removeBlockQuoteOnBackSpace();\n      emptyEditorWhenDeleting();\n\n      if (!Env.windowsPhone) {\n        normalizeSelection();\n      }\n\n      if (isWebKit) {\n        documentElementEditingFocus();\n        selectControlElements();\n        setDefaultBlockType();\n        blockFormSubmitInsideEditor();\n        disableBackspaceIntoATable();\n        removeAppleInterchangeBrs();\n\n        if (isiOS) {\n          restoreFocusOnKeyDown();\n          bodyHeight();\n          tapLinksAndImages();\n        } else {\n          selectAll();\n        }\n      }\n\n      if (isGecko) {\n        removeHrOnBackspace();\n        focusBody();\n        removeStylesWhenDeletingAcrossBlockElements();\n        setGeckoEditingOptions();\n        addBrAfterLastLinks();\n        showBrokenImageIcon();\n        blockCmdArrowNavigation();\n        disableBackspaceIntoATable();\n      }\n    };\n\n    if (isRtc(editor)) {\n      setupRtc();\n    } else {\n      setup();\n    }\n\n    return {\n      refreshContentEditable,\n      isHidden\n    };\n  };\n\n  const DOM$6 = DOMUtils.DOM;\n\n  const appendStyle = (editor, text) => {\n    const body = SugarElement.fromDom(editor.getBody());\n    const container = getStyleContainer(getRootNode(body));\n    const style = SugarElement.fromTag('style');\n    set$2(style, 'type', 'text/css');\n    append$1(style, SugarElement.fromText(text));\n    append$1(container, style);\n    editor.on('remove', () => {\n      remove$5(style);\n    });\n  };\n\n  const getRootName = editor => editor.inline ? editor.getElement().nodeName.toLowerCase() : undefined;\n\n  const removeUndefined = obj => filter$5(obj, v => isUndefined(v) === false);\n\n  const mkParserSettings = editor => {\n    const getOption = editor.options.get;\n    const blobCache = editor.editorUpload.blobCache;\n    return removeUndefined({\n      allow_conditional_comments: getOption('allow_conditional_comments'),\n      allow_html_data_urls: getOption('allow_html_data_urls'),\n      allow_svg_data_urls: getOption('allow_svg_data_urls'),\n      allow_html_in_named_anchor: getOption('allow_html_in_named_anchor'),\n      allow_script_urls: getOption('allow_script_urls'),\n      allow_unsafe_link_target: getOption('allow_unsafe_link_target'),\n      convert_fonts_to_spans: getOption('convert_fonts_to_spans'),\n      fix_list_elements: getOption('fix_list_elements'),\n      font_size_legacy_values: getOption('font_size_legacy_values'),\n      forced_root_block: getOption('forced_root_block'),\n      forced_root_block_attrs: getOption('forced_root_block_attrs'),\n      preserve_cdata: getOption('preserve_cdata'),\n      remove_trailing_brs: getOption('remove_trailing_brs'),\n      inline_styles: getOption('inline_styles'),\n      root_name: getRootName(editor),\n      validate: true,\n      blob_cache: blobCache,\n      document: editor.getDoc()\n    });\n  };\n\n  const mkSchemaSettings = editor => {\n    const getOption = editor.options.get;\n    return removeUndefined({\n      custom_elements: getOption('custom_elements'),\n      extended_valid_elements: getOption('extended_valid_elements'),\n      invalid_elements: getOption('invalid_elements'),\n      invalid_styles: getOption('invalid_styles'),\n      schema: getOption('schema'),\n      valid_children: getOption('valid_children'),\n      valid_classes: getOption('valid_classes'),\n      valid_elements: getOption('valid_elements'),\n      valid_styles: getOption('valid_styles'),\n      verify_html: getOption('verify_html')\n    });\n  };\n\n  const mkSerializerSettings = editor => {\n    const getOption = editor.options.get;\n    return { ...mkParserSettings(editor),\n      ...mkSchemaSettings(editor),\n      ...removeUndefined({\n        url_converter: getOption('url_converter'),\n        url_converter_scope: getOption('url_converter_scope'),\n        element_format: getOption('element_format'),\n        entities: getOption('entities'),\n        entity_encoding: getOption('entity_encoding'),\n        indent: getOption('indent'),\n        indent_after: getOption('indent_after'),\n        indent_before: getOption('indent_before')\n      })\n    };\n  };\n\n  const createParser = editor => {\n    const parser = DomParser(mkParserSettings(editor), editor.schema);\n    parser.addAttributeFilter('src,href,style,tabindex', (nodes, name) => {\n      let i = nodes.length,\n          node,\n          value;\n      const dom = editor.dom;\n      const internalName = 'data-mce-' + name;\n\n      while (i--) {\n        node = nodes[i];\n        value = node.attr(name);\n\n        if (value && !node.attr(internalName)) {\n          if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {\n            continue;\n          }\n\n          if (name === 'style') {\n            value = dom.serializeStyle(dom.parseStyle(value), node.name);\n\n            if (!value.length) {\n              value = null;\n            }\n\n            node.attr(internalName, value);\n            node.attr(name, value);\n          } else if (name === 'tabindex') {\n            node.attr(internalName, value);\n            node.attr(name, null);\n          } else {\n            node.attr(internalName, editor.convertURL(value, name, node.name));\n          }\n        }\n      }\n    });\n    parser.addNodeFilter('script', nodes => {\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n        const type = node.attr('type') || 'no/type';\n\n        if (type.indexOf('mce-') !== 0) {\n          node.attr('type', 'mce-' + type);\n        }\n      }\n    });\n\n    if (editor.options.get('preserve_cdata')) {\n      parser.addNodeFilter('#cdata', nodes => {\n        let i = nodes.length;\n\n        while (i--) {\n          const node = nodes[i];\n          node.type = 8;\n          node.name = '#comment';\n          node.value = '[CDATA[' + editor.dom.encode(node.value) + ']]';\n        }\n      });\n    }\n\n    parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', nodes => {\n      let i = nodes.length;\n      const nonEmptyElements = editor.schema.getNonEmptyElements();\n\n      while (i--) {\n        const node = nodes[i];\n\n        if (node.isEmpty(nonEmptyElements) && node.getAll('br').length === 0) {\n          node.append(new AstNode('br', 1));\n        }\n      }\n    });\n    return parser;\n  };\n\n  const autoFocus = editor => {\n    const autoFocus = getAutoFocus(editor);\n\n    if (autoFocus) {\n      Delay.setEditorTimeout(editor, () => {\n        let focusEditor;\n\n        if (autoFocus === true) {\n          focusEditor = editor;\n        } else {\n          focusEditor = editor.editorManager.get(autoFocus);\n        }\n\n        if (!focusEditor.destroyed) {\n          focusEditor.focus();\n        }\n      }, 100);\n    }\n  };\n\n  const moveSelectionToFirstCaretPosition = editor => {\n    const root = editor.dom.getRoot();\n\n    if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {\n      firstPositionIn(root).each(pos => {\n        const node = pos.getNode();\n        const caretPos = isTable$3(node) ? firstPositionIn(node).getOr(pos) : pos;\n        editor.selection.setRng(caretPos.toRange());\n      });\n    }\n  };\n\n  const initEditor = editor => {\n    editor.bindPendingEventDelegates();\n    editor.initialized = true;\n    fireInit(editor);\n    editor.focus(true);\n    moveSelectionToFirstCaretPosition(editor);\n    editor.nodeChanged({\n      initial: true\n    });\n    const initInstanceCallback = getInitInstanceCallback(editor);\n\n    if (isFunction(initInstanceCallback)) {\n      initInstanceCallback.call(editor, editor);\n    }\n\n    autoFocus(editor);\n  };\n\n  const getStyleSheetLoader$1 = editor => editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;\n\n  const makeStylesheetLoadingPromises = (editor, css, framedFonts) => {\n    const promises = [getStyleSheetLoader$1(editor).loadAll(css)];\n\n    if (editor.inline) {\n      return promises;\n    } else {\n      return promises.concat([editor.ui.styleSheetLoader.loadAll(framedFonts)]);\n    }\n  };\n\n  const loadContentCss = editor => {\n    const styleSheetLoader = getStyleSheetLoader$1(editor);\n    const fontCss = getFontCss(editor);\n    const css = editor.contentCSS;\n\n    const removeCss = () => {\n      styleSheetLoader.unloadAll(css);\n\n      if (!editor.inline) {\n        editor.ui.styleSheetLoader.unloadAll(fontCss);\n      }\n    };\n\n    const loaded = () => {\n      if (editor.removed) {\n        removeCss();\n      } else {\n        editor.on('remove', removeCss);\n      }\n    };\n\n    if (editor.contentStyles.length > 0) {\n      let contentCssText = '';\n      Tools.each(editor.contentStyles, style => {\n        contentCssText += style + '\\r\\n';\n      });\n      editor.dom.addStyle(contentCssText);\n    }\n\n    const allStylesheets = Promise.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);\n    const contentStyle = getContentStyle(editor);\n\n    if (contentStyle) {\n      appendStyle(editor, contentStyle);\n    }\n\n    return allStylesheets;\n  };\n\n  const preInit = editor => {\n    const doc = editor.getDoc(),\n          body = editor.getBody();\n    firePreInit(editor);\n\n    if (!shouldBrowserSpellcheck(editor)) {\n      doc.body.spellcheck = false;\n      DOM$6.setAttrib(body, 'spellcheck', 'false');\n    }\n\n    editor.quirks = Quirks(editor);\n    firePostRender(editor);\n    const directionality = getDirectionality(editor);\n\n    if (directionality !== undefined) {\n      body.dir = directionality;\n    }\n\n    const protect = getProtect(editor);\n\n    if (protect) {\n      editor.on('BeforeSetContent', e => {\n        Tools.each(protect, pattern => {\n          e.content = e.content.replace(pattern, str => {\n            return '<!--mce:protected ' + escape(str) + '-->';\n          });\n        });\n      });\n    }\n\n    editor.on('SetContent', () => {\n      editor.addVisual(editor.getBody());\n    });\n    editor.on('compositionstart compositionend', e => {\n      editor.composing = e.type === 'compositionstart';\n    });\n  };\n\n  const loadInitialContent = editor => {\n    if (!isRtc(editor)) {\n      editor.load({\n        initial: true,\n        format: 'html'\n      });\n    }\n\n    editor.startContent = editor.getContent({\n      format: 'raw'\n    });\n  };\n\n  const initEditorWithInitialContent = editor => {\n    if (editor.removed !== true) {\n      loadInitialContent(editor);\n      initEditor(editor);\n    }\n  };\n\n  const contentBodyLoaded = editor => {\n    const targetElm = editor.getElement();\n    let doc = editor.getDoc();\n\n    if (editor.inline) {\n      DOM$6.addClass(targetElm, 'mce-content-body');\n      editor.contentDocument = doc = document;\n      editor.contentWindow = window;\n      editor.bodyElement = targetElm;\n      editor.contentAreaContainer = targetElm;\n    }\n\n    const body = editor.getBody();\n    body.disabled = true;\n    editor.readonly = isReadOnly$1(editor);\n\n    if (!editor.readonly) {\n      if (editor.inline && DOM$6.getStyle(body, 'position', true) === 'static') {\n        body.style.position = 'relative';\n      }\n\n      body.contentEditable = 'true';\n    }\n\n    body.disabled = false;\n    editor.editorUpload = EditorUpload(editor);\n    editor.schema = Schema(mkSchemaSettings(editor));\n    editor.dom = DOMUtils(doc, {\n      keep_values: true,\n      url_converter: editor.convertURL,\n      url_converter_scope: editor,\n      update_styles: true,\n      root_element: editor.inline ? editor.getBody() : null,\n      collect: () => editor.inline,\n      schema: editor.schema,\n      contentCssCors: shouldUseContentCssCors(editor),\n      referrerPolicy: getReferrerPolicy(editor),\n      onSetAttrib: e => {\n        editor.dispatch('SetAttrib', e);\n      }\n    });\n    editor.parser = createParser(editor);\n    editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);\n    editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);\n    editor.annotator = Annotator(editor);\n    editor.formatter = Formatter(editor);\n    editor.undoManager = UndoManager(editor);\n    editor._nodeChangeDispatcher = new NodeChange(editor);\n    editor._selectionOverrides = SelectionOverrides(editor);\n    setup$o(editor);\n    setup$6(editor);\n    setup$m(editor);\n\n    if (!isRtc(editor)) {\n      setup$5(editor);\n      setup$1(editor);\n    }\n\n    const caret = setup$b(editor);\n    setup$p(editor, caret);\n    setup$n(editor);\n    setup$q(editor);\n    setup$7(editor);\n    const setupRtcThunk = setup$s(editor);\n    preInit(editor);\n    setupRtcThunk.fold(() => {\n      loadContentCss(editor).then(() => initEditorWithInitialContent(editor));\n    }, setupRtc => {\n      editor.setProgressState(true);\n      loadContentCss(editor).then(() => {\n        setupRtc().then(_rtcMode => {\n          editor.setProgressState(false);\n          initEditorWithInitialContent(editor);\n          bindEvents(editor);\n        }, err => {\n          editor.notificationManager.open({\n            type: 'error',\n            text: String(err)\n          });\n          initEditorWithInitialContent(editor);\n          bindEvents(editor);\n        });\n      });\n    });\n  };\n\n  const initContentBody = (editor, skipWrite) => {\n    if (!editor.inline) {\n      editor.getElement().style.visibility = editor.orgVisibility;\n    }\n\n    if (!skipWrite && !editor.inline) {\n      const iframe = editor.iframeElement;\n      const binder = bind$1(SugarElement.fromDom(iframe), 'load', () => {\n        binder.unbind();\n        editor.contentDocument = iframe.contentDocument;\n        contentBodyLoaded(editor);\n      });\n      iframe.srcdoc = editor.iframeHTML;\n    } else {\n      contentBodyLoaded(editor);\n    }\n  };\n\n  const DOM$5 = DOMUtils.DOM;\n\n  const createIframeElement = (id, title, customAttrs, tabindex) => {\n    const iframe = SugarElement.fromTag('iframe');\n    tabindex.each(t => set$2(iframe, 'tabindex', t));\n    setAll$1(iframe, customAttrs);\n    setAll$1(iframe, {\n      id: id + '_ifr',\n      frameBorder: '0',\n      allowTransparency: 'true',\n      title\n    });\n    add$2(iframe, 'tox-edit-area__iframe');\n    return iframe;\n  };\n\n  const getIframeHtml = editor => {\n    let iframeHTML = getDocType(editor) + '<html><head>';\n\n    if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {\n      iframeHTML += '<base href=\"' + editor.documentBaseURI.getURI() + '\" />';\n    }\n\n    iframeHTML += '<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />';\n    const bodyId = getBodyId(editor);\n    const bodyClass = getBodyClass(editor);\n    const translatedAriaText = editor.translate(getIframeAriaText(editor));\n\n    if (getContentSecurityPolicy(editor)) {\n      iframeHTML += '<meta http-equiv=\"Content-Security-Policy\" content=\"' + getContentSecurityPolicy(editor) + '\" />';\n    }\n\n    iframeHTML += '</head>' + `<body id=\"${bodyId}\" class=\"mce-content-body ${bodyClass}\" data-id=\"${editor.id}\" aria-label=\"${translatedAriaText}\">` + '<br>' + '</body></html>';\n    return iframeHTML;\n  };\n\n  const createIframe = (editor, boxInfo) => {\n    const iframeTitle = editor.translate('Rich Text Area');\n    const tabindex = getOpt(SugarElement.fromDom(editor.getElement()), 'tabindex').bind(toInt);\n    const ifr = createIframeElement(editor.id, iframeTitle, getIframeAttrs(editor), tabindex).dom;\n\n    ifr.onload = () => {\n      ifr.onload = null;\n      editor.dispatch('load');\n    };\n\n    editor.contentAreaContainer = boxInfo.iframeContainer;\n    editor.iframeElement = ifr;\n    editor.iframeHTML = getIframeHtml(editor);\n    DOM$5.add(boxInfo.iframeContainer, ifr);\n  };\n\n  const init$1 = (editor, boxInfo) => {\n    createIframe(editor, boxInfo);\n\n    if (boxInfo.editorContainer) {\n      DOM$5.get(boxInfo.editorContainer).style.display = editor.orgDisplay;\n      editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);\n    }\n\n    editor.getElement().style.display = 'none';\n    DOM$5.setAttrib(editor.id, 'aria-hidden', 'true');\n    initContentBody(editor);\n  };\n\n  const DOM$4 = DOMUtils.DOM;\n\n  const initPlugin = (editor, initializedPlugins, plugin) => {\n    const Plugin = PluginManager.get(plugin);\n    const pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\\/$/, '');\n    plugin = Tools.trim(plugin);\n\n    if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {\n      if (editor.plugins[plugin]) {\n        return;\n      }\n\n      try {\n        const pluginInstance = Plugin(editor, pluginUrl) || {};\n        editor.plugins[plugin] = pluginInstance;\n\n        if (isFunction(pluginInstance.init)) {\n          pluginInstance.init(editor, pluginUrl);\n          initializedPlugins.push(plugin);\n        }\n      } catch (e) {\n        pluginInitError(editor, plugin, e);\n      }\n    }\n  };\n\n  const trimLegacyPrefix = name => {\n    return name.replace(/^\\-/, '');\n  };\n\n  const initPlugins = editor => {\n    const initializedPlugins = [];\n    each$g(getPlugins(editor), name => {\n      initPlugin(editor, initializedPlugins, trimLegacyPrefix(name));\n    });\n  };\n\n  const initIcons = editor => {\n    const iconPackName = Tools.trim(getIconPackName(editor));\n    const currentIcons = editor.ui.registry.getAll().icons;\n    const loadIcons = { ...IconManager.get('default').icons,\n      ...IconManager.get(iconPackName).icons\n    };\n    each$f(loadIcons, (svgData, icon) => {\n      if (!has$2(currentIcons, icon)) {\n        editor.ui.registry.addIcon(icon, svgData);\n      }\n    });\n  };\n\n  const initTheme = editor => {\n    const theme = getTheme(editor);\n\n    if (isString(theme)) {\n      const Theme = ThemeManager.get(theme);\n      editor.theme = Theme(editor, ThemeManager.urls[theme]) || {};\n\n      if (isFunction(editor.theme.init)) {\n        editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\\/$/, ''));\n      }\n    } else {\n      editor.theme = {};\n    }\n  };\n\n  const initModel = editor => {\n    const model = getModel(editor);\n    const Model = ModelManager.get(model);\n    editor.model = Model(editor, ModelManager.urls[model]);\n  };\n\n  const renderFromLoadedTheme = editor => {\n    return editor.theme.renderUI();\n  };\n\n  const renderFromThemeFunc = editor => {\n    const elm = editor.getElement();\n    const theme = getTheme(editor);\n    const info = theme(editor, elm);\n\n    if (info.editorContainer.nodeType) {\n      info.editorContainer.id = info.editorContainer.id || editor.id + '_parent';\n    }\n\n    if (info.iframeContainer && info.iframeContainer.nodeType) {\n      info.iframeContainer.id = info.iframeContainer.id || editor.id + '_iframecontainer';\n    }\n\n    info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;\n    return info;\n  };\n\n  const createThemeFalseResult = element => {\n    return {\n      editorContainer: element,\n      iframeContainer: element,\n      api: {}\n    };\n  };\n\n  const renderThemeFalseIframe = targetElement => {\n    const iframeContainer = DOM$4.create('div');\n    DOM$4.insertAfter(iframeContainer, targetElement);\n    return createThemeFalseResult(iframeContainer);\n  };\n\n  const renderThemeFalse = editor => {\n    const targetElement = editor.getElement();\n    return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);\n  };\n\n  const renderThemeUi = editor => {\n    const elm = editor.getElement();\n    editor.orgDisplay = elm.style.display;\n\n    if (isString(getTheme(editor))) {\n      return renderFromLoadedTheme(editor);\n    } else if (isFunction(getTheme(editor))) {\n      return renderFromThemeFunc(editor);\n    } else {\n      return renderThemeFalse(editor);\n    }\n  };\n\n  const augmentEditorUiApi = (editor, api) => {\n    const uiApiFacade = {\n      show: Optional.from(api.show).getOr(noop),\n      hide: Optional.from(api.hide).getOr(noop),\n      isEnabled: Optional.from(api.isEnabled).getOr(always),\n      setEnabled: state => {\n        if (!editor.mode.isReadOnly()) {\n          Optional.from(api.setEnabled).each(f => f(state));\n        }\n      }\n    };\n    editor.ui = { ...editor.ui,\n      ...uiApiFacade\n    };\n  };\n\n  const init = editor => {\n    editor.dispatch('ScriptsLoaded');\n    initIcons(editor);\n    initTheme(editor);\n    initModel(editor);\n    initPlugins(editor);\n    const renderInfo = renderThemeUi(editor);\n    augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));\n    const boxInfo = {\n      editorContainer: renderInfo.editorContainer,\n      iframeContainer: renderInfo.iframeContainer\n    };\n    editor.editorContainer = boxInfo.editorContainer ? boxInfo.editorContainer : null;\n    appendContentCssFromSettings(editor);\n\n    if (editor.inline) {\n      return initContentBody(editor);\n    } else {\n      return init$1(editor, boxInfo);\n    }\n  };\n\n  const DOM$3 = DOMUtils.DOM;\n\n  const hasSkipLoadPrefix = name => name.charAt(0) === '-';\n\n  const loadLanguage = (scriptLoader, editor) => {\n    const languageCode = getLanguageCode(editor);\n    const languageUrl = getLanguageUrl(editor);\n\n    if (I18n.hasCode(languageCode) === false && languageCode !== 'en') {\n      const url = isNotEmpty(languageUrl) ? languageUrl : `${editor.editorManager.baseURL}/langs/${languageCode}.js`;\n      scriptLoader.add(url).catch(() => {\n        languageLoadError(editor, url, languageCode);\n      });\n    }\n  };\n\n  const loadTheme = (editor, suffix) => {\n    const theme = getTheme(editor);\n\n    if (isString(theme) && !hasSkipLoadPrefix(theme) && !has$2(ThemeManager.urls, theme)) {\n      const themeUrl = getThemeUrl(editor);\n      const url = themeUrl ? editor.documentBaseURI.toAbsolute(themeUrl) : `themes/${theme}/theme${suffix}.js`;\n      ThemeManager.load(theme, url).catch(() => {\n        themeLoadError(editor, url, theme);\n      });\n    }\n  };\n\n  const loadModel = (editor, suffix) => {\n    const model = getModel(editor);\n\n    if (model !== 'plugin' && !has$2(ModelManager.urls, model)) {\n      const modelUrl = getModelUrl(editor);\n      const url = isString(modelUrl) ? editor.documentBaseURI.toAbsolute(modelUrl) : `models/${model}/model${suffix}.js`;\n      ModelManager.load(model, url).catch(() => {\n        modelLoadError(editor, url, model);\n      });\n    }\n  };\n\n  const getIconsUrlMetaFromUrl = editor => Optional.from(getIconsUrl(editor)).filter(isNotEmpty).map(url => ({\n    url,\n    name: Optional.none()\n  }));\n\n  const getIconsUrlMetaFromName = (editor, name, suffix) => Optional.from(name).filter(name => isNotEmpty(name) && !IconManager.has(name)).map(name => ({\n    url: `${editor.editorManager.baseURL}/icons/${name}/icons${suffix}.js`,\n    name: Optional.some(name)\n  }));\n\n  const loadIcons = (scriptLoader, editor, suffix) => {\n    const defaultIconsUrl = getIconsUrlMetaFromName(editor, 'default', suffix);\n    const customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(() => getIconsUrlMetaFromName(editor, getIconPackName(editor), ''));\n    each$g(cat([defaultIconsUrl, customIconsUrl]), urlMeta => {\n      scriptLoader.add(urlMeta.url).catch(() => {\n        iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());\n      });\n    });\n  };\n\n  const loadPlugins = (editor, suffix) => {\n    const loadPlugin = (name, url) => {\n      PluginManager.load(name, url).catch(() => {\n        pluginLoadError(editor, url, name);\n      });\n    };\n\n    each$f(getExternalPlugins$1(editor), (url, name) => {\n      loadPlugin(name, url);\n      editor.options.set('plugins', getPlugins(editor).concat(name));\n    });\n    each$g(getPlugins(editor), plugin => {\n      plugin = Tools.trim(plugin);\n\n      if (plugin && !PluginManager.urls[plugin] && !hasSkipLoadPrefix(plugin)) {\n        loadPlugin(plugin, `plugins/${plugin}/plugin${suffix}.js`);\n      }\n    });\n  };\n\n  const isThemeLoaded = editor => {\n    const theme = getTheme(editor);\n    return !isString(theme) || isNonNullable(ThemeManager.get(theme));\n  };\n\n  const isModelLoaded = editor => {\n    const model = getModel(editor);\n    return isNonNullable(ModelManager.get(model));\n  };\n\n  const loadScripts = (editor, suffix) => {\n    const scriptLoader = ScriptLoader.ScriptLoader;\n\n    const initEditor = () => {\n      if (!editor.removed && isThemeLoaded(editor) && isModelLoaded(editor)) {\n        init(editor);\n      }\n    };\n\n    loadTheme(editor, suffix);\n    loadModel(editor, suffix);\n    loadLanguage(scriptLoader, editor);\n    loadIcons(scriptLoader, editor, suffix);\n    loadPlugins(editor, suffix);\n    scriptLoader.loadQueue().then(initEditor, initEditor);\n  };\n\n  const getStyleSheetLoader = (element, editor) => instance.forElement(element, {\n    contentCssCors: hasContentCssCors(editor),\n    referrerPolicy: getReferrerPolicy(editor)\n  });\n\n  const render = editor => {\n    const id = editor.id;\n    I18n.setCode(getLanguageCode(editor));\n\n    const readyHandler = () => {\n      DOM$3.unbind(window, 'ready', readyHandler);\n      editor.render();\n    };\n\n    if (!EventUtils.Event.domLoaded) {\n      DOM$3.bind(window, 'ready', readyHandler);\n      return;\n    }\n\n    if (!editor.getElement()) {\n      return;\n    }\n\n    const element = SugarElement.fromDom(editor.getElement());\n    const snapshot = clone$4(element);\n    editor.on('remove', () => {\n      eachr(element.dom.attributes, attr => remove$a(element, attr.name));\n      setAll$1(element, snapshot);\n    });\n    editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);\n\n    if (!isInline(editor)) {\n      editor.orgVisibility = editor.getElement().style.visibility;\n      editor.getElement().style.visibility = 'hidden';\n    } else {\n      editor.inline = true;\n    }\n\n    const form = editor.getElement().form || DOM$3.getParent(id, 'form');\n\n    if (form) {\n      editor.formElement = form;\n\n      if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {\n        DOM$3.insertAfter(DOM$3.create('input', {\n          type: 'hidden',\n          name: id\n        }), id);\n        editor.hasHiddenInput = true;\n      }\n\n      editor.formEventDelegate = e => {\n        editor.dispatch(e.type, e);\n      };\n\n      DOM$3.bind(form, 'submit reset', editor.formEventDelegate);\n      editor.on('reset', () => {\n        editor.resetContent();\n      });\n\n      if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {\n        form._mceOldSubmit = form.submit;\n\n        form.submit = () => {\n          editor.editorManager.triggerSave();\n          editor.setDirty(false);\n          return form._mceOldSubmit(form);\n        };\n      }\n    }\n\n    editor.windowManager = WindowManager(editor);\n    editor.notificationManager = NotificationManager(editor);\n\n    if (isEncodingXml(editor)) {\n      editor.on('GetContent', e => {\n        if (e.save) {\n          e.content = DOM$3.encode(e.content);\n        }\n      });\n    }\n\n    if (shouldAddFormSubmitTrigger(editor)) {\n      editor.on('submit', () => {\n        if (editor.initialized) {\n          editor.save();\n        }\n      });\n    }\n\n    if (shouldAddUnloadTrigger(editor)) {\n      editor._beforeUnload = () => {\n        if (editor.initialized && !editor.destroyed && !editor.isHidden()) {\n          editor.save({\n            format: 'raw',\n            no_events: true,\n            set_dirty: false\n          });\n        }\n      };\n\n      editor.editorManager.on('BeforeUnload', editor._beforeUnload);\n    }\n\n    editor.editorManager.add(editor);\n    loadScripts(editor, editor.suffix);\n  };\n\n  const sectionResult = (sections, settings) => ({\n    sections: constant(sections),\n    options: constant(settings)\n  });\n\n  const deviceDetection = detect$2().deviceType;\n  const isPhone = deviceDetection.isPhone();\n  const isTablet = deviceDetection.isTablet();\n\n  const normalizePlugins = plugins => {\n    if (isNullable(plugins)) {\n      return [];\n    } else {\n      const pluginNames = isArray$1(plugins) ? plugins : plugins.split(/[ ,]/);\n      const trimmedPlugins = map$3(pluginNames, trim$3);\n      return filter$6(trimmedPlugins, isNotEmpty);\n    }\n  };\n\n  const extractSections = (keys, options) => {\n    const result = bifilter(options, (value, key) => {\n      return contains$2(keys, key);\n    });\n    return sectionResult(result.t, result.f);\n  };\n\n  const getSection = function (sectionResult, name) {\n    let defaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const sections = sectionResult.sections();\n    const sectionOptions = get$a(sections, name).getOr({});\n    return Tools.extend({}, defaults, sectionOptions);\n  };\n\n  const hasSection = (sectionResult, name) => {\n    return has$2(sectionResult.sections(), name);\n  };\n\n  const getSectionConfig = (sectionResult, name) => {\n    return hasSection(sectionResult, name) ? sectionResult.sections()[name] : {};\n  };\n\n  const getMobileOverrideOptions = (mobileOptions, isPhone) => {\n    const defaultMobileOptions = {\n      table_grid: false,\n      object_resizing: false,\n      resize: false,\n      toolbar_mode: get$a(mobileOptions, 'toolbar_mode').getOr('scrolling'),\n      toolbar_sticky: false\n    };\n    const defaultPhoneOptions = {\n      menubar: false\n    };\n    return { ...defaultMobileOptions,\n      ...(isPhone ? defaultPhoneOptions : {})\n    };\n  };\n\n  const getExternalPlugins = (overrideOptions, options) => {\n    var _a;\n\n    const userDefinedExternalPlugins = (_a = options.external_plugins) !== null && _a !== void 0 ? _a : {};\n\n    if (overrideOptions && overrideOptions.external_plugins) {\n      return Tools.extend({}, overrideOptions.external_plugins, userDefinedExternalPlugins);\n    } else {\n      return userDefinedExternalPlugins;\n    }\n  };\n\n  const combinePlugins = (forcedPlugins, plugins) => {\n    return [].concat(normalizePlugins(forcedPlugins)).concat(normalizePlugins(plugins));\n  };\n\n  const getPlatformPlugins = (isMobileDevice, sectionResult, desktopPlugins, mobilePlugins) => {\n    if (isMobileDevice && hasSection(sectionResult, 'mobile')) {\n      return mobilePlugins;\n    } else {\n      return desktopPlugins;\n    }\n  };\n\n  const processPlugins = (isMobileDevice, sectionResult, defaultOverrideOptions, options) => {\n    const forcedPlugins = normalizePlugins(defaultOverrideOptions.forced_plugins);\n    const desktopPlugins = normalizePlugins(options.plugins);\n    const mobileConfig = getSectionConfig(sectionResult, 'mobile');\n    const mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;\n    const platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult, desktopPlugins, mobilePlugins);\n    const combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);\n    return Tools.extend(options, {\n      forced_plugins: forcedPlugins,\n      plugins: combinedPlugins\n    });\n  };\n\n  const isOnMobile = (isMobileDevice, sectionResult) => {\n    return isMobileDevice && hasSection(sectionResult, 'mobile');\n  };\n\n  const combineOptions = (isMobileDevice, isPhone, defaultOptions, defaultOverrideOptions, options) => {\n    var _a;\n\n    const deviceOverrideOptions = isMobileDevice ? {\n      mobile: getMobileOverrideOptions((_a = options.mobile) !== null && _a !== void 0 ? _a : {}, isPhone)\n    } : {};\n    const sectionResult = extractSections(['mobile'], deepMerge(deviceOverrideOptions, options));\n    const extendedOptions = Tools.extend(defaultOptions, defaultOverrideOptions, sectionResult.options(), isOnMobile(isMobileDevice, sectionResult) ? getSection(sectionResult, 'mobile') : {}, {\n      external_plugins: getExternalPlugins(defaultOverrideOptions, sectionResult.options())\n    });\n    return processPlugins(isMobileDevice, sectionResult, defaultOverrideOptions, extendedOptions);\n  };\n\n  const normalizeOptions = (defaultOverrideOptions, options) => combineOptions(isPhone || isTablet, isPhone, options, defaultOverrideOptions, options);\n\n  const addVisual = (editor, elm) => addVisual$1(editor, elm);\n\n  const registerExecCommands$3 = editor => {\n    const toggleFormat = (name, value) => {\n      editor.formatter.toggle(name, value);\n      editor.nodeChanged();\n    };\n\n    const toggleAlign = align => () => {\n      each$g('left,center,right,justify'.split(','), name => {\n        if (align !== name) {\n          editor.formatter.remove('align' + name);\n        }\n      });\n\n      if (align !== 'none') {\n        toggleFormat('align' + align);\n      }\n    };\n\n    editor.editorCommands.addCommands({\n      JustifyLeft: toggleAlign('left'),\n      JustifyCenter: toggleAlign('center'),\n      JustifyRight: toggleAlign('right'),\n      JustifyFull: toggleAlign('justify'),\n      JustifyNone: toggleAlign('none')\n    });\n  };\n\n  const registerQueryStateCommands$1 = editor => {\n    const alignStates = name => () => {\n      const selection = editor.selection;\n      const nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();\n      return exists(nodes, node => isNonNullable(editor.formatter.matchNode(node, name)));\n    };\n\n    editor.editorCommands.addCommands({\n      JustifyLeft: alignStates('alignleft'),\n      JustifyCenter: alignStates('aligncenter'),\n      JustifyRight: alignStates('alignright'),\n      JustifyFull: alignStates('alignjustify')\n    }, 'state');\n  };\n\n  const registerCommands$a = editor => {\n    registerExecCommands$3(editor);\n    registerQueryStateCommands$1(editor);\n  };\n\n  const registerCommands$9 = editor => {\n    editor.editorCommands.addCommands({\n      'Cut,Copy,Paste': command => {\n        const doc = editor.getDoc();\n        let failed;\n\n        try {\n          doc.execCommand(command);\n        } catch (ex) {\n          failed = true;\n        }\n\n        if (command === 'paste' && !doc.queryCommandEnabled(command)) {\n          failed = true;\n        }\n\n        if (failed || !doc.queryCommandSupported(command)) {\n          let msg = editor.translate(`Your browser doesn't support direct access to the clipboard. ` + 'Please use the Ctrl+X/C/V keyboard shortcuts instead.');\n\n          if (Env.os.isMacOS() || Env.os.isiOS()) {\n            msg = msg.replace(/Ctrl\\+/g, '\\u2318+');\n          }\n\n          editor.notificationManager.open({\n            text: msg,\n            type: 'error'\n          });\n        }\n      }\n    });\n  };\n\n  const trimOrPadLeftRight = (dom, rng, html) => {\n    const root = SugarElement.fromDom(dom.getRoot());\n\n    if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng))) {\n      html = html.replace(/^ /, '&nbsp;');\n    } else {\n      html = html.replace(/^&nbsp;/, ' ');\n    }\n\n    if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng))) {\n      html = html.replace(/(&nbsp;| )(<br( \\/)>)?$/, '&nbsp;');\n    } else {\n      html = html.replace(/&nbsp;(<br( \\/)?>)?$/, ' ');\n    }\n\n    return html;\n  };\n\n  const processValue$1 = value => {\n    if (typeof value !== 'string') {\n      const details = Tools.extend({\n        paste: value.paste,\n        data: {\n          paste: value.paste\n        }\n      }, value);\n      return {\n        content: value.content,\n        details\n      };\n    }\n\n    return {\n      content: value,\n      details: {}\n    };\n  };\n\n  const trimOrPad = (editor, value) => {\n    const selection = editor.selection;\n    const dom = editor.dom;\n\n    if (/^ | $/.test(value)) {\n      return trimOrPadLeftRight(dom, selection.getRng(), value);\n    } else {\n      return value;\n    }\n  };\n\n  const insertAtCaret = (editor, value) => {\n    const {\n      content,\n      details\n    } = processValue$1(value);\n    preProcessSetContent(editor, {\n      content: trimOrPad(editor, content),\n      format: 'html',\n      set: false,\n      selection: true,\n      paste: details.paste\n    }).each(args => {\n      const insertedContent = insertContent$1(editor, args.content, details);\n      postProcessSetContent(editor, insertedContent, args);\n      editor.addVisual();\n    });\n  };\n\n  const registerCommands$8 = editor => {\n    editor.editorCommands.addCommands({\n      mceCleanup: () => {\n        const bm = editor.selection.getBookmark();\n        editor.setContent(editor.getContent());\n        editor.selection.moveToBookmark(bm);\n      },\n      insertImage: (_command, _ui, value) => {\n        insertAtCaret(editor, editor.dom.createHTML('img', {\n          src: value\n        }));\n      },\n      insertHorizontalRule: () => {\n        editor.execCommand('mceInsertContent', false, '<hr>');\n      },\n      insertText: (_command, _ui, value) => {\n        insertAtCaret(editor, editor.dom.encode(value));\n      },\n      insertHTML: (_command, _ui, value) => {\n        insertAtCaret(editor, value);\n      },\n      mceInsertContent: (_command, _ui, value) => {\n        insertAtCaret(editor, value);\n      },\n      mceSetContent: (_command, _ui, value) => {\n        editor.setContent(value);\n      },\n      mceReplaceContent: (_command, _ui, value) => {\n        editor.execCommand('mceInsertContent', false, value.replace(/\\{\\$selection\\}/g, editor.selection.getContent({\n          format: 'text'\n        })));\n      },\n      mceNewDocument: () => {\n        editor.setContent('');\n      }\n    });\n  };\n\n  const legacyPropNames = {\n    'font-size': 'size',\n    'font-family': 'face'\n  };\n\n  const getSpecifiedFontProp = (propName, rootElm, elm) => {\n    const getProperty = elm => getRaw$1(elm, propName).orThunk(() => {\n      if (name(elm) === 'font') {\n        return get$a(legacyPropNames, propName).bind(legacyPropName => getOpt(elm, legacyPropName));\n      } else {\n        return Optional.none();\n      }\n    });\n\n    const isRoot = elm => eq(SugarElement.fromDom(rootElm), elm);\n\n    return closest$2(SugarElement.fromDom(elm), elm => getProperty(elm), isRoot);\n  };\n\n  const normalizeFontFamily = fontFamily => fontFamily.replace(/[\\'\\\"\\\\]/g, '').replace(/,\\s+/g, ',');\n\n  const getComputedFontProp = (propName, elm) => Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));\n\n  const getFontProp = propName => (rootElm, elm) => Optional.from(elm).map(SugarElement.fromDom).filter(isElement$7).bind(element => getSpecifiedFontProp(propName, rootElm, element.dom).or(getComputedFontProp(propName, element.dom))).getOr('');\n\n  const getFontSize = getFontProp('font-size');\n  const getFontFamily = compose(normalizeFontFamily, getFontProp('font-family'));\n\n  const findFirstCaretElement = editor => firstPositionIn(editor.getBody()).map(caret => {\n    const container = caret.container();\n    return isText$8(container) ? container.parentNode : container;\n  });\n\n  const getCaretElement = editor => Optional.from(editor.selection.getRng()).bind(rng => {\n    const root = editor.getBody();\n    const atStartOfNode = rng.startContainer === root && rng.startOffset === 0;\n    return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));\n  });\n\n  const bindRange = (editor, binder) => getCaretElement(editor).orThunk(curry(findFirstCaretElement, editor)).map(SugarElement.fromDom).filter(isElement$7).bind(binder);\n\n  const mapRange = (editor, mapper) => bindRange(editor, compose1(Optional.some, mapper));\n\n  const fromFontSizeNumber = (editor, value) => {\n    if (/^[0-9.]+$/.test(value)) {\n      const fontSizeNumber = parseInt(value, 10);\n\n      if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {\n        const fontSizes = getFontStyleValues(editor);\n        const fontClasses = getFontSizeClasses(editor);\n\n        if (fontClasses) {\n          return fontClasses[fontSizeNumber - 1] || value;\n        } else {\n          return fontSizes[fontSizeNumber - 1] || value;\n        }\n      } else {\n        return value;\n      }\n    } else {\n      return value;\n    }\n  };\n\n  const normalizeFontNames = font => {\n    const fonts = font.split(/\\s*,\\s*/);\n    return map$3(fonts, font => {\n      if (font.indexOf(' ') !== -1 && !(startsWith(font, '\"') || startsWith(font, `'`))) {\n        return `'${font}'`;\n      } else {\n        return font;\n      }\n    }).join(',');\n  };\n\n  const fontNameAction = (editor, value) => {\n    const font = fromFontSizeNumber(editor, value);\n    editor.formatter.toggle('fontname', {\n      value: normalizeFontNames(font)\n    });\n    editor.nodeChanged();\n  };\n\n  const fontNameQuery = editor => mapRange(editor, elm => getFontFamily(editor.getBody(), elm.dom)).getOr('');\n\n  const fontSizeAction = (editor, value) => {\n    editor.formatter.toggle('fontsize', {\n      value: fromFontSizeNumber(editor, value)\n    });\n    editor.nodeChanged();\n  };\n\n  const fontSizeQuery = editor => mapRange(editor, elm => getFontSize(editor.getBody(), elm.dom)).getOr('');\n\n  const lineHeightQuery = editor => mapRange(editor, elm => {\n    const root = SugarElement.fromDom(editor.getBody());\n    const specifiedStyle = closest$2(elm, elm => getRaw$1(elm, 'line-height'), curry(eq, root));\n\n    const computedStyle = () => {\n      const lineHeight = parseFloat(get$7(elm, 'line-height'));\n      const fontSize = parseFloat(get$7(elm, 'font-size'));\n      return String(lineHeight / fontSize);\n    };\n\n    return specifiedStyle.getOrThunk(computedStyle);\n  }).getOr('');\n\n  const lineHeightAction = (editor, lineHeight) => {\n    editor.formatter.toggle('lineheight', {\n      value: String(lineHeight)\n    });\n    editor.nodeChanged();\n  };\n\n  const registerExecCommands$2 = editor => {\n    const toggleFormat = (name, value) => {\n      editor.formatter.toggle(name, value);\n      editor.nodeChanged();\n    };\n\n    editor.editorCommands.addCommands({\n      'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => {\n        toggleFormat(command);\n      },\n      'ForeColor,HiliteColor': (command, _ui, value) => {\n        toggleFormat(command, {\n          value\n        });\n      },\n      'BackColor': (_command, _ui, value) => {\n        toggleFormat('hilitecolor', {\n          value\n        });\n      },\n      'FontName': (_command, _ui, value) => {\n        fontNameAction(editor, value);\n      },\n      'FontSize': (_command, _ui, value) => {\n        fontSizeAction(editor, value);\n      },\n      'LineHeight': (_command, _ui, value) => {\n        lineHeightAction(editor, value);\n      },\n      'Lang': (command, _ui, lang) => {\n        toggleFormat(command, {\n          value: lang.code,\n          customValue: lang.customCode\n        });\n      },\n      'RemoveFormat': command => {\n        editor.formatter.remove(command);\n      },\n      'mceBlockQuote': () => {\n        toggleFormat('blockquote');\n      },\n      'FormatBlock': (_command, _ui, value) => {\n        toggleFormat(isString(value) ? value : 'p');\n      },\n      'mceToggleFormat': (_command, _ui, value) => {\n        toggleFormat(value);\n      }\n    });\n  };\n\n  const registerQueryValueCommands = editor => {\n    const isFormatMatch = name => editor.formatter.match(name);\n\n    editor.editorCommands.addCommands({\n      'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => isFormatMatch(command),\n      'mceBlockQuote': () => isFormatMatch('blockquote')\n    }, 'state');\n    editor.editorCommands.addQueryValueHandler('FontName', () => fontNameQuery(editor));\n    editor.editorCommands.addQueryValueHandler('FontSize', () => fontSizeQuery(editor));\n    editor.editorCommands.addQueryValueHandler('LineHeight', () => lineHeightQuery(editor));\n  };\n\n  const registerCommands$7 = editor => {\n    registerExecCommands$2(editor);\n    registerQueryValueCommands(editor);\n  };\n\n  const registerCommands$6 = editor => {\n    editor.editorCommands.addCommands({\n      mceAddUndoLevel: () => {\n        editor.undoManager.add();\n      },\n      mceEndUndoLevel: () => {\n        editor.undoManager.add();\n      },\n      Undo: () => {\n        editor.undoManager.undo();\n      },\n      Redo: () => {\n        editor.undoManager.redo();\n      }\n    });\n  };\n\n  const registerCommands$5 = editor => {\n    editor.editorCommands.addCommands({\n      Indent: () => {\n        indent(editor);\n      },\n      Outdent: () => {\n        outdent(editor);\n      }\n    });\n    editor.editorCommands.addCommands({\n      Outdent: () => canOutdent(editor)\n    }, 'state');\n  };\n\n  const registerCommands$4 = editor => {\n    const applyLinkToSelection = (_command, _ui, value) => {\n      const linkDetails = isString(value) ? {\n        href: value\n      } : value;\n      const anchor = editor.dom.getParent(editor.selection.getNode(), 'a');\n\n      if (isObject(linkDetails) && isString(linkDetails.href)) {\n        linkDetails.href = linkDetails.href.replace(/ /g, '%20');\n\n        if (!anchor || !linkDetails.href) {\n          editor.formatter.remove('link');\n        }\n\n        if (linkDetails.href) {\n          editor.formatter.apply('link', linkDetails, anchor);\n        }\n      }\n    };\n\n    editor.editorCommands.addCommands({\n      unlink: () => {\n        if (editor.selection.isCollapsed()) {\n          const elm = editor.dom.getParent(editor.selection.getStart(), 'a');\n\n          if (elm) {\n            editor.dom.remove(elm, true);\n          }\n\n          return;\n        }\n\n        editor.formatter.remove('link');\n      },\n      mceInsertLink: applyLinkToSelection,\n      createLink: applyLinkToSelection\n    });\n  };\n\n  const registerExecCommands$1 = editor => {\n    editor.editorCommands.addCommands({\n      'InsertUnorderedList,InsertOrderedList': command => {\n        editor.getDoc().execCommand(command);\n        const listElm = editor.dom.getParent(editor.selection.getNode(), 'ol,ul');\n\n        if (listElm) {\n          const listParent = listElm.parentNode;\n\n          if (/^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {\n            const bm = editor.selection.getBookmark();\n            editor.dom.split(listParent, listElm);\n            editor.selection.moveToBookmark(bm);\n          }\n        }\n      }\n    });\n  };\n\n  const registerQueryStateCommands = editor => {\n    editor.editorCommands.addCommands({\n      'InsertUnorderedList,InsertOrderedList': command => {\n        const list = editor.dom.getParent(editor.selection.getNode(), 'ul,ol');\n        return list && (command === 'insertunorderedlist' && list.tagName === 'UL' || command === 'insertorderedlist' && list.tagName === 'OL');\n      }\n    }, 'state');\n  };\n\n  const registerCommands$3 = editor => {\n    registerExecCommands$1(editor);\n    registerQueryStateCommands(editor);\n  };\n\n  const registerCommands$2 = editor => {\n    editor.editorCommands.addCommands({\n      insertParagraph: () => {\n        insert(editor);\n      },\n      mceInsertNewLine: (_command, _ui, value) => {\n        insert(editor, value);\n      },\n      InsertLineBreak: (_command, _ui, value) => {\n        insert$1(editor, value);\n      }\n    });\n  };\n\n  const registerCommands$1 = editor => {\n    editor.editorCommands.addCommands({\n      mceSelectNodeDepth: (_command, _ui, value) => {\n        let counter = 0;\n        editor.dom.getParent(editor.selection.getNode(), node => {\n          if (node.nodeType === 1 && counter++ === value) {\n            editor.selection.select(node);\n            return false;\n          }\n        }, editor.getBody());\n      },\n      mceSelectNode: (_command, _ui, value) => {\n        editor.selection.select(value);\n      },\n      selectAll: () => {\n        const editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue$4);\n\n        if (editingHost) {\n          const rng = editor.dom.createRng();\n          rng.selectNodeContents(editingHost);\n          editor.selection.setRng(rng);\n        }\n      }\n    });\n  };\n\n  const registerExecCommands = editor => {\n    editor.editorCommands.addCommands({\n      mceRemoveNode: (_command, _ui, value) => {\n        const node = value !== null && value !== void 0 ? value : editor.selection.getNode();\n\n        if (node !== editor.getBody()) {\n          const bm = editor.selection.getBookmark();\n          editor.dom.remove(node, true);\n          editor.selection.moveToBookmark(bm);\n        }\n      },\n      mcePrint: () => {\n        editor.getWin().print();\n      },\n      mceFocus: (_command, _ui, value) => {\n        focus(editor, value);\n      },\n      mceToggleVisualAid: () => {\n        editor.hasVisual = !editor.hasVisual;\n        editor.addVisual();\n      }\n    });\n  };\n\n  const registerCommands = editor => {\n    registerCommands$a(editor);\n    registerCommands$9(editor);\n    registerCommands$6(editor);\n    registerCommands$1(editor);\n    registerCommands$8(editor);\n    registerCommands$4(editor);\n    registerCommands$5(editor);\n    registerCommands$2(editor);\n    registerCommands$3(editor);\n    registerCommands$7(editor);\n    registerExecCommands(editor);\n  };\n\n  class EditorCommands {\n    constructor(editor) {\n      this.commands = {\n        state: {},\n        exec: {},\n        value: {}\n      };\n      this.editor = editor;\n    }\n\n    execCommand(command, ui, value, args) {\n      const editor = this.editor;\n      const lowerCaseCommand = command.toLowerCase();\n      const skipFocus = args === null || args === void 0 ? void 0 : args.skip_focus;\n\n      if (editor.removed) {\n        return false;\n      }\n\n      if (lowerCaseCommand !== 'mcefocus') {\n        if (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(lowerCaseCommand) && !skipFocus) {\n          editor.focus();\n        } else {\n          restore(editor);\n        }\n      }\n\n      const eventArgs = editor.dispatch('BeforeExecCommand', {\n        command,\n        ui,\n        value\n      });\n\n      if (eventArgs.isDefaultPrevented()) {\n        return false;\n      }\n\n      const func = this.commands.exec[lowerCaseCommand];\n\n      if (isFunction(func)) {\n        func(lowerCaseCommand, ui, value);\n        editor.dispatch('ExecCommand', {\n          command,\n          ui,\n          value\n        });\n        return true;\n      }\n\n      return false;\n    }\n\n    queryCommandState(command) {\n      if (this.editor.quirks.isHidden() || this.editor.removed) {\n        return false;\n      }\n\n      const lowerCaseCommand = command.toLowerCase();\n      const func = this.commands.state[lowerCaseCommand];\n\n      if (isFunction(func)) {\n        return func(lowerCaseCommand);\n      }\n\n      return false;\n    }\n\n    queryCommandValue(command) {\n      if (this.editor.quirks.isHidden() || this.editor.removed) {\n        return '';\n      }\n\n      const lowerCaseCommand = command.toLowerCase();\n      const func = this.commands.value[lowerCaseCommand];\n\n      if (isFunction(func)) {\n        return func(lowerCaseCommand);\n      }\n\n      return '';\n    }\n\n    addCommands(commandList) {\n      let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'exec';\n      const commands = this.commands;\n      each$f(commandList, (callback, command) => {\n        each$g(command.toLowerCase().split(','), command => {\n          commands[type][command] = callback;\n        });\n      });\n    }\n\n    addCommand(command, callback, scope) {\n      const lowerCaseCommand = command.toLowerCase();\n\n      this.commands.exec[lowerCaseCommand] = (_command, ui, value) => callback.call(scope !== null && scope !== void 0 ? scope : this.editor, ui, value);\n    }\n\n    queryCommandSupported(command) {\n      const lowerCaseCommand = command.toLowerCase();\n\n      if (this.commands.exec[lowerCaseCommand]) {\n        return true;\n      }\n\n      return false;\n    }\n\n    addQueryStateHandler(command, callback, scope) {\n      this.commands.state[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\n    }\n\n    addQueryValueHandler(command, callback, scope) {\n      this.commands.value[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\n    }\n\n  }\n\n  const internalContentEditableAttr = 'data-mce-contenteditable';\n\n  const toggleClass = (elm, cls, state) => {\n    if (has(elm, cls) && state === false) {\n      remove$7(elm, cls);\n    } else if (state) {\n      add$2(elm, cls);\n    }\n  };\n\n  const setEditorCommandState = (editor, cmd, state) => {\n    try {\n      editor.getDoc().execCommand(cmd, false, String(state));\n    } catch (ex) {}\n  };\n\n  const setContentEditable = (elm, state) => {\n    elm.dom.contentEditable = state ? 'true' : 'false';\n  };\n\n  const switchOffContentEditableTrue = elm => {\n    each$g(descendants(elm, '*[contenteditable=\"true\"]'), elm => {\n      set$2(elm, internalContentEditableAttr, 'true');\n      setContentEditable(elm, false);\n    });\n  };\n\n  const switchOnContentEditableTrue = elm => {\n    each$g(descendants(elm, `*[${internalContentEditableAttr}=\"true\"]`), elm => {\n      remove$a(elm, internalContentEditableAttr);\n      setContentEditable(elm, true);\n    });\n  };\n\n  const removeFakeSelection = editor => {\n    Optional.from(editor.selection.getNode()).each(elm => {\n      elm.removeAttribute('data-mce-selected');\n    });\n  };\n\n  const restoreFakeSelection = editor => {\n    editor.selection.setRng(editor.selection.getRng());\n  };\n\n  const toggleReadOnly = (editor, state) => {\n    const body = SugarElement.fromDom(editor.getBody());\n    toggleClass(body, 'mce-content-readonly', state);\n\n    if (state) {\n      editor.selection.controlSelection.hideResizeRect();\n\n      editor._selectionOverrides.hideFakeCaret();\n\n      removeFakeSelection(editor);\n      editor.readonly = true;\n      setContentEditable(body, false);\n      switchOffContentEditableTrue(body);\n    } else {\n      editor.readonly = false;\n      setContentEditable(body, true);\n      switchOnContentEditableTrue(body);\n      setEditorCommandState(editor, 'StyleWithCSS', false);\n      setEditorCommandState(editor, 'enableInlineTableEditing', false);\n      setEditorCommandState(editor, 'enableObjectResizing', false);\n\n      if (hasEditorOrUiFocus(editor)) {\n        editor.focus();\n      }\n\n      restoreFakeSelection(editor);\n      editor.nodeChanged();\n    }\n  };\n\n  const isReadOnly = editor => editor.readonly;\n\n  const registerFilters = editor => {\n    editor.parser.addAttributeFilter('contenteditable', nodes => {\n      if (isReadOnly(editor)) {\n        each$g(nodes, node => {\n          node.attr(internalContentEditableAttr, node.attr('contenteditable'));\n          node.attr('contenteditable', 'false');\n        });\n      }\n    });\n    editor.serializer.addAttributeFilter(internalContentEditableAttr, nodes => {\n      if (isReadOnly(editor)) {\n        each$g(nodes, node => {\n          node.attr('contenteditable', node.attr(internalContentEditableAttr));\n        });\n      }\n    });\n    editor.serializer.addTempAttr(internalContentEditableAttr);\n  };\n\n  const registerReadOnlyContentFilters = editor => {\n    if (editor.serializer) {\n      registerFilters(editor);\n    } else {\n      editor.on('PreInit', () => {\n        registerFilters(editor);\n      });\n    }\n  };\n\n  const isClickEvent = e => e.type === 'click';\n\n  const getAnchorHrefOpt = (editor, elm) => {\n    const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\n\n    return closest$3(elm, 'a', isRoot).bind(a => getOpt(a, 'href'));\n  };\n\n  const processReadonlyEvents = (editor, e) => {\n    if (isClickEvent(e) && !VK.metaKeyPressed(e)) {\n      const elm = SugarElement.fromDom(e.target);\n      getAnchorHrefOpt(editor, elm).each(href => {\n        e.preventDefault();\n\n        if (/^#/.test(href)) {\n          const targetEl = editor.dom.select(`${href},[name=\"${removeLeading(href, '#')}\"]`);\n\n          if (targetEl.length) {\n            editor.selection.scrollIntoView(targetEl[0], true);\n          }\n        } else {\n          window.open(href, '_blank', 'rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes');\n        }\n      });\n    }\n  };\n\n  const registerReadOnlySelectionBlockers = editor => {\n    editor.on('ShowCaret', e => {\n      if (isReadOnly(editor)) {\n        e.preventDefault();\n      }\n    });\n    editor.on('ObjectSelected', e => {\n      if (isReadOnly(editor)) {\n        e.preventDefault();\n      }\n    });\n  };\n\n  const nativeEvents = Tools.makeMap('focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange ' + 'mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover ' + 'draggesture dragdrop drop drag submit ' + 'compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel', ' ');\n\n  class EventDispatcher {\n    constructor(settings) {\n      this.bindings = {};\n      this.settings = settings || {};\n      this.scope = this.settings.scope || this;\n      this.toggleEvent = this.settings.toggleEvent || never;\n    }\n\n    static isNative(name) {\n      return !!nativeEvents[name.toLowerCase()];\n    }\n\n    fire(name, args) {\n      return this.dispatch(name, args);\n    }\n\n    dispatch(name, args) {\n      const lcName = name.toLowerCase();\n      const event = normalize$3(lcName, args !== null && args !== void 0 ? args : {}, this.scope);\n\n      if (this.settings.beforeFire) {\n        this.settings.beforeFire(event);\n      }\n\n      const handlers = this.bindings[lcName];\n\n      if (handlers) {\n        for (let i = 0, l = handlers.length; i < l; i++) {\n          const callback = handlers[i];\n\n          if (callback.removed) {\n            continue;\n          }\n\n          if (callback.once) {\n            this.off(lcName, callback.func);\n          }\n\n          if (event.isImmediatePropagationStopped()) {\n            return event;\n          }\n\n          if (callback.func.call(this.scope, event) === false) {\n            event.preventDefault();\n            return event;\n          }\n        }\n      }\n\n      return event;\n    }\n\n    on(name, callback, prepend, extra) {\n      if (callback === false) {\n        callback = never;\n      }\n\n      if (callback) {\n        const wrappedCallback = {\n          func: callback,\n          removed: false\n        };\n\n        if (extra) {\n          Tools.extend(wrappedCallback, extra);\n        }\n\n        const names = name.toLowerCase().split(' ');\n        let i = names.length;\n\n        while (i--) {\n          const currentName = names[i];\n          let handlers = this.bindings[currentName];\n\n          if (!handlers) {\n            handlers = [];\n            this.toggleEvent(currentName, true);\n          }\n\n          if (prepend) {\n            handlers = [wrappedCallback, ...handlers];\n          } else {\n            handlers = [...handlers, wrappedCallback];\n          }\n\n          this.bindings[currentName] = handlers;\n        }\n      }\n\n      return this;\n    }\n\n    off(name, callback) {\n      if (name) {\n        const names = name.toLowerCase().split(' ');\n        let i = names.length;\n\n        while (i--) {\n          const currentName = names[i];\n          let handlers = this.bindings[currentName];\n\n          if (!currentName) {\n            each$f(this.bindings, (_value, bindingName) => {\n              this.toggleEvent(bindingName, false);\n              delete this.bindings[bindingName];\n            });\n            return this;\n          }\n\n          if (handlers) {\n            if (!callback) {\n              handlers.length = 0;\n            } else {\n              const filteredHandlers = partition$2(handlers, handler => handler.func === callback);\n              handlers = filteredHandlers.fail;\n              this.bindings[currentName] = handlers;\n              each$g(filteredHandlers.pass, handler => {\n                handler.removed = true;\n              });\n            }\n\n            if (!handlers.length) {\n              this.toggleEvent(name, false);\n              delete this.bindings[currentName];\n            }\n          }\n        }\n      } else {\n        each$f(this.bindings, (_value, name) => {\n          this.toggleEvent(name, false);\n        });\n        this.bindings = {};\n      }\n\n      return this;\n    }\n\n    once(name, callback, prepend) {\n      return this.on(name, callback, prepend, {\n        once: true\n      });\n    }\n\n    has(name) {\n      name = name.toLowerCase();\n      return !(!this.bindings[name] || this.bindings[name].length === 0);\n    }\n\n  }\n\n  const getEventDispatcher = obj => {\n    if (!obj._eventDispatcher) {\n      obj._eventDispatcher = new EventDispatcher({\n        scope: obj,\n        toggleEvent: (name, state) => {\n          if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {\n            obj.toggleNativeEvent(name, state);\n          }\n        }\n      });\n    }\n\n    return obj._eventDispatcher;\n  };\n\n  const Observable = {\n    fire(name, args, bubble) {\n      return this.dispatch(name, args, bubble);\n    },\n\n    dispatch(name, args, bubble) {\n      const self = this;\n\n      if (self.removed && name !== 'remove' && name !== 'detach') {\n        return normalize$3(name.toLowerCase(), args !== null && args !== void 0 ? args : {}, self);\n      }\n\n      const dispatcherArgs = getEventDispatcher(self).dispatch(name, args);\n\n      if (bubble !== false && self.parent) {\n        let parent = self.parent();\n\n        while (parent && !dispatcherArgs.isPropagationStopped()) {\n          parent.dispatch(name, dispatcherArgs, false);\n          parent = parent.parent();\n        }\n      }\n\n      return dispatcherArgs;\n    },\n\n    on(name, callback, prepend) {\n      return getEventDispatcher(this).on(name, callback, prepend);\n    },\n\n    off(name, callback) {\n      return getEventDispatcher(this).off(name, callback);\n    },\n\n    once(name, callback) {\n      return getEventDispatcher(this).once(name, callback);\n    },\n\n    hasEventListeners(name) {\n      return getEventDispatcher(this).has(name);\n    }\n\n  };\n  const DOM$2 = DOMUtils.DOM;\n  let customEventRootDelegates;\n\n  const getEventTarget = (editor, eventName) => {\n    if (eventName === 'selectionchange') {\n      return editor.getDoc();\n    }\n\n    if (!editor.inline && /^mouse|touch|click|contextmenu|drop|dragover|dragend/.test(eventName)) {\n      return editor.getDoc().documentElement;\n    }\n\n    const eventRoot = getEventRoot(editor);\n\n    if (eventRoot) {\n      if (!editor.eventRoot) {\n        editor.eventRoot = DOM$2.select(eventRoot)[0];\n      }\n\n      return editor.eventRoot;\n    }\n\n    return editor.getBody();\n  };\n\n  const isListening = editor => !editor.hidden && !isReadOnly(editor);\n\n  const fireEvent = (editor, eventName, e) => {\n    if (isListening(editor)) {\n      editor.dispatch(eventName, e);\n    } else if (isReadOnly(editor)) {\n      processReadonlyEvents(editor, e);\n    }\n  };\n\n  const bindEventDelegate = (editor, eventName) => {\n    let delegate;\n\n    if (!editor.delegates) {\n      editor.delegates = {};\n    }\n\n    if (editor.delegates[eventName] || editor.removed) {\n      return;\n    }\n\n    const eventRootElm = getEventTarget(editor, eventName);\n\n    if (getEventRoot(editor)) {\n      if (!customEventRootDelegates) {\n        customEventRootDelegates = {};\n        editor.editorManager.on('removeEditor', () => {\n          if (!editor.editorManager.activeEditor) {\n            if (customEventRootDelegates) {\n              each$f(customEventRootDelegates, (_value, name) => {\n                editor.dom.unbind(getEventTarget(editor, name));\n              });\n              customEventRootDelegates = null;\n            }\n          }\n        });\n      }\n\n      if (customEventRootDelegates[eventName]) {\n        return;\n      }\n\n      delegate = e => {\n        const target = e.target;\n        const editors = editor.editorManager.get();\n        let i = editors.length;\n\n        while (i--) {\n          const body = editors[i].getBody();\n\n          if (body === target || DOM$2.isChildOf(target, body)) {\n            fireEvent(editors[i], eventName, e);\n          }\n        }\n      };\n\n      customEventRootDelegates[eventName] = delegate;\n      DOM$2.bind(eventRootElm, eventName, delegate);\n    } else {\n      delegate = e => {\n        fireEvent(editor, eventName, e);\n      };\n\n      DOM$2.bind(eventRootElm, eventName, delegate);\n      editor.delegates[eventName] = delegate;\n    }\n  };\n\n  const EditorObservable = { ...Observable,\n\n    bindPendingEventDelegates() {\n      const self = this;\n      Tools.each(self._pendingNativeEvents, name => {\n        bindEventDelegate(self, name);\n      });\n    },\n\n    toggleNativeEvent(name, state) {\n      const self = this;\n\n      if (name === 'focus' || name === 'blur') {\n        return;\n      }\n\n      if (self.removed) {\n        return;\n      }\n\n      if (state) {\n        if (self.initialized) {\n          bindEventDelegate(self, name);\n        } else {\n          if (!self._pendingNativeEvents) {\n            self._pendingNativeEvents = [name];\n          } else {\n            self._pendingNativeEvents.push(name);\n          }\n        }\n      } else if (self.initialized) {\n        self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);\n        delete self.delegates[name];\n      }\n    },\n\n    unbindAllNativeEvents() {\n      const self = this;\n      const body = self.getBody();\n      const dom = self.dom;\n\n      if (self.delegates) {\n        each$f(self.delegates, (value, name) => {\n          self.dom.unbind(getEventTarget(self, name), name, value);\n        });\n        delete self.delegates;\n      }\n\n      if (!self.inline && body && dom) {\n        body.onload = null;\n        dom.unbind(self.getWin());\n        dom.unbind(self.getDoc());\n      }\n\n      if (dom) {\n        dom.unbind(body);\n        dom.unbind(self.getContainer());\n      }\n    }\n\n  };\n\n  const stringListProcessor = value => {\n    if (isString(value)) {\n      return {\n        value: value.split(/[ ,]/),\n        valid: true\n      };\n    } else if (isArrayOf(value, isString)) {\n      return {\n        value,\n        valid: true\n      };\n    } else {\n      return {\n        valid: false,\n        message: `The value must be a string[] or a comma/space separated string.`\n      };\n    }\n  };\n\n  const getBuiltInProcessor = type => {\n    const validator = (() => {\n      switch (type) {\n        case 'array':\n          return isArray$1;\n\n        case 'boolean':\n          return isBoolean;\n\n        case 'function':\n          return isFunction;\n\n        case 'number':\n          return isNumber;\n\n        case 'object':\n          return isObject;\n\n        case 'string':\n          return isString;\n\n        case 'string[]':\n          return stringListProcessor;\n\n        case 'object[]':\n          return val => isArrayOf(val, isObject);\n\n        case 'regexp':\n          return val => is$4(val, RegExp);\n      }\n    })();\n\n    return value => processValue(value, validator, `The value must be a ${type}.`);\n  };\n\n  const isBuiltInSpec = spec => isString(spec.processor);\n\n  const getErrorMessage = (message, result) => {\n    const additionalText = isEmpty$3(result.message) ? '' : `. ${result.message}`;\n    return message + additionalText;\n  };\n\n  const isValidResult = result => result.valid;\n\n  const processValue = function (value, processor) {\n    let message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    const result = processor(value);\n\n    if (isBoolean(result)) {\n      return result ? {\n        value: value,\n        valid: true\n      } : {\n        valid: false,\n        message\n      };\n    } else {\n      return result;\n    }\n  };\n\n  const processDefaultValue = (name, defaultValue, processor) => {\n    if (!isUndefined(defaultValue)) {\n      const result = processValue(defaultValue, processor);\n\n      if (isValidResult(result)) {\n        return result.value;\n      } else {\n        console.error(getErrorMessage(`Invalid default value passed for the \"${name}\" option`, result));\n      }\n    }\n\n    return undefined;\n  };\n\n  const create$5 = (editor, initialOptions) => {\n    const registry = {};\n    const values = {};\n\n    const setValue = (name, value, processor) => {\n      const result = processValue(value, processor);\n\n      if (isValidResult(result)) {\n        values[name] = result.value;\n        return true;\n      } else {\n        console.warn(getErrorMessage(`Invalid value passed for the ${name} option`, result));\n        return false;\n      }\n    };\n\n    const register = (name, spec) => {\n      const processor = isBuiltInSpec(spec) ? getBuiltInProcessor(spec.processor) : spec.processor;\n      const defaultValue = processDefaultValue(name, spec.default, processor);\n      registry[name] = { ...spec,\n        default: defaultValue,\n        processor\n      };\n      const initValue = get$a(values, name).orThunk(() => get$a(initialOptions, name));\n      initValue.each(value => setValue(name, value, processor));\n    };\n\n    const isRegistered = name => has$2(registry, name);\n\n    const get = name => get$a(values, name).orThunk(() => get$a(registry, name).map(spec => spec.default)).getOrUndefined();\n\n    const set = (name, value) => {\n      if (!isRegistered(name)) {\n        console.warn(`\"${name}\" is not a registered option. Ensure the option has been registered before setting a value.`);\n        return false;\n      } else {\n        const spec = registry[name];\n\n        if (spec.immutable) {\n          console.error(`\"${name}\" is an immutable option and cannot be updated`);\n          return false;\n        } else {\n          return setValue(name, value, spec.processor);\n        }\n      }\n    };\n\n    const unset = name => {\n      const registered = isRegistered(name);\n\n      if (registered) {\n        delete values[name];\n      }\n\n      return registered;\n    };\n\n    const isSet = name => has$2(values, name);\n\n    return {\n      register,\n      isRegistered,\n      get,\n      set,\n      unset,\n      isSet\n    };\n  };\n\n  const defaultModes = ['design', 'readonly'];\n\n  const switchToMode = (editor, activeMode, availableModes, mode) => {\n    const oldMode = availableModes[activeMode.get()];\n    const newMode = availableModes[mode];\n\n    try {\n      newMode.activate();\n    } catch (e) {\n      console.error(`problem while activating editor mode ${mode}:`, e);\n      return;\n    }\n\n    oldMode.deactivate();\n\n    if (oldMode.editorReadOnly !== newMode.editorReadOnly) {\n      toggleReadOnly(editor, newMode.editorReadOnly);\n    }\n\n    activeMode.set(mode);\n    fireSwitchMode(editor, mode);\n  };\n\n  const setMode = (editor, availableModes, activeMode, mode) => {\n    if (mode === activeMode.get()) {\n      return;\n    } else if (!has$2(availableModes, mode)) {\n      throw new Error(`Editor mode '${mode}' is invalid`);\n    }\n\n    if (editor.initialized) {\n      switchToMode(editor, activeMode, availableModes, mode);\n    } else {\n      editor.on('init', () => switchToMode(editor, activeMode, availableModes, mode));\n    }\n  };\n\n  const registerMode = (availableModes, mode, api) => {\n    if (contains$2(defaultModes, mode)) {\n      throw new Error(`Cannot override default mode ${mode}`);\n    }\n\n    return { ...availableModes,\n      [mode]: { ...api,\n        deactivate: () => {\n          try {\n            api.deactivate();\n          } catch (e) {\n            console.error(`problem while deactivating editor mode ${mode}:`, e);\n          }\n        }\n      }\n    };\n  };\n\n  const create$4 = editor => {\n    const activeMode = Cell('design');\n    const availableModes = Cell({\n      design: {\n        activate: noop,\n        deactivate: noop,\n        editorReadOnly: false\n      },\n      readonly: {\n        activate: noop,\n        deactivate: noop,\n        editorReadOnly: true\n      }\n    });\n    registerReadOnlyContentFilters(editor);\n    registerReadOnlySelectionBlockers(editor);\n    return {\n      isReadOnly: () => isReadOnly(editor),\n      set: mode => setMode(editor, availableModes.get(), activeMode, mode),\n      get: () => activeMode.get(),\n      register: (mode, api) => {\n        availableModes.set(registerMode(availableModes.get(), mode, api));\n      }\n    };\n  };\n\n  const each$2 = Tools.each,\n        explode = Tools.explode;\n  const keyCodeLookup = {\n    f1: 112,\n    f2: 113,\n    f3: 114,\n    f4: 115,\n    f5: 116,\n    f6: 117,\n    f7: 118,\n    f8: 119,\n    f9: 120,\n    f10: 121,\n    f11: 122,\n    f12: 123\n  };\n  const modifierNames = Tools.makeMap('alt,ctrl,shift,meta,access');\n\n  const parseShortcut = pattern => {\n    let key;\n    const shortcut = {};\n    const isMac = Env.os.isMacOS() || Env.os.isiOS();\n    each$2(explode(pattern.toLowerCase(), '+'), value => {\n      if (value in modifierNames) {\n        shortcut[value] = true;\n      } else {\n        if (/^[0-9]{2,}$/.test(value)) {\n          shortcut.keyCode = parseInt(value, 10);\n        } else {\n          shortcut.charCode = value.charCodeAt(0);\n          shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);\n        }\n      }\n    });\n    const id = [shortcut.keyCode];\n\n    for (key in modifierNames) {\n      if (shortcut[key]) {\n        id.push(key);\n      } else {\n        shortcut[key] = false;\n      }\n    }\n\n    shortcut.id = id.join(',');\n\n    if (shortcut.access) {\n      shortcut.alt = true;\n\n      if (isMac) {\n        shortcut.ctrl = true;\n      } else {\n        shortcut.shift = true;\n      }\n    }\n\n    if (shortcut.meta) {\n      if (isMac) {\n        shortcut.meta = true;\n      } else {\n        shortcut.ctrl = true;\n        shortcut.meta = false;\n      }\n    }\n\n    return shortcut;\n  };\n\n  class Shortcuts {\n    constructor(editor) {\n      this.shortcuts = {};\n      this.pendingPatterns = [];\n      this.editor = editor;\n      const self = this;\n      editor.on('keyup keypress keydown', e => {\n        if ((self.hasModifier(e) || self.isFunctionKey(e)) && !e.isDefaultPrevented()) {\n          each$2(self.shortcuts, shortcut => {\n            if (self.matchShortcut(e, shortcut)) {\n              self.pendingPatterns = shortcut.subpatterns.slice(0);\n\n              if (e.type === 'keydown') {\n                self.executeShortcutAction(shortcut);\n              }\n\n              return true;\n            }\n          });\n\n          if (self.matchShortcut(e, self.pendingPatterns[0])) {\n            if (self.pendingPatterns.length === 1) {\n              if (e.type === 'keydown') {\n                self.executeShortcutAction(self.pendingPatterns[0]);\n              }\n            }\n\n            self.pendingPatterns.shift();\n          }\n        }\n      });\n    }\n\n    add(pattern, desc, cmdFunc, scope) {\n      const self = this;\n      const func = self.normalizeCommandFunc(cmdFunc);\n      each$2(explode(Tools.trim(pattern)), pattern => {\n        const shortcut = self.createShortcut(pattern, desc, func, scope);\n        self.shortcuts[shortcut.id] = shortcut;\n      });\n      return true;\n    }\n\n    remove(pattern) {\n      const shortcut = this.createShortcut(pattern);\n\n      if (this.shortcuts[shortcut.id]) {\n        delete this.shortcuts[shortcut.id];\n        return true;\n      }\n\n      return false;\n    }\n\n    normalizeCommandFunc(cmdFunc) {\n      const self = this;\n      const cmd = cmdFunc;\n\n      if (typeof cmd === 'string') {\n        return () => {\n          self.editor.execCommand(cmd, false, null);\n        };\n      } else if (Tools.isArray(cmd)) {\n        return () => {\n          self.editor.execCommand(cmd[0], cmd[1], cmd[2]);\n        };\n      } else {\n        return cmd;\n      }\n    }\n\n    createShortcut(pattern, desc, cmdFunc, scope) {\n      const shortcuts = Tools.map(explode(pattern, '>'), parseShortcut);\n      shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {\n        func: cmdFunc,\n        scope: scope || this.editor\n      });\n      return Tools.extend(shortcuts[0], {\n        desc: this.editor.translate(desc),\n        subpatterns: shortcuts.slice(1)\n      });\n    }\n\n    hasModifier(e) {\n      return e.altKey || e.ctrlKey || e.metaKey;\n    }\n\n    isFunctionKey(e) {\n      return e.type === 'keydown' && e.keyCode >= 112 && e.keyCode <= 123;\n    }\n\n    matchShortcut(e, shortcut) {\n      if (!shortcut) {\n        return false;\n      }\n\n      if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {\n        return false;\n      }\n\n      if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {\n        return false;\n      }\n\n      if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {\n        e.preventDefault();\n        return true;\n      }\n\n      return false;\n    }\n\n    executeShortcutAction(shortcut) {\n      return shortcut.func ? shortcut.func.call(shortcut.scope) : null;\n    }\n\n  }\n\n  const create$3 = () => {\n    const buttons = {};\n    const menuItems = {};\n    const popups = {};\n    const icons = {};\n    const contextMenus = {};\n    const contextToolbars = {};\n    const sidebars = {};\n\n    const add = (collection, type) => (name, spec) => collection[name.toLowerCase()] = { ...spec,\n      type\n    };\n\n    const addIcon = (name, svgData) => icons[name.toLowerCase()] = svgData;\n\n    return {\n      addButton: add(buttons, 'button'),\n      addGroupToolbarButton: add(buttons, 'grouptoolbarbutton'),\n      addToggleButton: add(buttons, 'togglebutton'),\n      addMenuButton: add(buttons, 'menubutton'),\n      addSplitButton: add(buttons, 'splitbutton'),\n      addMenuItem: add(menuItems, 'menuitem'),\n      addNestedMenuItem: add(menuItems, 'nestedmenuitem'),\n      addToggleMenuItem: add(menuItems, 'togglemenuitem'),\n      addAutocompleter: add(popups, 'autocompleter'),\n      addContextMenu: add(contextMenus, 'contextmenu'),\n      addContextToolbar: add(contextToolbars, 'contexttoolbar'),\n      addContextForm: add(contextToolbars, 'contextform'),\n      addSidebar: add(sidebars, 'sidebar'),\n      addIcon,\n      getAll: () => ({\n        buttons,\n        menuItems,\n        icons,\n        popups,\n        contextMenus,\n        contextToolbars,\n        sidebars\n      })\n    };\n  };\n\n  const registry = () => {\n    const bridge = create$3();\n    return {\n      addAutocompleter: bridge.addAutocompleter,\n      addButton: bridge.addButton,\n      addContextForm: bridge.addContextForm,\n      addContextMenu: bridge.addContextMenu,\n      addContextToolbar: bridge.addContextToolbar,\n      addIcon: bridge.addIcon,\n      addMenuButton: bridge.addMenuButton,\n      addMenuItem: bridge.addMenuItem,\n      addNestedMenuItem: bridge.addNestedMenuItem,\n      addSidebar: bridge.addSidebar,\n      addSplitButton: bridge.addSplitButton,\n      addToggleButton: bridge.addToggleButton,\n      addGroupToolbarButton: bridge.addGroupToolbarButton,\n      addToggleMenuItem: bridge.addToggleMenuItem,\n      getAll: bridge.getAll\n    };\n  };\n\n  const DOM$1 = DOMUtils.DOM;\n  const extend = Tools.extend,\n        each$1 = Tools.each;\n\n  class Editor {\n    constructor(id, options, editorManager) {\n      this.plugins = {};\n      this.contentCSS = [];\n      this.contentStyles = [];\n      this.loadedCSS = {};\n      this.isNotDirty = false;\n      this.editorManager = editorManager;\n      this.documentBaseUrl = editorManager.documentBaseURL;\n      extend(this, EditorObservable);\n      const self = this;\n      this.id = id;\n      this.hidden = false;\n      const normalizedOptions = normalizeOptions(editorManager.defaultOptions, options);\n      this.options = create$5(self, normalizedOptions);\n      register$7(self);\n      const getOption = this.options.get;\n\n      if (getOption('deprecation_warnings')) {\n        logWarnings(options, normalizedOptions);\n      }\n\n      const suffix = getOption('suffix');\n\n      if (suffix) {\n        editorManager.suffix = suffix;\n      }\n\n      this.suffix = editorManager.suffix;\n      const baseUrl = getOption('base_url');\n\n      if (baseUrl) {\n        editorManager._setBaseUrl(baseUrl);\n      }\n\n      this.baseUri = editorManager.baseURI;\n      const referrerPolicy = getReferrerPolicy(self);\n\n      if (referrerPolicy) {\n        ScriptLoader.ScriptLoader._setReferrerPolicy(referrerPolicy);\n\n        DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(referrerPolicy);\n      }\n\n      AddOnManager.languageLoad = getOption('language_load');\n      AddOnManager.baseURL = editorManager.baseURL;\n      this.setDirty(false);\n      this.documentBaseURI = new URI(getDocumentBaseUrl(self), {\n        base_uri: this.baseUri\n      });\n      this.baseURI = this.baseUri;\n      this.inline = isInline(self);\n      this.shortcuts = new Shortcuts(this);\n      this.editorCommands = new EditorCommands(this);\n      registerCommands(this);\n      const cacheSuffix = getOption('cache_suffix');\n\n      if (cacheSuffix) {\n        Env.cacheSuffix = cacheSuffix.replace(/^[\\?\\&]+/, '');\n      }\n\n      this.ui = {\n        registry: registry(),\n        styleSheetLoader: undefined,\n        show: noop,\n        hide: noop,\n        setEnabled: noop,\n        isEnabled: always\n      };\n      this.mode = create$4(self);\n      editorManager.dispatch('SetupEditor', {\n        editor: this\n      });\n      const setupCallback = getSetupCallback(self);\n\n      if (isFunction(setupCallback)) {\n        setupCallback.call(self, self);\n      }\n    }\n\n    render() {\n      render(this);\n    }\n\n    focus(skipFocus) {\n      this.execCommand('mceFocus', false, skipFocus);\n    }\n\n    hasFocus() {\n      return hasFocus(this);\n    }\n\n    translate(text) {\n      return I18n.translate(text);\n    }\n\n    getParam(name, defaultVal, type) {\n      const options = this.options;\n\n      if (!options.isRegistered(name)) {\n        if (isNonNullable(type)) {\n          options.register(name, {\n            processor: type,\n            default: defaultVal\n          });\n        } else {\n          options.register(name, {\n            processor: always,\n            default: defaultVal\n          });\n        }\n      }\n\n      return !options.isSet(name) && !isUndefined(defaultVal) ? defaultVal : options.get(name);\n    }\n\n    hasPlugin(name, loaded) {\n      const hasPlugin = contains$2(getPlugins(this), name);\n\n      if (hasPlugin) {\n        return loaded ? PluginManager.get(name) !== undefined : true;\n      } else {\n        return false;\n      }\n    }\n\n    nodeChanged(args) {\n      this._nodeChangeDispatcher.nodeChanged(args);\n    }\n\n    addCommand(name, callback, scope) {\n      this.editorCommands.addCommand(name, callback, scope);\n    }\n\n    addQueryStateHandler(name, callback, scope) {\n      this.editorCommands.addQueryStateHandler(name, callback, scope);\n    }\n\n    addQueryValueHandler(name, callback, scope) {\n      this.editorCommands.addQueryValueHandler(name, callback, scope);\n    }\n\n    addShortcut(pattern, desc, cmdFunc, scope) {\n      this.shortcuts.add(pattern, desc, cmdFunc, scope);\n    }\n\n    execCommand(cmd, ui, value, args) {\n      return this.editorCommands.execCommand(cmd, ui, value, args);\n    }\n\n    queryCommandState(cmd) {\n      return this.editorCommands.queryCommandState(cmd);\n    }\n\n    queryCommandValue(cmd) {\n      return this.editorCommands.queryCommandValue(cmd);\n    }\n\n    queryCommandSupported(cmd) {\n      return this.editorCommands.queryCommandSupported(cmd);\n    }\n\n    show() {\n      const self = this;\n\n      if (self.hidden) {\n        self.hidden = false;\n\n        if (self.inline) {\n          self.getBody().contentEditable = 'true';\n        } else {\n          DOM$1.show(self.getContainer());\n          DOM$1.hide(self.id);\n        }\n\n        self.load();\n        self.dispatch('show');\n      }\n    }\n\n    hide() {\n      const self = this;\n\n      if (!self.hidden) {\n        self.save();\n\n        if (self.inline) {\n          self.getBody().contentEditable = 'false';\n\n          if (self === self.editorManager.focusedEditor) {\n            self.editorManager.focusedEditor = null;\n          }\n        } else {\n          DOM$1.hide(self.getContainer());\n          DOM$1.setStyle(self.id, 'display', self.orgDisplay);\n        }\n\n        self.hidden = true;\n        self.dispatch('hide');\n      }\n    }\n\n    isHidden() {\n      return this.hidden;\n    }\n\n    setProgressState(state, time) {\n      this.dispatch('ProgressState', {\n        state,\n        time\n      });\n    }\n\n    load(args) {\n      const self = this;\n      let elm = self.getElement(),\n          html;\n\n      if (self.removed) {\n        return '';\n      }\n\n      if (elm) {\n        args = args || {};\n        args.load = true;\n        const value = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;\n        html = self.setContent(value, args);\n        args.element = elm;\n\n        if (!args.no_events) {\n          self.dispatch('LoadContent', args);\n        }\n\n        args.element = elm = null;\n        return html;\n      }\n    }\n\n    save(args) {\n      const self = this;\n      let elm = self.getElement(),\n          html,\n          form;\n\n      if (!elm || !self.initialized || self.removed) {\n        return;\n      }\n\n      args = args || {};\n      args.save = true;\n      args.element = elm;\n      html = args.content = self.getContent(args);\n\n      if (!args.no_events) {\n        self.dispatch('SaveContent', args);\n      }\n\n      if (args.format === 'raw') {\n        self.dispatch('RawSaveContent', args);\n      }\n\n      html = args.content;\n\n      if (!isTextareaOrInput(elm)) {\n        if (args.is_removing || !self.inline) {\n          elm.innerHTML = html;\n        }\n\n        if (form = DOM$1.getParent(self.id, 'form')) {\n          each$1(form.elements, elm => {\n            if (elm.name === self.id) {\n              elm.value = html;\n              return false;\n            }\n          });\n        }\n      } else {\n        elm.value = html;\n      }\n\n      args.element = elm = null;\n\n      if (args.set_dirty !== false) {\n        self.setDirty(false);\n      }\n\n      return html;\n    }\n\n    setContent(content, args) {\n      return setContent(this, content, args);\n    }\n\n    getContent(args) {\n      return getContent(this, args);\n    }\n\n    insertContent(content, args) {\n      if (args) {\n        content = extend({\n          content\n        }, args);\n      }\n\n      this.execCommand('mceInsertContent', false, content);\n    }\n\n    resetContent(initialContent) {\n      if (initialContent === undefined) {\n        setContent(this, this.startContent, {\n          format: 'raw'\n        });\n      } else {\n        setContent(this, initialContent);\n      }\n\n      this.undoManager.reset();\n      this.setDirty(false);\n      this.nodeChanged();\n    }\n\n    isDirty() {\n      return !this.isNotDirty;\n    }\n\n    setDirty(state) {\n      const oldState = !this.isNotDirty;\n      this.isNotDirty = !state;\n\n      if (state && state !== oldState) {\n        this.dispatch('dirty');\n      }\n    }\n\n    getContainer() {\n      const self = this;\n\n      if (!self.container) {\n        self.container = DOM$1.get(self.editorContainer || self.id + '_parent');\n      }\n\n      return self.container;\n    }\n\n    getContentAreaContainer() {\n      return this.contentAreaContainer;\n    }\n\n    getElement() {\n      if (!this.targetElm) {\n        this.targetElm = DOM$1.get(this.id);\n      }\n\n      return this.targetElm;\n    }\n\n    getWin() {\n      const self = this;\n      let elm;\n\n      if (!self.contentWindow) {\n        elm = self.iframeElement;\n\n        if (elm) {\n          self.contentWindow = elm.contentWindow;\n        }\n      }\n\n      return self.contentWindow;\n    }\n\n    getDoc() {\n      const self = this;\n      let win;\n\n      if (!self.contentDocument) {\n        win = self.getWin();\n\n        if (win) {\n          self.contentDocument = win.document;\n        }\n      }\n\n      return self.contentDocument;\n    }\n\n    getBody() {\n      const doc = this.getDoc();\n      return this.bodyElement || (doc ? doc.body : null);\n    }\n\n    convertURL(url, name, elm) {\n      const self = this,\n            getOption = self.options.get;\n      const urlConverterCallback = getUrlConverterCallback(self);\n\n      if (isFunction(urlConverterCallback)) {\n        return urlConverterCallback.call(self, url, elm, true, name);\n      }\n\n      if (!getOption('convert_urls') || elm && elm.nodeName === 'LINK' || url.indexOf('file:') === 0 || url.length === 0) {\n        return url;\n      }\n\n      if (getOption('relative_urls')) {\n        return self.documentBaseURI.toRelative(url);\n      }\n\n      url = self.documentBaseURI.toAbsolute(url, getOption('remove_script_host'));\n      return url;\n    }\n\n    addVisual(elm) {\n      addVisual(this, elm);\n    }\n\n    remove() {\n      remove$1(this);\n    }\n\n    destroy(automatic) {\n      destroy(this, automatic);\n    }\n\n    uploadImages() {\n      return this.editorUpload.uploadImages();\n    }\n\n    _scanForImages() {\n      return this.editorUpload.scanForImages();\n    }\n\n  }\n\n  const DOM = DOMUtils.DOM;\n  const each = Tools.each;\n  let boundGlobalEvents = false;\n  let beforeUnloadDelegate;\n  let editors = [];\n\n  const globalEventDelegate = e => {\n    const type = e.type;\n    each(EditorManager.get(), editor => {\n      switch (type) {\n        case 'scroll':\n          editor.dispatch('ScrollWindow', e);\n          break;\n\n        case 'resize':\n          editor.dispatch('ResizeWindow', e);\n          break;\n      }\n    });\n  };\n\n  const toggleGlobalEvents = state => {\n    if (state !== boundGlobalEvents) {\n      const DOM = DOMUtils.DOM;\n\n      if (state) {\n        DOM.bind(window, 'resize', globalEventDelegate);\n        DOM.bind(window, 'scroll', globalEventDelegate);\n      } else {\n        DOM.unbind(window, 'resize', globalEventDelegate);\n        DOM.unbind(window, 'scroll', globalEventDelegate);\n      }\n\n      boundGlobalEvents = state;\n    }\n  };\n\n  const removeEditorFromList = targetEditor => {\n    const oldEditors = editors;\n    editors = filter$6(editors, editor => {\n      return targetEditor !== editor;\n    });\n\n    if (EditorManager.activeEditor === targetEditor) {\n      EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;\n    }\n\n    if (EditorManager.focusedEditor === targetEditor) {\n      EditorManager.focusedEditor = null;\n    }\n\n    return oldEditors.length !== editors.length;\n  };\n\n  const purgeDestroyedEditor = editor => {\n    if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {\n      removeEditorFromList(editor);\n      editor.unbindAllNativeEvents();\n      editor.destroy(true);\n      editor.removed = true;\n      editor = null;\n    }\n\n    return editor;\n  };\n\n  const isQuirksMode = document.compatMode !== 'CSS1Compat';\n  const EditorManager = { ...Observable,\n    baseURI: null,\n    baseURL: null,\n    defaultOptions: {},\n    documentBaseURL: null,\n    suffix: null,\n    majorVersion: '6',\n    minorVersion: '0.2',\n    releaseDate: '2022-04-27',\n    i18n: I18n,\n    activeEditor: null,\n    focusedEditor: null,\n\n    setup() {\n      const self = this;\n      let baseURL,\n          documentBaseURL,\n          suffix = '';\n      documentBaseURL = URI.getDocumentBaseUrl(document.location);\n\n      if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(documentBaseURL)) {\n        documentBaseURL = documentBaseURL.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\n\n        if (!/[\\/\\\\]$/.test(documentBaseURL)) {\n          documentBaseURL += '/';\n        }\n      }\n\n      const preInit = window.tinymce || window.tinyMCEPreInit;\n\n      if (preInit) {\n        baseURL = preInit.base || preInit.baseURL;\n        suffix = preInit.suffix;\n      } else {\n        const scripts = document.getElementsByTagName('script');\n\n        for (let i = 0; i < scripts.length; i++) {\n          const src = scripts[i].src || '';\n\n          if (src === '') {\n            continue;\n          }\n\n          const srcScript = src.substring(src.lastIndexOf('/'));\n\n          if (/tinymce(\\.full|\\.jquery|)(\\.min|\\.dev|)\\.js/.test(src)) {\n            if (srcScript.indexOf('.min') !== -1) {\n              suffix = '.min';\n            }\n\n            baseURL = src.substring(0, src.lastIndexOf('/'));\n            break;\n          }\n        }\n\n        if (!baseURL && document.currentScript) {\n          const src = document.currentScript.src;\n\n          if (src.indexOf('.min') !== -1) {\n            suffix = '.min';\n          }\n\n          baseURL = src.substring(0, src.lastIndexOf('/'));\n        }\n      }\n\n      self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);\n      self.documentBaseURL = documentBaseURL;\n      self.baseURI = new URI(self.baseURL);\n      self.suffix = suffix;\n      setup$v(self);\n    },\n\n    overrideDefaults(defaultOptions) {\n      const baseUrl = defaultOptions.base_url;\n\n      if (baseUrl) {\n        this._setBaseUrl(baseUrl);\n      }\n\n      const suffix = defaultOptions.suffix;\n\n      if (defaultOptions.suffix) {\n        this.suffix = suffix;\n      }\n\n      this.defaultOptions = defaultOptions;\n      const pluginBaseUrls = defaultOptions.plugin_base_urls;\n\n      if (pluginBaseUrls !== undefined) {\n        each$f(pluginBaseUrls, (pluginBaseUrl, pluginName) => {\n          AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;\n        });\n      }\n    },\n\n    init(options) {\n      const self = this;\n      let result;\n      const invalidInlineTargets = Tools.makeMap('area base basefont br col frame hr img input isindex link meta param embed source wbr track ' + 'colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu', ' ');\n\n      const isInvalidInlineTarget = (options, elm) => options.inline && elm.tagName.toLowerCase() in invalidInlineTargets;\n\n      const createId = elm => {\n        let id = elm.id;\n\n        if (!id) {\n          id = get$a(elm, 'name').filter(name => !DOM.get(name)).getOrThunk(DOM.uniqueId);\n          elm.setAttribute('id', id);\n        }\n\n        return id;\n      };\n\n      const execCallback = name => {\n        const callback = options[name];\n\n        if (!callback) {\n          return;\n        }\n\n        return callback.apply(self, []);\n      };\n\n      const findTargets = options => {\n        if (Env.browser.isIE() || Env.browser.isEdge()) {\n          initError('TinyMCE does not support the browser you are using. For a list of supported' + ' browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers');\n          return [];\n        } else if (isQuirksMode) {\n          initError('Failed to initialize the editor as the document is not in standards mode. ' + 'TinyMCE requires standards mode.');\n          return [];\n        } else if (isString(options.selector)) {\n          return DOM.select(options.selector);\n        } else if (isNonNullable(options.target)) {\n          return [options.target];\n        } else {\n          return [];\n        }\n      };\n\n      let provideResults = editors => {\n        result = editors;\n      };\n\n      const initEditors = () => {\n        let initCount = 0;\n        const editors = [];\n        let targets;\n\n        const createEditor = (id, options, targetElm) => {\n          const editor = new Editor(id, options, self);\n          editors.push(editor);\n          editor.on('init', () => {\n            if (++initCount === targets.length) {\n              provideResults(editors);\n            }\n          });\n          editor.targetElm = editor.targetElm || targetElm;\n          editor.render();\n        };\n\n        DOM.unbind(window, 'ready', initEditors);\n        execCallback('onpageload');\n        targets = unique$1(findTargets(options));\n        Tools.each(targets, elm => {\n          purgeDestroyedEditor(self.get(elm.id));\n        });\n        targets = Tools.grep(targets, elm => {\n          return !self.get(elm.id);\n        });\n\n        if (targets.length === 0) {\n          provideResults([]);\n        } else {\n          each(targets, elm => {\n            if (isInvalidInlineTarget(options, elm)) {\n              initError('Could not initialize inline editor on invalid inline target element', elm);\n            } else {\n              createEditor(createId(elm), options, elm);\n            }\n          });\n        }\n      };\n\n      DOM.bind(window, 'ready', initEditors);\n      return new Promise(resolve => {\n        if (result) {\n          resolve(result);\n        } else {\n          provideResults = editors => {\n            resolve(editors);\n          };\n        }\n      });\n    },\n\n    get(id) {\n      if (arguments.length === 0) {\n        return editors.slice(0);\n      } else if (isString(id)) {\n        return find$2(editors, editor => {\n          return editor.id === id;\n        }).getOr(null);\n      } else if (isNumber(id)) {\n        return editors[id] ? editors[id] : null;\n      } else {\n        return null;\n      }\n    },\n\n    add(editor) {\n      const self = this;\n      const existingEditor = self.get(editor.id);\n\n      if (existingEditor === editor) {\n        return editor;\n      }\n\n      if (existingEditor === null) {\n        editors.push(editor);\n      }\n\n      toggleGlobalEvents(true);\n      self.activeEditor = editor;\n      self.dispatch('AddEditor', {\n        editor\n      });\n\n      if (!beforeUnloadDelegate) {\n        beforeUnloadDelegate = e => {\n          const event = self.dispatch('BeforeUnload');\n\n          if (event.returnValue) {\n            e.preventDefault();\n            e.returnValue = event.returnValue;\n            return event.returnValue;\n          }\n        };\n\n        window.addEventListener('beforeunload', beforeUnloadDelegate);\n      }\n\n      return editor;\n    },\n\n    createEditor(id, options) {\n      return this.add(new Editor(id, options, this));\n    },\n\n    remove(selector) {\n      const self = this;\n      let i, editor;\n\n      if (!selector) {\n        for (i = editors.length - 1; i >= 0; i--) {\n          self.remove(editors[i]);\n        }\n\n        return;\n      }\n\n      if (isString(selector)) {\n        each(DOM.select(selector), elm => {\n          editor = self.get(elm.id);\n\n          if (editor) {\n            self.remove(editor);\n          }\n        });\n        return;\n      }\n\n      editor = selector;\n\n      if (isNull(self.get(editor.id))) {\n        return null;\n      }\n\n      if (removeEditorFromList(editor)) {\n        self.dispatch('RemoveEditor', {\n          editor\n        });\n      }\n\n      if (editors.length === 0) {\n        window.removeEventListener('beforeunload', beforeUnloadDelegate);\n      }\n\n      editor.remove();\n      toggleGlobalEvents(editors.length > 0);\n      return editor;\n    },\n\n    execCommand(cmd, ui, value) {\n      var _a;\n\n      const self = this;\n      const editorId = isObject(value) ? (_a = value.id) !== null && _a !== void 0 ? _a : value.index : value;\n\n      switch (cmd) {\n        case 'mceAddEditor':\n          {\n            if (!self.get(editorId)) {\n              const editorOptions = value.options;\n              new Editor(editorId, editorOptions, self).render();\n            }\n\n            return true;\n          }\n\n        case 'mceRemoveEditor':\n          {\n            const editor = self.get(editorId);\n\n            if (editor) {\n              editor.remove();\n            }\n\n            return true;\n          }\n\n        case 'mceToggleEditor':\n          {\n            const editor = self.get(editorId);\n\n            if (!editor) {\n              self.execCommand('mceAddEditor', false, value);\n              return true;\n            }\n\n            if (editor.isHidden()) {\n              editor.show();\n            } else {\n              editor.hide();\n            }\n\n            return true;\n          }\n      }\n\n      if (self.activeEditor) {\n        return self.activeEditor.execCommand(cmd, ui, value);\n      }\n\n      return false;\n    },\n\n    triggerSave: () => {\n      each(editors, editor => {\n        editor.save();\n      });\n    },\n    addI18n: (code, items) => {\n      I18n.add(code, items);\n    },\n    translate: text => {\n      return I18n.translate(text);\n    },\n\n    setActive(editor) {\n      const activeEditor = this.activeEditor;\n\n      if (this.activeEditor !== editor) {\n        if (activeEditor) {\n          activeEditor.dispatch('deactivate', {\n            relatedTarget: editor\n          });\n        }\n\n        editor.dispatch('activate', {\n          relatedTarget: activeEditor\n        });\n      }\n\n      this.activeEditor = editor;\n    },\n\n    _setBaseUrl(baseUrl) {\n      this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\\/+$/, ''));\n      this.baseURI = new URI(this.baseURL);\n    }\n\n  };\n  EditorManager.setup();\n\n  const setup = () => {\n    const dataValue = value$2();\n\n    const FakeClipboardItem = items => ({\n      items,\n      types: keys(items),\n      getType: type => get$a(items, type).getOrUndefined()\n    });\n\n    const write = data => {\n      dataValue.set(data);\n    };\n\n    const read = () => dataValue.get().getOrUndefined();\n\n    const clear = dataValue.clear;\n    return {\n      FakeClipboardItem,\n      write,\n      read,\n      clear\n    };\n  };\n\n  const FakeClipboard = setup();\n  const min = Math.min,\n        max = Math.max,\n        round = Math.round;\n\n  const relativePosition = (rect, targetRect, rel) => {\n    let x = targetRect.x;\n    let y = targetRect.y;\n    const w = rect.w;\n    const h = rect.h;\n    const targetW = targetRect.w;\n    const targetH = targetRect.h;\n    const relChars = (rel || '').split('');\n\n    if (relChars[0] === 'b') {\n      y += targetH;\n    }\n\n    if (relChars[1] === 'r') {\n      x += targetW;\n    }\n\n    if (relChars[0] === 'c') {\n      y += round(targetH / 2);\n    }\n\n    if (relChars[1] === 'c') {\n      x += round(targetW / 2);\n    }\n\n    if (relChars[3] === 'b') {\n      y -= h;\n    }\n\n    if (relChars[4] === 'r') {\n      x -= w;\n    }\n\n    if (relChars[3] === 'c') {\n      y -= round(h / 2);\n    }\n\n    if (relChars[4] === 'c') {\n      x -= round(w / 2);\n    }\n\n    return create$2(x, y, w, h);\n  };\n\n  const findBestRelativePosition = (rect, targetRect, constrainRect, rels) => {\n    let pos, i;\n\n    for (i = 0; i < rels.length; i++) {\n      pos = relativePosition(rect, targetRect, rels[i]);\n\n      if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {\n        return rels[i];\n      }\n    }\n\n    return null;\n  };\n\n  const inflate = (rect, w, h) => {\n    return create$2(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);\n  };\n\n  const intersect = (rect, cropRect) => {\n    const x1 = max(rect.x, cropRect.x);\n    const y1 = max(rect.y, cropRect.y);\n    const x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);\n    const y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);\n\n    if (x2 - x1 < 0 || y2 - y1 < 0) {\n      return null;\n    }\n\n    return create$2(x1, y1, x2 - x1, y2 - y1);\n  };\n\n  const clamp = (rect, clampRect, fixedSize) => {\n    let x1 = rect.x;\n    let y1 = rect.y;\n    let x2 = rect.x + rect.w;\n    let y2 = rect.y + rect.h;\n    const cx2 = clampRect.x + clampRect.w;\n    const cy2 = clampRect.y + clampRect.h;\n    const underflowX1 = max(0, clampRect.x - x1);\n    const underflowY1 = max(0, clampRect.y - y1);\n    const overflowX2 = max(0, x2 - cx2);\n    const overflowY2 = max(0, y2 - cy2);\n    x1 += underflowX1;\n    y1 += underflowY1;\n\n    if (fixedSize) {\n      x2 += underflowX1;\n      y2 += underflowY1;\n      x1 -= overflowX2;\n      y1 -= overflowY2;\n    }\n\n    x2 -= overflowX2;\n    y2 -= overflowY2;\n    return create$2(x1, y1, x2 - x1, y2 - y1);\n  };\n\n  const create$2 = (x, y, w, h) => {\n    return {\n      x,\n      y,\n      w,\n      h\n    };\n  };\n\n  const fromClientRect = clientRect => {\n    return create$2(clientRect.left, clientRect.top, clientRect.width, clientRect.height);\n  };\n\n  const Rect = {\n    inflate,\n    relativePosition,\n    findBestRelativePosition,\n    intersect,\n    clamp,\n    create: create$2,\n    fromClientRect\n  };\n\n  const awaiter = function (resolveCb, rejectCb) {\n    let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n    let done = false;\n    let timer = null;\n\n    const complete = completer => function () {\n      if (!done) {\n        done = true;\n\n        if (timer !== null) {\n          clearTimeout(timer);\n          timer = null;\n        }\n\n        for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n          args[_key16] = arguments[_key16];\n        }\n\n        completer.apply(null, args);\n      }\n    };\n\n    const resolve = complete(resolveCb);\n    const reject = complete(rejectCb);\n\n    const start = function () {\n      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        args[_key17] = arguments[_key17];\n      }\n\n      if (!done && timer === null) {\n        timer = setTimeout(() => reject.apply(null, args), timeout);\n      }\n    };\n\n    return {\n      start,\n      resolve,\n      reject\n    };\n  };\n\n  const create$1 = () => {\n    const tasks = {};\n    const resultFns = {};\n\n    const load = (id, url) => {\n      const loadErrMsg = `Script at URL \"${url}\" failed to load`;\n      const runErrMsg = `Script at URL \"${url}\" did not call \\`tinymce.Resource.add('${id}', data)\\` within 1 second`;\n\n      if (tasks[id] !== undefined) {\n        return tasks[id];\n      } else {\n        const task = new Promise((resolve, reject) => {\n          const waiter = awaiter(resolve, reject);\n          resultFns[id] = waiter.resolve;\n          ScriptLoader.ScriptLoader.loadScript(url).then(() => waiter.start(runErrMsg), () => waiter.reject(loadErrMsg));\n        });\n        tasks[id] = task;\n        return task;\n      }\n    };\n\n    const add = (id, data) => {\n      if (resultFns[id] !== undefined) {\n        resultFns[id](data);\n        delete resultFns[id];\n      }\n\n      tasks[id] = Promise.resolve(data);\n    };\n\n    const unload = id => {\n      delete tasks[id];\n    };\n\n    return {\n      load,\n      add,\n      unload\n    };\n  };\n\n  const Resource = create$1();\n\n  const create = () => (() => {\n    let data = {};\n    let keys = [];\n    const storage = {\n      getItem: key => {\n        const item = data[key];\n        return item ? item : null;\n      },\n      setItem: (key, value) => {\n        keys.push(key);\n        data[key] = String(value);\n      },\n      key: index => {\n        return keys[index];\n      },\n      removeItem: key => {\n        keys = keys.filter(k => k === key);\n        delete data[key];\n      },\n      clear: () => {\n        keys = [];\n        data = {};\n      },\n      length: 0\n    };\n    Object.defineProperty(storage, 'length', {\n      get: () => keys.length,\n      configurable: false,\n      enumerable: false\n    });\n    return storage;\n  })();\n\n  let localStorage;\n\n  try {\n    const test = '__storage_test__';\n    localStorage = window.localStorage;\n    localStorage.setItem(test, test);\n    localStorage.removeItem(test);\n  } catch (e) {\n    localStorage = create();\n  }\n\n  var LocalStorage = localStorage;\n  const publicApi = {\n    geom: {\n      Rect\n    },\n    util: {\n      Delay,\n      Tools,\n      VK,\n      URI,\n      EventDispatcher,\n      Observable,\n      I18n,\n      LocalStorage,\n      ImageUploader\n    },\n    dom: {\n      EventUtils,\n      TreeWalker: DomTreeWalker,\n      TextSeeker,\n      DOMUtils,\n      ScriptLoader,\n      RangeUtils,\n      Serializer: DomSerializer,\n      StyleSheetLoader,\n      ControlSelection,\n      BookmarkManager,\n      Selection: EditorSelection,\n      Event: EventUtils.Event\n    },\n    html: {\n      Styles,\n      Entities,\n      Node: AstNode,\n      Schema,\n      DomParser,\n      Writer,\n      Serializer: HtmlSerializer\n    },\n    Env,\n    AddOnManager,\n    Annotator,\n    Formatter,\n    UndoManager,\n    EditorCommands,\n    WindowManager,\n    NotificationManager,\n    EditorObservable,\n    Shortcuts,\n    Editor,\n    FocusManager,\n    EditorManager,\n    DOM: DOMUtils.DOM,\n    ScriptLoader: ScriptLoader.ScriptLoader,\n    PluginManager,\n    ThemeManager,\n    ModelManager,\n    IconManager,\n    Resource,\n    FakeClipboard,\n    trim: Tools.trim,\n    isArray: Tools.isArray,\n    is: Tools.is,\n    toArray: Tools.toArray,\n    makeMap: Tools.makeMap,\n    each: Tools.each,\n    map: Tools.map,\n    grep: Tools.grep,\n    inArray: Tools.inArray,\n    extend: Tools.extend,\n    walk: Tools.walk,\n    resolve: Tools.resolve,\n    explode: Tools.explode,\n    _addCacheSuffix: Tools._addCacheSuffix\n  };\n  const tinymce = Tools.extend(EditorManager, publicApi);\n\n  const exportToModuleLoaders = tinymce => {\n    if (typeof module === 'object') {\n      try {\n        module.exports = tinymce;\n      } catch (_) {}\n    }\n  };\n\n  const exportToWindowGlobal = tinymce => {\n    window.tinymce = tinymce;\n    window.tinyMCE = tinymce;\n  };\n\n  exportToWindowGlobal(tinymce);\n  exportToModuleLoaders(tinymce);\n})();","map":{"version":3,"names":["typeOf$1","x","undefined","t","Array","prototype","isPrototypeOf","constructor","name","String","isEquatableType","indexOf","sort$1","xs","compareFn","clone","slice","call","sort","contramap","eqa","f","eq$2","y","eq","tripleEq","eqString","eqArray","length","len","i","eqSortedArray","eqRecord","kx","Object","keys","ky","q","eqAny","tx","ty","getPrototypeOf$1","getPrototypeOf","hasProto","v","predicate","_a","typeOf","isArray","o","proto","isType$1","type","value","isSimpleType","eq$1","a","is$4","isObject","isString","isPlainObject","isArray$1","isNull","isBoolean","isUndefined","isNullable","isNonNullable","isFunction","isNumber","isArrayOf","pred","noop","compose","fa","fb","args","apply","compose1","fbc","fab","constant","identity","tripleEquals","b","curry","fn","initialArgs","restArgs","all","concat","not","die","msg","Error","apply$1","never","always","Optional","tag","some","none","singletonNone","fold","onNone","onSome","isSome","isNone","map","mapper","bind","binder","exists","forall","filter","getOr","replacement","or","getOrThunk","thunk","orThunk","getOrDie","message","from","getOrNull","getOrUndefined","each","worker","toArray","toString","nativeSlice","nativeIndexOf","nativePush","push","rawIndexOf","ts","indexOf$1","r","contains$2","map$3","each$g","eachr","partition$2","pass","fail","arr","filter$6","foldr","acc","foldl","findUntil$1","until","find$2","findIndex$2","flatten","bind$3","reverse","difference","a1","a2","mapToObject","comparator","copy","get$b","head","last$3","findMap","unique$1","isDuplicated","hasOwnProperty$2","hasOwnProperty","each$f","obj","props","k","map$2","tupleMap","tuple","objAcc","internalFilter","onTrue","onFalse","bifilter","filter$5","mapToArray","values","get$a","key","has$2","hasNonNullableKey","equal$1","stringArray","toArray$1","array","l","each$e","cb","s","n","map$1","callback","out","item","index","filter$4","reduce","collection","iteratee","accumulator","thisArg","findIndex$1","last$2","cached","called","DeviceType","os","browser","userAgent","mediaMatch","isiPad","isiOS","test","isiPhone","isMobile","isAndroid","isTouch","isTablet","isPhone","iOSwebview","isSafari","isDesktop","isWebView","firstMatch","regexes","find$1","agent","major","minor","group","Number","replace","nu$3","detect$5","versionRegexes","cleanedAgent","toLowerCase","unknown$2","Version","nu","detect","unknown","detectBrowser$1","browsers","userAgentData","brands","uaBrand","lcBrand","brand","info","current","version","parseInt","detect$4","candidates","candidate","search","detectBrowser","detectOs","oses","removeFromStart","str","numChars","substring","checkRange","substr","start","removeLeading","prefix","startsWith","contains$1","endsWith","suffix","blank","trim$3","lTrim","rTrim","isNotEmpty","isEmpty$3","repeat","count","join","toInt","radix","num","isNaN","normalVersionRegex","checkContains","target","uastring","PlatformInfo","edge","chromium","ie","opera","firefox","safari","unknown$1","nu$2","isBrowser","isEdge","isChromium","isIE","isOpera","isFirefox","Browser","windows","ios","android","linux","macos","solaris","freebsd","chromeos","nu$1","isOS","isWindows","isMacOS","isLinux","isSolaris","isFreeBSD","isChromeOS","OperatingSystem","detect$3","userAgentDataOpt","deviceType","PlatformDetection","query","window","matchMedia","matches","platform$2","navigator","detect$2","platform$1","browser$1","windowsPhone","Env","transparentSrc","documentMode","document","cacheSuffix","container","canHaveCSP","whiteSpaceRegExp$1","trim$2","is$3","makeMap$4","items","delim","split","hasOwnProperty$1","extend$3","ext","walk$4","resolve$2","explode$3","d","_addCacheSuffix","url","Tools","trim","is","makeMap","grep","inArray","hasOwn","extend","walk","resolve","explode","is$2","lhs","rhs","left","cat","lift2","oa","ob","lift3","oc","someIf","Function","COMMENT","DOCUMENT","DOCUMENT_FRAGMENT","ELEMENT","TEXT","element","dom","nodeName","type$1","nodeType","isType","isComment$1","isElement$7","isText$9","isDocument$2","isDocumentFragment$1","isTag","e","rawSet","setAttribute","console","error","set$2","setAll$1","attrs","get$9","getAttribute","getOpt","has$1","hasAttribute","remove$a","removeAttribute","hasNone","attributes","clone$4","attr","read$4","add$4","id","old","remove$9","supports","classList","get$8","add$3","clazz","remove$8","toggle$2","add$2","add","cleanClass","remove$7","remove","toggle$1","result","toggle","has","contains","isSupported$1","style","getPropertyValue","fromHtml$1","html","scope","doc","div","createElement","innerHTML","hasChildNodes","childNodes","fromDom$2","fromTag","node","fromText","text","createTextNode","fromPoint$2","docElm","elementFromPoint","SugarElement","fromHtml","fromDom","fromPoint","recurse","cur","is$1","selector","elem","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","bypassSelector","childElementCount","base","querySelectorAll","one","querySelector","e1","e2","d1","d2","owner$1","ownerDocument","documentOrOwner","dos","documentElement","defaultView","parent","parentNode","parentElement","parents$1","isRoot","stop","ret","rawParent","p","siblings","filterSelf","elements","children","prevSibling","previousSibling","nextSibling","prevSiblings","nextSiblings","child$1","cs","firstChild","lastChild","childNodesCount","getHead","isShadowRoot","host","supported","Element","attachShadow","Node","getRootNode","isSupported","getStyleContainer","getShadowRoot","getShadowHost","getOriginalEventTarget","event","el","isOpenShadowHost","composed","composedPath","shadowRoot","inBody","body","internalSet","property","setProperty","internalRemove","removeProperty","set$1","setAll","css","get$7","styles","getComputedStyle","getUnsafeProperty","getRaw$1","raw","getAllRaw","ruleName","remove$6","reflow","offsetWidth","before$3","marker","parent$1","insertBefore","after$4","sibling","append$1","prepend","firstChild$1","appendChild","wrap$2","wrapper","after$3","append","empty","textContent","rogue","remove$5","removeChild","unwrap","children$1","fromDom$1","nodes","get$6","set","content","owner","docDom","fragment","createDocumentFragment","contentElements","getOuter","cloneNode","mkEvent","prevent","kill","fromRawEvent","rawEvent","stopPropagation","preventDefault","clientX","clientY","handle$1","handler","useCapture","wrapped","addEventListener","unbind","bind$2","removeEventListener","top","translate","SugarPosition","boxPosition","box","getBoundingClientRect","firstDefinedOrZero","absolute","win","offsetLeft","offsetTop","scrollTop","pageYOffset","scrollLeft","pageXOffset","clientTop","clientLeft","viewport","get$5","_DOC","to","scrollTo","intoView","alignToTop","scrollIntoViewIfNeeded","scrollIntoView","get$4","_win","visualViewport","bounds","width","height","right","bottom","getBounds","scroll","clientWidth","clientHeight","Math","max","pageLeft","pageTop","isNodeType","isRestrictedNode","isElement$6","matchNodeNames","names","lowercasedNames","matchStyleValues","computed","cssValue","attrName","hasAttributeValue","attrValue","isBogus$2","isBogusAll$1","isTable$3","tagName","hasContentEditableState","contentEditable","isTextareaOrInput","isText$8","isCData","isPi","isComment","isDocument$1","isDocumentFragment","isBr$5","isImg","isContentEditableTrue$4","isContentEditableFalse$a","isTableCell$5","isMedia$2","firstElement","getTableCaptionDeltaY","elm","caption","bodyTop","captionTop","captionHeight","offsetHeight","hasChild","child","getPos","rootElm","pos","offsetParent","castOffsetParent","ClosestOrAncestor","ancestor","ancestor$3","closest$4","sibling$1","descendant$1","descend","res","ancestor$2","descendant","closest$3","StyleSheetLoader","documentOrShadowRoot","settings","idCount","loadedStates","edos","maxLoadTime","_setReferrerPolicy","referrerPolicy","addStyle","removeStyle","styleContainer","getOrCreateState","passed","failed","load","Promise","success","failure","link","urlWithSuffix","state","callbacks","status","onload","onerror","wait","testCallback","waitCallback","Date","now","startTime","setTimeout","waitForWebKitLinkLoaded","styleSheets","styleSheet","ownerNode","linkElem","rel","contentCssCors","loadAll","urls","loadedUrls","allSettled","then","results","parts","reject","reason","unload","unloadAll","create$c","WeakMap","forElement","referenceElement","root","rootDom","get","sl","instance","DomTreeWalker","startNode","rootNode","next","prev","prev2","shallow","findSibling","findPreviousNode","startName","siblingName","blocks","tableCells","tableSections","textBlocks","headings","listItems$1","lists","wsElements","lazyLookup","lookup","isHeading","isBlock$2","isTable$2","isInline$1","isBr$4","isTextBlock$2","isList","isListItem","isTableSection","isTableCell$4","isWsPreserveElement","ancestor$1","zeroWidth","nbsp","isZwsp$1","char","removeZwsp","ZWSP$1","isZwsp","trim$1","isElement$5","isText$7","isCaretContainerBlock$1","isCaretContainerInline","data","isCaretContainer$2","hasContent","insertInline$1","before","textNode","startsWithCaretContainer$1","splitText","endsWithCaretContainer$1","isBeforeInline","charAt","offset","isAtStart","isAfterInline","isAtEnd","createBogusBr","br","insertBlock","blockName","blockNode","trimBogusBr","brs","getElementsByTagName","lastBr","showCaretContainerBlock","caretContainer","isRangeInCaretContainerBlock","range","startContainer","isContentEditableTrue$3","isContentEditableFalse$9","isBr$3","isText$6","isInvalidTextElement","isAtomicInline","isTable$1","isCaretContainer$1","isCaretCandidate$3","isNonUiContentEditableFalse","isUnselectable","isInEditable","isAtomicContentEditableFalse","isAtomic$1","isEditableCaretCandidate$1","whiteSpaceRegExp","isWhitespaceText","isCollapsibleWhitespace$1","c","isNewLineChar","isNewline","idx","normalize$4","tabSpaces","isStartOfContent","isEndOfContent","tabSpace","normalizedText","pcIsSpace","hasWhitespacePreserveParent","rootElement","isWhitespace$1","isNamedAnchor","isContent$1","isBookmark","isBogus$1","isBogusAll","isEmptyNode","targetNode","skipBogus","brCount","walker","isEmpty$2","isSpan","isInlineContent","surroundedByInlineContent","prevIsInline","nextIsInline","isBookmarkNode$2","isKeepTextNode","isKeepElement","isDocument","trimNode","currentChildren","makeMap$3","attrsCharsRegExp","textCharsRegExp","rawCharsRegExp","entityRegExp","asciiMap","baseEntities","reverseEntities","nativeDecode","innerText","buildEntitiesLookup","chr","entity","fromCharCode","namedEntities","encodeRaw","encodeAllRaw","encodeNumeric","charCodeAt","encodeNamed","entities","getEncodeFunc","entitiesMap","encodeNamedAndNumeric","encodeCustomNamed","nameMap","named","numeric","decode","Entities","mapCache","dummyObj","makeMap$2","each$d","extend$2","explode$2","split$1","compileSchema","schema","globalAttributes","blockContent","phrasingContent","flowContent","html4BlockContent","html4PhrasingContent","childNames","ni","attributesOrder","addAttrs","schemaItem","video","audio","table","script","compileElementMap","mode","toUpperCase","Schema","patternElements","customElementsMap","specialElements","createLookupTable","option","defaultValue","extendWith","schemaType","schemaItems","verify_html","valid_elements","validStyles","valid_styles","invalidStyles","invalid_styles","validClasses","valid_classes","whitespaceElementsMap","selfClosingElementsMap","voidElementsMap","boolAttrMap","nonEmptyOrMoveCaretBeforeOnEnter","nonEmptyElementsMap","moveCaretBeforeOnEnterElementsMap","textBlockElementsMap","blockElementsMap","textInlineElementsMap","RegExp","patternToRegExp","addValidElements","validElements","ei","ai","al","attrData","elementName","attrType","outputName","globalAttributesOrder","elementRuleRegExp","attrRuleRegExp","hasPatternsRegExp","validElementsArr","exec","paddEmpty","removeEmpty","removeEmptyAttrs","attributesRequired","required","splice","attributesDefault","attributesForced","forcedValue","validValues","attributePatterns","pattern","setValidElements","addCustomElements","customElements","customElementRegExp","text_block_elements","block_elements","rule","inline","cloneName","customRule","elmName","addValidChildren","validChildren","childRuleRegExp","getElementRule","custom_elements","valid_children","extended_valid_elements","dd","dt","li","td","th","tr","tbody","thead","tfoot","legend","area","param","parents","parentsRequired","invalid_elements","getValidStyles","getInvalidStyles","getValidClasses","getBoolAttrs","getBlockElements","getTextBlockElements","getTextInlineElements","getVoidElements","seal","getSelfClosingElements","getNonEmptyElements","getMoveCaretBeforeOnEnterElements","getWhitespaceElements","getSpecialElements","isValidChild","isValid","attrPatterns","getCustomElements","Styles","urlOrStrRegExp","styleRegExp","trimRightRegExp","encodingLookup","invisibleChar","encodingItems","self","parse","isEncoded","urlConverter","url_converter","urlConverterScope","url_converter_scope","compress","noJoin","canCompress","compress2","encode","keepSlashes","decodeSingleHexSequence","escSeq","decodeHexSequences","processUrl","match","url2","url3","str2","allow_script_urls","scriptUrl","allow_svg_data_urls","lastIndex","border","serialize","serializeStyles","styleList","styleMap","deprecated","keyLocation","layerX","layerY","returnValue","webkitMovementX","webkitMovementY","keyIdentifier","mozPressure","isNativeEvent","Event","initEvent","hasIsDefaultPrevented","isDefaultPrevented","needsNormalizing","clone$3","originalEvent","normalize$3","fallbackTarget","srcElement","defaultPrevented","cancelBubble","isPropagationStopped","stopImmediatePropagation","isImmediatePropagationStopped","eventExpandoPrefix","mouseEventRe","addEvent","capture","attachEvent","removeEvent","detachEvent","isMouseEvent","fix","pageX","eventDoc","mouseEvent","pageY","bindOnReady","eventUtils","domLoaded","isDocReady","readyState","readyHandler","EventUtils","events","expando","hasMouseEnterLeave","hasFocusIn","callbackList","fakeName","nativeHandler","defaultNativeHandler","evt","executeHandlers","namesList","mouseEnterLeave","currentTarget","related","relatedTarget","func","ci","eventMap","ex","fire","dispatch","parentWindow","clean","destroy","cancel","each$c","internalStyleName","legacySetAttribute","setupAttrHooks","getContext","keepValues","keep_values","keepUrlHook","sugarElm","internalName","attrHooks","href","src","updateInternalStyleAttr","rawValue","findNodeIndex","normalized","lastNodeType","nodeValue","numericalCssMap","camelCaseToHyphens","DOMUtils","addedStyles","files","counter","stdMode","boxModel","styleSheetLoader","boundEvents","ownEvents","isBlock","getElementById","_get","getAttrib","defaultVal","$elm","hook","getAttribs","setAttrib","run","originalValue","onSetAttrib","attrElm","deep","getRoot","root_element","getViewPort","argWin","vp","w","h","getPos$1","setStyle","convertStyleToString","cssName","applyStyle","normalizedName","update_styles","setStyles","stylesArg","getStyle","getSize","getRect","size","elms","getParents","collect","selectorVal","getParent","_findSib","getNext","getPrev","select","_b","context","setAttribs","setHTML","parentElm","create","newElm","createHTML","outHtml","createFragment","frag","keepChildren","$node","removeAllAttribs","removeAttributeNode","parseStyle","cssText","serializeStyle","styleElm","DOM","loadCSS","catch","toggleClass","cls","classes","addClass","removeClass","hasClass","show","hide","isHidden","uniqueId","getOuterHTML","outerHTML","setOuterHTML","insertAfter","reference","referenceNode","oldElm","replaceChild","rename","attrNode","findCommonAncestor","ps","pe","isNonEmptyElement","isEmpty","whitespace","bogusVal","createRng","createRange","splitElm","replacementElm","beforeFragment","afterFragment","setStart","setEnd","extractContents","rv","getContentEditable","getContentEditableParent","_","isChildOf","dumpRng","startOffset","endContainer","endOffset","nodeIndex","DOM$b","QUEUED","LOADING","LOADED","FAILED","ScriptLoader","states","queue","scriptLoadedCallbacks","queueLoadedCallbacks","loading","loadScript","cleanup","done","isDone","markDone","loadQueue","loadScripts","scripts","execCallbacks","processResults","failures","processQueue","nextQueuedItem","shift","uniqueScripts","Cell","initial","isRaw","isTokenised","currentCode","getLanguageData","getData$1","setCode","newCode","getCode","add$1","code","langData","translation","getLangData","textstr","removeContext","substitued","$1","$2","isRtl$1","dir","hasCode","I18n","getData","isRtl","AddOnManager","_listeners","runListeners","matchedListeners","listener","isLoaded","isAdded","loadLanguagePack","languages","language","wrappedLanguages","requireLangPack","languageLoad","waitFor","addOn","createUrl","baseUrl","dep","resource","addOnUrl","urlString","baseURL","lastIndexOf","PluginManager","ThemeManager","ModelManager","singleton","doRevoke","subject","revoke","clear","isSet","value$2","on","first$1","rate","timer","clearTimeout","throttle","last$1","descendants$1","descendants","annotation","dataAnnotation","dataAnnotationId","dataAnnotationActive","identify","editor","annotationName","rng","selection","getRng","getBody","an","newStart","closest","getAttr","uid","findMarkers","isAnnotation","findAll","markers","directory","m","nodesAlready","setup$x","registry","changeCallbacks","initData","listeners","previous","withCallbacks","updateCallbacks","callbackMap","outputData","fireCallbacks","fireNoAnnotation","toggleActiveAttr","span","onNodeChange","annotations","getNames","addListener","setup$w","identifyParserNode","serializer","addTempAttr","addNodeFilter","spans","persistent","create$b","register","unique","generate$1","date","time","getTime","random","floor","clone$2","original","isDeep","shallow$1","deep$1","shallowAs","mutate","TextWalker","isBoundary","direction","TextSeeker","isBlockBoundary","process","newOffset","backwards","forwards","round$1","round","clone$1","rect","collapse","toStart","isEqual","rect1","rect2","isValidOverflow","overflowY","min","isAbove$1","halfHeight","isBelow$1","containsXY","boundingClientRectFromRects","rects","prevRect","distanceToRectEdgeFromXY","cx","cy","sqrt","overlapY","r1","r2","clamp$2","getSelectedNode","getNode$1","safeOffset","getNodeUnsafe","extendingChars","isExtendingChar","ch","and","isElement$4","isCaretCandidate$2","isBlock$1","isFloated","isValidElementCaretCandidate","isNotPre","isText$5","isBr$2","nodeIndex$1","resolveIndex$1","createRange$1","isWhiteSpace$1","isRange","isHiddenWhiteSpaceRange","getBrClientRect","brNode","nbsp$1","clientRect","getBoundingClientRectWebKitText","sc","ec","so","eo","newRng","cloneRange","setEndAfter","getBoundingClientRect$1","isZeroRect","clientRects","getClientRects","collapseAndInflateWidth","newClientRect","getCaretPositionClientRects","caretPosition","addUniqueAndValidRect","addCharacterOffset","beforeNode","CaretPosition","toRange","isVisible","getNode","fromRangeStart","fromRangeEnd","after","isAbove","pos1","pos2","isBelow","isTextPosition","isElementPosition","trimEmptyTextNode$1","insertNode","insertFragment","rangeInsertNode","isText$4","isBogus","normalizedParent","getChildNodes","normalizedTextOffset","equal","normalizedNodeIndex","numTextFragments","createPathItem","parentsUntil$1","create$a","path","outputOffset","resolvePathItem","findTextPosition","targetOffset","dataLen","resolve$1","paths","isContentEditableFalse$8","getNormalizedTextOffset","trimmedOffset","getPoint","point","getLocation","bookmark","isCollapsed","end","isFakeCaret","findIndex","moveEndPoint$1","normalizeTableCellSelection","findAdjacentContentEditableFalseElm","getOffsetBookmark","getCaretBookmark","getRangeBookmark","createBookmarkSpan","filled","getPersistentBookmark","collapsed","rng2","endBookmarkNode","startBookmarkNode","moveToBookmark","keep","getBookmark$2","getUndoBookmark","value$1","applyHelper","constHelper","outputHelper","output","inner","_onError","onValue","isValue","isError","Result","mapError","toOptional","onError","_onValue","fromOption","optional","err","generate","cases","constructors","adt","acase","keys$1","argLength","branches","branchKeys","allReqd","reqKey","foldArgs","log","label","params","Adt","bothErrors","firstError","secondError","bothValues","partition$1","errors","isInlinePattern","isBlockPattern","sortPatterns","patterns","normalizePattern","formatOrCmd","onFormat","onCommand","format","formats","cmd","command","commandValue","getBlockPatterns","getInlinePatterns","createPatternSet","inlinePatterns","blockPatterns","fromRawPatterns","deviceDetection$1","DOM$a","getHash","val","isRegExp","options","stringOrObjectProcessor","bodyOptionProcessor","valid","bodyObj","register$7","registerOption","processor","default","documentBaseUrl","isInline","newValue","hasPlugin","convertURL","getElement","getIframeAttrs","getDocType","getDocumentBaseUrl","getBodyId","getBodyClass","getContentSecurityPolicy","shouldPutBrInPre$1","getForcedRootBlock","getForcedRootBlockAttrs","getBrNewLineSelector","getNoNewLineSelector","shouldKeepStyles","shouldEndContainerOnEmptyBlock","isAutomaticUploadsEnabled","shouldReuseFileName","shouldReplaceBlobUris","getIconPackName","getIconsUrl","getImageUploadUrl","getImageUploadBasePath","getImagesUploadCredentials","getImagesUploadHandler","shouldUseContentCssCors","getReferrerPolicy","getLanguageCode","getLanguageUrl","shouldIndentUseMargin","getIndentation","getContentCss","getContentStyle","getFontCss","getDirectionality","getInlineBoundarySelector","getObjectResizing","getResizeImgProportional","getPlaceholder","getEventRoot","getServiceMessage","getTheme","getThemeUrl","getModel","getModelUrl","isInlineBoundariesEnabled","getFormats","getPreviewStyles","canFormatEmptyLines","getCustomUiSelector","hasHiddenInput","shouldPatchSubmit","shouldAddFormSubmitTrigger","shouldAddUnloadTrigger","getCustomUndoRedoLevels","shouldDisableNodeChange","isReadOnly$1","hasContentCssCors","getPlugins","getExternalPlugins$1","shouldBlockUnsupportedDrop","isVisualAidsEnabled","getVisualAidsTableClass","getVisualAidsAnchorClass","getIframeAriaText","getSetupCallback","getInitInstanceCallback","getUrlConverterCallback","getAutoFocus","shouldBrowserSpellcheck","getProtect","shouldPasteBlockDrop","shouldPasteDataImages","getPastePreProcess","getPastePostProcess","getPasteWebkitStyles","shouldPasteRemoveWebKitStyles","shouldPasteMergeFormats","isSmartPasteEnabled","isPasteAsTextEnabled","getPasteTabSpaces","shouldAllowHtmlDataUrls","getTextPatterns","getNonEditableClass","getEditableClass","getNonEditableRegExps","getFontStyleValues","getFontSizeClasses","isEncodingXml","getAllowedImageFileTypes","hasTableTabNavigation","isElement$3","isText$3","removeNode$1","trimCount","trimmedText","deleteZwspChars","deleteData","removeUnchanged","remove$4","removeTextAndReposition","removeElementAndReposition","newPosition","removeTextCaretContainer","removeElementCaretContainer","removeAndReposition","caretContainerNode","isContentEditableFalse$7","isMedia$1","isTableCell$3","inlineFakeCaretSelector","getAbsoluteClientRect","scrollX","scrollY","rootRect","margin","trimInlineCaretContainers","fakeCaretTargetNodes","FakeCaret","hasFocus","lastVisualCaret","cursorInterval","caretBlock","caret","startBlink","isInlineFakeCaretTarget","caretState","clearInterval","setInterval","reposition","getCss","isFakeCaretTableBrowser","isFakeCaretTarget","isContentEditableTrue$2","isContentEditableFalse$6","isMedia","isBlockLike","isCaretContainer","isCaretContainerBlock","isElement$2","isCaretCandidate$1","isForwards","isBackwards","skipCaretContainers","findNode","predicateFn","isCefOrCaretContainer","getEditingHost","isCETrue","getParentBlock$3","isInSameBlock","caretPosition1","caretPosition2","getChildNodeAtRelativeOffset","relativeOffset","beforeAfter","setStartBefore","setEndBefore","setStartAfter","isNodesInSameBlock","node1","node2","lean","before$2","after$2","normalizeRange","leanLeft","leanRight","location","getRelativeCefElm","forward","getNormalizedRangeEndPoint","normalizedRange","getElementFromPosition","getElementFromPrevPosition","getVisualCaretPosition","walkFn","isMoveInsideSameBlock","inSameBlock","HDirection","isContentEditableFalse$5","isText$2","isElement$1","isBr$1","isCaretCandidate","isAtomic","isEditableCaretCandidate","getParents$3","nodeAtIndex","getCaretCandidatePosition","moveForwardFromBr","nextNode","findCaretPosition$1","Forwards","startPos","innerNode","rootContentEditableFalseElm","CaretWalker","Backwards","walkToPositionIn","position","fromPosition","afterElement","isBeforeOrStart","isAfterOrEnd","isBeforeAfterSameElement","isAtBr","shouldSkipPosition","navigate","navigateIgnore","ignoreFilter","positionIn","nextPosition","prevPosition","firstPositionIn","lastPositionIn","CARET_ID$1","isCaretNode","getParentCaretContainer","isStringPathBookmark","isRangeBookmark","isIdBookmark","isIndexBookmark","isPathBookmark","addBogus","resolveCaretPositionBookmark","insertZwsp","isEmpty$1","tryFindRangePosition","padEmptyCaretContainer","setEndPoint","isValidTextNode","restoreEndPoint","appendData","resolvePaths","resolveId","endPos","spos","epos","resolveIndex","selectNode","getBookmark$1","setRng","isBookmarkNode$1","expected","actual","isNbsp","isWhiteSpace","isContent","hexColour","toHex","component","hex","fromRgba","rgbaColour","red","green","blue","rgbRegex","rgbaRegex","alpha","fromStringValues","g","parseFloat","fromString","rgbaString","rgbMatch","rgbaMatch","rgbaToHexString","color","isNode","isInlineBlock","moveStart","isWhiteSpaceNode$1","getNonWhiteSpaceSibling","inc","nextName","isTextBlock$1","ed","allowSpaces","isEmptyTextNode$1","replaceVars","vars","isEq$5","str1","normalizeStyleValue","getTextDecoration","decoration","getParents$2","isVariableFormatName","formatName","hasVariableValues","isVariableValue","field","fieldValues","formatter","areSimilarFormats","otherFormatName","validKeys","filterObj","validKey","fmt1","filteredFmt1","fmt2","filteredFmt2","isBlockFormat","isSelectorFormat","isInlineFormat","isMixedFormat","shouldExpandToSelector","expand","isBookmarkNode","getParents$1","isWhiteSpaceNode","isTextBlock","isBogusBr","findParentContentEditable","walkText","findSpace","findContent","findWordEndPoint","includeTrailingSpaces","lastTextNode","textSeeker","textOffset","spaceResult","findSelectorEndPoint","formatList","curFormat","findBlockEndPoint","block","scopeRoot","isAtBlockBoundary$1","findParentContainer","block_expand","isSelfOrParentBookmark","expandRng","includeTrailingSpace","startPoint","endPoint","walk$3","exclude","firstNode","lastNode","collectSiblings","endNode","findEndPoint","walkBoundary","getRanges$1","ranges","rangeCount","getRangeAt","getSelectedNodes","hasMultipleRanges","getCellsFromRanges","getCellsFromElement","getCellsFromElementOrRanges","selectedCells","getCellsFromEditor","getSel","getClosestTable","cell","getStartNode","getEndNode","getFirstChildren","getLastChildren$1","hasAllContentsSelected","moveEndPoint","hasAnyRanges","sel","runOnRanges","executor","fakeSelectionNodes","fakeNodeRng","preserve","fillBookmark","NodeValue","getOption","api$1","get$3","isZeroWidth","wrapName","applyWordGrab","makeAnnotation","eDoc","decorate","master","annotate","newWrappers","getDoc","finishWrapper","getOrOpenWrapper","processElements","elems","processElement","ctx","processNodes","annotateWithBookmark","undoManager","transact","initialRng","hasFakeSelection","selectionRng","Annotator","changes","annotationChanged","getBookmark","removeAll","getAll","BookmarkManager","isXYWithinRange","firePreProcess","firePostProcess","fireRemove","fireDetach","fireSwitchMode","fireObjectResizeStart","origin","fireObjectResized","firePreInit","firePostRender","fireInit","firePlaceholderToggle","fireError","errorType","fireFormatApply","fireFormatRemove","fireBeforeSetContent","fireSetContent","fireBeforeGetContent","fireGetContent","fireAutocompleterStart","fireAutocompleterUpdate","fireAutocompleterEnd","firePastePreProcess","internal","firePastePostProcess","firePastePlainTextToggle","VK","BACKSPACE","DELETE","DOWN","ENTER","ESC","LEFT","RIGHT","SPACEBAR","TAB","UP","PAGE_UP","PAGE_DOWN","END","HOME","modifierPressed","shiftKey","ctrlKey","altKey","metaKeyPressed","metaKey","ControlSelection","elementSelectionAttr","selectedElm","selectedElmGhost","resizeHelper","selectedHandle","resizeBackdrop","startX","startY","selectedElmX","selectedElmY","startW","startH","ratio","resizeStarted","editableDoc","rootDocument","abs","startScrollWidth","startScrollHeight","resizeHandles","nw","ne","se","sw","isImage","isEventOnImageOutsideRange","touch","touches","contextMenuSelectImage","getResizeTargets","firstElementChild","isResizable","createGhostElement","setSizeProp","targets","setGhostElmSize","ghostElm","resizeGhostElement","deltaX","deltaY","proportional","resizeHelperX","resizeHelperY","screenX","screenY","display","scrollWidth","scrollHeight","endGhostResize","wasResizeStarted","showResizeRect","nodeChanged","targetElm","unbindResizeHandleEvents","targetWidth","targetHeight","hideResizeRect","selectedValue","handle","handleElm","startDrag","updateResizeRect","startElm","controlElm","isChildOrEqual","removed","img","disableGeckoResize","getStart","getEnd","execCommand","throttledUpdateResizeRect","composing","situ","setFinish","relativeToNative","startSitu","finishSitu","exactToNative","soffset","finish","foffset","adt$3","ltr","rtl","fromRange","getRanges","domRange","relative","exact","doDiagnose","reversed","rev","diagnose","create$9","SimRange","caretPositionFromPoint","offsetNode","caretRangeFromPoint","availableSearch","fromPoint$1","adt$2","cata","onBefore","onOn","onAfter","getStart$2","before$1","after$1","Situ","adt$1","exactFromRange","simRange","getStart$1","_finishSitu","_soffset","_finish","_foffset","getWin","SimSelection","beforeSpecial","name$1","preprocessRelative","preprocessExact","preprocess","fromElements","toNative","getDomRange","filtered","getAtPoint","isEq$4","rng1","findParent","hasParent$1","hasParentWithName","isTable","isTableCell$2","isCeFalseCaretContainer","hasBrBeforeAfter","isPrevNode","hasContentEditableFalseParent","findTextNodeRelative","isAfterNode","lastInlineElement","parentBlockContainer","normalizeEndPoint","directionLeft","normalize$2","normRng","RangeUtils","normalize","normalizedRng","compareRanges","getCaretRangeFromPoint","Dimension","getOffset","aggregate","properties","cumulativeInclusions","absoluteMax","api","get$2","getDocument","walkUp","navigation","frame","view","rest","pathTo","frameElement","Navigation","freeze","__proto__","find","frames","loc","excludeFromDescend","fireScrollIntoViewEvent","scrollEvent","fireAfterScrollIntoViewEvent","last","markerInfo","cleanupFun","createMarker$1","elementMarker","withMarker","preserveWith","_s","_e","applyWithMarker","withScrollEvents","withElement","startElement","endElement","scrollToMarker","viewHeight","intoWindowIfNeeded","viewportBottom","markerTop","markerBottom","largerThanViewport","align","intoWindow","innerHeight","intoFrame","frameViewHeight","op","viewportBounds","rangeIntoWindow","elementIntoWindow","rangeIntoFrame","elementIntoFrame","scrollElementIntoView","scroller","scrollRangeIntoView","focus$1","focus","hasFocus$1","activeElement","active$1","clamp$1","normalizeRng","isOrContains","isRngInRoot","shouldStore","nativeRangeToSelectionRange","readRange","getSelection","validate","bookmarkToNativeRng","store","newBookmark","restore","isEditorUIElement$1","className","FocusManager","isEditorUIElement","wrappedSetTimeout","wrappedSetInterval","Delay","setEditorTimeout","setEditorInterval","isManualNodeChange","selectionChange","registerPageMouseUp","throttledStore","mouseUpPage","registerMouseUp","registerEditorEvents","register$6","documentFocusInHandler","DOM$9","isEditorContentAreaElement","isUIElement","customSelector","getActiveElement","registerEvents$1","editorManager","focusedEditor","setActive","blurredEditor","activeEditor","unregisterDocumentEvents","setup$v","getContentEditableHost","getCollapsedNode","getFocusInElement","normalizeSelection$1","caretPos","focusBody","hasElementFocus","hasIframeFocus","iframeElement","hasInlineFocus","rawBody","hasUiFocus","hasEditorOrUiFocus","focusEditor","quirks","refreshContentEditable","bookmarkRng","contentEditableHost","activateEditor","skipFocus","getEndpointElement","real","getEnd$1","skipEmptyTextNodes","orig","commonAncestorContainer","getSelectedBlocks","endElm","selectedBlocks","processRanges","isTextNodeWithCursorPosition","elementsWithCursorPosition","isCursorPosition","hasCursorPosition","first","descendantRtl","autocompleteSelector","create$8","findIn","setCursorLocation","detect$1","remove$3","typeLookup","walk$2","isEmptyTextNode","AstNode","insert","selfAttrs","cloneAttrs","selfAttr","wrap","refNode","isConditionalComment","startIndex","findCommentEndIndex","lcHtml","endIfIndex","endIndex","endCommentRegexp","findMatchingEndTagIndex","startTagRegExp","endTagRegExp","voidElements","startMatch","endMatch","trimHtml$1","tempAttrs","trimContentRegExp","trimInternal","bogusAllRegExp","getTempAttrs","matchLength","endTagIndex","trimExternal","trimEmptyContents","emptyRegExp","getContentFromBody","shouldTrim","getContentInternal","each$b","ElementUtils","compare","attribs","compareObjects","obj1","obj2","makeMap$1","Writer","indent","indentBefore","indent_before","indentAfter","indent_after","entity_encoding","htmlOutput","element_format","cdata","comment","pi","doctype","reset","getContent","HtmlSerializer","writer","handlers","sortedAttrs","elementRule","nonInheritableStyles","Set","nonInheritableStylesArr","shorthandStyleProps","getStyleProps","isNonInheritableStyle","hasInheritableStyles","getLonghandStyleProps","prop","hasStyleConflict","nodeStyleProps","parentNodeStyleProps","valueMismatch","parentValue","nodeStyleProp","propExists","longhandProps","isChar","delta","isBeforeSpace","isAfterSpace","isEmptyText","matchesElementPosition","isImageBlock","isCefNode","isBeforeImageBlock","isAfterImageBlock","isBeforeMedia","isAfterMedia","isBeforeTable","isAfterTable","isBeforeContentEditableFalse","isAfterContentEditableFalse","getLastChildren","rawNode","removeTrailingBr","allBrs","fillWithPaddingBr","trimBlockTrailingBr","lastChildPrevSibling","dropLast","parentsUntil","parentsAndSelf","navigateIgnoreEmptyTextNodes","getClosestBlock$1","isAtBeforeAfterBlockBoundary","newPos","fromBlock","isAtBlockBoundary","isAtStartOfBlock","isAtEndOfBlock","isBeforeBlock","isAfterBlock","isBr","findBr","parentBlocks","isBeforeBr$1","isAfterBr","findPreviousBr","findNextBr","isInMiddleOfText","getClosestBlock","hasSpaceBefore","hasSpaceAfter","isPreValue","isInPre","isAtBeginningOfBody","isAtEndOfBody","isAtLineBoundary","needsToHaveNbsp","needsToBeNbspLeft","needsToBeNbspRight","needsToBeNbsp","isNbspAt","hasNbsp","normalizeNbspMiddle","chars","normalizeNbspAtStart","firstPos","normalizeNbspInMiddleOfTextNode","newText","normalizeNbspAtEnd","lastPos","normalizeNbsps","normalizeNbspsInEditor","normalize$1","replaceData","normalizeWhitespaceAfter","whitespaceCount","normalizeWhitespaceBefore","mergeTextNodes","prevNode","normalizeWhitespace","mergeToPrev","whitespaceOffset","newNode","removeNode","insertData","needsReposition","beforeOrStartOf","afterOrEndOf","getPreviousSiblingCaretPosition","getNextSiblingCaretPosition","findCaretPositionBackwardsFromElm","startPosition","findCaretPositionForwardsFromElm","findCaretPositionBackwards","findCaretPositionForward","findCaretPosition","findCaretPosOutsideElmAfterDelete","setSelection$1","eqRawNode","paddEmptyBlock","deleteNormalized","afterDeletePosOpt","prevTextOpt","nextTextOpt","isInlineElement","deleteElement$2","moveCaret","afterDeletePos","parentBlock","normalizedAfterDeletePos","setContent","paddPos","isRootFromElement","getTableCells","getTableDetailsFromRange","getTable","startTable","endTable","isStartInTable","isEndInTable","isSameTable","isMultiTable","tableCellRng","tableSelection","cells","deleteAction","singleCellTable","fullTable","partialTable","multiTable","getClosestCell$1","isExpandedCellRng","cellRng","getTableFromCellRng","startParentTable","endParentTable","isSingleCellTable","rows","getCellRng","startCell","endCell","getCellRangeFromStartTable","getCellRangeFromEndTable","getTableSelectionFromCellRng","getTableSelections","selectionDetails","sameTableSelection","startTableSelection","endTableSelection","getCellIndex","getSelectedCells","isSingleCellTableContentSelected","optCellRng","unselectCells","otherContentRng","handleSingleTable","handleMultiTable","startTableSelectedCells","endTableSelectedCells","getActionFromRange","freefallRtl","cleanCells","getOutsideBlock","handleEmptyBlock","startInTable","emptyBlock","deleteContentInsideCell","isFirstCellInSelection","insideTableRng","deleteCellContents","action","collapseAndRestoreCellSelection","selectedNode","emptySingleTableCells","outsideDetails","editorRng","cellsToClean","outsideBlock","deleteContents","endPointCell","emptyMultiTableCells","startTableCells","endTableCells","betweenRng","startTableCellsToClean","endTableCellsToClean","moveSelection","lastBlock","additionalCleanupNodes","deleteTableElement","deleteCellRange","deleteCaptionRange","emptyElement","deleteTableRange","getParentCaption","deleteRange$2","getParentCell","deleteBetweenCells","fromCell","toCell","isDeleteOfLastCharPos","fromCaption","emptyCaretCaption","validateCaretCaption","toCaption","deleteCaretInsideCaption","deleteCaretCells","deleteCaretCaption","isNearTable","isBeforeOrAfterTable","fromPos","deleteCaret$3","backspaceDelete$9","getContentEditableRoot$1","traverse","matchNode$1","nodeFilters","attributeFilters","nl","findMatchingNodes","runFilters","matchRecord","filter$3","paddEmptyNode","blockElements","isPaddedWithNbsp","hasOnlyChild","isPadded","nonEmptyElements","whitespaceElements","isLineBreakNode","removeOrUnwrapInvalidNode","originalNodeParent","childNode","cleanInvalidNodes","onCreate","textBlockElements","nonSplittableElements","fixed","newParent","tempNode","currentNode","normalizeBlockSelectionRange","newEndPos","hasOnlyOneChild$1","isPaddingNode","isPaddedEmptyBlock","isEmptyFragmentElement","isListFragment","cleanupDomFragment","domFragment","toDomFragment","listItems","isPadding","isListItemPadded","isEmptyOrPadded","trimListItems","getParentLi","isParentBlockLi","getSplit","beforeRng","afterRng","cloneContents","findFirstIn","caretWalker","newCaretPos","findLastOf","insertMiddle","insertBefore$1","insertAfter$1","insertAtCaret$1","liTarget","liElms","BEGINNING","isAt","isTableCell$1","isTableCellContentSelected","validInsertion","no_events","trimBrsFromTableCell","reduceInlineTextElements","merge","textInlineElements","elementUtils","styleConflict","markFragmentElements","unmarkFragmentElements","isPartOfFragment","canHaveChildren","moveSelectionToMarker","nextRng","parentEditableElm","findNextCaretRng","deleteSelectedContent","insertHtmlAtCaret","details","parser","bookmarkHtml","caretElement","parserArgs","paste","_selectionOverrides","showBlockCaretContainer","invalid","markerNode","toExtract","invalidChildren","getNodeFilters","getAttributeFilters","isTreeNode","setEditorHtml","noSelection","setContentString","padd","forcedRootBlockName","no_selection","isRootContent","trimmedHtml","setContentTree","setContentInternal","ensureIsRoot","transform","transformed","closest$2","isEq$3","matchesUnInheritedFormatSelector","inherit","matchParents","similar","matchNode","matchName","matchItems","itemName","onmatch","expectedValue","isEmptyValue","match$2","matchAll","matchedFormatNames","checkedMap","closest$1","rawElm","canApply","matchAllOnNode","formatNames","matchSimilar","ZWSP","CARET_ID","importNode","getEmptyCaretContainers","isCaretContainerEmpty","findFirstTextNode","createCaretContainer","fill","trimZwspFromCaretContainer","removeCaretContainerNode","removeCaretContainer","insertCaretContainerNode","formatNode","appendNode","insertFormatNodesIntoCaretContainer","formatNodes","innerMostFormatNode","cleanFormatNode","validFormats","matchedFormats","uniqueFormats","fmtName","clonedFormatNode","applyCaretFormat","wordcharRegex","removeCaretFormat","hasContentAfter","expandedRng","newCaretContainer","cleanedFormatNode","caretTextNode","disableCaretContainer","keyCode","setup$u","replaceWithCaretFormat","innerMost","isFormatElement","inlineElements","isEmptyCaretFormatElement","postProcessHooks","filter$2","each$a","addPostProcessHook","hooks","postProcess$1","hasPreSibling","pre","isPre","joinPre","pre1","pre2","sPre2","each$9","isElementNode$1","findElementSibling","mergeSiblingsNodes","tmpSibling","mergeSiblings","merge_siblings","clearChildStyles","clear_child_styles","links","processChildElements","unwrapEmptySpan","hasStyle","removeResult","MCE_ATTR_RE","each$8","isEq$2","isTableCellOrRow","isChildOfInlineParent","getContainer","lastIdx","normalizeTableSelection","wrap$1","wrapWithSiblings","isColorFormatAndAnchor","rootBlockElm","forcedRootBlock","list_block","removeFormatInternal","compareNode","stylesModified","preserve_attributes","attrsToPreserve","remove_similar","valueOut","removeFormat$1","newName","findFormatRoot","formatRoot","removeFormatFromClone","wrapAndSplit","lastClone","firstClone","formatRootParent","mixed","remove$2","splitToFormatRoot","isRemoveBookmarkNode","removeNodeFormat","fmt","lastContentEditable","currentNodeMatches","textDecorations","textDecoration","removeRngStyle","ceFalseOverride","each$7","mergeTextDecorationsAndColor","processTextDecorationsAndColor","mergeBackgroundColorAndFontSize","backgroundColor","mergeSubSup","mergeWithChildren","mergeWithParents","merge_with_parents","each$6","isElementNode","canFormatBR","parentName","validBRParentElements","figcaption","summary","hasCaretNodeSibling","applyFormat$1","setElementFormat","onformat","styleVal","applyNodeStyle","found","createWrapElement","wrapElm","applyRngStyle","nodeSpecific","currentWrapElm","getChildCount","mergeStyles","childElement","childCount","formatItem","fake","hasVars","setup$t","registeredFormatListeners","updateAndFireChangeCallbacks","nodeOrRange","fallbackElement","matchingNode","isMatchingNode","matchingFormat","isUnableToMatch","registeredCallbacks","runIfChanged","spec","withSimilar","withoutSimilar","withVars","addListeners","formatChangeItems","getCurrent","toAppendTo","removeListeners","formatChangedInternal","_toConsumableArray","arr2","setPrototypeOf","isFrozen","getOwnPropertyDescriptor","create$7","_ref","Reflect","construct","fun","thisValue","Func","arrayForEach","unapply","forEach","arrayPop","pop","arrayPush","stringToLowerCase","stringMatch","stringReplace","stringIndexOf","stringTrim","regExpTest","typeErrorCreate","unconstruct","TypeError","_len","arguments","_key","_len2","_key2","addToSet","lcElement","object","newObject","lookupGetter","desc","fallbackValue","warn","svg","svgFilters","svgDisallowed","mathMl","mathMlDisallowed","html$1","svg$1","mathMl$1","xml","MUSTACHE_EXPR","ERB_EXPR","DATA_ATTR","ARIA_ATTR","IS_ALLOWED_URI","IS_SCRIPT_OR_DATA","ATTR_WHITESPACE","DOCTYPE_NAME","_typeof","Symbol","iterator","_toConsumableArray$1","getGlobal","_createTrustedTypesPolicy","trustedTypes","createPolicy","ATTR_NAME","currentScript","policyName","html$$1","createDOMPurify","DOMPurify","originalDocument","DocumentFragment","HTMLTemplateElement","NodeFilter","_window$NamedNodeMap","NamedNodeMap","MozNamedAttrMap","HTMLFormElement","DOMParser","ElementPrototype","getNextSibling","getParentNode","template","trustedTypesPolicy","emptyHTML","_document","implementation","createNodeIterator","createHTMLDocument","MUSTACHE_EXPR$$1","ERB_EXPR$$1","DATA_ATTR$$1","ARIA_ATTR$$1","IS_SCRIPT_OR_DATA$$1","ATTR_WHITESPACE$$1","IS_ALLOWED_URI$$1","ALLOWED_TAGS","DEFAULT_ALLOWED_TAGS","ALLOWED_ATTR","DEFAULT_ALLOWED_ATTR","CUSTOM_ELEMENT_HANDLING","tagNameCheck","writable","configurable","enumerable","attributeNameCheck","allowCustomizedBuiltInElements","FORBID_TAGS","FORBID_ATTR","ALLOW_ARIA_ATTR","ALLOW_DATA_ATTR","ALLOW_UNKNOWN_PROTOCOLS","SAFE_FOR_TEMPLATES","WHOLE_DOCUMENT","SET_CONFIG","FORCE_BODY","RETURN_DOM","RETURN_DOM_FRAGMENT","RETURN_TRUSTED_TYPE","SANITIZE_DOM","KEEP_CONTENT","IN_PLACE","USE_PROFILES","FORBID_CONTENTS","DEFAULT_FORBID_CONTENTS","DATA_URI_TAGS","DEFAULT_DATA_URI_TAGS","URI_SAFE_ATTRIBUTES","DEFAULT_URI_SAFE_ATTRIBUTES","MATHML_NAMESPACE","SVG_NAMESPACE","HTML_NAMESPACE","NAMESPACE","IS_EMPTY_INPUT","PARSER_MEDIA_TYPE","SUPPORTED_PARSER_MEDIA_TYPES","DEFAULT_PARSER_MEDIA_TYPE","transformCaseFunc","CONFIG","formElement","isRegexOrFunction","testValue","_parseConfig","cfg","ADD_URI_SAFE_ATTR","ADD_DATA_URI_TAGS","ALLOWED_URI_REGEXP","ADD_TAGS","ADD_ATTR","MATHML_TEXT_INTEGRATION_POINTS","HTML_INTEGRATION_POINTS","COMMON_SVG_AND_HTML_ELEMENTS","ALL_SVG_TAGS","ALL_MATHML_TAGS","_checkValidNamespace","namespaceURI","parentTagName","Boolean","_forceRemove","_removeAttribute","attribute","getAttributeNode","_initDocument","dirty","leadingWhitespace","dirtyPayload","parseFromString","createDocument","_createIterator","SHOW_ELEMENT","SHOW_COMMENT","SHOW_TEXT","_isClobbered","_isNode","_executeHook","entryPoint","_sanitizeElements","allowedTags","_basicCustomElementTest","_isValidAttribute","lcTag","lcName","_sanitizeAttributes","hookEvent","keepAttr","allowedAttributes","_attr","initValue","forceKeepAttr","setAttributeNS","_sanitizeShadowDOM","shadowNode","shadowIterator","sanitize","importedNode","oldNode","returnNode","toStaticHTML","nodeIterator","shadowroot","serializedHTML","setConfig","clearConfig","isValidAttribute","addHook","hookFunction","removeHook","removeHooks","removeAllHooks","purify","removeAttrs","addFontToSpansFilter","domParser","fontSizes","face","addStrikeFilter","convertToSTag","addFilters","convert_fonts_to_spans","font_size_legacy_values","register$5","inline_styles","blobUriToBlob","rejectWithError","xhr","XMLHttpRequest","open","responseType","response","send","parseDataUri$1","uri","uriParts","decodeURIComponent","buildBlob","atob","Uint8Array","Blob","dataUriToBlob","uriToBlob","blobToDataUri","blob","reader","FileReader","onloadend","readAsDataURL","count$1","uniqueId$1","imageToBlobInfo","blobCache","base64","blobInfo","getByUri","image","dataUri","getByData","getAllImages","ImageScanner","uploadStatus","cachedPromises","images","isUploaded","promises","imageInfo","newPromise","parseDataUri","isBogusImage","isInternalImageSource","registerBase64ImageFilter","blob_cache","processImage","inputSrc","blobUri","addAttributeFilter","register$4","remove_trailing_brs","prevName","lastParent","appendRel","addNoOpener","newRel","allow_unsafe_link_target","allow_html_in_named_anchor","fix_list_elements","classValue","validClassesMap","each$5","queryParts","DEFAULT_PORTS","ftp","http","https","mailto","safeSvgDataUrlElements","blockSvgDataUris","allowSvgDataUrls","decodeUri","encodedUri","unescape","isInvalidUri","decodedUri","allow_html_data_urls","URI","baseUri","base_uri","source","isProtocolRelative","protocol","toAbsPath","urlMatch","part","userInfo","port","uriComponents","isDomSafe","pathname","setPath","pathMatch","file","getURI","toRelative","relativeUri","tu","uu","toRelPath","anchor","toAbsolute","noHost","absoluteUri","isSameOrigin","defaultPort","breakPoint","normalizedBase","nb","outPath","normalizedPath","noProtoHost","each$4","explode$1","extend$1","basePurifyConfig","filteredUrlAttrs","internalElementAttr","getPurifyConfig","mimeType","config","setupPurify","purify$1","ele","allow_conditional_comments","isInternalElement","bogus","transferChildren","nativeParent","isSpecial","nativeChild","walkTree","preprocessors","postprocessors","traverseOrder","postprocess","whitespaceCleaner","allWhiteSpaceRegExp","startWhiteSpaceRegExp","endWhiteSpaceRegExp","hasWhitespaceParent","isAtEdgeOfBlock","neighbour","isNodeEmpty","getRootBlockName","forced_root_block","DomParser","defaultedSettings","root_name","parseAndSanitizeWithContext","rootName","isSpecialRoot","wrappedHtml","list","findInvalidChildren","addRootBlocks","rootBlockName","rootBlockNode","rootBlock","forced_root_block_attrs","whitespacePre","whitespacePost","invalidFinder","matchFinder","topLevelChildren","otherChildren","exports","serializeContent","withSerializedContent","fireEvent","serializedContent","eventArgs","preProcessGetContent","postProcessGetContent","processedEventArgs","preProcessSetContent","postProcessSetContent","tableModel","tableRow","cellPosition","getSpan","fillout","rowspan","colspan","y2","x2","cellExists","skipCellsX","getWidth","row","findElementPos","extractRows","sx","sy","ey","newRows","subTable","createDomTable","tableElement","tableBody","modelRowsToDomRows","tableElm","toDom","subsection","findParentListContainer","getFullySelectedListWrappers","_li","listCont","listElm","listStyles","_style","innerElm","directListWrappers","commonAnchorContainer","getWrapElements","wrapElements","listWrappers","allWrappers","emptyFragment","getFragmentFromRange","getParentTable","getTableFragment","selectedTableCells","firstCell","lastCell","fullTableModel","sectionedTableModel","getSelectionFragment","read$3","isCollapsibleWhitespace","getInnerText","bin","getContextNodeName","parentBlockOpt","getTextContent","contextNodeName","nonRenderedText","parentBlockText","textIndex","hasProceedingSpace","hasTrailingSpace","getSerializedContent","tmpElm","contextual","extractSelectedContent","setupArgs$3","getInner","getSelectedContentInternal","defaultedArgs","updatedArgs","KEEP","INSERT","diff","vDown","vUp","snake","diag","buildScript","start1","end1","start2","end2","middle","getMiddleSnake","j","i2","buildSnake","sum","getOuterHtml","insertAt","removeAt","applyDiff","read$2","write","fragments","currentFragments","lazyTempDocument","hasIframes","createFragmentedLevel","beforeBookmark","createCompleteLevel","createFromEditor","trimmedFragments","trimmed","applyToEditor","level","getLevelContent","getCleanLevelContent","hasEqualContent","level1","level2","hasEqualCleanedContent","isEq$1","isUnlocked","locks","setTyping","typing","endTyping","endTypingLevelIgnoreLocks","beforeChange$1","addUndoLevel$1","currentLevel","lastLevel","bm","customUndoRedoLevels","setDirty","clear$1","extra$1","callback1","callback2","redo$1","undo$1","reset$1","hasUndo$1","hasRedo$1","transact$1","beforeChange","ignore","ignore$1","addVisualInternal","hasVisual","matchedElm","makePlainAdaptor","init","bindEvents","undo","redo","hasUndo","hasRedo","extra","formatChanged","insertContent","addVisual","autocompleter","addDecoration","removeDecoration","makeRtcAdaptor","rtcEditor","defaultVars","_undoManager","_locks","_index","_node","_similar","_rfl","_details","_format","getRawModel","makeNoopAdaptor","nul","isRtc","plugins","getRtcSetup","rtcPlugin","setup","setup$s","editorCast","rtcInstance","rtc","isRemote","getRtcInstanceWithFallback","getRtcInstanceWithError","addUndoLevel","matchFormat","matchAllFormats","matchNodeFormat","canApplyFormat","closestFormat","applyFormat","removeFormat","toggleFormat","getContent$2","setContent$2","insertContent$1","getSelectedContent","addVisual$1","addAutocompleterDecoration","removeAutocompleterDecoration","getContent$1","walkPastBookmark","merge$1","outer","outerElm","oldLength","normalizeTextIfRequired","mergeAndNormalizeText","outerNode","normalizer","innerTextNode","rngSetContent","prevText","nextText","setupArgs$2","cleanContent","contextBlock","contextArgs","setContent$1","cleanedContent","createContextualFragment","deleteFromCallbackMap","newCallbacks","SelectorChanged","selectorChangedData","currentSelectors","findMatchingNode","selectorChangedWithUnbind","matchedSelectors","isAttachedToDom","isValidRange","EditorSelection","selectedRange","explicitRange","getRng$1","bookmarkManager","select$1","compareEndPoints","tryCompareBoundaryPoints","how","sourceRange","destinationRange","compareBoundaryPoints","anchorNode","START_TO_START","END_TO_END","removeAllRanges","addRange","setBaseAndExtent","focusNode","setNode","getSelectedBlocks$1","isForward","anchorRange","anchorOffset","focusRange","focusOffset","selectorChanged","getScrollContainer","scrollContainer","placeCaretAt","controlSelection","register$3","htmlParser","hasChildren","preserve_cdata","trimTrailingBr","brNode1","brNode2","preProcess$1","oldDoc","clonedNode","impl","shouldFireEvent","hasEventListeners","process$1","postProcess","outArgs","getHtmlFromNode","parseHtml","serializeNode","htmlSerializer","toHtml","DomSerializerImpl","addRules","setRules","DomSerializer","domSerializer","defaultFormat$1","setupArgs$1","defaultFormat","setupArgs","removedOptions","removedPlugins","getRemovedOptions","settingNames","setting","getRemovedPlugins","plugin","pluginNames","logRemovedWarnings","rawOptions","normalizedOptions","hasRemovedPlugins","hasRemovedOptions","isLegacyMobileTheme","theme","listJoiner","themesMessage","pluginsMessage","optionsMessage","logWarnings","DOM$8","restoreOriginalStyles","orgDisplay","safeDestroy","clearDomReferences","contentAreaContainer","editorContainer","bodyElement","contentDocument","contentWindow","restoreForm","form","_mceOldSubmit","submit","formEventDelegate","remove$1","editorUpload","save","is_removing","unbindAllNativeEvents","automatic","destroyed","off","_beforeUnload","CreateIconManager","iconPack","icons","IconManager","getProp","propName","getComputedSizeProp","getClientWidth","getClientHeight","getMarginTop","getMarginLeft","isInsideElementContentArea","bodyElm","transpose","isXYInContentArea","transposedPoint","fromDomSafe","isEditorAttachedToDom","rawContainer","getContentAreaContainer","NotificationManagerImpl","unimplemented","close","getArgs","NotificationManager","notifications","getImplementation","getNotificationManagerImpl","getTopNotification","progressBar","timeout","notification","addNotification","closeNotification","otherNotification","getEl","getNotifications","registerEvents","serviceMessage","requestAnimationFrame","WindowManagerImpl","openUrl","alert","confirm","getParams","setParams","WindowManager","dialogs","getWindowManagerImpl","funcBind","fireOpenEvent","dialog","fireCloseEvent","addDialog","closeDialog","otherDialog","getTopDialog","storeSelectionAndOpenDialog","openDialog","ui","windowManagerImpl","displayNotification","notificationManager","displayError","_skinLoaded","uploadError","logError","createLoadError","pluginLoadError","iconsLoadError","languageLoadError","themeLoadError","modelLoadError","pluginInitError","initError","isContentCssSkinName","getContentCssUrls","transformToUrls","getFontCssUrls","cssLinks","skinUrl","contentCssFile","documentBaseURI","appendContentCssFromSettings","contentCSS","filter$1","bind$1","UploadStatus","PENDING","UPLOADED","blobUriStatuses","createStatus","resultUri","hasBlobUri","getResultUri","isPending","markPending","markUploaded","removeFailed","seed","rnd","uuid","BlobCache","cache","mimeToExt","mime","mimes","filename","toBlobInfo","URL","createObjectURL","findFirst","cachedBlobInfo","removeByUri","revokeObjectURL","Uploader","pendingPromises","pathJoin","path1","path2","defaultHandler","progress","withCredentials","credentials","upload","onprogress","loaded","total","json","JSON","responseText","basePath","formData","FormData","noUpload","handlerSuccess","handlerFailure","resolvePending","uploadBlobInfo","openNotification","percent","isDefaultHandler","pendingUploadBlobInfo","uploadBlobs","blobInfos","createUploader","ImageUploader","uploader","showNotification","UploadChangeHandler","lastChangedLevel","fireIfChanged","EditorUpload","imageScanner","urlFilters","changeHandler","aliveGuard","cacheInvalidator","replaceString","replaceImageUrl","targetUrl","replacementUrl","replacementString","replaceUrlInUndoStack","replaceImageUriInView","uploadImages","scanForImages","imageInfos","imagesToRemove","filteredResult","uploadInfo","uploadUri","uploadImagesAuto","isValidDataUriImage","imgElm","addFilter","resultItem","replaceBlobUris","source_view","get$1","valigntop","verticalAlign","valignmiddle","valignbottom","alignleft","preview","textAlign","float","marginLeft","marginRight","aligncenter","alignright","alignjustify","bold","fontWeight","italic","fontStyle","underline","strikethrough","strike","forecolor","hilitecolor","fontname","fontFamily","fontsize","fontSize","lineheight","lineHeight","fontsize_class","class","blockquote","subscript","superscript","_fmt","_itemName","lang","customValue","removeformat","genericBase","cellBase","cellFormats","tablecellbackgroundcolor","tablecellverticalalign","tablecellbordercolor","borderColor","tablecellclass","tableclass","tablecellborderstyle","borderStyle","tablecellborderwidth","borderWidth","FormatRegistry","unregister","each$3","parsedSelectorToHtml","ancestry","sItem","getRequiredParent","elmRule","wrapInHtml","parentCandidate","ancestorName","parentRequired","siblingElm","parseSelectorItem","$0","$3","$4","parseSelector","getCssText","previewFrag","previewCss","parentFontSize","previewStyles","removeVars","previewOpt","previewElm","numValue","setup$r","addShortcut","Formatter","formatChangeState","shouldIgnoreCommand","isFirstTypedCharacter","addNonTypingUndoLevel","isDirty","modKey","isInsertReplacementText","inputType","isInsertTextDataNull","isInsertFromPasteOrDrop","addKeyboardShortcuts","UndoManager","nonTypingKeycodes","placeholderAttr","isKeyboardEvent","isDeleteEvent","isNonTypingKeyboardEvent","isTypingKeyboardEvent","isVisuallyEmpty","setup$q","placeholder","updatePlaceholder","showPlaceholder","isPlaceholderShown","strongRtl","hasStrongRtl","isInlineTarget","findInlineParents","findRootInline","hasSameParentBlock","block1","block2","isAtZwsp","normalizePosition","normalizeForwards","normalizeBackwards","execCommandIgnoreInputEvents","inputBlocker","execDeleteCommand","execForwardDeleteCommand","isBeforeRoot","isTextBlockOrListItem","getParentBlock$2","placeCaretInEmptyBody","paddEmptyBody","willDeleteLastPositionInElement","normalizedFirstPos","normalizedLastPos","normalizedFromPos","nextPos","prevPos","blockPosition","blockBoundary","getBlockPosition","containerElm","isDifferentBlocks","hasSameParent","parent1","parent2","isEditable$2","skipLastBr","lastPositionInBlock","readFromRange","fromBlockPos","toBlockPos","blockPos","read$1","getChildrenUntilBlockBoundary","extractChildren","removeEmptyRoot","isEmptyBefore","nestedBlockMerge","toBlock","insertionPoint","sidelongBlockMerge","findInsertionPoint","parentsAndSelf$1","getInsertionPoint","trimBr","mergeBlockInto","mergeBlocks","backspaceDelete$8","deleteRangeMergeBlocks","isRawNodeInTable","isSelectionInTable","isEverythingSelected","noPrevious","noNext","emptyEditor","deleteRange$1","backspaceDelete$7","_forward","isContentEditableTrue$1","isContentEditableFalse$4","showCaret","getNodeRange","renderCaretAtRange","caretPositionNode","caretPositionBeforeNode","ceRoot","renderRangeCaret","isBeforeBoundary","isAfterBoundary","trimEmptyTextNode","deleteContentAndShowCaret","peekCaretPosition","caretRange","deleteRange","deleteBoundaryText","getNextPosFn","isBeforeFn","nextCaretPosition","backspaceDelete$6","isCompoundElement","DeleteAction","moveToElement","moveToPosition","isAtContentEditableBlockCaret","caretLocation","isDeleteFromCefDifferentBlocks","deleteEmptyBlockOrMoveToCef","toCefElm","blockElm","findCefPosition","getContentEditableBlockAction","skipMoveToActionFromInlineCefToContent","getContentEditableAction","read","deleteElement$1","hideFakeCaret","getAncestorCe","backspaceDeleteCaret","deleteOffscreenSelection","backspaceDeleteRange","hasCefAncestor","paddEmptyElement","backspaceDelete$5","deleteCaret$2","backspaceDelete$4","isText$1","startsWithCaretContainer","endsWithCaretContainer","createZwsp","insertInline","insertInlineBefore","insertInlineAfter","insertInlinePos","isPosCaretContainer","caretNode","renderCaret","evaluateUntil","fns","Location","rescope$1","nPos","isNotInsideFormatCaretContainer","findInsideRootInline","start$1","isValidLocation","readLocation","getName","outside","inside","isEq","location1","location2","betweenInlines","fromInline","toInline","skipNoMovement","fromLocation","toLocation","findLocationTraverse","findLocationSimple","findLocation$1","hasSelectionModifyApi","modify","moveRel","moveByWord","BreakType","flip","positions","walk$1","getBreakType","currentPos","Br","Block","Wrap","getPositionsUntil","breakType","breakAt","Eol","getAdjacentLinePositions","getPositionsUntilBreak","findClosestHorizontalPositionFromPoint","lastRect","newRect","lastDist","newDist","findClosestHorizontalPosition","targetRect","getPositionsUntilPreviousLine","getPositionsUntilNextLine","getPositionsAbove","getPositionsBelow","isAtFirstLine","isAtLastLine","getFirstLinePositions","getLastLinePositions","isContentEditableFalse$3","distanceToRectLeft$1","distanceToRectRight$1","isNodeClientRect","findClosestClientRect","oldClientRect","oldDistance","newDistance","getNodeClientRects","toArrayWithNode","VDirection","findUntil","walkUntil","isAboveFn","isBeflowFn","line","targetClientRect","aboveLineNumber","lineNumber","isLineNumber","upUntil","Up","downUntil","Down","positionsUntil","isBelowFn","getClientRect","isAboveLine","isLine","moveToRange","renderRangeCaretOpt","moveHorizontally","isBefore","isAfter","isElement","rangeIsInContainerBlock","moveVertically","caretClientRect","walkerFn","linePositions","nextLinePositions","nextLineRect","dist1","dist2","caretPositions","closestNextLineRect","getLineEndPoint","lineInfo","moveToLineEndPoint$3","setCaretPosition","setSelected","renderCaretLocation","findLocation","isInlineTarget$1","toggleInlines","inlineBoundaries","selectedInlines","targetInlines","safeRemoveCaretContainer","renderInsideInlineCaret","inlines","_inline","move$2","moveWord","_caret","setupSelectedState","moveNextWord","movePrevWord","moveToLineEndPoint$2","linePoint","outsideLoc","rangeFromPositions","hasOnlyTwoOrLessPositionsLeft","setCaretLocation","deleteFromTo","rescope","backspaceDeleteCollapsed","toPosition","backspaceDelete$3","getParentInlines","hasOnlyOneChild","deleteLastPosition","parentInlines","isFormatElement$1","deleteCaret$1","backspaceDelete$2","deleteElement","deleteCaret","isNearMedia","backspaceDelete$1","isEditable$1","parseIndentValue","number","getIndentStyleName","useMargin","indentStyleName","indentElement","unit","styleValue","validateBlocks","intentValue","canOutdent","getBlocksToIndent","isReadOnly","isListComponent","parentIsListComponent","indentation","indentUnit","indentValue","outdent","backspaceDelete","findAction","deleteCommand","forwardDeleteCommand","setup$p","addCommand","SIGNIFICANT_MOVE","LONGPRESS_DELAY","getTouch","isFarEnough","distX","distY","setup$o","startData","longpressFired","debounceLongpress","isEqualNode","isBlockElement","isValidTarget","hasBlockParent","shouldRemoveTextNode","rootNodeName","restoreSelection","setup$n","checkClassName","replaceMatchWithSpan","prevChar","findStartTagIndex","tagHtml","convertRegExpsToNonEditable","nonEditableRegExps","setup$m","contentEditableAttrName","editClass","nonEditClass","hasEditClass","hasNonEditClass","findBlockCaretContainer","blockCaretContainer","handleBlockContainer","setup$l","isContentEditableFalse$2","moveToCeFalseHorizontally","moveToCeFalseVertically","createTextBlock","textBlock","exitPreBlock","getVisualCaretPosition$1","newBlock","getHorizontalRange","getVerticalRange","down","moveH$2","newRange","moveV$3","moveToLineEndPoint$1","isCefPosition","isTarget","rangeBefore","insertElement","insertEmptyLine","getClosestTargetBlock","isAtFirstOrLastLine","moveCaretToNewEmptyLine","rootBlockAttrs","moveV$2","baseKeyPattern","defaultPatterns","defaultDelayedPatterns","matchesEvent","match$1","matchDelayed","execute","executeWithDelayedAction","moveH$1","moveV$1","moveToLineEndPoint","CellLocation","firstLayer","filterFirstLayer","lookup$1","tags","isRootOrUpperTable","isEligible","newIndex","detection","isEditable","assumeEditable","isContentEditable","editable","getRaw","deflate","getCorners","getYAxisValue","tds","findClosestCorner","corners","newCorner","oldCorner","oldDist","getClosestCell","isTargetCorner","corner","getBottomValue","getTopValue","getClosestCellAbove","getClosestCellBelow","findClosestPositionInAboveCell","findClosestPositionInBelowCell","hasNextBreak","breakPos","startsWithWrapBreak","startsWithBrBreak","isAtTableCellLine","isAtFirstTableCellLine","isAtLastTableCellLine","isCaretAtStartOrEndOfTable","navigateHorizontally","_td","getClosestAbovePosition","getClosestBelowPosition","renderBlock","navigateVertically","move$1","mover","moveH","moveV","getCellFirstCursorPosition","tabGo","_current","tabForward","tabBackward","handleTab","rootElements","model","clearSelectedCells","executeKeydownOverride$4","setup$k","DOM$7","alwaysNext","textBefore","textAfter","scanLeft","scanRight","repeatLeft","isValidTextRange","getText","isWhitespace","stripTriggerChar","triggerCh","findChar","findStart","initRange","minChars","findTriggerChIndex","spot","triggerCharIndex","triggerChar","isText","toLast","toLeaf","isPreviousCharContent","leaf","isStartOfWord","getTriggerContext","database","triggerChars","getDatabase","lookupWithContext","fetchOptions","startText","autocompleters","lookupByChar","lookupData","ac","fetchResult","fetch","maxResults","matchText","columns","onAction","highlightOn","SimpleResultType","fold$1","stype","serror","svalue","partition","Value","bindError","toResult","fromResult","SimpleResult","formatObj","input","stringify","formatErrors","es","getErrorInfo","missingRequired","missingKey","missingBranch","branch","custom","chooseFrom","fields","extract","choose$1","choice","chosen","bothObjects","deepMerge","baseMerge","merger","curObject","defaultedThunk","fallbackThunk","defaulted$1","fallback","asOption","mergeValues","mergeErrors","consolidateObj","objects","consolidateArr","partitions","ResultCombine","field$1","newKey","presence","customField$1","instantiator","ifField","ifCustom","validator","anyValue$1","requiredAccess","bundle","fallbackAccess","optionAccess","optionDefaultedAccess","opt","extractField","av","bundleAsOption","optValue","ov","extractFields","objOf","fieldStrings","_okey","_presence","_instantiator","arrOf","valueOf","extractValue","errs","asRaw","formatError","errInfo","choose","anyValue","typedValue","expectedType","actualType","string","boolean","functionProcessor","customField","validateEnum","requiredOf","requiredString","requiredFunction","requiredArrayOf","optionOf","optionString","optionFunction","defaulted","defaultedOf","defaultedNumber","defaultedString","defaultedStringEnum","defaultedBoolean","defaultedFunction","defaultedArrayOf","onSetup","optionalText","optionalIcon","optionalTooltip","optionalLabel","active","enabled","primary","defaultedColumns","defaultedType","autocompleterSchema","createAutocompleter","baseToolbarButtonFields","baseToolbarToggleButtonFields","contextBarFields","contextButtonFields","contextToggleButtonFields","launchButtonFields","launchToggleButtonFields","toggleOrNormal","contextformbutton","contextformtogglebutton","register$2","popups","dataset","popup","datasetValues","dv","setupEditorInput","update","which","cancelIfNecessary","setup$j","activeAutocompleter","uiActive","isActive","commenceIfNecessary","getAutocompleters","doLookup","newContext","lookupInfo","_ui","createAndFireInputEvent","eventType","specifics","overrides","bubbles","isComposing","detail","eventPhase","AT_TARGET","originalTarget","explicitOriginalTarget","isTrusted","cancelable","InputEvent","fireFakeInputEvent","fireFakeBeforeInputEvent","executeKeydownOverride$3","applyAction","beforeInput","executeKeyupOverride","setup$i","firstNonWhiteSpaceNodeSibling","moveToCaretPosition","getEditableRoot$1","editableRoot","getParentBlock$1","getParentBlockName","isListItemParentBlock","hasFirstChild","isFirstChild","hasParent","isListBlock","isNestedList","getContainerBlock","containerBlock","containerBlockParent","isFirstOrLastLi","insert$3","createNewBlock","newBlockName","tmpRng","trimZwsp","isEmptyAnchor","isTableCell","containerAndSiblingName","canSplitBlock","trimInlineElementsOnLeftSideOfBlock","firstChilds","normalizeZwspOffset","includeZwspInRange","trimLeadingLineBreaks","getEditableRoot","applyAttributes","forcedRootBlockAttrs","attrStyles","currentStyles","newStyles","attrClassesOpt","attrClasses","currentClassesOpt","currentClasses","filteredClasses","newClasses","appliedAttrs","remainingAttrs","setForcedBlockAttrs","wrapSelfAndSiblingsInDefaultBlock","addBrToBlockIfNeeded","insert$2","parentBlockName","isAfterLastNodeInContainer","isCaretAtStartOrEndOfBlock","normalizedOffset","insertNewBlockAfter","containerBlockName","hasRightSideContent","moveSelectionToBr","brElm","extraBr","insertBrAtCaret","isControlKey","insertBrBefore","insertBrAfter","hasBrAfter","isBeforeBr","isAnchorLink","isInsideAnchor","readInlineAnchorLocation","insertBrOutsideAnchor","insert$1","anchorLocation","matchesSelector","shouldInsertBr","shouldBlockNewLine$1","newLineAction","shouldBlockNewLine","_shiftKey","inListBlock","requiredState","inBlock","inPreBlock","inSummaryBlock","shouldPutBrInPre","inBrContext","hasShiftKey","_editor","canInsertIntoEditableRoot","rootEditable","predicates","isMatch","getAction","handleEnterKeyEvent","setup$h","executeKeydownOverride$2","setup$g","setup$f","platform","executeKeyupAction","isPageUpDown","setNodeChangeBlocker","blocked","setup$e","insertTextAtPosition","insertNbspAtPosition","insertSpaceAtPosition","locationToCaretPosition","insertInlineBoundarySpaceOrNbsp","checkPos","setSelection","insertSpaceOrNbspAtSelection","executeKeydownOverride$1","setup$d","tableTabNavigation","executeKeydownOverride","setup$c","setup$b","NodeChange","lastPath","lastRng","nativeRng","fakeRng","isSameElementPath","initialized","currentPath","internalMimeType","internalHtmlMime","internalMark","mark","unmark","isMarked","isPlainText","openContainer","rootTag","rootAttrs","toBlockElements","tagOpen","tagClose","paragraphs","stitch","pasteBinDefaultContent","create$6","lastRngCell","pasteBinElm","pasteBinClone","isPasteBin","getHtml","copyAndRemove","toElm","fromElm","pasteBinClones","dirtyWrappers","cleanWrapper","isDefaultPasteBinContent","PasteBin","getLastRng","ignoreElements","trimHtml","trimSpaces","s1","s2","createIdGenerator","getImageMimeType","lowerExt","mimeOverrides","jpg","jpe","jfi","jif","jfif","pjpeg","pjp","preProcess","processResult","cancelled","postProcessFilter","tempBody","postProcessArgs","filterContent","preProcessArgs","filteredContent","pasteHtml$1","isAbsoluteUrl","isImageUrl","createImage","pasteHtmlFn","createLink","linkSelection","insertImage","smartInsertContent","pasteAsText","doPaste","pasteHtml","internalFlag","pasteText","encodedText","getDataTransferItems","dataTransfer","types","contentType","hasContentType","clipboardContent","hasHtmlOrText","extractFilename","createBlobInfo","useFileName","pasteImage","imageItem","existingBlobInfo","isClipboardEvent","readFilesAsDataUris","allowedExtensions","extension","getImagesFromDataTransfer","kind","getAsFile","pasteImageData","clipboardData","fileResults","isBrokenAndroidClipboardEvent","isKeyboardPasteEvent","insertClipboardContent","plainTextMode","isInternal","isPlainTextHtml","isAbsoluteUrl$1","registerEventHandlers","pasteBin","pasteFormat","keyboardPastePlainTextState","registerDataImageFilter","isWebKitFakeUrl","isDataUri","isPasteInsert","registerEventsAndFilters","togglePlainTextPaste","register$1","setHtml5Clipboard","clearData","setData","setClipboardData","contenteditable","overflow","offscreenRange","selectNodeContents","isTableSelection","hasSelectedContent","cut","getCaretRangeFromEvent","isPlainTextFileUrl","plainTextContent","setFocusedRange","hasImage","setup$a","draggingInternallyState","dropContent","internalContent","trimmedContent","setup$9","processEvent","addPreProcessFilter","filterFunc","rgbRegExp","rgbToHex","removeWebKitStyles","webKitStylesOption","webKitStyles","inputStyles","outputStyles","inputValue","compareInput","currentValue","outputStyle","setup$8","setup$7","preventSummaryToggle","filterDetails","setup$6","isTextBlockNode","normalizeSelection","setup$5","FakeCaretPosition","distanceToRectLeft","distanceToRectRight","isInsideY","collidesY","isOverlapping","overlap","splitRectsPerAxis","intersectingRects","boundingRect","horizontal","vertical","clientInfo","Before","After","horizontalDistance","_y","closestChildCaretCandidateNodeRect","caretCandidateRect","getClosestTextNode","distance","deltaDistance","findClosestCaretCandidateNodeRect","sortedRects","horizontalRects","verticalRects","above","below","traverseUp","helper","prevScope","uncheckedChildren","newScope","closestCaretCandidateNodeRect","ownerDoc","elementAtPoint","closestFakeCaretCandidate","getAbsolutePosition","docElem","getBodyPosition","getScrollPosition","getBodyScroll","inlineScroll","iframeScroll","getMousePosition","iframePosition","scrollPosition","calculatePosition","bodyPosition","mousePosition","calc","isContentEditableFalse$1","isContentEditableTrue","isDraggable","isValidDropTarget","targetElement","dragElement","cloneElement","cloneElm","createGhost","clonedElm","opacity","padding","boxSizing","appendGhostToBody","moveGhost","maxX","maxY","overflowX","removeElement","isLeftMouseButtonPressed","button","applyRelPos","relX","ceElm","elmPos","dragging","relY","ghost","move","throttledPlaceCaretAt","movement","targetPos","getRawTarget","drop","targetClone","removeDragState","bindFakeDragEvents","pageDom","dragStartHandler","dragHandler","dropHandler","dragEndHandler","blockUnsupportedFileDrop","preventFileDrop","preventFileDropIfUIElement","editorRoot","eventNames","init$2","setup$4","renderFocusCaret","setup$3","isContentEditableFalse","getContentEditableRoot","SelectionOverrides","fakeCaret","realSelectionId","selectedElement","isFakeSelectionElement","isFakeSelectionTargetElement","setRange","contentEditableRoot","removeElementSelection","setElementSelection","closestContentEditable","caretInfo","normalizeVoidElementSelection","isRangeInCaretContainer","isWithinCaretContainer","setupOffscreenSelection","realSelectionContainer","newContainer","selectElement","nodeElm","afterNode","generatePath","generatePathRange","resolvePath","nodePath","resolvedNode","optNode","resolvePathRange","generatePathRangeFromRange","cleanEmptyNodes","deleteRng","startParent","endParent","getParentBlock","stripPattern","firstTextNode","applyPattern$1","isBlockFormatName","formatSet","findPattern$1","nuText","findPatterns$1","matchesForcedRootBlock","blockText","matchedPattern","applyMatches$1","newMarker","rangeFromMarker","createMarker","markerPrefix","pathRange","textEnd","textStart","removeMarker","isReplacementPattern","matchesPattern","patternContent","searchText","startEndIndex","findPatternStartFromSpot","startPattern","startSpot","nextSpot","findPatternStart","requireGap","startRange","findPattern","endPathRng","startRng","endRng","resultsOpt","findPatternsRec","remainingPatterns","startPathRng","endSpot","patternsWithoutCurrent","applyPattern","patternRange","applyReplacementPattern","markerRange","applyPatternWithContent","startMarker","endMarker","markerEndRange","markerStartRange","patternMarker","addMarkers","matchesWithEnds","findPatterns","space","applyMatches","matchesWithMarkers","hasPatterns","patternSet","handleEnter","inlineMatches","blockMatches","handleInlineKey","checkKeyEvent","codes","checkKeyCode","checkCharCode","charCode","setup$2","charCodes","keyCodes","getPatternSet","getInlinePatterns$1","setup$1","Quirks","isGecko","isWebKit","isMac","setEditorCommandState","emptyEditorWhenDeleting","serializeRng","contents","allContentsSelected","allRng","allSelection","selectAll","shortcuts","documentElementEditingFocus","removeHrOnBackspace","Range","blur","selectControlElements","visualAidsAnchorClass","removeStylesWhenDeletingAcrossBlockElements","getAttributeApplyFunction","setAttributeNode","isSelectionAcrossElements","disableBackspaceIntoATable","removeBlockQuoteOnBackSpace","setGeckoEditingOptions","setOpts","addBrAfterLastLinks","fixLinks","setDefaultBlockType","showBrokenImageIcon","contentStyles","restoreFocusOnKeyDown","bodyHeight","blockCmdArrowNavigation","tapLinksAndImages","blockFormSubmitInsideEditor","removeAppleInterchangeBrs","setupRtc","DOM$6","appendStyle","getRootName","removeUndefined","mkParserSettings","mkSchemaSettings","mkSerializerSettings","createParser","autoFocus","moveSelectionToFirstCaretPosition","initEditor","bindPendingEventDelegates","initInstanceCallback","getStyleSheetLoader$1","makeStylesheetLoadingPromises","framedFonts","loadContentCss","fontCss","removeCss","contentCssText","allStylesheets","contentStyle","preInit","spellcheck","directionality","protect","escape","loadInitialContent","startContent","initEditorWithInitialContent","contentBodyLoaded","disabled","readonly","annotator","_nodeChangeDispatcher","setupRtcThunk","setProgressState","_rtcMode","initContentBody","skipWrite","visibility","orgVisibility","iframe","srcdoc","iframeHTML","DOM$5","createIframeElement","title","customAttrs","tabindex","frameBorder","allowTransparency","getIframeHtml","bodyId","bodyClass","translatedAriaText","createIframe","boxInfo","iframeTitle","ifr","iframeContainer","init$1","hidden","DOM$4","initPlugin","initializedPlugins","Plugin","pluginUrl","pluginInstance","trimLegacyPrefix","initPlugins","initIcons","iconPackName","currentIcons","loadIcons","svgData","icon","addIcon","initTheme","Theme","initModel","Model","renderFromLoadedTheme","renderUI","renderFromThemeFunc","iframeHeight","createThemeFalseResult","renderThemeFalseIframe","renderThemeFalse","renderThemeUi","augmentEditorUiApi","uiApiFacade","isEnabled","setEnabled","renderInfo","DOM$3","hasSkipLoadPrefix","loadLanguage","scriptLoader","languageCode","languageUrl","loadTheme","themeUrl","loadModel","modelUrl","getIconsUrlMetaFromUrl","getIconsUrlMetaFromName","defaultIconsUrl","customIconsUrl","urlMeta","loadPlugins","loadPlugin","isThemeLoaded","isModelLoaded","getStyleSheetLoader","render","snapshot","resetContent","triggerSave","windowManager","set_dirty","sectionResult","sections","deviceDetection","normalizePlugins","trimmedPlugins","extractSections","getSection","defaults","sectionOptions","hasSection","getSectionConfig","getMobileOverrideOptions","mobileOptions","defaultMobileOptions","table_grid","object_resizing","resize","toolbar_mode","toolbar_sticky","defaultPhoneOptions","menubar","getExternalPlugins","overrideOptions","userDefinedExternalPlugins","external_plugins","combinePlugins","forcedPlugins","getPlatformPlugins","isMobileDevice","desktopPlugins","mobilePlugins","processPlugins","defaultOverrideOptions","forced_plugins","mobileConfig","platformPlugins","combinedPlugins","isOnMobile","combineOptions","defaultOptions","deviceOverrideOptions","mobile","extendedOptions","normalizeOptions","registerExecCommands$3","toggleAlign","editorCommands","addCommands","JustifyLeft","JustifyCenter","JustifyRight","JustifyFull","JustifyNone","registerQueryStateCommands$1","alignStates","registerCommands$a","registerCommands$9","queryCommandEnabled","queryCommandSupported","trimOrPadLeftRight","processValue$1","trimOrPad","insertAtCaret","insertedContent","registerCommands$8","mceCleanup","_command","insertHorizontalRule","insertText","insertHTML","mceInsertContent","mceSetContent","mceReplaceContent","mceNewDocument","legacyPropNames","getSpecifiedFontProp","getProperty","legacyPropName","normalizeFontFamily","getComputedFontProp","getFontProp","getFontSize","getFontFamily","findFirstCaretElement","getCaretElement","atStartOfNode","bindRange","mapRange","fromFontSizeNumber","fontSizeNumber","fontClasses","normalizeFontNames","font","fonts","fontNameAction","fontNameQuery","fontSizeAction","fontSizeQuery","lineHeightQuery","specifiedStyle","computedStyle","lineHeightAction","registerExecCommands$2","customCode","registerQueryValueCommands","isFormatMatch","addQueryValueHandler","registerCommands$7","registerCommands$6","mceAddUndoLevel","mceEndUndoLevel","Undo","Redo","registerCommands$5","Indent","Outdent","registerCommands$4","applyLinkToSelection","linkDetails","unlink","mceInsertLink","registerExecCommands$1","listParent","registerQueryStateCommands","registerCommands$3","registerCommands$2","insertParagraph","mceInsertNewLine","InsertLineBreak","registerCommands$1","mceSelectNodeDepth","mceSelectNode","editingHost","registerExecCommands","mceRemoveNode","mcePrint","print","mceFocus","mceToggleVisualAid","registerCommands","EditorCommands","commands","lowerCaseCommand","skip_focus","queryCommandState","queryCommandValue","commandList","addQueryStateHandler","internalContentEditableAttr","setContentEditable","switchOffContentEditableTrue","switchOnContentEditableTrue","removeFakeSelection","restoreFakeSelection","toggleReadOnly","registerFilters","registerReadOnlyContentFilters","isClickEvent","getAnchorHrefOpt","processReadonlyEvents","targetEl","registerReadOnlySelectionBlockers","nativeEvents","EventDispatcher","bindings","toggleEvent","isNative","beforeFire","once","wrappedCallback","currentName","_value","bindingName","filteredHandlers","getEventDispatcher","_eventDispatcher","toggleNativeEvent","Observable","bubble","dispatcherArgs","DOM$2","customEventRootDelegates","getEventTarget","eventName","eventRoot","isListening","bindEventDelegate","delegate","delegates","eventRootElm","editors","EditorObservable","_pendingNativeEvents","stringListProcessor","getBuiltInProcessor","processValue","isBuiltInSpec","getErrorMessage","additionalText","isValidResult","processDefaultValue","create$5","initialOptions","setValue","isRegistered","immutable","unset","registered","defaultModes","switchToMode","activeMode","availableModes","oldMode","newMode","activate","deactivate","editorReadOnly","setMode","registerMode","create$4","design","each$2","keyCodeLookup","f1","f2","f3","f4","f5","f6","f7","f8","f9","f10","f11","f12","modifierNames","parseShortcut","shortcut","access","alt","ctrl","meta","Shortcuts","pendingPatterns","hasModifier","isFunctionKey","matchShortcut","subpatterns","executeShortcutAction","cmdFunc","normalizeCommandFunc","createShortcut","create$3","buttons","menuItems","contextMenus","contextToolbars","sidebars","addButton","addGroupToolbarButton","addToggleButton","addMenuButton","addSplitButton","addMenuItem","addNestedMenuItem","addToggleMenuItem","addAutocompleter","addContextMenu","addContextToolbar","addContextForm","addSidebar","bridge","DOM$1","each$1","Editor","loadedCSS","isNotDirty","documentBaseURL","_setBaseUrl","baseURI","setupCallback","getParam","initialContent","oldState","urlConverterCallback","_scanForImages","boundGlobalEvents","beforeUnloadDelegate","globalEventDelegate","EditorManager","toggleGlobalEvents","removeEditorFromList","targetEditor","oldEditors","purgeDestroyedEditor","isQuirksMode","compatMode","majorVersion","minorVersion","releaseDate","i18n","tinymce","tinyMCEPreInit","srcScript","overrideDefaults","base_url","pluginBaseUrls","plugin_base_urls","pluginBaseUrl","pluginName","invalidInlineTargets","isInvalidInlineTarget","createId","execCallback","findTargets","provideResults","initEditors","initCount","createEditor","existingEditor","editorId","editorOptions","addI18n","dataValue","FakeClipboardItem","getType","FakeClipboard","relativePosition","targetW","targetH","relChars","create$2","findBestRelativePosition","constrainRect","rels","inflate","intersect","cropRect","x1","y1","clamp","clampRect","fixedSize","cx2","cy2","underflowX1","underflowY1","overflowX2","overflowY2","fromClientRect","Rect","awaiter","resolveCb","rejectCb","complete","completer","create$1","tasks","resultFns","loadErrMsg","runErrMsg","task","waiter","Resource","storage","getItem","setItem","removeItem","defineProperty","localStorage","LocalStorage","publicApi","geom","util","TreeWalker","Serializer","Selection","exportToModuleLoaders","module","exportToWindowGlobal","tinyMCE"],"sources":["C:/Users/Ankit/Pictures/Tiny_MCE/node_modules/tinymce/tinymce.js"],"sourcesContent":["/**\n * TinyMCE version 6.0.2 (2022-04-27)\n */\n\n(function () {\n    'use strict';\n\n    var typeOf$1 = function (x) {\n      if (x === null) {\n        return 'null';\n      }\n      if (x === undefined) {\n        return 'undefined';\n      }\n      var t = typeof x;\n      if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {\n        return 'array';\n      }\n      if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {\n        return 'string';\n      }\n      return t;\n    };\n    var isEquatableType = function (x) {\n      return [\n        'undefined',\n        'boolean',\n        'number',\n        'string',\n        'function',\n        'xml',\n        'null'\n      ].indexOf(x) !== -1;\n    };\n\n    var sort$1 = function (xs, compareFn) {\n      var clone = Array.prototype.slice.call(xs);\n      return clone.sort(compareFn);\n    };\n\n    var contramap = function (eqa, f) {\n      return eq$2(function (x, y) {\n        return eqa.eq(f(x), f(y));\n      });\n    };\n    var eq$2 = function (f) {\n      return { eq: f };\n    };\n    var tripleEq = eq$2(function (x, y) {\n      return x === y;\n    });\n    var eqString = tripleEq;\n    var eqArray = function (eqa) {\n      return eq$2(function (x, y) {\n        if (x.length !== y.length) {\n          return false;\n        }\n        var len = x.length;\n        for (var i = 0; i < len; i++) {\n          if (!eqa.eq(x[i], y[i])) {\n            return false;\n          }\n        }\n        return true;\n      });\n    };\n    var eqSortedArray = function (eqa, compareFn) {\n      return contramap(eqArray(eqa), function (xs) {\n        return sort$1(xs, compareFn);\n      });\n    };\n    var eqRecord = function (eqa) {\n      return eq$2(function (x, y) {\n        var kx = Object.keys(x);\n        var ky = Object.keys(y);\n        if (!eqSortedArray(eqString).eq(kx, ky)) {\n          return false;\n        }\n        var len = kx.length;\n        for (var i = 0; i < len; i++) {\n          var q = kx[i];\n          if (!eqa.eq(x[q], y[q])) {\n            return false;\n          }\n        }\n        return true;\n      });\n    };\n    var eqAny = eq$2(function (x, y) {\n      if (x === y) {\n        return true;\n      }\n      var tx = typeOf$1(x);\n      var ty = typeOf$1(y);\n      if (tx !== ty) {\n        return false;\n      }\n      if (isEquatableType(tx)) {\n        return x === y;\n      } else if (tx === 'array') {\n        return eqArray(eqAny).eq(x, y);\n      } else if (tx === 'object') {\n        return eqRecord(eqAny).eq(x, y);\n      }\n      return false;\n    });\n\n    const getPrototypeOf$1 = Object.getPrototypeOf;\n    const hasProto = (v, constructor, predicate) => {\n      var _a;\n      if (predicate(v, constructor.prototype)) {\n        return true;\n      } else {\n        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n      }\n    };\n    const typeOf = x => {\n      const t = typeof x;\n      if (x === null) {\n        return 'null';\n      } else if (t === 'object' && Array.isArray(x)) {\n        return 'array';\n      } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n        return 'string';\n      } else {\n        return t;\n      }\n    };\n    const isType$1 = type => value => typeOf(value) === type;\n    const isSimpleType = type => value => typeof value === type;\n    const eq$1 = t => a => t === a;\n    const is$4 = (value, constructor) => isObject(value) && hasProto(value, constructor, (o, proto) => getPrototypeOf$1(o) === proto);\n    const isString = isType$1('string');\n    const isObject = isType$1('object');\n    const isPlainObject = value => is$4(value, Object);\n    const isArray$1 = isType$1('array');\n    const isNull = eq$1(null);\n    const isBoolean = isSimpleType('boolean');\n    const isUndefined = eq$1(undefined);\n    const isNullable = a => a === null || a === undefined;\n    const isNonNullable = a => !isNullable(a);\n    const isFunction = isSimpleType('function');\n    const isNumber = isSimpleType('number');\n    const isArrayOf = (value, pred) => {\n      if (isArray$1(value)) {\n        for (let i = 0, len = value.length; i < len; ++i) {\n          if (!pred(value[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    };\n\n    const noop = () => {\n    };\n    const compose = (fa, fb) => {\n      return (...args) => {\n        return fa(fb.apply(null, args));\n      };\n    };\n    const compose1 = (fbc, fab) => a => fbc(fab(a));\n    const constant = value => {\n      return () => {\n        return value;\n      };\n    };\n    const identity = x => {\n      return x;\n    };\n    const tripleEquals = (a, b) => {\n      return a === b;\n    };\n    function curry(fn, ...initialArgs) {\n      return (...restArgs) => {\n        const all = initialArgs.concat(restArgs);\n        return fn.apply(null, all);\n      };\n    }\n    const not = f => t => !f(t);\n    const die = msg => {\n      return () => {\n        throw new Error(msg);\n      };\n    };\n    const apply$1 = f => {\n      return f();\n    };\n    const call = f => {\n      f();\n    };\n    const never = constant(false);\n    const always = constant(true);\n\n    class Optional {\n      constructor(tag, value) {\n        this.tag = tag;\n        this.value = value;\n      }\n      static some(value) {\n        return new Optional(true, value);\n      }\n      static none() {\n        return Optional.singletonNone;\n      }\n      fold(onNone, onSome) {\n        if (this.tag) {\n          return onSome(this.value);\n        } else {\n          return onNone();\n        }\n      }\n      isSome() {\n        return this.tag;\n      }\n      isNone() {\n        return !this.tag;\n      }\n      map(mapper) {\n        if (this.tag) {\n          return Optional.some(mapper(this.value));\n        } else {\n          return Optional.none();\n        }\n      }\n      bind(binder) {\n        if (this.tag) {\n          return binder(this.value);\n        } else {\n          return Optional.none();\n        }\n      }\n      exists(predicate) {\n        return this.tag && predicate(this.value);\n      }\n      forall(predicate) {\n        return !this.tag || predicate(this.value);\n      }\n      filter(predicate) {\n        if (!this.tag || predicate(this.value)) {\n          return this;\n        } else {\n          return Optional.none();\n        }\n      }\n      getOr(replacement) {\n        return this.tag ? this.value : replacement;\n      }\n      or(replacement) {\n        return this.tag ? this : replacement;\n      }\n      getOrThunk(thunk) {\n        return this.tag ? this.value : thunk();\n      }\n      orThunk(thunk) {\n        return this.tag ? this : thunk();\n      }\n      getOrDie(message) {\n        if (!this.tag) {\n          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n        } else {\n          return this.value;\n        }\n      }\n      static from(value) {\n        return isNonNullable(value) ? Optional.some(value) : Optional.none();\n      }\n      getOrNull() {\n        return this.tag ? this.value : null;\n      }\n      getOrUndefined() {\n        return this.value;\n      }\n      each(worker) {\n        if (this.tag) {\n          worker(this.value);\n        }\n      }\n      toArray() {\n        return this.tag ? [this.value] : [];\n      }\n      toString() {\n        return this.tag ? `some(${ this.value })` : 'none()';\n      }\n    }\n    Optional.singletonNone = new Optional(false);\n\n    const nativeSlice = Array.prototype.slice;\n    const nativeIndexOf = Array.prototype.indexOf;\n    const nativePush = Array.prototype.push;\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n    const indexOf$1 = (xs, x) => {\n      const r = rawIndexOf(xs, x);\n      return r === -1 ? Optional.none() : Optional.some(r);\n    };\n    const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;\n    const exists = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const map$3 = (xs, f) => {\n      const len = xs.length;\n      const r = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const x = xs[i];\n        r[i] = f(x, i);\n      }\n      return r;\n    };\n    const each$g = (xs, f) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const eachr = (xs, f) => {\n      for (let i = xs.length - 1; i >= 0; i--) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const partition$2 = (xs, pred) => {\n      const pass = [];\n      const fail = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        const arr = pred(x, i) ? pass : fail;\n        arr.push(x);\n      }\n      return {\n        pass,\n        fail\n      };\n    };\n    const filter$6 = (xs, pred) => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n    const foldr = (xs, f, acc) => {\n      eachr(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const foldl = (xs, f, acc) => {\n      each$g(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const findUntil$1 = (xs, pred, until) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(x);\n        } else if (until(x, i)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const find$2 = (xs, pred) => {\n      return findUntil$1(xs, pred, never);\n    };\n    const findIndex$2 = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(i);\n        }\n      }\n      return Optional.none();\n    };\n    const flatten = xs => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        if (!isArray$1(xs[i])) {\n          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n        }\n        nativePush.apply(r, xs[i]);\n      }\n      return r;\n    };\n    const bind$3 = (xs, f) => flatten(map$3(xs, f));\n    const forall = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        const x = xs[i];\n        if (pred(x, i) !== true) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const reverse = xs => {\n      const r = nativeSlice.call(xs, 0);\n      r.reverse();\n      return r;\n    };\n    const difference = (a1, a2) => filter$6(a1, x => !contains$2(a2, x));\n    const mapToObject = (xs, f) => {\n      const r = {};\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        r[String(x)] = f(x, i);\n      }\n      return r;\n    };\n    const sort = (xs, comparator) => {\n      const copy = nativeSlice.call(xs, 0);\n      copy.sort(comparator);\n      return copy;\n    };\n    const get$b = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n    const head = xs => get$b(xs, 0);\n    const last$3 = xs => get$b(xs, xs.length - 1);\n    const from = isFunction(Array.from) ? Array.from : x => nativeSlice.call(x);\n    const findMap = (arr, f) => {\n      for (let i = 0; i < arr.length; i++) {\n        const r = f(arr[i], i);\n        if (r.isSome()) {\n          return r;\n        }\n      }\n      return Optional.none();\n    };\n    const unique$1 = (xs, comparator) => {\n      const r = [];\n      const isDuplicated = isFunction(comparator) ? x => exists(r, i => comparator(i, x)) : x => contains$2(r, x);\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (!isDuplicated(x)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n\n    const keys = Object.keys;\n    const hasOwnProperty$2 = Object.hasOwnProperty;\n    const each$f = (obj, f) => {\n      const props = keys(obj);\n      for (let k = 0, len = props.length; k < len; k++) {\n        const i = props[k];\n        const x = obj[i];\n        f(x, i);\n      }\n    };\n    const map$2 = (obj, f) => {\n      return tupleMap(obj, (x, i) => ({\n        k: i,\n        v: f(x, i)\n      }));\n    };\n    const tupleMap = (obj, f) => {\n      const r = {};\n      each$f(obj, (x, i) => {\n        const tuple = f(x, i);\n        r[tuple.k] = tuple.v;\n      });\n      return r;\n    };\n    const objAcc = r => (x, i) => {\n      r[i] = x;\n    };\n    const internalFilter = (obj, pred, onTrue, onFalse) => {\n      const r = {};\n      each$f(obj, (x, i) => {\n        (pred(x, i) ? onTrue : onFalse)(x, i);\n      });\n      return r;\n    };\n    const bifilter = (obj, pred) => {\n      const t = {};\n      const f = {};\n      internalFilter(obj, pred, objAcc(t), objAcc(f));\n      return {\n        t,\n        f\n      };\n    };\n    const filter$5 = (obj, pred) => {\n      const t = {};\n      internalFilter(obj, pred, objAcc(t), noop);\n      return t;\n    };\n    const mapToArray = (obj, f) => {\n      const r = [];\n      each$f(obj, (value, name) => {\n        r.push(f(value, name));\n      });\n      return r;\n    };\n    const values = obj => {\n      return mapToArray(obj, identity);\n    };\n    const get$a = (obj, key) => {\n      return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();\n    };\n    const has$2 = (obj, key) => hasOwnProperty$2.call(obj, key);\n    const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;\n    const equal$1 = (a1, a2, eq = eqAny) => eqRecord(eq).eq(a1, a2);\n\n    const stringArray = a => {\n      const all = {};\n      each$g(a, key => {\n        all[key] = {};\n      });\n      return keys(all);\n    };\n\n    const isArray = Array.isArray;\n    const toArray$1 = obj => {\n      if (!isArray(obj)) {\n        const array = [];\n        for (let i = 0, l = obj.length; i < l; i++) {\n          array[i] = obj[i];\n        }\n        return array;\n      } else {\n        return obj;\n      }\n    };\n    const each$e = (o, cb, s) => {\n      let n, l;\n      if (!o) {\n        return false;\n      }\n      s = s || o;\n      if (o.length !== undefined) {\n        for (n = 0, l = o.length; n < l; n++) {\n          if (cb.call(s, o[n], n, o) === false) {\n            return false;\n          }\n        }\n      } else {\n        for (n in o) {\n          if (has$2(o, n)) {\n            if (cb.call(s, o[n], n, o) === false) {\n              return false;\n            }\n          }\n        }\n      }\n      return true;\n    };\n    const map$1 = (array, callback) => {\n      const out = [];\n      each$e(array, (item, index) => {\n        out.push(callback(item, index, array));\n      });\n      return out;\n    };\n    const filter$4 = (a, f) => {\n      const o = [];\n      each$e(a, (v, index) => {\n        if (!f || f(v, index, a)) {\n          o.push(v);\n        }\n      });\n      return o;\n    };\n    const indexOf = (a, v) => {\n      if (a) {\n        for (let i = 0, l = a.length; i < l; i++) {\n          if (a[i] === v) {\n            return i;\n          }\n        }\n      }\n      return -1;\n    };\n    const reduce = (collection, iteratee, accumulator, thisArg) => {\n      let acc = isUndefined(accumulator) ? collection[0] : accumulator;\n      for (let i = 0; i < collection.length; i++) {\n        acc = iteratee.call(thisArg, acc, collection[i], i);\n      }\n      return acc;\n    };\n    const findIndex$1 = (array, predicate, thisArg) => {\n      let i, l;\n      for (i = 0, l = array.length; i < l; i++) {\n        if (predicate.call(thisArg, array[i], i, array)) {\n          return i;\n        }\n      }\n      return -1;\n    };\n    const last$2 = collection => collection[collection.length - 1];\n\n    const cached = f => {\n      let called = false;\n      let r;\n      return (...args) => {\n        if (!called) {\n          called = true;\n          r = f.apply(null, args);\n        }\n        return r;\n      };\n    };\n\n    const DeviceType = (os, browser, userAgent, mediaMatch) => {\n      const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;\n      const isiPhone = os.isiOS() && !isiPad;\n      const isMobile = os.isiOS() || os.isAndroid();\n      const isTouch = isMobile || mediaMatch('(pointer:coarse)');\n      const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');\n      const isPhone = isiPhone || isMobile && !isTablet;\n      const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;\n      const isDesktop = !isPhone && !isTablet && !iOSwebview;\n      return {\n        isiPad: constant(isiPad),\n        isiPhone: constant(isiPhone),\n        isTablet: constant(isTablet),\n        isPhone: constant(isPhone),\n        isTouch: constant(isTouch),\n        isAndroid: os.isAndroid,\n        isiOS: os.isiOS,\n        isWebView: constant(iOSwebview),\n        isDesktop: constant(isDesktop)\n      };\n    };\n\n    const firstMatch = (regexes, s) => {\n      for (let i = 0; i < regexes.length; i++) {\n        const x = regexes[i];\n        if (x.test(s)) {\n          return x;\n        }\n      }\n      return undefined;\n    };\n    const find$1 = (regexes, agent) => {\n      const r = firstMatch(regexes, agent);\n      if (!r) {\n        return {\n          major: 0,\n          minor: 0\n        };\n      }\n      const group = i => {\n        return Number(agent.replace(r, '$' + i));\n      };\n      return nu$3(group(1), group(2));\n    };\n    const detect$5 = (versionRegexes, agent) => {\n      const cleanedAgent = String(agent).toLowerCase();\n      if (versionRegexes.length === 0) {\n        return unknown$2();\n      }\n      return find$1(versionRegexes, cleanedAgent);\n    };\n    const unknown$2 = () => {\n      return nu$3(0, 0);\n    };\n    const nu$3 = (major, minor) => {\n      return {\n        major,\n        minor\n      };\n    };\n    const Version = {\n      nu: nu$3,\n      detect: detect$5,\n      unknown: unknown$2\n    };\n\n    const detectBrowser$1 = (browsers, userAgentData) => {\n      return findMap(userAgentData.brands, uaBrand => {\n        const lcBrand = uaBrand.brand.toLowerCase();\n        return find$2(browsers, browser => {\n          var _a;\n          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());\n        }).map(info => ({\n          current: info.name,\n          version: Version.nu(parseInt(uaBrand.version, 10), 0)\n        }));\n      });\n    };\n\n    const detect$4 = (candidates, userAgent) => {\n      const agent = String(userAgent).toLowerCase();\n      return find$2(candidates, candidate => {\n        return candidate.search(agent);\n      });\n    };\n    const detectBrowser = (browsers, userAgent) => {\n      return detect$4(browsers, userAgent).map(browser => {\n        const version = Version.detect(browser.versionRegexes, userAgent);\n        return {\n          current: browser.name,\n          version\n        };\n      });\n    };\n    const detectOs = (oses, userAgent) => {\n      return detect$4(oses, userAgent).map(os => {\n        const version = Version.detect(os.versionRegexes, userAgent);\n        return {\n          current: os.name,\n          version\n        };\n      });\n    };\n\n    const removeFromStart = (str, numChars) => {\n      return str.substring(numChars);\n    };\n\n    const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;\n    const removeLeading = (str, prefix) => {\n      return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;\n    };\n    const contains$1 = (str, substr) => {\n      return str.indexOf(substr) !== -1;\n    };\n    const startsWith = (str, prefix) => {\n      return checkRange(str, prefix, 0);\n    };\n    const endsWith = (str, suffix) => {\n      return checkRange(str, suffix, str.length - suffix.length);\n    };\n    const blank = r => s => s.replace(r, '');\n    const trim$3 = blank(/^\\s+|\\s+$/g);\n    const lTrim = blank(/^\\s+/g);\n    const rTrim = blank(/\\s+$/g);\n    const isNotEmpty = s => s.length > 0;\n    const isEmpty$3 = s => !isNotEmpty(s);\n    const repeat = (s, count) => count <= 0 ? '' : new Array(count + 1).join(s);\n    const toInt = (value, radix = 10) => {\n      const num = parseInt(value, radix);\n      return isNaN(num) ? Optional.none() : Optional.some(num);\n    };\n\n    const normalVersionRegex = /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/;\n    const checkContains = target => {\n      return uastring => {\n        return contains$1(uastring, target);\n      };\n    };\n    const browsers = [\n      {\n        name: 'Edge',\n        versionRegexes: [/.*?edge\\/ ?([0-9]+)\\.([0-9]+)$/],\n        search: uastring => {\n          return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');\n        }\n      },\n      {\n        name: 'Chromium',\n        brand: 'Chromium',\n        versionRegexes: [\n          /.*?chrome\\/([0-9]+)\\.([0-9]+).*/,\n          normalVersionRegex\n        ],\n        search: uastring => {\n          return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');\n        }\n      },\n      {\n        name: 'IE',\n        versionRegexes: [\n          /.*?msie\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*?rv:([0-9]+)\\.([0-9]+).*/\n        ],\n        search: uastring => {\n          return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');\n        }\n      },\n      {\n        name: 'Opera',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?opera\\/([0-9]+)\\.([0-9]+).*/\n        ],\n        search: checkContains('opera')\n      },\n      {\n        name: 'Firefox',\n        versionRegexes: [/.*?firefox\\/\\ ?([0-9]+)\\.([0-9]+).*/],\n        search: checkContains('firefox')\n      },\n      {\n        name: 'Safari',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?cpu os ([0-9]+)_([0-9]+).*/\n        ],\n        search: uastring => {\n          return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');\n        }\n      }\n    ];\n    const oses = [\n      {\n        name: 'Windows',\n        search: checkContains('win'),\n        versionRegexes: [/.*?windows\\ nt\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'iOS',\n        search: uastring => {\n          return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');\n        },\n        versionRegexes: [\n          /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*cpu os ([0-9]+)_([0-9]+).*/,\n          /.*cpu iphone os ([0-9]+)_([0-9]+).*/\n        ]\n      },\n      {\n        name: 'Android',\n        search: checkContains('android'),\n        versionRegexes: [/.*?android\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'macOS',\n        search: checkContains('mac os x'),\n        versionRegexes: [/.*?mac\\ os\\ x\\ ?([0-9]+)_([0-9]+).*/]\n      },\n      {\n        name: 'Linux',\n        search: checkContains('linux'),\n        versionRegexes: []\n      },\n      {\n        name: 'Solaris',\n        search: checkContains('sunos'),\n        versionRegexes: []\n      },\n      {\n        name: 'FreeBSD',\n        search: checkContains('freebsd'),\n        versionRegexes: []\n      },\n      {\n        name: 'ChromeOS',\n        search: checkContains('cros'),\n        versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/]\n      }\n    ];\n    const PlatformInfo = {\n      browsers: constant(browsers),\n      oses: constant(oses)\n    };\n\n    const edge = 'Edge';\n    const chromium = 'Chromium';\n    const ie = 'IE';\n    const opera = 'Opera';\n    const firefox = 'Firefox';\n    const safari = 'Safari';\n    const unknown$1 = () => {\n      return nu$2({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu$2 = info => {\n      const current = info.current;\n      const version = info.version;\n      const isBrowser = name => () => current === name;\n      return {\n        current,\n        version,\n        isEdge: isBrowser(edge),\n        isChromium: isBrowser(chromium),\n        isIE: isBrowser(ie),\n        isOpera: isBrowser(opera),\n        isFirefox: isBrowser(firefox),\n        isSafari: isBrowser(safari)\n      };\n    };\n    const Browser = {\n      unknown: unknown$1,\n      nu: nu$2,\n      edge: constant(edge),\n      chromium: constant(chromium),\n      ie: constant(ie),\n      opera: constant(opera),\n      firefox: constant(firefox),\n      safari: constant(safari)\n    };\n\n    const windows = 'Windows';\n    const ios = 'iOS';\n    const android = 'Android';\n    const linux = 'Linux';\n    const macos = 'macOS';\n    const solaris = 'Solaris';\n    const freebsd = 'FreeBSD';\n    const chromeos = 'ChromeOS';\n    const unknown = () => {\n      return nu$1({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu$1 = info => {\n      const current = info.current;\n      const version = info.version;\n      const isOS = name => () => current === name;\n      return {\n        current,\n        version,\n        isWindows: isOS(windows),\n        isiOS: isOS(ios),\n        isAndroid: isOS(android),\n        isMacOS: isOS(macos),\n        isLinux: isOS(linux),\n        isSolaris: isOS(solaris),\n        isFreeBSD: isOS(freebsd),\n        isChromeOS: isOS(chromeos)\n      };\n    };\n    const OperatingSystem = {\n      unknown,\n      nu: nu$1,\n      windows: constant(windows),\n      ios: constant(ios),\n      android: constant(android),\n      linux: constant(linux),\n      macos: constant(macos),\n      solaris: constant(solaris),\n      freebsd: constant(freebsd),\n      chromeos: constant(chromeos)\n    };\n\n    const detect$3 = (userAgent, userAgentDataOpt, mediaMatch) => {\n      const browsers = PlatformInfo.browsers();\n      const oses = PlatformInfo.oses();\n      const browser = userAgentDataOpt.bind(userAgentData => detectBrowser$1(browsers, userAgentData)).orThunk(() => detectBrowser(browsers, userAgent)).fold(Browser.unknown, Browser.nu);\n      const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);\n      const deviceType = DeviceType(os, browser, userAgent, mediaMatch);\n      return {\n        browser,\n        os,\n        deviceType\n      };\n    };\n    const PlatformDetection = { detect: detect$3 };\n\n    const mediaMatch = query => window.matchMedia(query).matches;\n    let platform$2 = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));\n    const detect$2 = () => platform$2();\n\n    const userAgent = navigator.userAgent;\n    const platform$1 = detect$2();\n    const browser$1 = platform$1.browser;\n    const os = platform$1.os;\n    const deviceType = platform$1.deviceType;\n    const windowsPhone = userAgent.indexOf('Windows Phone') !== -1;\n    const Env = {\n      transparentSrc: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',\n      documentMode: browser$1.isIE() ? document.documentMode || 7 : 10,\n      cacheSuffix: null,\n      container: null,\n      canHaveCSP: !browser$1.isIE(),\n      windowsPhone,\n      browser: {\n        current: browser$1.current,\n        version: browser$1.version,\n        isChromium: browser$1.isChromium,\n        isEdge: browser$1.isEdge,\n        isFirefox: browser$1.isFirefox,\n        isIE: browser$1.isIE,\n        isOpera: browser$1.isOpera,\n        isSafari: browser$1.isSafari\n      },\n      os: {\n        current: os.current,\n        version: os.version,\n        isAndroid: os.isAndroid,\n        isChromeOS: os.isChromeOS,\n        isFreeBSD: os.isFreeBSD,\n        isiOS: os.isiOS,\n        isLinux: os.isLinux,\n        isMacOS: os.isMacOS,\n        isSolaris: os.isSolaris,\n        isWindows: os.isWindows\n      },\n      deviceType: {\n        isDesktop: deviceType.isDesktop,\n        isiPad: deviceType.isiPad,\n        isiPhone: deviceType.isiPhone,\n        isPhone: deviceType.isPhone,\n        isTablet: deviceType.isTablet,\n        isTouch: deviceType.isTouch,\n        isWebView: deviceType.isWebView\n      }\n    };\n\n    const whiteSpaceRegExp$1 = /^\\s*|\\s*$/g;\n    const trim$2 = str => {\n      return str === null || str === undefined ? '' : ('' + str).replace(whiteSpaceRegExp$1, '');\n    };\n    const is$3 = (obj, type) => {\n      if (!type) {\n        return obj !== undefined;\n      }\n      if (type === 'array' && isArray(obj)) {\n        return true;\n      }\n      return typeof obj === type;\n    };\n    const makeMap$4 = (items, delim, map) => {\n      let i;\n      items = items || [];\n      delim = delim || ',';\n      if (typeof items === 'string') {\n        items = items.split(delim);\n      }\n      map = map || {};\n      i = items.length;\n      while (i--) {\n        map[items[i]] = {};\n      }\n      return map;\n    };\n    const hasOwnProperty$1 = has$2;\n    const extend$3 = (obj, ...exts) => {\n      for (let i = 0; i < exts.length; i++) {\n        const ext = exts[i];\n        for (const name in ext) {\n          if (has$2(ext, name)) {\n            const value = ext[name];\n            if (value !== undefined) {\n              obj[name] = value;\n            }\n          }\n        }\n      }\n      return obj;\n    };\n    const walk$4 = function (o, f, n, s) {\n      s = s || this;\n      if (o) {\n        if (n) {\n          o = o[n];\n        }\n        each$e(o, (o, i) => {\n          if (f.call(s, o, i, n) === false) {\n            return false;\n          }\n          walk$4(o, f, n, s);\n        });\n      }\n    };\n    const resolve$2 = (n, o) => {\n      let i, l;\n      o = o || window;\n      n = n.split('.');\n      for (i = 0, l = n.length; i < l; i++) {\n        o = o[n[i]];\n        if (!o) {\n          break;\n        }\n      }\n      return o;\n    };\n    const explode$3 = (s, d) => {\n      if (!s || is$3(s, 'array')) {\n        return s;\n      }\n      return map$1(s.split(d || ','), trim$2);\n    };\n    const _addCacheSuffix = url => {\n      const cacheSuffix = Env.cacheSuffix;\n      if (cacheSuffix) {\n        url += (url.indexOf('?') === -1 ? '?' : '&') + cacheSuffix;\n      }\n      return url;\n    };\n    const Tools = {\n      trim: trim$2,\n      isArray: isArray,\n      is: is$3,\n      toArray: toArray$1,\n      makeMap: makeMap$4,\n      each: each$e,\n      map: map$1,\n      grep: filter$4,\n      inArray: indexOf,\n      hasOwn: hasOwnProperty$1,\n      extend: extend$3,\n      walk: walk$4,\n      resolve: resolve$2,\n      explode: explode$3,\n      _addCacheSuffix\n    };\n\n    const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists(left => comparator(left, rhs));\n    const cat = arr => {\n      const r = [];\n      const push = x => {\n        r.push(x);\n      };\n      for (let i = 0; i < arr.length; i++) {\n        arr[i].each(push);\n      }\n      return r;\n    };\n    const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\n    const lift3 = (oa, ob, oc, f) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();\n    const someIf = (b, a) => b ? Optional.some(a) : Optional.none();\n\n    typeof window !== 'undefined' ? window : Function('return this;')();\n\n    const COMMENT = 8;\n    const DOCUMENT = 9;\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const name = element => {\n      const r = element.dom.nodeName;\n      return r.toLowerCase();\n    };\n    const type$1 = element => element.dom.nodeType;\n    const isType = t => element => type$1(element) === t;\n    const isComment$1 = element => type$1(element) === COMMENT || name(element) === '#comment';\n    const isElement$7 = isType(ELEMENT);\n    const isText$9 = isType(TEXT);\n    const isDocument$2 = isType(DOCUMENT);\n    const isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);\n    const isTag = tag => e => isElement$7(e) && name(e) === tag;\n\n    const rawSet = (dom, key, value) => {\n      if (isString(value) || isBoolean(value) || isNumber(value)) {\n        dom.setAttribute(key, value + '');\n      } else {\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n        throw new Error('Attribute value was not simple');\n      }\n    };\n    const set$2 = (element, key, value) => {\n      rawSet(element.dom, key, value);\n    };\n    const setAll$1 = (element, attrs) => {\n      const dom = element.dom;\n      each$f(attrs, (v, k) => {\n        rawSet(dom, k, v);\n      });\n    };\n    const get$9 = (element, key) => {\n      const v = element.dom.getAttribute(key);\n      return v === null ? undefined : v;\n    };\n    const getOpt = (element, key) => Optional.from(get$9(element, key));\n    const has$1 = (element, key) => {\n      const dom = element.dom;\n      return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;\n    };\n    const remove$a = (element, key) => {\n      element.dom.removeAttribute(key);\n    };\n    const hasNone = element => {\n      const attrs = element.dom.attributes;\n      return attrs === undefined || attrs === null || attrs.length === 0;\n    };\n    const clone$4 = element => foldl(element.dom.attributes, (acc, attr) => {\n      acc[attr.name] = attr.value;\n      return acc;\n    }, {});\n\n    const read$4 = (element, attr) => {\n      const value = get$9(element, attr);\n      return value === undefined || value === '' ? [] : value.split(' ');\n    };\n    const add$4 = (element, attr, id) => {\n      const old = read$4(element, attr);\n      const nu = old.concat([id]);\n      set$2(element, attr, nu.join(' '));\n      return true;\n    };\n    const remove$9 = (element, attr, id) => {\n      const nu = filter$6(read$4(element, attr), v => v !== id);\n      if (nu.length > 0) {\n        set$2(element, attr, nu.join(' '));\n      } else {\n        remove$a(element, attr);\n      }\n      return false;\n    };\n\n    const supports = element => element.dom.classList !== undefined;\n    const get$8 = element => read$4(element, 'class');\n    const add$3 = (element, clazz) => add$4(element, 'class', clazz);\n    const remove$8 = (element, clazz) => remove$9(element, 'class', clazz);\n    const toggle$2 = (element, clazz) => {\n      if (contains$2(get$8(element), clazz)) {\n        return remove$8(element, clazz);\n      } else {\n        return add$3(element, clazz);\n      }\n    };\n\n    const add$2 = (element, clazz) => {\n      if (supports(element)) {\n        element.dom.classList.add(clazz);\n      } else {\n        add$3(element, clazz);\n      }\n    };\n    const cleanClass = element => {\n      const classList = supports(element) ? element.dom.classList : get$8(element);\n      if (classList.length === 0) {\n        remove$a(element, 'class');\n      }\n    };\n    const remove$7 = (element, clazz) => {\n      if (supports(element)) {\n        const classList = element.dom.classList;\n        classList.remove(clazz);\n      } else {\n        remove$8(element, clazz);\n      }\n      cleanClass(element);\n    };\n    const toggle$1 = (element, clazz) => {\n      const result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$2(element, clazz);\n      cleanClass(element);\n      return result;\n    };\n    const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);\n\n    const isSupported$1 = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n    const fromHtml$1 = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\n        const message = 'HTML does not have a single root node';\n        console.error(message, html);\n        throw new Error(message);\n      }\n      return fromDom$2(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n      const doc = scope || document;\n      const node = doc.createElement(tag);\n      return fromDom$2(node);\n    };\n    const fromText = (text, scope) => {\n      const doc = scope || document;\n      const node = doc.createTextNode(text);\n      return fromDom$2(node);\n    };\n    const fromDom$2 = node => {\n      if (node === null || node === undefined) {\n        throw new Error('Node cannot be null or undefined');\n      }\n      return { dom: node };\n    };\n    const fromPoint$2 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$2);\n    const SugarElement = {\n      fromHtml: fromHtml$1,\n      fromTag,\n      fromText,\n      fromDom: fromDom$2,\n      fromPoint: fromPoint$2\n    };\n\n    const toArray = (target, f) => {\n      const r = [];\n      const recurse = e => {\n        r.push(e);\n        return f(e);\n      };\n      let cur = f(target);\n      do {\n        cur = cur.bind(recurse);\n      } while (cur.isSome());\n      return r;\n    };\n\n    const is$1 = (element, selector) => {\n      const dom = element.dom;\n      if (dom.nodeType !== ELEMENT) {\n        return false;\n      } else {\n        const elem = dom;\n        if (elem.matches !== undefined) {\n          return elem.matches(selector);\n        } else if (elem.msMatchesSelector !== undefined) {\n          return elem.msMatchesSelector(selector);\n        } else if (elem.webkitMatchesSelector !== undefined) {\n          return elem.webkitMatchesSelector(selector);\n        } else if (elem.mozMatchesSelector !== undefined) {\n          return elem.mozMatchesSelector(selector);\n        } else {\n          throw new Error('Browser lacks native selectors');\n        }\n      }\n    };\n    const bypassSelector = dom => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;\n    const all = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? [] : map$3(base.querySelectorAll(selector), SugarElement.fromDom);\n    };\n    const one = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);\n    };\n\n    const eq = (e1, e2) => e1.dom === e2.dom;\n    const contains = (e1, e2) => {\n      const d1 = e1.dom;\n      const d2 = e2.dom;\n      return d1 === d2 ? false : d1.contains(d2);\n    };\n\n    const owner$1 = element => SugarElement.fromDom(element.dom.ownerDocument);\n    const documentOrOwner = dos => isDocument$2(dos) ? dos : owner$1(dos);\n    const documentElement = element => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);\n    const defaultView = element => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);\n    const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\n    const parents$1 = (element, isRoot) => {\n      const stop = isFunction(isRoot) ? isRoot : never;\n      let dom = element.dom;\n      const ret = [];\n      while (dom.parentNode !== null && dom.parentNode !== undefined) {\n        const rawParent = dom.parentNode;\n        const p = SugarElement.fromDom(rawParent);\n        ret.push(p);\n        if (stop(p) === true) {\n          break;\n        } else {\n          dom = rawParent;\n        }\n      }\n      return ret;\n    };\n    const siblings = element => {\n      const filterSelf = elements => filter$6(elements, x => !eq(element, x));\n      return parent(element).map(children).map(filterSelf).getOr([]);\n    };\n    const prevSibling = element => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);\n    const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n    const prevSiblings = element => reverse(toArray(element, prevSibling));\n    const nextSiblings = element => toArray(element, nextSibling);\n    const children = element => map$3(element.dom.childNodes, SugarElement.fromDom);\n    const child$1 = (element, index) => {\n      const cs = element.dom.childNodes;\n      return Optional.from(cs[index]).map(SugarElement.fromDom);\n    };\n    const firstChild = element => child$1(element, 0);\n    const lastChild = element => child$1(element, element.dom.childNodes.length - 1);\n    const childNodesCount = element => element.dom.childNodes.length;\n\n    const getHead = doc => {\n      const b = doc.dom.head;\n      if (b === null || b === undefined) {\n        throw new Error('Head is not available yet');\n      }\n      return SugarElement.fromDom(b);\n    };\n\n    const isShadowRoot = dos => isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);\n    const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);\n    const isSupported = constant(supported);\n    const getRootNode = supported ? e => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;\n    const getStyleContainer = dos => isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));\n    const getShadowRoot = e => {\n      const r = getRootNode(e);\n      return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n    };\n    const getShadowHost = e => SugarElement.fromDom(e.dom.host);\n    const getOriginalEventTarget = event => {\n      if (isSupported() && isNonNullable(event.target)) {\n        const el = SugarElement.fromDom(event.target);\n        if (isElement$7(el) && isOpenShadowHost(el)) {\n          if (event.composed && event.composedPath) {\n            const composedPath = event.composedPath();\n            if (composedPath) {\n              return head(composedPath);\n            }\n          }\n        }\n      }\n      return Optional.from(event.target);\n    };\n    const isOpenShadowHost = element => isNonNullable(element.dom.shadowRoot);\n\n    const inBody = element => {\n      const dom = isText$9(element) ? element.dom.parentNode : element.dom;\n      if (dom === undefined || dom === null || dom.ownerDocument === null) {\n        return false;\n      }\n      const doc = dom.ownerDocument;\n      return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n    };\n\n    const internalSet = (dom, property, value) => {\n      if (!isString(value)) {\n        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n        throw new Error('CSS value must be a string: ' + value);\n      }\n      if (isSupported$1(dom)) {\n        dom.style.setProperty(property, value);\n      }\n    };\n    const internalRemove = (dom, property) => {\n      if (isSupported$1(dom)) {\n        dom.style.removeProperty(property);\n      }\n    };\n    const set$1 = (element, property, value) => {\n      const dom = element.dom;\n      internalSet(dom, property, value);\n    };\n    const setAll = (element, css) => {\n      const dom = element.dom;\n      each$f(css, (v, k) => {\n        internalSet(dom, k, v);\n      });\n    };\n    const get$7 = (element, property) => {\n      const dom = element.dom;\n      const styles = window.getComputedStyle(dom);\n      const r = styles.getPropertyValue(property);\n      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;\n    };\n    const getUnsafeProperty = (dom, property) => isSupported$1(dom) ? dom.style.getPropertyValue(property) : '';\n    const getRaw$1 = (element, property) => {\n      const dom = element.dom;\n      const raw = getUnsafeProperty(dom, property);\n      return Optional.from(raw).filter(r => r.length > 0);\n    };\n    const getAllRaw = element => {\n      const css = {};\n      const dom = element.dom;\n      if (isSupported$1(dom)) {\n        for (let i = 0; i < dom.style.length; i++) {\n          const ruleName = dom.style.item(i);\n          css[ruleName] = dom.style[ruleName];\n        }\n      }\n      return css;\n    };\n    const remove$6 = (element, property) => {\n      const dom = element.dom;\n      internalRemove(dom, property);\n      if (is$2(getOpt(element, 'style').map(trim$3), '')) {\n        remove$a(element, 'style');\n      }\n    };\n    const reflow = e => e.dom.offsetWidth;\n\n    const before$3 = (marker, element) => {\n      const parent$1 = parent(marker);\n      parent$1.each(v => {\n        v.dom.insertBefore(element.dom, marker.dom);\n      });\n    };\n    const after$4 = (marker, element) => {\n      const sibling = nextSibling(marker);\n      sibling.fold(() => {\n        const parent$1 = parent(marker);\n        parent$1.each(v => {\n          append$1(v, element);\n        });\n      }, v => {\n        before$3(v, element);\n      });\n    };\n    const prepend = (parent, element) => {\n      const firstChild$1 = firstChild(parent);\n      firstChild$1.fold(() => {\n        append$1(parent, element);\n      }, v => {\n        parent.dom.insertBefore(element.dom, v.dom);\n      });\n    };\n    const append$1 = (parent, element) => {\n      parent.dom.appendChild(element.dom);\n    };\n    const wrap$2 = (element, wrapper) => {\n      before$3(element, wrapper);\n      append$1(wrapper, element);\n    };\n\n    const after$3 = (marker, elements) => {\n      each$g(elements, (x, i) => {\n        const e = i === 0 ? marker : elements[i - 1];\n        after$4(e, x);\n      });\n    };\n    const append = (parent, elements) => {\n      each$g(elements, x => {\n        append$1(parent, x);\n      });\n    };\n\n    const empty = element => {\n      element.dom.textContent = '';\n      each$g(children(element), rogue => {\n        remove$5(rogue);\n      });\n    };\n    const remove$5 = element => {\n      const dom = element.dom;\n      if (dom.parentNode !== null) {\n        dom.parentNode.removeChild(dom);\n      }\n    };\n    const unwrap = wrapper => {\n      const children$1 = children(wrapper);\n      if (children$1.length > 0) {\n        after$3(wrapper, children$1);\n      }\n      remove$5(wrapper);\n    };\n\n    const fromHtml = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      return children(SugarElement.fromDom(div));\n    };\n    const fromDom$1 = nodes => map$3(nodes, SugarElement.fromDom);\n\n    const get$6 = element => element.dom.innerHTML;\n    const set = (element, content) => {\n      const owner = owner$1(element);\n      const docDom = owner.dom;\n      const fragment = SugarElement.fromDom(docDom.createDocumentFragment());\n      const contentElements = fromHtml(content, docDom);\n      append(fragment, contentElements);\n      empty(element);\n      append$1(element, fragment);\n    };\n    const getOuter = element => {\n      const container = SugarElement.fromTag('div');\n      const clone = SugarElement.fromDom(element.dom.cloneNode(true));\n      append$1(container, clone);\n      return get$6(container);\n    };\n\n    const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({\n      target,\n      x,\n      y,\n      stop,\n      prevent,\n      kill,\n      raw\n    });\n    const fromRawEvent = rawEvent => {\n      const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));\n      const stop = () => rawEvent.stopPropagation();\n      const prevent = () => rawEvent.preventDefault();\n      const kill = compose(prevent, stop);\n      return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);\n    };\n    const handle$1 = (filter, handler) => rawEvent => {\n      if (filter(rawEvent)) {\n        handler(fromRawEvent(rawEvent));\n      }\n    };\n    const binder = (element, event, filter, handler, useCapture) => {\n      const wrapped = handle$1(filter, handler);\n      element.dom.addEventListener(event, wrapped, useCapture);\n      return { unbind: curry(unbind, element, event, wrapped, useCapture) };\n    };\n    const bind$2 = (element, event, filter, handler) => binder(element, event, filter, handler, false);\n    const unbind = (element, event, handler, useCapture) => {\n      element.dom.removeEventListener(event, handler, useCapture);\n    };\n\n    const r = (left, top) => {\n      const translate = (x, y) => r(left + x, top + y);\n      return {\n        left,\n        top,\n        translate\n      };\n    };\n    const SugarPosition = r;\n\n    const boxPosition = dom => {\n      const box = dom.getBoundingClientRect();\n      return SugarPosition(box.left, box.top);\n    };\n    const firstDefinedOrZero = (a, b) => {\n      if (a !== undefined) {\n        return a;\n      } else {\n        return b !== undefined ? b : 0;\n      }\n    };\n    const absolute = element => {\n      const doc = element.dom.ownerDocument;\n      const body = doc.body;\n      const win = doc.defaultView;\n      const html = doc.documentElement;\n      if (body === element.dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);\n      const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);\n      const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);\n      const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);\n      return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);\n    };\n    const viewport = element => {\n      const dom = element.dom;\n      const doc = dom.ownerDocument;\n      const body = doc.body;\n      if (body === dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      if (!inBody(element)) {\n        return SugarPosition(0, 0);\n      }\n      return boxPosition(dom);\n    };\n\n    const get$5 = _DOC => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;\n      const y = doc.body.scrollTop || doc.documentElement.scrollTop;\n      return SugarPosition(x, y);\n    };\n    const to = (x, y, _DOC) => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const win = doc.defaultView;\n      if (win) {\n        win.scrollTo(x, y);\n      }\n    };\n    const intoView = (element, alignToTop) => {\n      const isSafari = detect$2().browser.isSafari();\n      if (isSafari && isFunction(element.dom.scrollIntoViewIfNeeded)) {\n        element.dom.scrollIntoViewIfNeeded(false);\n      } else {\n        element.dom.scrollIntoView(alignToTop);\n      }\n    };\n\n    const get$4 = _win => {\n      const win = _win === undefined ? window : _win;\n      if (detect$2().browser.isFirefox()) {\n        return Optional.none();\n      } else {\n        return Optional.from(win.visualViewport);\n      }\n    };\n    const bounds = (x, y, width, height) => ({\n      x,\n      y,\n      width,\n      height,\n      right: x + width,\n      bottom: y + height\n    });\n    const getBounds = _win => {\n      const win = _win === undefined ? window : _win;\n      const doc = win.document;\n      const scroll = get$5(SugarElement.fromDom(doc));\n      return get$4(win).fold(() => {\n        const html = win.document.documentElement;\n        const width = html.clientWidth;\n        const height = html.clientHeight;\n        return bounds(scroll.left, scroll.top, width, height);\n      }, visualViewport => bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));\n    };\n\n    const isNodeType = type => {\n      return node => {\n        return !!node && node.nodeType === type;\n      };\n    };\n    const isRestrictedNode = node => !!node && !Object.getPrototypeOf(node);\n    const isElement$6 = isNodeType(1);\n    const matchNodeNames = names => {\n      const lowercasedNames = names.map(s => s.toLowerCase());\n      return node => {\n        if (node && node.nodeName) {\n          const nodeName = node.nodeName.toLowerCase();\n          return contains$2(lowercasedNames, nodeName);\n        }\n        return false;\n      };\n    };\n    const matchStyleValues = (name, values) => {\n      const items = values.toLowerCase().split(' ');\n      return node => {\n        if (isElement$6(node)) {\n          for (let i = 0; i < items.length; i++) {\n            const computed = node.ownerDocument.defaultView.getComputedStyle(node, null);\n            const cssValue = computed ? computed.getPropertyValue(name) : null;\n            if (cssValue === items[i]) {\n              return true;\n            }\n          }\n        }\n        return false;\n      };\n    };\n    const hasAttribute = attrName => {\n      return node => {\n        return isElement$6(node) && node.hasAttribute(attrName);\n      };\n    };\n    const hasAttributeValue = (attrName, attrValue) => {\n      return node => {\n        return isElement$6(node) && node.getAttribute(attrName) === attrValue;\n      };\n    };\n    const isBogus$2 = node => isElement$6(node) && node.hasAttribute('data-mce-bogus');\n    const isBogusAll$1 = node => isElement$6(node) && node.getAttribute('data-mce-bogus') === 'all';\n    const isTable$3 = node => isElement$6(node) && node.tagName === 'TABLE';\n    const hasContentEditableState = value => {\n      return node => {\n        if (isElement$6(node)) {\n          if (node.contentEditable === value) {\n            return true;\n          }\n          if (node.getAttribute('data-mce-contenteditable') === value) {\n            return true;\n          }\n        }\n        return false;\n      };\n    };\n    const isTextareaOrInput = matchNodeNames([\n      'textarea',\n      'input'\n    ]);\n    const isText$8 = isNodeType(3);\n    const isCData = isNodeType(4);\n    const isPi = isNodeType(7);\n    const isComment = isNodeType(8);\n    const isDocument$1 = isNodeType(9);\n    const isDocumentFragment = isNodeType(11);\n    const isBr$5 = matchNodeNames(['br']);\n    const isImg = matchNodeNames(['img']);\n    const isContentEditableTrue$4 = hasContentEditableState('true');\n    const isContentEditableFalse$a = hasContentEditableState('false');\n    const isTableCell$5 = matchNodeNames([\n      'td',\n      'th'\n    ]);\n    const isMedia$2 = matchNodeNames([\n      'video',\n      'audio',\n      'object',\n      'embed'\n    ]);\n\n    const browser = detect$2().browser;\n    const firstElement = nodes => find$2(nodes, isElement$7);\n    const getTableCaptionDeltaY = elm => {\n      if (browser.isFirefox() && name(elm) === 'table') {\n        return firstElement(children(elm)).filter(elm => {\n          return name(elm) === 'caption';\n        }).bind(caption => {\n          return firstElement(nextSiblings(caption)).map(body => {\n            const bodyTop = body.dom.offsetTop;\n            const captionTop = caption.dom.offsetTop;\n            const captionHeight = caption.dom.offsetHeight;\n            return bodyTop <= captionTop ? -captionHeight : 0;\n          });\n        }).getOr(0);\n      } else {\n        return 0;\n      }\n    };\n    const hasChild = (elm, child) => elm.children && contains$2(elm.children, child);\n    const getPos = (body, elm, rootElm) => {\n      let x = 0, y = 0;\n      const doc = body.ownerDocument;\n      rootElm = rootElm ? rootElm : body;\n      if (elm) {\n        if (rootElm === body && elm.getBoundingClientRect && get$7(SugarElement.fromDom(body), 'position') === 'static') {\n          const pos = elm.getBoundingClientRect();\n          x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;\n          y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;\n          return {\n            x,\n            y\n          };\n        }\n        let offsetParent = elm;\n        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\n          const castOffsetParent = offsetParent;\n          x += castOffsetParent.offsetLeft || 0;\n          y += castOffsetParent.offsetTop || 0;\n          offsetParent = castOffsetParent.offsetParent;\n        }\n        offsetParent = elm.parentNode;\n        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\n          x -= offsetParent.scrollLeft || 0;\n          y -= offsetParent.scrollTop || 0;\n          offsetParent = offsetParent.parentNode;\n        }\n        y += getTableCaptionDeltaY(SugarElement.fromDom(elm));\n      }\n      return {\n        x,\n        y\n      };\n    };\n\n    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n      if (is(scope, a)) {\n        return Optional.some(scope);\n      } else if (isFunction(isRoot) && isRoot(scope)) {\n        return Optional.none();\n      } else {\n        return ancestor(scope, a, isRoot);\n      }\n    };\n\n    const ancestor$3 = (scope, predicate, isRoot) => {\n      let element = scope.dom;\n      const stop = isFunction(isRoot) ? isRoot : never;\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        if (predicate(el)) {\n          return Optional.some(el);\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$4 = (scope, predicate, isRoot) => {\n      const is = (s, test) => test(s);\n      return ClosestOrAncestor(is, ancestor$3, scope, predicate, isRoot);\n    };\n    const sibling$1 = (scope, predicate) => {\n      const element = scope.dom;\n      if (!element.parentNode) {\n        return Optional.none();\n      }\n      return child(SugarElement.fromDom(element.parentNode), x => !eq(scope, x) && predicate(x));\n    };\n    const child = (scope, predicate) => {\n      const pred = node => predicate(SugarElement.fromDom(node));\n      const result = find$2(scope.dom.childNodes, pred);\n      return result.map(SugarElement.fromDom);\n    };\n    const descendant$1 = (scope, predicate) => {\n      const descend = node => {\n        for (let i = 0; i < node.childNodes.length; i++) {\n          const child = SugarElement.fromDom(node.childNodes[i]);\n          if (predicate(child)) {\n            return Optional.some(child);\n          }\n          const res = descend(node.childNodes[i]);\n          if (res.isSome()) {\n            return res;\n          }\n        }\n        return Optional.none();\n      };\n      return descend(scope.dom);\n    };\n\n    const ancestor$2 = (scope, selector, isRoot) => ancestor$3(scope, e => is$1(e, selector), isRoot);\n    const descendant = (scope, selector) => one(selector, scope);\n    const closest$3 = (scope, selector, isRoot) => {\n      const is = (element, selector) => is$1(element, selector);\n      return ClosestOrAncestor(is, ancestor$2, scope, selector, isRoot);\n    };\n\n    const StyleSheetLoader = (documentOrShadowRoot, settings = {}) => {\n      let idCount = 0;\n      const loadedStates = {};\n      const edos = SugarElement.fromDom(documentOrShadowRoot);\n      const doc = documentOrOwner(edos);\n      const maxLoadTime = settings.maxLoadTime || 5000;\n      const _setReferrerPolicy = referrerPolicy => {\n        settings.referrerPolicy = referrerPolicy;\n      };\n      const addStyle = element => {\n        append$1(getStyleContainer(edos), element);\n      };\n      const removeStyle = id => {\n        const styleContainer = getStyleContainer(edos);\n        descendant(styleContainer, '#' + id).each(remove$5);\n      };\n      const getOrCreateState = url => get$a(loadedStates, url).getOrThunk(() => ({\n        id: 'mce-u' + idCount++,\n        passed: [],\n        failed: [],\n        count: 0\n      }));\n      const load = url => new Promise((success, failure) => {\n        let link;\n        const urlWithSuffix = Tools._addCacheSuffix(url);\n        const state = getOrCreateState(urlWithSuffix);\n        loadedStates[urlWithSuffix] = state;\n        state.count++;\n        const resolve = (callbacks, status) => {\n          each$g(callbacks, call);\n          state.status = status;\n          state.passed = [];\n          state.failed = [];\n          if (link) {\n            link.onload = null;\n            link.onerror = null;\n            link = null;\n          }\n        };\n        const passed = () => resolve(state.passed, 2);\n        const failed = () => resolve(state.failed, 3);\n        const wait = (testCallback, waitCallback) => {\n          if (!testCallback()) {\n            if (Date.now() - startTime < maxLoadTime) {\n              setTimeout(waitCallback);\n            } else {\n              failed();\n            }\n          }\n        };\n        const waitForWebKitLinkLoaded = () => {\n          wait(() => {\n            const styleSheets = documentOrShadowRoot.styleSheets;\n            let i = styleSheets.length;\n            while (i--) {\n              const styleSheet = styleSheets[i];\n              const owner = styleSheet.ownerNode;\n              if (owner && owner.id === link.id) {\n                passed();\n                return true;\n              }\n            }\n            return false;\n          }, waitForWebKitLinkLoaded);\n        };\n        if (success) {\n          state.passed.push(success);\n        }\n        if (failure) {\n          state.failed.push(failure);\n        }\n        if (state.status === 1) {\n          return;\n        }\n        if (state.status === 2) {\n          passed();\n          return;\n        }\n        if (state.status === 3) {\n          failed();\n          return;\n        }\n        state.status = 1;\n        const linkElem = SugarElement.fromTag('link', doc.dom);\n        setAll$1(linkElem, {\n          rel: 'stylesheet',\n          type: 'text/css',\n          id: state.id\n        });\n        const startTime = Date.now();\n        if (settings.contentCssCors) {\n          set$2(linkElem, 'crossOrigin', 'anonymous');\n        }\n        if (settings.referrerPolicy) {\n          set$2(linkElem, 'referrerpolicy', settings.referrerPolicy);\n        }\n        link = linkElem.dom;\n        link.onload = waitForWebKitLinkLoaded;\n        link.onerror = failed;\n        addStyle(linkElem);\n        set$2(linkElem, 'href', urlWithSuffix);\n      });\n      const loadAll = urls => {\n        const loadedUrls = Promise.allSettled(map$3(urls, url => load(url).then(constant(url))));\n        return loadedUrls.then(results => {\n          const parts = partition$2(results, r => r.status === 'fulfilled');\n          if (parts.fail.length > 0) {\n            return Promise.reject(map$3(parts.fail, result => result.reason));\n          } else {\n            return map$3(parts.pass, result => result.value);\n          }\n        });\n      };\n      const unload = url => {\n        const urlWithSuffix = Tools._addCacheSuffix(url);\n        get$a(loadedStates, urlWithSuffix).each(state => {\n          const count = --state.count;\n          if (count === 0) {\n            delete loadedStates[urlWithSuffix];\n            removeStyle(state.id);\n          }\n        });\n      };\n      const unloadAll = urls => {\n        each$g(urls, url => {\n          unload(url);\n        });\n      };\n      return {\n        load,\n        loadAll,\n        unload,\n        unloadAll,\n        _setReferrerPolicy\n      };\n    };\n\n    const create$c = () => {\n      const map = new WeakMap();\n      const forElement = (referenceElement, settings) => {\n        const root = getRootNode(referenceElement);\n        const rootDom = root.dom;\n        return Optional.from(map.get(rootDom)).getOrThunk(() => {\n          const sl = StyleSheetLoader(rootDom, settings);\n          map.set(rootDom, sl);\n          return sl;\n        });\n      };\n      return { forElement };\n    };\n    const instance = create$c();\n\n    class DomTreeWalker {\n      constructor(startNode, rootNode) {\n        this.node = startNode;\n        this.rootNode = rootNode;\n        this.current = this.current.bind(this);\n        this.next = this.next.bind(this);\n        this.prev = this.prev.bind(this);\n        this.prev2 = this.prev2.bind(this);\n      }\n      current() {\n        return this.node;\n      }\n      next(shallow) {\n        this.node = this.findSibling(this.node, 'firstChild', 'nextSibling', shallow);\n        return this.node;\n      }\n      prev(shallow) {\n        this.node = this.findSibling(this.node, 'lastChild', 'previousSibling', shallow);\n        return this.node;\n      }\n      prev2(shallow) {\n        this.node = this.findPreviousNode(this.node, 'lastChild', 'previousSibling', shallow);\n        return this.node;\n      }\n      findSibling(node, startName, siblingName, shallow) {\n        let sibling, parent;\n        if (node) {\n          if (!shallow && node[startName]) {\n            return node[startName];\n          }\n          if (node !== this.rootNode) {\n            sibling = node[siblingName];\n            if (sibling) {\n              return sibling;\n            }\n            for (parent = node.parentNode; parent && parent !== this.rootNode; parent = parent.parentNode) {\n              sibling = parent[siblingName];\n              if (sibling) {\n                return sibling;\n              }\n            }\n          }\n        }\n      }\n      findPreviousNode(node, startName, siblingName, shallow) {\n        let sibling, parent, child;\n        if (node) {\n          sibling = node[siblingName];\n          if (this.rootNode && sibling === this.rootNode) {\n            return;\n          }\n          if (sibling) {\n            if (!shallow) {\n              for (child = sibling[startName]; child; child = child[startName]) {\n                if (!child[startName]) {\n                  return child;\n                }\n              }\n            }\n            return sibling;\n          }\n          parent = node.parentNode;\n          if (parent && parent !== this.rootNode) {\n            return parent;\n          }\n        }\n      }\n    }\n\n    const blocks = [\n      'article',\n      'aside',\n      'details',\n      'div',\n      'dt',\n      'figcaption',\n      'footer',\n      'form',\n      'fieldset',\n      'header',\n      'hgroup',\n      'html',\n      'main',\n      'nav',\n      'section',\n      'summary',\n      'body',\n      'p',\n      'dl',\n      'multicol',\n      'dd',\n      'figure',\n      'address',\n      'center',\n      'blockquote',\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'listing',\n      'xmp',\n      'pre',\n      'plaintext',\n      'menu',\n      'dir',\n      'ul',\n      'ol',\n      'li',\n      'hr',\n      'table',\n      'tbody',\n      'thead',\n      'tfoot',\n      'th',\n      'tr',\n      'td',\n      'caption'\n    ];\n    const tableCells = [\n      'td',\n      'th'\n    ];\n    const tableSections = [\n      'thead',\n      'tbody',\n      'tfoot'\n    ];\n    const textBlocks = [\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'p',\n      'div',\n      'address',\n      'pre',\n      'form',\n      'blockquote',\n      'center',\n      'dir',\n      'fieldset',\n      'header',\n      'footer',\n      'article',\n      'section',\n      'hgroup',\n      'aside',\n      'nav',\n      'figure'\n    ];\n    const headings = [\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6'\n    ];\n    const listItems$1 = [\n      'li',\n      'dd',\n      'dt'\n    ];\n    const lists = [\n      'ul',\n      'ol',\n      'dl'\n    ];\n    const wsElements = [\n      'pre',\n      'script',\n      'textarea',\n      'style'\n    ];\n    const lazyLookup = items => {\n      let lookup;\n      return node => {\n        lookup = lookup ? lookup : mapToObject(items, always);\n        return has$2(lookup, name(node));\n      };\n    };\n    const isHeading = lazyLookup(headings);\n    const isBlock$2 = lazyLookup(blocks);\n    const isTable$2 = node => name(node) === 'table';\n    const isInline$1 = node => isElement$7(node) && !isBlock$2(node);\n    const isBr$4 = node => isElement$7(node) && name(node) === 'br';\n    const isTextBlock$2 = lazyLookup(textBlocks);\n    const isList = lazyLookup(lists);\n    const isListItem = lazyLookup(listItems$1);\n    const isTableSection = lazyLookup(tableSections);\n    const isTableCell$4 = lazyLookup(tableCells);\n    const isWsPreserveElement = lazyLookup(wsElements);\n\n    const ancestor$1 = (scope, selector, isRoot) => ancestor$2(scope, selector, isRoot).isSome();\n\n    const zeroWidth = '\\uFEFF';\n    const nbsp = '\\xA0';\n    const isZwsp$1 = char => char === zeroWidth;\n    const removeZwsp = s => s.replace(/\\uFEFF/g, '');\n\n    const ZWSP$1 = zeroWidth;\n    const isZwsp = isZwsp$1;\n    const trim$1 = removeZwsp;\n\n    const isElement$5 = isElement$6;\n    const isText$7 = isText$8;\n    const isCaretContainerBlock$1 = node => {\n      if (isText$7(node)) {\n        node = node.parentNode;\n      }\n      return isElement$5(node) && node.hasAttribute('data-mce-caret');\n    };\n    const isCaretContainerInline = node => isText$7(node) && isZwsp(node.data);\n    const isCaretContainer$2 = node => isCaretContainerBlock$1(node) || isCaretContainerInline(node);\n    const hasContent = node => node.firstChild !== node.lastChild || !isBr$5(node.firstChild);\n    const insertInline$1 = (node, before) => {\n      const doc = node.ownerDocument;\n      const textNode = doc.createTextNode(ZWSP$1);\n      const parentNode = node.parentNode;\n      if (!before) {\n        const sibling = node.nextSibling;\n        if (isText$7(sibling)) {\n          if (isCaretContainer$2(sibling)) {\n            return sibling;\n          }\n          if (startsWithCaretContainer$1(sibling)) {\n            sibling.splitText(1);\n            return sibling;\n          }\n        }\n        if (node.nextSibling) {\n          parentNode.insertBefore(textNode, node.nextSibling);\n        } else {\n          parentNode.appendChild(textNode);\n        }\n      } else {\n        const sibling = node.previousSibling;\n        if (isText$7(sibling)) {\n          if (isCaretContainer$2(sibling)) {\n            return sibling;\n          }\n          if (endsWithCaretContainer$1(sibling)) {\n            return sibling.splitText(sibling.data.length - 1);\n          }\n        }\n        parentNode.insertBefore(textNode, node);\n      }\n      return textNode;\n    };\n    const isBeforeInline = pos => {\n      const container = pos.container();\n      if (!isText$8(container)) {\n        return false;\n      }\n      return container.data.charAt(pos.offset()) === ZWSP$1 || pos.isAtStart() && isCaretContainerInline(container.previousSibling);\n    };\n    const isAfterInline = pos => {\n      const container = pos.container();\n      if (!isText$8(container)) {\n        return false;\n      }\n      return container.data.charAt(pos.offset() - 1) === ZWSP$1 || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);\n    };\n    const createBogusBr = () => {\n      const br = document.createElement('br');\n      br.setAttribute('data-mce-bogus', '1');\n      return br;\n    };\n    const insertBlock = (blockName, node, before) => {\n      const doc = node.ownerDocument;\n      const blockNode = doc.createElement(blockName);\n      blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');\n      blockNode.setAttribute('data-mce-bogus', 'all');\n      blockNode.appendChild(createBogusBr());\n      const parentNode = node.parentNode;\n      if (!before) {\n        if (node.nextSibling) {\n          parentNode.insertBefore(blockNode, node.nextSibling);\n        } else {\n          parentNode.appendChild(blockNode);\n        }\n      } else {\n        parentNode.insertBefore(blockNode, node);\n      }\n      return blockNode;\n    };\n    const startsWithCaretContainer$1 = node => isText$7(node) && node.data[0] === ZWSP$1;\n    const endsWithCaretContainer$1 = node => isText$7(node) && node.data[node.data.length - 1] === ZWSP$1;\n    const trimBogusBr = elm => {\n      const brs = elm.getElementsByTagName('br');\n      const lastBr = brs[brs.length - 1];\n      if (isBogus$2(lastBr)) {\n        lastBr.parentNode.removeChild(lastBr);\n      }\n    };\n    const showCaretContainerBlock = caretContainer => {\n      if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {\n        trimBogusBr(caretContainer);\n        caretContainer.removeAttribute('data-mce-caret');\n        caretContainer.removeAttribute('data-mce-bogus');\n        caretContainer.removeAttribute('style');\n        caretContainer.removeAttribute('data-mce-style');\n        caretContainer.removeAttribute('_moz_abspos');\n        return caretContainer;\n      }\n      return null;\n    };\n    const isRangeInCaretContainerBlock = range => isCaretContainerBlock$1(range.startContainer);\n\n    const isContentEditableTrue$3 = isContentEditableTrue$4;\n    const isContentEditableFalse$9 = isContentEditableFalse$a;\n    const isBr$3 = isBr$5;\n    const isText$6 = isText$8;\n    const isInvalidTextElement = matchNodeNames([\n      'script',\n      'style',\n      'textarea'\n    ]);\n    const isAtomicInline = matchNodeNames([\n      'img',\n      'input',\n      'textarea',\n      'hr',\n      'iframe',\n      'video',\n      'audio',\n      'object',\n      'embed'\n    ]);\n    const isTable$1 = matchNodeNames(['table']);\n    const isCaretContainer$1 = isCaretContainer$2;\n    const isCaretCandidate$3 = node => {\n      if (isCaretContainer$1(node)) {\n        return false;\n      }\n      if (isText$6(node)) {\n        return !isInvalidTextElement(node.parentNode);\n      }\n      return isAtomicInline(node) || isBr$3(node) || isTable$1(node) || isNonUiContentEditableFalse(node);\n    };\n    const isUnselectable = node => isElement$6(node) && node.getAttribute('unselectable') === 'true';\n    const isNonUiContentEditableFalse = node => isUnselectable(node) === false && isContentEditableFalse$9(node);\n    const isInEditable = (node, root) => {\n      for (node = node.parentNode; node && node !== root; node = node.parentNode) {\n        if (isNonUiContentEditableFalse(node)) {\n          return false;\n        }\n        if (isContentEditableTrue$3(node)) {\n          return true;\n        }\n      }\n      return true;\n    };\n    const isAtomicContentEditableFalse = node => {\n      if (!isNonUiContentEditableFalse(node)) {\n        return false;\n      }\n      return foldl(from(node.getElementsByTagName('*')), (result, elm) => {\n        return result || isContentEditableTrue$3(elm);\n      }, false) !== true;\n    };\n    const isAtomic$1 = node => isAtomicInline(node) || isAtomicContentEditableFalse(node);\n    const isEditableCaretCandidate$1 = (node, root) => isCaretCandidate$3(node) && isInEditable(node, root);\n\n    const whiteSpaceRegExp = /^[ \\t\\r\\n]*$/;\n    const isWhitespaceText = text => whiteSpaceRegExp.test(text);\n    const isCollapsibleWhitespace$1 = c => ' \\f\\t\\x0B'.indexOf(c) !== -1;\n    const isNewLineChar = c => c === '\\n' || c === '\\r';\n    const isNewline = (text, idx) => idx < text.length && idx >= 0 ? isNewLineChar(text[idx]) : false;\n    const normalize$4 = (text, tabSpaces = 4, isStartOfContent = true, isEndOfContent = true) => {\n      const tabSpace = repeat(' ', tabSpaces);\n      const normalizedText = text.replace(/\\t/g, tabSpace);\n      const result = foldl(normalizedText, (acc, c) => {\n        if (isCollapsibleWhitespace$1(c) || c === nbsp) {\n          if (acc.pcIsSpace || acc.str === '' && isStartOfContent || acc.str.length === normalizedText.length - 1 && isEndOfContent || isNewline(normalizedText, acc.str.length + 1)) {\n            return {\n              pcIsSpace: false,\n              str: acc.str + nbsp\n            };\n          } else {\n            return {\n              pcIsSpace: true,\n              str: acc.str + ' '\n            };\n          }\n        } else {\n          return {\n            pcIsSpace: isNewLineChar(c),\n            str: acc.str + c\n          };\n        }\n      }, {\n        pcIsSpace: false,\n        str: ''\n      });\n      return result.str;\n    };\n\n    const hasWhitespacePreserveParent = (node, rootNode) => {\n      const rootElement = SugarElement.fromDom(rootNode);\n      const startNode = SugarElement.fromDom(node);\n      return ancestor$1(startNode, 'pre,code', curry(eq, rootElement));\n    };\n    const isWhitespace$1 = (node, rootNode) => {\n      return isText$8(node) && isWhitespaceText(node.data) && hasWhitespacePreserveParent(node, rootNode) === false;\n    };\n    const isNamedAnchor = node => {\n      return isElement$6(node) && node.nodeName === 'A' && !node.hasAttribute('href') && (node.hasAttribute('name') || node.hasAttribute('id'));\n    };\n    const isContent$1 = (node, rootNode) => {\n      return isCaretCandidate$3(node) && isWhitespace$1(node, rootNode) === false || isNamedAnchor(node) || isBookmark(node);\n    };\n    const isBookmark = hasAttribute('data-mce-bookmark');\n    const isBogus$1 = hasAttribute('data-mce-bogus');\n    const isBogusAll = hasAttributeValue('data-mce-bogus', 'all');\n    const isEmptyNode = (targetNode, skipBogus) => {\n      let brCount = 0;\n      if (isContent$1(targetNode, targetNode)) {\n        return false;\n      } else {\n        let node = targetNode.firstChild;\n        if (!node) {\n          return true;\n        }\n        const walker = new DomTreeWalker(node, targetNode);\n        do {\n          if (skipBogus) {\n            if (isBogusAll(node)) {\n              node = walker.next(true);\n              continue;\n            }\n            if (isBogus$1(node)) {\n              node = walker.next();\n              continue;\n            }\n          }\n          if (isBr$5(node)) {\n            brCount++;\n            node = walker.next();\n            continue;\n          }\n          if (isContent$1(node, targetNode)) {\n            return false;\n          }\n          node = walker.next();\n        } while (node);\n        return brCount <= 1;\n      }\n    };\n    const isEmpty$2 = (elm, skipBogus = true) => isEmptyNode(elm.dom, skipBogus);\n\n    const isSpan = node => node.nodeName.toLowerCase() === 'span';\n    const isInlineContent = (node, root) => isNonNullable(node) && (isContent$1(node, root) || isInline$1(SugarElement.fromDom(node)));\n    const surroundedByInlineContent = (node, root) => {\n      const prev = new DomTreeWalker(node, root).prev(false);\n      const next = new DomTreeWalker(node, root).next(false);\n      const prevIsInline = isUndefined(prev) || isInlineContent(prev, root);\n      const nextIsInline = isUndefined(next) || isInlineContent(next, root);\n      return prevIsInline && nextIsInline;\n    };\n    const isBookmarkNode$2 = node => isSpan(node) && node.getAttribute('data-mce-type') === 'bookmark';\n    const isKeepTextNode = (node, root) => isText$8(node) && node.data.length > 0 && surroundedByInlineContent(node, root);\n    const isKeepElement = node => isElement$6(node) ? node.childNodes.length > 0 : false;\n    const isDocument = node => isDocumentFragment(node) || isDocument$1(node);\n    const trimNode = (dom, node, root) => {\n      const rootNode = root || node;\n      if (isElement$6(node) && isBookmarkNode$2(node)) {\n        return node;\n      }\n      const children = node.childNodes;\n      for (let i = children.length - 1; i >= 0; i--) {\n        trimNode(dom, children[i], rootNode);\n      }\n      if (isElement$6(node)) {\n        const currentChildren = node.childNodes;\n        if (currentChildren.length === 1 && isBookmarkNode$2(currentChildren[0])) {\n          node.parentNode.insertBefore(currentChildren[0], node);\n        }\n      }\n      if (!isDocument(node) && !isContent$1(node, rootNode) && !isKeepElement(node) && !isKeepTextNode(node, rootNode)) {\n        dom.remove(node);\n      }\n      return node;\n    };\n\n    const makeMap$3 = Tools.makeMap;\n    const attrsCharsRegExp = /[&<>\\\"\\u0060\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n    const textCharsRegExp = /[<>&\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n    const rawCharsRegExp = /[<>&\\\"\\']/g;\n    const entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;\n    const asciiMap = {\n      128: '\\u20AC',\n      130: '\\u201A',\n      131: '\\u0192',\n      132: '\\u201E',\n      133: '\\u2026',\n      134: '\\u2020',\n      135: '\\u2021',\n      136: '\\u02c6',\n      137: '\\u2030',\n      138: '\\u0160',\n      139: '\\u2039',\n      140: '\\u0152',\n      142: '\\u017d',\n      145: '\\u2018',\n      146: '\\u2019',\n      147: '\\u201C',\n      148: '\\u201D',\n      149: '\\u2022',\n      150: '\\u2013',\n      151: '\\u2014',\n      152: '\\u02DC',\n      153: '\\u2122',\n      154: '\\u0161',\n      155: '\\u203A',\n      156: '\\u0153',\n      158: '\\u017e',\n      159: '\\u0178'\n    };\n    const baseEntities = {\n      '\"': '&quot;',\n      '\\'': '&#39;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '&': '&amp;',\n      '`': '&#96;'\n    };\n    const reverseEntities = {\n      '&lt;': '<',\n      '&gt;': '>',\n      '&amp;': '&',\n      '&quot;': '\"',\n      '&apos;': `'`\n    };\n    const nativeDecode = text => {\n      const elm = SugarElement.fromTag('div').dom;\n      elm.innerHTML = text;\n      return elm.textContent || elm.innerText || text;\n    };\n    const buildEntitiesLookup = (items, radix) => {\n      let i, chr, entity;\n      const lookup = {};\n      if (items) {\n        items = items.split(',');\n        radix = radix || 10;\n        for (i = 0; i < items.length; i += 2) {\n          chr = String.fromCharCode(parseInt(items[i], radix));\n          if (!baseEntities[chr]) {\n            entity = '&' + items[i + 1] + ';';\n            lookup[chr] = entity;\n            lookup[entity] = chr;\n          }\n        }\n        return lookup;\n      }\n    };\n    const namedEntities = buildEntitiesLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' + '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' + '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' + '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' + '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' + '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' + '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' + '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' + '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' + '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' + 'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' + 'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' + 't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' + 'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' + 'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' + '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' + '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' + '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' + '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' + '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' + 'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' + 'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' + 'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' + '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' + '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);\n    const encodeRaw = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n      return baseEntities[chr] || chr;\n    });\n    const encodeAllRaw = text => ('' + text).replace(rawCharsRegExp, chr => {\n      return baseEntities[chr] || chr;\n    });\n    const encodeNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n      if (chr.length > 1) {\n        return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\n      }\n      return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';\n    });\n    const encodeNamed = (text, attr, entities) => {\n      entities = entities || namedEntities;\n      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n        return baseEntities[chr] || entities[chr] || chr;\n      });\n    };\n    const getEncodeFunc = (name, entities) => {\n      const entitiesMap = buildEntitiesLookup(entities) || namedEntities;\n      const encodeNamedAndNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n        if (baseEntities[chr] !== undefined) {\n          return baseEntities[chr];\n        }\n        if (entitiesMap[chr] !== undefined) {\n          return entitiesMap[chr];\n        }\n        if (chr.length > 1) {\n          return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\n        }\n        return '&#' + chr.charCodeAt(0) + ';';\n      });\n      const encodeCustomNamed = (text, attr) => {\n        return encodeNamed(text, attr, entitiesMap);\n      };\n      const nameMap = makeMap$3(name.replace(/\\+/g, ','));\n      if (nameMap.named && nameMap.numeric) {\n        return encodeNamedAndNumeric;\n      }\n      if (nameMap.named) {\n        if (entities) {\n          return encodeCustomNamed;\n        }\n        return encodeNamed;\n      }\n      if (nameMap.numeric) {\n        return encodeNumeric;\n      }\n      return encodeRaw;\n    };\n    const decode = text => text.replace(entityRegExp, (all, numeric) => {\n      if (numeric) {\n        if (numeric.charAt(0).toLowerCase() === 'x') {\n          numeric = parseInt(numeric.substr(1), 16);\n        } else {\n          numeric = parseInt(numeric, 10);\n        }\n        if (numeric > 65535) {\n          numeric -= 65536;\n          return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));\n        }\n        return asciiMap[numeric] || String.fromCharCode(numeric);\n      }\n      return reverseEntities[all] || namedEntities[all] || nativeDecode(all);\n    });\n    const Entities = {\n      encodeRaw,\n      encodeAllRaw,\n      encodeNumeric,\n      encodeNamed,\n      getEncodeFunc,\n      decode\n    };\n\n    const mapCache = {}, dummyObj = {};\n    const makeMap$2 = Tools.makeMap, each$d = Tools.each, extend$2 = Tools.extend, explode$2 = Tools.explode, inArray = Tools.inArray;\n    const split$1 = (items, delim) => {\n      items = Tools.trim(items);\n      return items ? items.split(delim || ' ') : [];\n    };\n    const compileSchema = type => {\n      const schema = {};\n      let globalAttributes, blockContent;\n      let phrasingContent, flowContent, html4BlockContent, html4PhrasingContent;\n      const add = (name, attributes = '', children = '') => {\n        const childNames = split$1(children);\n        const names = split$1(name);\n        let ni = names.length;\n        while (ni--) {\n          const attributesOrder = split$1([\n            globalAttributes,\n            attributes\n          ].join(' '));\n          schema[names[ni]] = {\n            attributes: mapToObject(attributesOrder, () => ({})),\n            attributesOrder,\n            children: mapToObject(childNames, constant(dummyObj))\n          };\n        }\n      };\n      const addAttrs = (name, attributes) => {\n        const names = split$1(name);\n        const attrs = split$1(attributes);\n        let ni = names.length;\n        while (ni--) {\n          const schemaItem = schema[names[ni]];\n          for (let i = 0, l = attrs.length; i < l; i++) {\n            schemaItem.attributes[attrs[i]] = {};\n            schemaItem.attributesOrder.push(attrs[i]);\n          }\n        }\n      };\n      if (mapCache[type]) {\n        return mapCache[type];\n      }\n      globalAttributes = 'id accesskey class dir lang style tabindex title role';\n      blockContent = 'address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul';\n      phrasingContent = 'a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd ' + 'label map noscript object q s samp script select small span strong sub sup ' + 'textarea u var #text #comment';\n      if (type !== 'html4') {\n        globalAttributes += ' contenteditable contextmenu draggable dropzone ' + 'hidden spellcheck translate';\n        blockContent += ' article aside details dialog figure main header footer hgroup section nav';\n        phrasingContent += ' audio canvas command datalist mark meter output picture ' + 'progress time wbr video ruby bdi keygen';\n      }\n      if (type !== 'html5-strict') {\n        globalAttributes += ' xml:lang';\n        html4PhrasingContent = 'acronym applet basefont big font strike tt';\n        phrasingContent = [\n          phrasingContent,\n          html4PhrasingContent\n        ].join(' ');\n        each$d(split$1(html4PhrasingContent), name => {\n          add(name, '', phrasingContent);\n        });\n        html4BlockContent = 'center dir isindex noframes';\n        blockContent = [\n          blockContent,\n          html4BlockContent\n        ].join(' ');\n        flowContent = [\n          blockContent,\n          phrasingContent\n        ].join(' ');\n        each$d(split$1(html4BlockContent), name => {\n          add(name, '', flowContent);\n        });\n      }\n      flowContent = flowContent || [\n        blockContent,\n        phrasingContent\n      ].join(' ');\n      add('html', 'manifest', 'head body');\n      add('head', '', 'base command link meta noscript script style title');\n      add('title hr noscript br');\n      add('base', 'href target');\n      add('link', 'href rel media hreflang type sizes hreflang');\n      add('meta', 'name http-equiv content charset');\n      add('style', 'media type scoped');\n      add('script', 'src async defer type charset');\n      add('body', 'onafterprint onbeforeprint onbeforeunload onblur onerror onfocus ' + 'onhashchange onload onmessage onoffline ononline onpagehide onpageshow ' + 'onpopstate onresize onscroll onstorage onunload', flowContent);\n      add('address dt dd div caption', '', flowContent);\n      add('h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn', '', phrasingContent);\n      add('blockquote', 'cite', flowContent);\n      add('ol', 'reversed start type', 'li');\n      add('ul', '', 'li');\n      add('li', 'value', flowContent);\n      add('dl', '', 'dt dd');\n      add('a', 'href target rel media hreflang type', phrasingContent);\n      add('q', 'cite', phrasingContent);\n      add('ins del', 'cite datetime', flowContent);\n      add('img', 'src sizes srcset alt usemap ismap width height');\n      add('iframe', 'src name width height', flowContent);\n      add('embed', 'src type width height');\n      add('object', 'data type typemustmatch name usemap form width height', [\n        flowContent,\n        'param'\n      ].join(' '));\n      add('param', 'name value');\n      add('map', 'name', [\n        flowContent,\n        'area'\n      ].join(' '));\n      add('area', 'alt coords shape href target rel media hreflang type');\n      add('table', 'border', 'caption colgroup thead tfoot tbody tr' + (type === 'html4' ? ' col' : ''));\n      add('colgroup', 'span', 'col');\n      add('col', 'span');\n      add('tbody thead tfoot', '', 'tr');\n      add('tr', '', 'td th');\n      add('td', 'colspan rowspan headers', flowContent);\n      add('th', 'colspan rowspan headers scope abbr', flowContent);\n      add('form', 'accept-charset action autocomplete enctype method name novalidate target', flowContent);\n      add('fieldset', 'disabled form name', [\n        flowContent,\n        'legend'\n      ].join(' '));\n      add('label', 'form for', phrasingContent);\n      add('input', 'accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate ' + 'formtarget height list max maxlength min multiple name pattern readonly required size src step type value width');\n      add('button', 'disabled form formaction formenctype formmethod formnovalidate formtarget name type value', type === 'html4' ? flowContent : phrasingContent);\n      add('select', 'disabled form multiple name required size', 'option optgroup');\n      add('optgroup', 'disabled label', 'option');\n      add('option', 'disabled label selected value');\n      add('textarea', 'cols dirname disabled form maxlength name readonly required rows wrap');\n      add('menu', 'type label', [\n        flowContent,\n        'li'\n      ].join(' '));\n      add('noscript', '', flowContent);\n      if (type !== 'html4') {\n        add('wbr');\n        add('ruby', '', [\n          phrasingContent,\n          'rt rp'\n        ].join(' '));\n        add('figcaption', '', flowContent);\n        add('mark rt rp summary bdi', '', phrasingContent);\n        add('canvas', 'width height', flowContent);\n        add('video', 'src crossorigin poster preload autoplay mediagroup loop ' + 'muted controls width height buffered', [\n          flowContent,\n          'track source'\n        ].join(' '));\n        add('audio', 'src crossorigin preload autoplay mediagroup loop muted controls ' + 'buffered volume', [\n          flowContent,\n          'track source'\n        ].join(' '));\n        add('picture', '', 'img source');\n        add('source', 'src srcset type media sizes');\n        add('track', 'kind src srclang label default');\n        add('datalist', '', [\n          phrasingContent,\n          'option'\n        ].join(' '));\n        add('article section nav aside main header footer', '', flowContent);\n        add('hgroup', '', 'h1 h2 h3 h4 h5 h6');\n        add('figure', '', [\n          flowContent,\n          'figcaption'\n        ].join(' '));\n        add('time', 'datetime', phrasingContent);\n        add('dialog', 'open', flowContent);\n        add('command', 'type label icon disabled checked radiogroup command');\n        add('output', 'for form name', phrasingContent);\n        add('progress', 'value max', phrasingContent);\n        add('meter', 'value min max low high optimum', phrasingContent);\n        add('details', 'open', [\n          flowContent,\n          'summary'\n        ].join(' '));\n        add('keygen', 'autofocus challenge disabled form keytype name');\n      }\n      if (type !== 'html5-strict') {\n        addAttrs('script', 'language xml:space');\n        addAttrs('style', 'xml:space');\n        addAttrs('object', 'declare classid code codebase codetype archive standby align border hspace vspace');\n        addAttrs('embed', 'align name hspace vspace');\n        addAttrs('param', 'valuetype type');\n        addAttrs('a', 'charset name rev shape coords');\n        addAttrs('br', 'clear');\n        addAttrs('applet', 'codebase archive code object alt name width height align hspace vspace');\n        addAttrs('img', 'name longdesc align border hspace vspace');\n        addAttrs('iframe', 'longdesc frameborder marginwidth marginheight scrolling align');\n        addAttrs('font basefont', 'size color face');\n        addAttrs('input', 'usemap align');\n        addAttrs('select');\n        addAttrs('textarea');\n        addAttrs('h1 h2 h3 h4 h5 h6 div p legend caption', 'align');\n        addAttrs('ul', 'type compact');\n        addAttrs('li', 'type');\n        addAttrs('ol dl menu dir', 'compact');\n        addAttrs('pre', 'width xml:space');\n        addAttrs('hr', 'align noshade size width');\n        addAttrs('isindex', 'prompt');\n        addAttrs('table', 'summary width frame rules cellspacing cellpadding align bgcolor');\n        addAttrs('col', 'width align char charoff valign');\n        addAttrs('colgroup', 'width align char charoff valign');\n        addAttrs('thead', 'align char charoff valign');\n        addAttrs('tr', 'align char charoff valign bgcolor');\n        addAttrs('th', 'axis align char charoff valign nowrap bgcolor width height');\n        addAttrs('form', 'accept');\n        addAttrs('td', 'abbr axis scope align char charoff valign nowrap bgcolor width height');\n        addAttrs('tfoot', 'align char charoff valign');\n        addAttrs('tbody', 'align char charoff valign');\n        addAttrs('area', 'nohref');\n        addAttrs('body', 'background bgcolor text link vlink alink');\n      }\n      if (type !== 'html4') {\n        addAttrs('input button select textarea', 'autofocus');\n        addAttrs('input textarea', 'placeholder');\n        addAttrs('a', 'download');\n        addAttrs('link script img', 'crossorigin');\n        addAttrs('img', 'loading');\n        addAttrs('iframe', 'sandbox seamless allowfullscreen loading');\n      }\n      if (type !== 'html4') {\n        each$g([\n          schema.video,\n          schema.audio\n        ], item => {\n          delete item.children.audio;\n          delete item.children.video;\n        });\n      }\n      each$d(split$1('a form meter progress dfn'), name => {\n        if (schema[name]) {\n          delete schema[name].children[name];\n        }\n      });\n      delete schema.caption.children.table;\n      delete schema.script;\n      mapCache[type] = schema;\n      return schema;\n    };\n    const compileElementMap = (value, mode) => {\n      let styles;\n      if (value) {\n        styles = {};\n        if (typeof value === 'string') {\n          value = { '*': value };\n        }\n        each$d(value, (value, key) => {\n          styles[key] = styles[key.toUpperCase()] = mode === 'map' ? makeMap$2(value, /[, ]/) : explode$2(value, /[, ]/);\n        });\n      }\n      return styles;\n    };\n    const Schema = settings => {\n      var _a;\n      const elements = {};\n      const children = {};\n      let patternElements = [];\n      const customElementsMap = {}, specialElements = {};\n      const createLookupTable = (option, defaultValue, extendWith) => {\n        let value = settings[option];\n        if (!value) {\n          value = mapCache[option];\n          if (!value) {\n            value = makeMap$2(defaultValue, ' ', makeMap$2(defaultValue.toUpperCase(), ' '));\n            value = extend$2(value, extendWith);\n            mapCache[option] = value;\n          }\n        } else {\n          value = makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));\n        }\n        return value;\n      };\n      settings = settings || {};\n      const schemaType = (_a = settings.schema) !== null && _a !== void 0 ? _a : 'html5';\n      const schemaItems = compileSchema(schemaType);\n      if (settings.verify_html === false) {\n        settings.valid_elements = '*[*]';\n      }\n      const validStyles = compileElementMap(settings.valid_styles);\n      const invalidStyles = compileElementMap(settings.invalid_styles, 'map');\n      const validClasses = compileElementMap(settings.valid_classes, 'map');\n      const whitespaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object code');\n      const selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');\n      const voidElementsMap = createLookupTable('void_elements', 'area base basefont br col frame hr img input isindex link ' + 'meta param embed source wbr track');\n      const boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' + 'noshade nowrap readonly selected autoplay loop controls allowfullscreen');\n      const nonEmptyOrMoveCaretBeforeOnEnter = 'td th iframe video audio object script code';\n      const nonEmptyElementsMap = createLookupTable('non_empty_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' pre', voidElementsMap);\n      const moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' table', voidElementsMap);\n      const textBlockElementsMap = createLookupTable('text_block_elements', 'h1 h2 h3 h4 h5 h6 p div address pre form ' + 'blockquote center dir fieldset header footer article section hgroup aside main nav figure');\n      const blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' + 'th tr td li ol ul caption dl dt dd noscript menu isindex option ' + 'datalist select optgroup figcaption details summary', textBlockElementsMap);\n      const textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font strike u var cite ' + 'dfn code mark q sup sub samp');\n      each$d('script noscript iframe noframes noembed title style textarea xmp plaintext'.split(' '), name => {\n        specialElements[name] = new RegExp('</' + name + '[^>]*>', 'gi');\n      });\n      const patternToRegExp = str => new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');\n      const addValidElements = validElements => {\n        let ei, el, ai, al, matches, element, attr, attrData, elementName, attrName, attrType, attributes, attributesOrder, prefix, outputName, globalAttributes, globalAttributesOrder, value;\n        const elementRuleRegExp = /^([#+\\-])?([^\\[!\\/]+)(?:\\/([^\\[!]+))?(?:(!?)\\[([^\\]]+)])?$/, attrRuleRegExp = /^([!\\-])?(\\w+[\\\\:]:\\w+|[^=~<]+)?(?:([=~<])(.*))?$/, hasPatternsRegExp = /[*?+]/;\n        if (validElements) {\n          const validElementsArr = split$1(validElements, ',');\n          if (elements['@']) {\n            globalAttributes = elements['@'].attributes;\n            globalAttributesOrder = elements['@'].attributesOrder;\n          }\n          for (ei = 0, el = validElementsArr.length; ei < el; ei++) {\n            matches = elementRuleRegExp.exec(validElementsArr[ei]);\n            if (matches) {\n              prefix = matches[1];\n              elementName = matches[2];\n              outputName = matches[3];\n              attrData = matches[5];\n              attributes = {};\n              attributesOrder = [];\n              element = {\n                attributes,\n                attributesOrder\n              };\n              if (prefix === '#') {\n                element.paddEmpty = true;\n              }\n              if (prefix === '-') {\n                element.removeEmpty = true;\n              }\n              if (matches[4] === '!') {\n                element.removeEmptyAttrs = true;\n              }\n              if (globalAttributes) {\n                each$f(globalAttributes, (value, key) => {\n                  attributes[key] = value;\n                });\n                attributesOrder.push.apply(attributesOrder, globalAttributesOrder);\n              }\n              if (attrData) {\n                attrData = split$1(attrData, '|');\n                for (ai = 0, al = attrData.length; ai < al; ai++) {\n                  matches = attrRuleRegExp.exec(attrData[ai]);\n                  if (matches) {\n                    attr = {};\n                    attrType = matches[1];\n                    attrName = matches[2].replace(/[\\\\:]:/g, ':');\n                    prefix = matches[3];\n                    value = matches[4];\n                    if (attrType === '!') {\n                      element.attributesRequired = element.attributesRequired || [];\n                      element.attributesRequired.push(attrName);\n                      attr.required = true;\n                    }\n                    if (attrType === '-') {\n                      delete attributes[attrName];\n                      attributesOrder.splice(inArray(attributesOrder, attrName), 1);\n                      continue;\n                    }\n                    if (prefix) {\n                      if (prefix === '=') {\n                        element.attributesDefault = element.attributesDefault || [];\n                        element.attributesDefault.push({\n                          name: attrName,\n                          value\n                        });\n                        attr.defaultValue = value;\n                      }\n                      if (prefix === '~') {\n                        element.attributesForced = element.attributesForced || [];\n                        element.attributesForced.push({\n                          name: attrName,\n                          value\n                        });\n                        attr.forcedValue = value;\n                      }\n                      if (prefix === '<') {\n                        attr.validValues = makeMap$2(value, '?');\n                      }\n                    }\n                    if (hasPatternsRegExp.test(attrName)) {\n                      element.attributePatterns = element.attributePatterns || [];\n                      attr.pattern = patternToRegExp(attrName);\n                      element.attributePatterns.push(attr);\n                    } else {\n                      if (!attributes[attrName]) {\n                        attributesOrder.push(attrName);\n                      }\n                      attributes[attrName] = attr;\n                    }\n                  }\n                }\n              }\n              if (!globalAttributes && elementName === '@') {\n                globalAttributes = attributes;\n                globalAttributesOrder = attributesOrder;\n              }\n              if (outputName) {\n                element.outputName = elementName;\n                elements[outputName] = element;\n              }\n              if (hasPatternsRegExp.test(elementName)) {\n                element.pattern = patternToRegExp(elementName);\n                patternElements.push(element);\n              } else {\n                elements[elementName] = element;\n              }\n            }\n          }\n        }\n      };\n      const setValidElements = validElements => {\n        patternElements = [];\n        each$g(keys(elements), name => {\n          delete elements[name];\n        });\n        addValidElements(validElements);\n        each$d(schemaItems, (element, name) => {\n          children[name] = element.children;\n        });\n      };\n      const addCustomElements = customElements => {\n        const customElementRegExp = /^(~)?(.+)$/;\n        if (customElements) {\n          mapCache.text_block_elements = mapCache.block_elements = null;\n          each$d(split$1(customElements, ','), rule => {\n            const matches = customElementRegExp.exec(rule), inline = matches[1] === '~', cloneName = inline ? 'span' : 'div', name = matches[2];\n            children[name] = children[cloneName];\n            customElementsMap[name] = cloneName;\n            if (!inline) {\n              blockElementsMap[name.toUpperCase()] = {};\n              blockElementsMap[name] = {};\n            }\n            if (!elements[name]) {\n              let customRule = elements[cloneName];\n              customRule = extend$2({}, customRule);\n              delete customRule.removeEmptyAttrs;\n              delete customRule.removeEmpty;\n              elements[name] = customRule;\n            }\n            each$d(children, (element, elmName) => {\n              if (element[cloneName]) {\n                children[elmName] = element = extend$2({}, children[elmName]);\n                element[name] = element[cloneName];\n              }\n            });\n          });\n        }\n      };\n      const addValidChildren = validChildren => {\n        const childRuleRegExp = /^([+\\-]?)([A-Za-z0-9_\\-.\\u00b7\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u037d\\u037f-\\u1fff\\u200c-\\u200d\\u203f-\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]+)\\[([^\\]]+)]$/;\n        mapCache[schemaType] = null;\n        if (validChildren) {\n          each$d(split$1(validChildren, ','), rule => {\n            const matches = childRuleRegExp.exec(rule);\n            let parent, prefix;\n            if (matches) {\n              prefix = matches[1];\n              if (prefix) {\n                parent = children[matches[2]];\n              } else {\n                parent = children[matches[2]] = { '#comment': {} };\n              }\n              parent = children[matches[2]];\n              each$d(split$1(matches[3], '|'), child => {\n                if (prefix === '-') {\n                  delete parent[child];\n                } else {\n                  parent[child] = {};\n                }\n              });\n            }\n          });\n        }\n      };\n      const getElementRule = name => {\n        let element = elements[name], i;\n        if (element) {\n          return element;\n        }\n        i = patternElements.length;\n        while (i--) {\n          element = patternElements[i];\n          if (element.pattern.test(name)) {\n            return element;\n          }\n        }\n      };\n      if (!settings.valid_elements) {\n        each$d(schemaItems, (element, name) => {\n          elements[name] = {\n            attributes: element.attributes,\n            attributesOrder: element.attributesOrder\n          };\n          children[name] = element.children;\n        });\n        each$d(split$1('strong/b em/i'), item => {\n          const items = split$1(item, '/');\n          elements[items[1]].outputName = items[0];\n        });\n        each$d(split$1('ol ul sub sup blockquote span font a table tbody strong em b i'), name => {\n          if (elements[name]) {\n            elements[name].removeEmpty = true;\n          }\n        });\n        each$d(split$1('p h1 h2 h3 h4 h5 h6 th td pre div address caption li'), name => {\n          elements[name].paddEmpty = true;\n        });\n        each$d(split$1('span'), name => {\n          elements[name].removeEmptyAttrs = true;\n        });\n      } else {\n        setValidElements(settings.valid_elements);\n      }\n      addCustomElements(settings.custom_elements);\n      addValidChildren(settings.valid_children);\n      addValidElements(settings.extended_valid_elements);\n      addValidChildren('+ol[ul|ol],+ul[ul|ol]');\n      each$d({\n        dd: 'dl',\n        dt: 'dl',\n        li: 'ul ol',\n        td: 'tr',\n        th: 'tr',\n        tr: 'tbody thead tfoot',\n        tbody: 'table',\n        thead: 'table',\n        tfoot: 'table',\n        legend: 'fieldset',\n        area: 'map',\n        param: 'video audio object'\n      }, (parents, item) => {\n        if (elements[item]) {\n          elements[item].parentsRequired = split$1(parents);\n        }\n      });\n      if (settings.invalid_elements) {\n        each$d(explode$2(settings.invalid_elements), item => {\n          if (elements[item]) {\n            delete elements[item];\n          }\n        });\n      }\n      if (!getElementRule('span')) {\n        addValidElements('span[!data-mce-type|*]');\n      }\n      const getValidStyles = constant(validStyles);\n      const getInvalidStyles = constant(invalidStyles);\n      const getValidClasses = constant(validClasses);\n      const getBoolAttrs = constant(boolAttrMap);\n      const getBlockElements = constant(blockElementsMap);\n      const getTextBlockElements = constant(textBlockElementsMap);\n      const getTextInlineElements = constant(textInlineElementsMap);\n      const getVoidElements = constant(Object.seal(voidElementsMap));\n      const getSelfClosingElements = constant(selfClosingElementsMap);\n      const getNonEmptyElements = constant(nonEmptyElementsMap);\n      const getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);\n      const getWhitespaceElements = constant(whitespaceElementsMap);\n      const getSpecialElements = constant(Object.seal(specialElements));\n      const isValidChild = (name, child) => {\n        const parent = children[name.toLowerCase()];\n        return !!(parent && parent[child.toLowerCase()]);\n      };\n      const isValid = (name, attr) => {\n        let attrPatterns, i;\n        const rule = getElementRule(name);\n        if (rule) {\n          if (attr) {\n            if (rule.attributes[attr]) {\n              return true;\n            }\n            attrPatterns = rule.attributePatterns;\n            if (attrPatterns) {\n              i = attrPatterns.length;\n              while (i--) {\n                if (attrPatterns[i].pattern.test(attr)) {\n                  return true;\n                }\n              }\n            }\n          } else {\n            return true;\n          }\n        }\n        return false;\n      };\n      const getCustomElements = constant(customElementsMap);\n      return {\n        type: schemaType,\n        children,\n        elements,\n        getValidStyles,\n        getValidClasses,\n        getBlockElements,\n        getInvalidStyles,\n        getVoidElements,\n        getTextBlockElements,\n        getTextInlineElements,\n        getBoolAttrs,\n        getElementRule,\n        getSelfClosingElements,\n        getNonEmptyElements,\n        getMoveCaretBeforeOnEnterElements,\n        getWhitespaceElements,\n        getSpecialElements,\n        isValidChild,\n        isValid,\n        getCustomElements,\n        addValidElements,\n        setValidElements,\n        addCustomElements,\n        addValidChildren\n      };\n    };\n\n    const Styles = (settings, schema) => {\n      const urlOrStrRegExp = /(?:url(?:(?:\\(\\s*\\\"([^\\\"]+)\\\"\\s*\\))|(?:\\(\\s*\\'([^\\']+)\\'\\s*\\))|(?:\\(\\s*([^)\\s]+)\\s*\\))))|(?:\\'([^\\']+)\\')|(?:\\\"([^\\\"]+)\\\")/gi;\n      const styleRegExp = /\\s*([^:]+):\\s*([^;]+);?/g;\n      const trimRightRegExp = /\\s+$/;\n      let i;\n      const encodingLookup = {};\n      let validStyles;\n      let invalidStyles;\n      const invisibleChar = zeroWidth;\n      settings = settings || {};\n      if (schema) {\n        validStyles = schema.getValidStyles();\n        invalidStyles = schema.getInvalidStyles();\n      }\n      const encodingItems = (`\\\\\" \\\\' \\\\; \\\\: ; : ` + invisibleChar).split(' ');\n      for (i = 0; i < encodingItems.length; i++) {\n        encodingLookup[encodingItems[i]] = invisibleChar + i;\n        encodingLookup[invisibleChar + i] = encodingItems[i];\n      }\n      const self = {\n        parse: css => {\n          const styles = {};\n          let matches, name, value, isEncoded;\n          const urlConverter = settings.url_converter;\n          const urlConverterScope = settings.url_converter_scope || self;\n          const compress = (prefix, suffix, noJoin) => {\n            const top = styles[prefix + '-top' + suffix];\n            if (!top) {\n              return;\n            }\n            const right = styles[prefix + '-right' + suffix];\n            if (!right) {\n              return;\n            }\n            const bottom = styles[prefix + '-bottom' + suffix];\n            if (!bottom) {\n              return;\n            }\n            const left = styles[prefix + '-left' + suffix];\n            if (!left) {\n              return;\n            }\n            const box = [\n              top,\n              right,\n              bottom,\n              left\n            ];\n            i = box.length - 1;\n            while (i--) {\n              if (box[i] !== box[i + 1]) {\n                break;\n              }\n            }\n            if (i > -1 && noJoin) {\n              return;\n            }\n            styles[prefix + suffix] = i === -1 ? box[0] : box.join(' ');\n            delete styles[prefix + '-top' + suffix];\n            delete styles[prefix + '-right' + suffix];\n            delete styles[prefix + '-bottom' + suffix];\n            delete styles[prefix + '-left' + suffix];\n          };\n          const canCompress = key => {\n            let value = styles[key], i;\n            if (!value) {\n              return;\n            }\n            value = value.split(' ');\n            i = value.length;\n            while (i--) {\n              if (value[i] !== value[0]) {\n                return false;\n              }\n            }\n            styles[key] = value[0];\n            return true;\n          };\n          const compress2 = (target, a, b, c) => {\n            if (!canCompress(a)) {\n              return;\n            }\n            if (!canCompress(b)) {\n              return;\n            }\n            if (!canCompress(c)) {\n              return;\n            }\n            styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];\n            delete styles[a];\n            delete styles[b];\n            delete styles[c];\n          };\n          const encode = str => {\n            isEncoded = true;\n            return encodingLookup[str];\n          };\n          const decode = (str, keepSlashes) => {\n            if (isEncoded) {\n              str = str.replace(/\\uFEFF[0-9]/g, str => {\n                return encodingLookup[str];\n              });\n            }\n            if (!keepSlashes) {\n              str = str.replace(/\\\\([\\'\\\";:])/g, '$1');\n            }\n            return str;\n          };\n          const decodeSingleHexSequence = escSeq => {\n            return String.fromCharCode(parseInt(escSeq.slice(1), 16));\n          };\n          const decodeHexSequences = value => {\n            return value.replace(/\\\\[0-9a-f]+/gi, decodeSingleHexSequence);\n          };\n          const processUrl = (match, url, url2, url3, str, str2) => {\n            str = str || str2;\n            if (str) {\n              str = decode(str);\n              return `'` + str.replace(/\\'/g, `\\\\'`) + `'`;\n            }\n            url = decode(url || url2 || url3);\n            if (!settings.allow_script_urls) {\n              const scriptUrl = url.replace(/[\\s\\r\\n]+/g, '');\n              if (/(java|vb)script:/i.test(scriptUrl)) {\n                return '';\n              }\n              if (!settings.allow_svg_data_urls && /^data:image\\/svg/i.test(scriptUrl)) {\n                return '';\n              }\n            }\n            if (urlConverter) {\n              url = urlConverter.call(urlConverterScope, url, 'style');\n            }\n            return `url('` + url.replace(/\\'/g, `\\\\'`) + `')`;\n          };\n          if (css) {\n            css = css.replace(/[\\u0000-\\u001F]/g, '');\n            css = css.replace(/\\\\[\\\"\\';:\\uFEFF]/g, encode).replace(/\\\"[^\\\"]+\\\"|\\'[^\\']+\\'/g, str => {\n              return str.replace(/[;:]/g, encode);\n            });\n            while (matches = styleRegExp.exec(css)) {\n              styleRegExp.lastIndex = matches.index + matches[0].length;\n              name = matches[1].replace(trimRightRegExp, '').toLowerCase();\n              value = matches[2].replace(trimRightRegExp, '');\n              if (name && value) {\n                name = decodeHexSequences(name);\n                value = decodeHexSequences(value);\n                if (name.indexOf(invisibleChar) !== -1 || name.indexOf('\"') !== -1) {\n                  continue;\n                }\n                if (!settings.allow_script_urls && (name === 'behavior' || /expression\\s*\\(|\\/\\*|\\*\\//.test(value))) {\n                  continue;\n                }\n                if (name === 'font-weight' && value === '700') {\n                  value = 'bold';\n                } else if (name === 'color' || name === 'background-color') {\n                  value = value.toLowerCase();\n                }\n                value = value.replace(urlOrStrRegExp, processUrl);\n                styles[name] = isEncoded ? decode(value, true) : value;\n              }\n            }\n            compress('border', '', true);\n            compress('border', '-width');\n            compress('border', '-color');\n            compress('border', '-style');\n            compress('padding', '');\n            compress('margin', '');\n            compress2('border', 'border-width', 'border-style', 'border-color');\n            if (styles.border === 'medium none') {\n              delete styles.border;\n            }\n            if (styles['border-image'] === 'none') {\n              delete styles['border-image'];\n            }\n          }\n          return styles;\n        },\n        serialize: (styles, elementName) => {\n          let css = '';\n          const serializeStyles = name => {\n            let value;\n            const styleList = validStyles[name];\n            if (styleList) {\n              for (let i = 0, l = styleList.length; i < l; i++) {\n                name = styleList[i];\n                value = styles[name];\n                if (value) {\n                  css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\n                }\n              }\n            }\n          };\n          const isValid = (name, elementName) => {\n            let styleMap = invalidStyles['*'];\n            if (styleMap && styleMap[name]) {\n              return false;\n            }\n            styleMap = invalidStyles[elementName];\n            return !(styleMap && styleMap[name]);\n          };\n          if (elementName && validStyles) {\n            serializeStyles('*');\n            serializeStyles(elementName);\n          } else {\n            each$f(styles, (value, name) => {\n              if (value && (!invalidStyles || isValid(name, elementName))) {\n                css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\n              }\n            });\n          }\n          return css;\n        }\n      };\n      return self;\n    };\n\n    const deprecated = {\n      keyLocation: true,\n      layerX: true,\n      layerY: true,\n      returnValue: true,\n      webkitMovementX: true,\n      webkitMovementY: true,\n      keyIdentifier: true,\n      mozPressure: true\n    };\n    const isNativeEvent = event => event instanceof Event || isFunction(event.initEvent);\n    const hasIsDefaultPrevented = event => event.isDefaultPrevented === always || event.isDefaultPrevented === never;\n    const needsNormalizing = event => isNullable(event.preventDefault) || isNativeEvent(event);\n    const clone$3 = (originalEvent, data) => {\n      const event = data !== null && data !== void 0 ? data : {};\n      for (const name in originalEvent) {\n        if (!has$2(deprecated, name)) {\n          event[name] = originalEvent[name];\n        }\n      }\n      if (isNonNullable(event.composedPath)) {\n        event.composedPath = () => originalEvent.composedPath();\n      }\n      return event;\n    };\n    const normalize$3 = (type, originalEvent, fallbackTarget, data) => {\n      var _a;\n      const event = clone$3(originalEvent, data);\n      event.type = type;\n      if (isNullable(event.target)) {\n        event.target = (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;\n      }\n      if (needsNormalizing(originalEvent)) {\n        event.preventDefault = () => {\n          event.defaultPrevented = true;\n          event.isDefaultPrevented = always;\n          if (isFunction(originalEvent.preventDefault)) {\n            originalEvent.preventDefault();\n          }\n        };\n        event.stopPropagation = () => {\n          event.cancelBubble = true;\n          event.isPropagationStopped = always;\n          if (isFunction(originalEvent.stopPropagation)) {\n            originalEvent.stopPropagation();\n          }\n        };\n        event.stopImmediatePropagation = () => {\n          event.isImmediatePropagationStopped = always;\n          event.stopPropagation();\n        };\n        if (!hasIsDefaultPrevented(event)) {\n          event.isDefaultPrevented = event.defaultPrevented === true ? always : never;\n          event.isPropagationStopped = event.cancelBubble === true ? always : never;\n          event.isImmediatePropagationStopped = never;\n        }\n      }\n      return event;\n    };\n\n    const eventExpandoPrefix = 'mce-data-';\n    const mouseEventRe = /^(?:mouse|contextmenu)|click/;\n    const addEvent = (target, name, callback, capture) => {\n      if (target.addEventListener) {\n        target.addEventListener(name, callback, capture || false);\n      } else if (target.attachEvent) {\n        target.attachEvent('on' + name, callback);\n      }\n    };\n    const removeEvent = (target, name, callback, capture) => {\n      if (target.removeEventListener) {\n        target.removeEventListener(name, callback, capture || false);\n      } else if (target.detachEvent) {\n        target.detachEvent('on' + name, callback);\n      }\n    };\n    const isMouseEvent = event => isNonNullable(event) && mouseEventRe.test(event.type);\n    const fix = (originalEvent, data) => {\n      const event = normalize$3(originalEvent.type, originalEvent, document, data);\n      if (isMouseEvent(originalEvent) && isUndefined(originalEvent.pageX) && !isUndefined(originalEvent.clientX)) {\n        const eventDoc = event.target.ownerDocument || document;\n        const doc = eventDoc.documentElement;\n        const body = eventDoc.body;\n        const mouseEvent = event;\n        mouseEvent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n        mouseEvent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n      }\n      return event;\n    };\n    const bindOnReady = (win, callback, eventUtils) => {\n      const doc = win.document, event = { type: 'ready' };\n      if (eventUtils.domLoaded) {\n        callback(event);\n        return;\n      }\n      const isDocReady = () => {\n        return doc.readyState === 'complete' || doc.readyState === 'interactive' && doc.body;\n      };\n      const readyHandler = () => {\n        removeEvent(win, 'DOMContentLoaded', readyHandler);\n        removeEvent(win, 'load', readyHandler);\n        if (!eventUtils.domLoaded) {\n          eventUtils.domLoaded = true;\n          callback(event);\n        }\n        win = null;\n      };\n      if (isDocReady()) {\n        readyHandler();\n      } else {\n        addEvent(win, 'DOMContentLoaded', readyHandler);\n      }\n      if (!eventUtils.domLoaded) {\n        addEvent(win, 'load', readyHandler);\n      }\n    };\n    class EventUtils {\n      constructor() {\n        this.domLoaded = false;\n        this.events = {};\n        this.count = 1;\n        this.expando = eventExpandoPrefix + (+new Date()).toString(32);\n        this.hasMouseEnterLeave = 'onmouseenter' in document.documentElement;\n        this.hasFocusIn = 'onfocusin' in document.documentElement;\n        this.count = 1;\n      }\n      bind(target, names, callback, scope) {\n        const self = this;\n        let id, callbackList, i, name, fakeName, nativeHandler, capture;\n        const win = window;\n        const defaultNativeHandler = evt => {\n          self.executeHandlers(fix(evt || win.event), id);\n        };\n        if (!target || target.nodeType === 3 || target.nodeType === 8) {\n          return;\n        }\n        if (!target[self.expando]) {\n          id = self.count++;\n          target[self.expando] = id;\n          self.events[id] = {};\n        } else {\n          id = target[self.expando];\n        }\n        scope = scope || target;\n        const namesList = names.split(' ');\n        i = namesList.length;\n        while (i--) {\n          name = namesList[i];\n          nativeHandler = defaultNativeHandler;\n          fakeName = capture = false;\n          if (name === 'DOMContentLoaded') {\n            name = 'ready';\n          }\n          if (self.domLoaded && name === 'ready' && target.readyState === 'complete') {\n            callback.call(scope, fix({ type: name }));\n            continue;\n          }\n          if (!self.hasMouseEnterLeave) {\n            fakeName = self.mouseEnterLeave[name];\n            if (fakeName) {\n              nativeHandler = evt => {\n                const current = evt.currentTarget;\n                let related = evt.relatedTarget;\n                if (related && current.contains) {\n                  related = current.contains(related);\n                } else {\n                  while (related && related !== current) {\n                    related = related.parentNode;\n                  }\n                }\n                if (!related) {\n                  evt = fix(evt || win.event);\n                  evt.type = evt.type === 'mouseout' ? 'mouseleave' : 'mouseenter';\n                  evt.target = current;\n                  self.executeHandlers(evt, id);\n                }\n              };\n            }\n          }\n          if (!self.hasFocusIn && (name === 'focusin' || name === 'focusout')) {\n            capture = true;\n            fakeName = name === 'focusin' ? 'focus' : 'blur';\n            nativeHandler = evt => {\n              evt = fix(evt || win.event);\n              evt.type = evt.type === 'focus' ? 'focusin' : 'focusout';\n              self.executeHandlers(evt, id);\n            };\n          }\n          callbackList = self.events[id][name];\n          if (!callbackList) {\n            self.events[id][name] = callbackList = [{\n                func: callback,\n                scope\n              }];\n            callbackList.fakeName = fakeName;\n            callbackList.capture = capture;\n            callbackList.nativeHandler = nativeHandler;\n            if (name === 'ready') {\n              bindOnReady(target, nativeHandler, self);\n            } else {\n              addEvent(target, fakeName || name, nativeHandler, capture);\n            }\n          } else {\n            if (name === 'ready' && self.domLoaded) {\n              callback(fix({ type: name }));\n            } else {\n              callbackList.push({\n                func: callback,\n                scope\n              });\n            }\n          }\n        }\n        target = callbackList = null;\n        return callback;\n      }\n      unbind(target, names, callback) {\n        let callbackList, i, ci, name, eventMap;\n        if (!target || target.nodeType === 3 || target.nodeType === 8) {\n          return this;\n        }\n        const id = target[this.expando];\n        if (id) {\n          eventMap = this.events[id];\n          if (names) {\n            const namesList = names.split(' ');\n            i = namesList.length;\n            while (i--) {\n              name = namesList[i];\n              callbackList = eventMap[name];\n              if (callbackList) {\n                if (callback) {\n                  ci = callbackList.length;\n                  while (ci--) {\n                    if (callbackList[ci].func === callback) {\n                      const nativeHandler = callbackList.nativeHandler;\n                      const fakeName = callbackList.fakeName, capture = callbackList.capture;\n                      callbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));\n                      callbackList.nativeHandler = nativeHandler;\n                      callbackList.fakeName = fakeName;\n                      callbackList.capture = capture;\n                      eventMap[name] = callbackList;\n                    }\n                  }\n                }\n                if (!callback || callbackList.length === 0) {\n                  delete eventMap[name];\n                  removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n                }\n              }\n            }\n          } else {\n            each$f(eventMap, (callbackList, name) => {\n              removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n            });\n            eventMap = {};\n          }\n          for (name in eventMap) {\n            if (has$2(eventMap, name)) {\n              return this;\n            }\n          }\n          delete this.events[id];\n          try {\n            delete target[this.expando];\n          } catch (ex) {\n            target[this.expando] = null;\n          }\n        }\n        return this;\n      }\n      fire(target, name, args) {\n        return this.dispatch(target, name, args);\n      }\n      dispatch(target, name, args) {\n        let id;\n        if (!target || target.nodeType === 3 || target.nodeType === 8) {\n          return this;\n        }\n        const event = fix({\n          type: name,\n          target\n        }, args);\n        do {\n          id = target[this.expando];\n          if (id) {\n            this.executeHandlers(event, id);\n          }\n          target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;\n        } while (target && !event.isPropagationStopped());\n        return this;\n      }\n      clean(target) {\n        let i, children;\n        if (!target || target.nodeType === 3 || target.nodeType === 8) {\n          return this;\n        }\n        if (target[this.expando]) {\n          this.unbind(target);\n        }\n        if (!target.getElementsByTagName) {\n          target = target.document;\n        }\n        if (target && target.getElementsByTagName) {\n          this.unbind(target);\n          children = target.getElementsByTagName('*');\n          i = children.length;\n          while (i--) {\n            target = children[i];\n            if (target[this.expando]) {\n              this.unbind(target);\n            }\n          }\n        }\n        return this;\n      }\n      destroy() {\n        this.events = {};\n      }\n      cancel(e) {\n        if (e) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n        }\n        return false;\n      }\n      executeHandlers(evt, id) {\n        const container = this.events[id];\n        const callbackList = container && container[evt.type];\n        if (callbackList) {\n          for (let i = 0, l = callbackList.length; i < l; i++) {\n            const callback = callbackList[i];\n            if (callback && callback.func.call(callback.scope, evt) === false) {\n              evt.preventDefault();\n            }\n            if (evt.isImmediatePropagationStopped()) {\n              return;\n            }\n          }\n        }\n      }\n    }\n    EventUtils.Event = new EventUtils();\n\n    const each$c = Tools.each;\n    const grep = Tools.grep;\n    const internalStyleName = 'data-mce-style';\n    const legacySetAttribute = (elm, name, value) => {\n      if (isNullable(value) || value === '') {\n        remove$a(elm, name);\n      } else {\n        set$2(elm, name, value);\n      }\n    };\n    const setupAttrHooks = (styles, settings, getContext) => {\n      const keepValues = settings.keep_values;\n      const keepUrlHook = {\n        set: (elm, value, name) => {\n          const sugarElm = SugarElement.fromDom(elm);\n          if (isFunction(settings.url_converter) && isNonNullable(value)) {\n            value = settings.url_converter.call(settings.url_converter_scope || getContext(), value, name, elm[0]);\n          }\n          const internalName = 'data-mce-' + name;\n          legacySetAttribute(sugarElm, internalName, value);\n          legacySetAttribute(sugarElm, name, value);\n        },\n        get: (elm, name) => {\n          const sugarElm = SugarElement.fromDom(elm);\n          return get$9(sugarElm, 'data-mce-' + name) || get$9(sugarElm, name);\n        }\n      };\n      const attrHooks = {\n        style: {\n          set: (elm, value) => {\n            const sugarElm = SugarElement.fromDom(elm);\n            if (isObject(value)) {\n              setAll(sugarElm, value);\n              return;\n            }\n            if (keepValues) {\n              legacySetAttribute(sugarElm, internalStyleName, value);\n            }\n            remove$a(sugarElm, 'style');\n            if (isString(value)) {\n              setAll(sugarElm, styles.parse(value));\n            }\n          },\n          get: elm => {\n            const sugarElm = SugarElement.fromDom(elm);\n            const value = get$9(sugarElm, internalStyleName) || get$9(sugarElm, 'style');\n            return styles.serialize(styles.parse(value), name(sugarElm));\n          }\n        }\n      };\n      if (keepValues) {\n        attrHooks.href = attrHooks.src = keepUrlHook;\n      }\n      return attrHooks;\n    };\n    const updateInternalStyleAttr = (styles, elm) => {\n      const rawValue = get$9(elm, 'style');\n      const value = styles.serialize(styles.parse(rawValue), name(elm));\n      legacySetAttribute(elm, internalStyleName, value);\n    };\n    const findNodeIndex = (node, normalized) => {\n      let idx = 0, lastNodeType, nodeType;\n      if (node) {\n        for (lastNodeType = node.nodeType, node = node.previousSibling; node; node = node.previousSibling) {\n          nodeType = node.nodeType;\n          if (normalized && nodeType === 3) {\n            if (nodeType === lastNodeType || !node.nodeValue.length) {\n              continue;\n            }\n          }\n          idx++;\n          lastNodeType = nodeType;\n        }\n      }\n      return idx;\n    };\n    const numericalCssMap = Tools.makeMap('fill-opacity font-weight line-height opacity orphans widows z-index zoom', ' ');\n    const camelCaseToHyphens = name => name.replace(/[A-Z]/g, v => '-' + v.toLowerCase());\n    const DOMUtils = (doc, settings = {}) => {\n      const addedStyles = {};\n      const win = window;\n      const files = {};\n      let counter = 0;\n      const stdMode = true;\n      const boxModel = true;\n      const styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {\n        contentCssCors: settings.contentCssCors,\n        referrerPolicy: settings.referrerPolicy\n      });\n      const boundEvents = [];\n      const schema = settings.schema ? settings.schema : Schema({});\n      const styles = Styles({\n        url_converter: settings.url_converter,\n        url_converter_scope: settings.url_converter_scope\n      }, settings.schema);\n      const events = settings.ownEvents ? new EventUtils() : EventUtils.Event;\n      const blockElementsMap = schema.getBlockElements();\n      const isBlock = node => {\n        if (isString(node)) {\n          return has$2(blockElementsMap, node);\n        } else {\n          return isElement$6(node) && has$2(blockElementsMap, node.nodeName);\n        }\n      };\n      const get = elm => elm && doc && isString(elm) ? doc.getElementById(elm) : elm;\n      const _get = elm => {\n        const value = get(elm);\n        return isNonNullable(value) ? SugarElement.fromDom(value) : null;\n      };\n      const getAttrib = (elm, name, defaultVal) => {\n        let value;\n        const $elm = _get(elm);\n        if (isNonNullable($elm) && isElement$7($elm)) {\n          const hook = attrHooks[name];\n          if (hook && hook.get) {\n            value = hook.get($elm.dom, name);\n          } else {\n            value = get$9($elm, name);\n          }\n        }\n        return isNonNullable(value) ? value : defaultVal !== null && defaultVal !== void 0 ? defaultVal : '';\n      };\n      const getAttribs = elm => {\n        const node = get(elm);\n        return isNullable(node) ? [] : node.attributes;\n      };\n      const setAttrib = (elm, name, value) => {\n        run(elm, e => {\n          if (isElement$6(e)) {\n            const $elm = SugarElement.fromDom(e);\n            if (value === '') {\n              value = null;\n            }\n            const originalValue = get$9($elm, name);\n            const hook = attrHooks[name];\n            if (hook && hook.set) {\n              hook.set($elm.dom, value, name);\n            } else {\n              legacySetAttribute($elm, name, value);\n            }\n            if (originalValue !== value && settings.onSetAttrib) {\n              settings.onSetAttrib({\n                attrElm: $elm,\n                attrName: name,\n                attrValue: value\n              });\n            }\n          }\n        });\n      };\n      const clone = (node, deep) => {\n        return node.cloneNode(deep);\n      };\n      const getRoot = () => settings.root_element || doc.body;\n      const getViewPort = argWin => {\n        const vp = getBounds(argWin);\n        return {\n          x: vp.x,\n          y: vp.y,\n          w: vp.width,\n          h: vp.height\n        };\n      };\n      const getPos$1 = (elm, rootElm) => getPos(doc.body, get(elm), rootElm);\n      const setStyle = (elm, name, value) => {\n        const convertStyleToString = (cssValue, cssName) => {\n          if (isString(cssValue)) {\n            return cssValue;\n          } else if (isNumber(cssValue)) {\n            return has$2(numericalCssMap, cssName) ? cssValue + '' : cssValue + 'px';\n          } else {\n            return map$2(cssValue, convertStyleToString);\n          }\n        };\n        const applyStyle = ($elm, cssName, cssValue) => {\n          const normalizedName = camelCaseToHyphens(cssName);\n          if (isNullable(cssValue) || cssValue === '') {\n            remove$6($elm, normalizedName);\n          } else {\n            set$1($elm, normalizedName, convertStyleToString(cssValue, normalizedName));\n          }\n        };\n        run(elm, e => {\n          const $elm = SugarElement.fromDom(e);\n          if (isString(name)) {\n            applyStyle($elm, name, value);\n          } else {\n            each$f(name, (v, n) => {\n              applyStyle($elm, n, v);\n            });\n          }\n          if (settings.update_styles) {\n            updateInternalStyleAttr(styles, $elm);\n          }\n        });\n      };\n      const setStyles = (elm, stylesArg) => {\n        setStyle(elm, stylesArg);\n      };\n      const getStyle = (elm, name, computed) => {\n        const $elm = get(elm);\n        if (isNullable($elm) || !isElement$6($elm)) {\n          return undefined;\n        }\n        if (computed) {\n          return get$7(SugarElement.fromDom($elm), camelCaseToHyphens(name));\n        } else {\n          name = name.replace(/-(\\D)/g, (a, b) => b.toUpperCase());\n          if (name === 'float') {\n            name = 'cssFloat';\n          }\n          return $elm.style ? $elm.style[name] : undefined;\n        }\n      };\n      const getSize = elm => {\n        let w, h;\n        const $elm = get(elm);\n        w = getStyle($elm, 'width');\n        h = getStyle($elm, 'height');\n        if (w.indexOf('px') === -1) {\n          w = 0;\n        }\n        if (h.indexOf('px') === -1) {\n          h = 0;\n        }\n        return {\n          w: parseInt(w, 10) || $elm.offsetWidth || $elm.clientWidth,\n          h: parseInt(h, 10) || $elm.offsetHeight || $elm.clientHeight\n        };\n      };\n      const getRect = elm => {\n        const $elm = get(elm);\n        const pos = getPos$1($elm);\n        const size = getSize($elm);\n        return {\n          x: pos.x,\n          y: pos.y,\n          w: size.w,\n          h: size.h\n        };\n      };\n      const is = (elm, selector) => {\n        if (!elm) {\n          return false;\n        }\n        const elms = isArray$1(elm) ? elm : [elm];\n        return exists(elms, e => {\n          return is$1(SugarElement.fromDom(e), selector);\n        });\n      };\n      const getParents = (elm, selector, root, collect) => {\n        const result = [];\n        let selectorVal;\n        let node = get(elm);\n        collect = collect === undefined;\n        root = root || (getRoot().nodeName !== 'BODY' ? getRoot().parentNode : null);\n        if (isString(selector)) {\n          selectorVal = selector;\n          if (selector === '*') {\n            selector = isElement$6;\n          } else {\n            selector = node => is(node, selectorVal);\n          }\n        }\n        while (node) {\n          if (node === root || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment(node)) {\n            break;\n          }\n          if (!selector || selector(node)) {\n            if (collect) {\n              result.push(node);\n            } else {\n              return [node];\n            }\n          }\n          node = node.parentNode;\n        }\n        return collect ? result : null;\n      };\n      const getParent = (node, selector, root) => {\n        const parents = getParents(node, selector, root, false);\n        return parents && parents.length > 0 ? parents[0] : null;\n      };\n      const _findSib = (node, selector, name) => {\n        let func = selector;\n        if (node) {\n          if (isString(selector)) {\n            func = node => {\n              return is(node, selector);\n            };\n          }\n          for (node = node[name]; node; node = node[name]) {\n            if (isFunction(func) && func(node)) {\n              return node;\n            }\n          }\n        }\n        return null;\n      };\n      const getNext = (node, selector) => _findSib(node, selector, 'nextSibling');\n      const getPrev = (node, selector) => _findSib(node, selector, 'previousSibling');\n      const select = (selector, scope) => {\n        var _a, _b;\n        const elm = (_b = (_a = get(scope)) !== null && _a !== void 0 ? _a : settings.root_element) !== null && _b !== void 0 ? _b : doc;\n        return from(elm.querySelectorAll(selector));\n      };\n      const run = function (elm, func, scope) {\n        const context = scope !== null && scope !== void 0 ? scope : this;\n        const node = isString(elm) ? get(elm) : elm;\n        if (!node) {\n          return false;\n        }\n        if (isArray$1(node) && (node.length || node.length === 0)) {\n          const result = [];\n          each$c(node, (elm, i) => {\n            if (elm) {\n              result.push(func.call(context, isString(elm) ? get(elm) : elm, i));\n            }\n          });\n          return result;\n        } else {\n          return func.call(context, node);\n        }\n      };\n      const setAttribs = (elm, attrs) => {\n        run(elm, $elm => {\n          each$f(attrs, (value, name) => {\n            setAttrib($elm, name, value);\n          });\n        });\n      };\n      const setHTML = (elm, html) => {\n        run(elm, e => {\n          const $elm = SugarElement.fromDom(e);\n          set($elm, html);\n        });\n      };\n      const add = (parentElm, name, attrs, html, create) => run(parentElm, parentElm => {\n        const newElm = isString(name) ? doc.createElement(name) : name;\n        if (isNonNullable(attrs)) {\n          setAttribs(newElm, attrs);\n        }\n        if (html) {\n          if (!isString(html) && html.nodeType) {\n            newElm.appendChild(html);\n          } else if (isString(html)) {\n            setHTML(newElm, html);\n          }\n        }\n        return !create ? parentElm.appendChild(newElm) : newElm;\n      });\n      const create = (name, attrs, html) => add(doc.createElement(name), name, attrs, html, true);\n      const decode = Entities.decode;\n      const encode = Entities.encodeAllRaw;\n      const createHTML = (name, attrs, html = '') => {\n        let outHtml = '', key;\n        outHtml += '<' + name;\n        for (key in attrs) {\n          if (hasNonNullableKey(attrs, key)) {\n            outHtml += ' ' + key + '=\"' + encode(attrs[key]) + '\"';\n          }\n        }\n        if (isEmpty$3(html) && has$2(schema.getVoidElements(), name)) {\n          return outHtml + ' />';\n        } else {\n          return outHtml + '>' + html + '</' + name + '>';\n        }\n      };\n      const createFragment = html => {\n        let node;\n        const container = doc.createElement('div');\n        const frag = doc.createDocumentFragment();\n        frag.appendChild(container);\n        if (html) {\n          container.innerHTML = html;\n        }\n        while (node = container.firstChild) {\n          frag.appendChild(node);\n        }\n        frag.removeChild(container);\n        return frag;\n      };\n      const remove = (node, keepChildren) => {\n        return run(node, n => {\n          const $node = SugarElement.fromDom(n);\n          if (keepChildren) {\n            each$g(children($node), child => {\n              if (isText$9(child) && child.dom.length === 0) {\n                remove$5(child);\n              } else {\n                before$3($node, child);\n              }\n            });\n          }\n          remove$5($node);\n          return $node.dom;\n        });\n      };\n      const removeAllAttribs = e => run(e, e => {\n        const attrs = e.attributes;\n        for (let i = attrs.length - 1; i >= 0; i--) {\n          e.removeAttributeNode(attrs.item(i));\n        }\n      });\n      const parseStyle = cssText => styles.parse(cssText);\n      const serializeStyle = (stylesArg, name) => styles.serialize(stylesArg, name);\n      const addStyle = cssText => {\n        let head, styleElm;\n        if (self !== DOMUtils.DOM && doc === document) {\n          if (addedStyles[cssText]) {\n            return;\n          }\n          addedStyles[cssText] = true;\n        }\n        styleElm = doc.getElementById('mceDefaultStyles');\n        if (!styleElm) {\n          styleElm = doc.createElement('style');\n          styleElm.id = 'mceDefaultStyles';\n          styleElm.type = 'text/css';\n          head = doc.getElementsByTagName('head')[0];\n          if (head.firstChild) {\n            head.insertBefore(styleElm, head.firstChild);\n          } else {\n            head.appendChild(styleElm);\n          }\n        }\n        if (styleElm.styleSheet) {\n          styleElm.styleSheet.cssText += cssText;\n        } else {\n          styleElm.appendChild(doc.createTextNode(cssText));\n        }\n      };\n      const loadCSS = urls => {\n        if (!urls) {\n          urls = '';\n        }\n        each$g(urls.split(','), url => {\n          files[url] = true;\n          styleSheetLoader.load(url).catch(noop);\n        });\n      };\n      const toggleClass = (elm, cls, state) => {\n        run(elm, e => {\n          if (isElement$6(e)) {\n            const $elm = SugarElement.fromDom(e);\n            const classes = cls.split(' ');\n            each$g(classes, c => {\n              if (isNonNullable(state)) {\n                const fn = state ? add$2 : remove$7;\n                fn($elm, c);\n              } else {\n                toggle$1($elm, c);\n              }\n            });\n          }\n        });\n      };\n      const addClass = (elm, cls) => {\n        toggleClass(elm, cls, true);\n      };\n      const removeClass = (elm, cls) => {\n        toggleClass(elm, cls, false);\n      };\n      const hasClass = (elm, cls) => {\n        const $elm = _get(elm);\n        const classes = cls.split(' ');\n        return forall(classes, c => has($elm, c));\n      };\n      const show = elm => {\n        run(elm, e => remove$6(SugarElement.fromDom(e), 'display'));\n      };\n      const hide = elm => {\n        run(elm, e => set$1(SugarElement.fromDom(e), 'display', 'none'));\n      };\n      const isHidden = elm => {\n        const $elm = _get(elm);\n        return is$2(getRaw$1($elm, 'display'), 'none');\n      };\n      const uniqueId = prefix => (!prefix ? 'mce_' : prefix) + counter++;\n      const getOuterHTML = elm => {\n        const $elm = _get(elm);\n        return isElement$6($elm.dom) ? $elm.dom.outerHTML : getOuter($elm);\n      };\n      const setOuterHTML = (elm, html) => {\n        run(elm, $elm => {\n          if (isElement$6($elm)) {\n            $elm.outerHTML = html;\n          }\n        });\n      };\n      const insertAfter = (node, reference) => {\n        const referenceNode = get(reference);\n        return run(node, node => {\n          const parent = referenceNode.parentNode;\n          const nextSibling = referenceNode.nextSibling;\n          if (nextSibling) {\n            parent.insertBefore(node, nextSibling);\n          } else {\n            parent.appendChild(node);\n          }\n          return node;\n        });\n      };\n      const replace = (newElm, oldElm, keepChildren) => run(oldElm, oldElm => {\n        if (isArray$1(oldElm)) {\n          newElm = newElm.cloneNode(true);\n        }\n        if (keepChildren) {\n          each$c(grep(oldElm.childNodes), node => {\n            newElm.appendChild(node);\n          });\n        }\n        return oldElm.parentNode.replaceChild(newElm, oldElm);\n      });\n      const rename = (elm, name) => {\n        let newElm;\n        if (elm.nodeName !== name.toUpperCase()) {\n          newElm = create(name);\n          each$c(getAttribs(elm), attrNode => {\n            setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));\n          });\n          replace(newElm, elm, true);\n        }\n        return newElm || elm;\n      };\n      const findCommonAncestor = (a, b) => {\n        let ps = a, pe;\n        while (ps) {\n          pe = b;\n          while (pe && ps !== pe) {\n            pe = pe.parentNode;\n          }\n          if (ps === pe) {\n            break;\n          }\n          ps = ps.parentNode;\n        }\n        if (!ps && a.ownerDocument) {\n          return a.ownerDocument.documentElement;\n        }\n        return ps;\n      };\n      const isNonEmptyElement = node => {\n        if (isElement$6(node)) {\n          const isNamedAnchor = node.nodeName.toLowerCase() === 'a' && !getAttrib(node, 'href') && getAttrib(node, 'id');\n          if (getAttrib(node, 'name') || getAttrib(node, 'data-mce-bookmark') || isNamedAnchor) {\n            return true;\n          }\n        }\n        return false;\n      };\n      const isEmpty = (node, elements) => {\n        let type, name, brCount = 0;\n        if (isNonEmptyElement(node)) {\n          return false;\n        }\n        node = node.firstChild;\n        if (node) {\n          const walker = new DomTreeWalker(node, node.parentNode);\n          const whitespace = schema ? schema.getWhitespaceElements() : {};\n          elements = elements || (schema ? schema.getNonEmptyElements() : null);\n          do {\n            type = node.nodeType;\n            if (isElement$6(node)) {\n              const bogusVal = node.getAttribute('data-mce-bogus');\n              if (bogusVal) {\n                node = walker.next(bogusVal === 'all');\n                continue;\n              }\n              name = node.nodeName.toLowerCase();\n              if (elements && elements[name]) {\n                if (name === 'br') {\n                  brCount++;\n                  node = walker.next();\n                  continue;\n                }\n                return false;\n              }\n              if (isNonEmptyElement(node)) {\n                return false;\n              }\n            }\n            if (type === 8) {\n              return false;\n            }\n            if (type === 3 && !isWhitespaceText(node.nodeValue)) {\n              return false;\n            }\n            if (type === 3 && node.parentNode && whitespace[node.parentNode.nodeName] && isWhitespaceText(node.nodeValue)) {\n              return false;\n            }\n            node = walker.next();\n          } while (node);\n        }\n        return brCount <= 1;\n      };\n      const createRng = () => doc.createRange();\n      const split = (parentElm, splitElm, replacementElm) => {\n        let range = createRng();\n        let beforeFragment;\n        let afterFragment;\n        let parentNode;\n        if (parentElm && splitElm) {\n          range.setStart(parentElm.parentNode, findNodeIndex(parentElm));\n          range.setEnd(splitElm.parentNode, findNodeIndex(splitElm));\n          beforeFragment = range.extractContents();\n          range = createRng();\n          range.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);\n          range.setEnd(parentElm.parentNode, findNodeIndex(parentElm) + 1);\n          afterFragment = range.extractContents();\n          parentNode = parentElm.parentNode;\n          parentNode.insertBefore(trimNode(self, beforeFragment), parentElm);\n          if (replacementElm) {\n            parentNode.insertBefore(replacementElm, parentElm);\n          } else {\n            parentNode.insertBefore(splitElm, parentElm);\n          }\n          parentNode.insertBefore(trimNode(self, afterFragment), parentElm);\n          remove(parentElm);\n          return replacementElm || splitElm;\n        }\n      };\n      const bind = (target, name, func, scope) => {\n        if (isArray$1(target)) {\n          let i = target.length;\n          const rv = [];\n          while (i--) {\n            rv[i] = bind(target[i], name, func, scope);\n          }\n          return rv;\n        } else {\n          if (settings.collect && (target === doc || target === win)) {\n            boundEvents.push([\n              target,\n              name,\n              func,\n              scope\n            ]);\n          }\n          return events.bind(target, name, func, scope || self);\n        }\n      };\n      const unbind = (target, name, func) => {\n        if (isArray$1(target)) {\n          let i = target.length;\n          const rv = [];\n          while (i--) {\n            rv[i] = unbind(target[i], name, func);\n          }\n          return rv;\n        } else {\n          if (boundEvents.length > 0 && (target === doc || target === win)) {\n            let i = boundEvents.length;\n            while (i--) {\n              const item = boundEvents[i];\n              if (target === item[0] && (!name || name === item[1]) && (!func || func === item[2])) {\n                events.unbind(item[0], item[1], item[2]);\n              }\n            }\n          }\n          return events.unbind(target, name, func);\n        }\n      };\n      const dispatch = (target, name, evt) => events.dispatch(target, name, evt);\n      const fire = (target, name, evt) => events.dispatch(target, name, evt);\n      const getContentEditable = node => {\n        if (node && isElement$6(node)) {\n          const contentEditable = node.getAttribute('data-mce-contenteditable');\n          if (contentEditable && contentEditable !== 'inherit') {\n            return contentEditable;\n          }\n          return node.contentEditable !== 'inherit' ? node.contentEditable : null;\n        } else {\n          return null;\n        }\n      };\n      const getContentEditableParent = node => {\n        const root = getRoot();\n        let state = null;\n        for (; node && node !== root; node = node.parentNode) {\n          state = getContentEditable(node);\n          if (state !== null) {\n            break;\n          }\n        }\n        return state;\n      };\n      const destroy = () => {\n        if (boundEvents.length > 0) {\n          let i = boundEvents.length;\n          while (i--) {\n            const item = boundEvents[i];\n            events.unbind(item[0], item[1], item[2]);\n          }\n        }\n        each$f(files, (_, url) => {\n          styleSheetLoader.unload(url);\n          delete files[url];\n        });\n      };\n      const isChildOf = (node, parent) => {\n        return node === parent || parent.contains(node);\n      };\n      const dumpRng = r => 'startContainer: ' + r.startContainer.nodeName + ', startOffset: ' + r.startOffset + ', endContainer: ' + r.endContainer.nodeName + ', endOffset: ' + r.endOffset;\n      const self = {\n        doc,\n        settings,\n        win,\n        files,\n        stdMode,\n        boxModel,\n        styleSheetLoader,\n        boundEvents,\n        styles,\n        schema,\n        events,\n        isBlock,\n        root: null,\n        clone,\n        getRoot,\n        getViewPort,\n        getRect,\n        getSize,\n        getParent,\n        getParents,\n        get,\n        getNext,\n        getPrev,\n        select,\n        is,\n        add,\n        create,\n        createHTML,\n        createFragment,\n        remove,\n        setStyle,\n        getStyle,\n        setStyles,\n        removeAllAttribs,\n        setAttrib,\n        setAttribs,\n        getAttrib,\n        getPos: getPos$1,\n        parseStyle,\n        serializeStyle,\n        addStyle,\n        loadCSS,\n        addClass,\n        removeClass,\n        hasClass,\n        toggleClass,\n        show,\n        hide,\n        isHidden,\n        uniqueId,\n        setHTML,\n        getOuterHTML,\n        setOuterHTML,\n        decode,\n        encode,\n        insertAfter,\n        replace,\n        rename,\n        findCommonAncestor,\n        run,\n        getAttribs,\n        isEmpty,\n        createRng,\n        nodeIndex: findNodeIndex,\n        split,\n        bind: bind,\n        unbind: unbind,\n        fire,\n        dispatch,\n        getContentEditable,\n        getContentEditableParent,\n        destroy,\n        isChildOf,\n        dumpRng\n      };\n      const attrHooks = setupAttrHooks(styles, settings, constant(self));\n      return self;\n    };\n    DOMUtils.DOM = DOMUtils(document);\n    DOMUtils.nodeIndex = findNodeIndex;\n\n    const DOM$b = DOMUtils.DOM;\n    const QUEUED = 0;\n    const LOADING = 1;\n    const LOADED = 2;\n    const FAILED = 3;\n    class ScriptLoader {\n      constructor(settings = {}) {\n        this.states = {};\n        this.queue = [];\n        this.scriptLoadedCallbacks = {};\n        this.queueLoadedCallbacks = [];\n        this.loading = false;\n        this.settings = settings;\n      }\n      _setReferrerPolicy(referrerPolicy) {\n        this.settings.referrerPolicy = referrerPolicy;\n      }\n      loadScript(url) {\n        return new Promise((resolve, reject) => {\n          const dom = DOM$b;\n          let elm;\n          const cleanup = () => {\n            dom.remove(id);\n            if (elm) {\n              elm.onerror = elm.onload = elm = null;\n            }\n          };\n          const done = () => {\n            cleanup();\n            resolve();\n          };\n          const error = () => {\n            cleanup();\n            reject('Failed to load script: ' + url);\n          };\n          const id = dom.uniqueId();\n          elm = document.createElement('script');\n          elm.id = id;\n          elm.type = 'text/javascript';\n          elm.src = Tools._addCacheSuffix(url);\n          if (this.settings.referrerPolicy) {\n            dom.setAttrib(elm, 'referrerpolicy', this.settings.referrerPolicy);\n          }\n          elm.onload = done;\n          elm.onerror = error;\n          (document.getElementsByTagName('head')[0] || document.body).appendChild(elm);\n        });\n      }\n      isDone(url) {\n        return this.states[url] === LOADED;\n      }\n      markDone(url) {\n        this.states[url] = LOADED;\n      }\n      add(url) {\n        const self = this;\n        self.queue.push(url);\n        const state = self.states[url];\n        if (state === undefined) {\n          self.states[url] = QUEUED;\n        }\n        return new Promise((resolve, reject) => {\n          if (!self.scriptLoadedCallbacks[url]) {\n            self.scriptLoadedCallbacks[url] = [];\n          }\n          self.scriptLoadedCallbacks[url].push({\n            resolve,\n            reject\n          });\n        });\n      }\n      load(url) {\n        return this.add(url);\n      }\n      remove(url) {\n        delete this.states[url];\n        delete this.scriptLoadedCallbacks[url];\n      }\n      loadQueue() {\n        const queue = this.queue;\n        this.queue = [];\n        return this.loadScripts(queue);\n      }\n      loadScripts(scripts) {\n        const self = this;\n        const execCallbacks = (name, url) => {\n          get$a(self.scriptLoadedCallbacks, url).each(callbacks => {\n            each$g(callbacks, callback => callback[name](url));\n          });\n          delete self.scriptLoadedCallbacks[url];\n        };\n        const processResults = results => {\n          const failures = filter$6(results, result => result.status === 'rejected');\n          if (failures.length > 0) {\n            return Promise.reject(bind$3(failures, ({reason}) => isArray$1(reason) ? reason : [reason]));\n          } else {\n            return Promise.resolve();\n          }\n        };\n        const load = urls => Promise.allSettled(map$3(urls, url => {\n          if (self.states[url] === LOADED) {\n            execCallbacks('resolve', url);\n            return Promise.resolve();\n          } else if (self.states[url] === FAILED) {\n            execCallbacks('reject', url);\n            return Promise.reject(url);\n          } else {\n            self.states[url] = LOADING;\n            return self.loadScript(url).then(() => {\n              self.states[url] = LOADED;\n              execCallbacks('resolve', url);\n              const queue = self.queue;\n              if (queue.length > 0) {\n                self.queue = [];\n                return load(queue).then(processResults);\n              }\n            }, () => {\n              self.states[url] = FAILED;\n              execCallbacks('reject', url);\n              return Promise.reject(url);\n            });\n          }\n        }));\n        const processQueue = urls => {\n          self.loading = true;\n          return load(urls).then(results => {\n            self.loading = false;\n            const nextQueuedItem = self.queueLoadedCallbacks.shift();\n            Optional.from(nextQueuedItem).each(call);\n            return processResults(results);\n          });\n        };\n        const uniqueScripts = stringArray(scripts);\n        if (self.loading) {\n          return new Promise((resolve, reject) => {\n            self.queueLoadedCallbacks.push(() => processQueue(uniqueScripts).then(resolve, reject));\n          });\n        } else {\n          return processQueue(uniqueScripts);\n        }\n      }\n    }\n    ScriptLoader.ScriptLoader = new ScriptLoader();\n\n    const Cell = initial => {\n      let value = initial;\n      const get = () => {\n        return value;\n      };\n      const set = v => {\n        value = v;\n      };\n      return {\n        get,\n        set\n      };\n    };\n\n    const isRaw = str => isObject(str) && has$2(str, 'raw');\n    const isTokenised = str => isArray$1(str) && str.length > 1;\n    const data = {};\n    const currentCode = Cell('en');\n    const getLanguageData = () => get$a(data, currentCode.get());\n    const getData$1 = () => map$2(data, value => ({ ...value }));\n    const setCode = newCode => {\n      if (newCode) {\n        currentCode.set(newCode);\n      }\n    };\n    const getCode = () => currentCode.get();\n    const add$1 = (code, items) => {\n      let langData = data[code];\n      if (!langData) {\n        data[code] = langData = {};\n      }\n      each$f(items, (translation, name) => {\n        langData[name.toLowerCase()] = translation;\n      });\n    };\n    const translate = text => {\n      const langData = getLanguageData().getOr({});\n      const toString = obj => {\n        if (isFunction(obj)) {\n          return Object.prototype.toString.call(obj);\n        }\n        return !isEmpty(obj) ? '' + obj : '';\n      };\n      const isEmpty = text => text === '' || text === null || text === undefined;\n      const getLangData = text => {\n        const textstr = toString(text);\n        return get$a(langData, textstr.toLowerCase()).map(toString).getOr(textstr);\n      };\n      const removeContext = str => str.replace(/{context:\\w+}$/, '');\n      if (isEmpty(text)) {\n        return '';\n      }\n      if (isRaw(text)) {\n        return toString(text.raw);\n      }\n      if (isTokenised(text)) {\n        const values = text.slice(1);\n        const substitued = getLangData(text[0]).replace(/\\{([0-9]+)\\}/g, ($1, $2) => has$2(values, $2) ? toString(values[$2]) : $1);\n        return removeContext(substitued);\n      }\n      return removeContext(getLangData(text));\n    };\n    const isRtl$1 = () => getLanguageData().bind(items => get$a(items, '_dir')).exists(dir => dir === 'rtl');\n    const hasCode = code => has$2(data, code);\n    const I18n = {\n      getData: getData$1,\n      setCode,\n      getCode,\n      add: add$1,\n      translate,\n      isRtl: isRtl$1,\n      hasCode\n    };\n\n    const AddOnManager = () => {\n      const items = [];\n      const urls = {};\n      const lookup = {};\n      const _listeners = [];\n      const runListeners = (name, state) => {\n        const matchedListeners = filter$6(_listeners, listener => listener.name === name && listener.state === state);\n        each$g(matchedListeners, listener => listener.resolve());\n      };\n      const isLoaded = name => has$2(urls, name);\n      const isAdded = name => has$2(lookup, name);\n      const get = name => {\n        if (lookup[name]) {\n          return lookup[name].instance;\n        }\n        return undefined;\n      };\n      const loadLanguagePack = (name, languages) => {\n        const language = I18n.getCode();\n        const wrappedLanguages = ',' + (languages || '') + ',';\n        if (!language || languages && wrappedLanguages.indexOf(',' + language + ',') === -1) {\n          return;\n        }\n        ScriptLoader.ScriptLoader.add(urls[name] + '/langs/' + language + '.js');\n      };\n      const requireLangPack = (name, languages) => {\n        if (AddOnManager.languageLoad !== false) {\n          if (isLoaded(name)) {\n            loadLanguagePack(name, languages);\n          } else {\n            waitFor(name, 'loaded').then(() => loadLanguagePack(name, languages));\n          }\n        }\n      };\n      const add = (id, addOn) => {\n        items.push(addOn);\n        lookup[id] = { instance: addOn };\n        runListeners(id, 'added');\n        return addOn;\n      };\n      const remove = name => {\n        delete urls[name];\n        delete lookup[name];\n      };\n      const createUrl = (baseUrl, dep) => {\n        if (isString(dep)) {\n          return isString(baseUrl) ? {\n            prefix: '',\n            resource: dep,\n            suffix: ''\n          } : {\n            prefix: baseUrl.prefix,\n            resource: dep,\n            suffix: baseUrl.suffix\n          };\n        } else {\n          return dep;\n        }\n      };\n      const load = (name, addOnUrl) => {\n        if (urls[name]) {\n          return Promise.resolve();\n        }\n        let urlString = isString(addOnUrl) ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;\n        if (urlString.indexOf('/') !== 0 && urlString.indexOf('://') === -1) {\n          urlString = AddOnManager.baseURL + '/' + urlString;\n        }\n        urls[name] = urlString.substring(0, urlString.lastIndexOf('/'));\n        const done = () => {\n          runListeners(name, 'loaded');\n          return Promise.resolve();\n        };\n        if (lookup[name]) {\n          return done();\n        } else {\n          return ScriptLoader.ScriptLoader.add(urlString).then(done);\n        }\n      };\n      const waitFor = (name, state = 'added') => {\n        if (state === 'added' && isAdded(name)) {\n          return Promise.resolve();\n        } else if (state === 'loaded' && isLoaded(name)) {\n          return Promise.resolve();\n        } else {\n          return new Promise(resolve => {\n            _listeners.push({\n              name,\n              state,\n              resolve\n            });\n          });\n        }\n      };\n      return {\n        items,\n        urls,\n        lookup,\n        get,\n        requireLangPack,\n        add,\n        remove,\n        createUrl,\n        load,\n        waitFor\n      };\n    };\n    AddOnManager.languageLoad = true;\n    AddOnManager.baseURL = '';\n    AddOnManager.PluginManager = AddOnManager();\n    AddOnManager.ThemeManager = AddOnManager();\n    AddOnManager.ModelManager = AddOnManager();\n\n    const singleton = doRevoke => {\n      const subject = Cell(Optional.none());\n      const revoke = () => subject.get().each(doRevoke);\n      const clear = () => {\n        revoke();\n        subject.set(Optional.none());\n      };\n      const isSet = () => subject.get().isSome();\n      const get = () => subject.get();\n      const set = s => {\n        revoke();\n        subject.set(Optional.some(s));\n      };\n      return {\n        clear,\n        isSet,\n        get,\n        set\n      };\n    };\n    const value$2 = () => {\n      const subject = singleton(noop);\n      const on = f => subject.get().each(f);\n      return {\n        ...subject,\n        on\n      };\n    };\n\n    const first$1 = (fn, rate) => {\n      let timer = null;\n      const cancel = () => {\n        if (!isNull(timer)) {\n          clearTimeout(timer);\n          timer = null;\n        }\n      };\n      const throttle = (...args) => {\n        if (isNull(timer)) {\n          timer = setTimeout(() => {\n            timer = null;\n            fn.apply(null, args);\n          }, rate);\n        }\n      };\n      return {\n        cancel,\n        throttle\n      };\n    };\n    const last$1 = (fn, rate) => {\n      let timer = null;\n      const cancel = () => {\n        if (!isNull(timer)) {\n          clearTimeout(timer);\n          timer = null;\n        }\n      };\n      const throttle = (...args) => {\n        cancel();\n        timer = setTimeout(() => {\n          timer = null;\n          fn.apply(null, args);\n        }, rate);\n      };\n      return {\n        cancel,\n        throttle\n      };\n    };\n\n    const descendants$1 = (scope, predicate) => {\n      let result = [];\n      each$g(children(scope), x => {\n        if (predicate(x)) {\n          result = result.concat([x]);\n        }\n        result = result.concat(descendants$1(x, predicate));\n      });\n      return result;\n    };\n\n    const descendants = (scope, selector) => all(selector, scope);\n\n    const annotation = constant('mce-annotation');\n    const dataAnnotation = constant('data-mce-annotation');\n    const dataAnnotationId = constant('data-mce-annotation-uid');\n    const dataAnnotationActive = constant('data-mce-annotation-active');\n\n    const identify = (editor, annotationName) => {\n      const rng = editor.selection.getRng();\n      const start = SugarElement.fromDom(rng.startContainer);\n      const root = SugarElement.fromDom(editor.getBody());\n      const selector = annotationName.fold(() => '.' + annotation(), an => `[${ dataAnnotation() }=\"${ an }\"]`);\n      const newStart = child$1(start, rng.startOffset).getOr(start);\n      const closest = closest$3(newStart, selector, n => eq(n, root));\n      const getAttr = (c, property) => {\n        if (has$1(c, property)) {\n          return Optional.some(get$9(c, property));\n        } else {\n          return Optional.none();\n        }\n      };\n      return closest.bind(c => getAttr(c, `${ dataAnnotationId() }`).bind(uid => getAttr(c, `${ dataAnnotation() }`).map(name => {\n        const elements = findMarkers(editor, uid);\n        return {\n          uid,\n          name,\n          elements\n        };\n      })));\n    };\n    const isAnnotation = elem => isElement$7(elem) && has(elem, annotation());\n    const findMarkers = (editor, uid) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      return descendants(body, `[${ dataAnnotationId() }=\"${ uid }\"]`);\n    };\n    const findAll = (editor, name) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const markers = descendants(body, `[${ dataAnnotation() }=\"${ name }\"]`);\n      const directory = {};\n      each$g(markers, m => {\n        const uid = get$9(m, dataAnnotationId());\n        const nodesAlready = get$a(directory, uid).getOr([]);\n        directory[uid] = nodesAlready.concat([m]);\n      });\n      return directory;\n    };\n\n    const setup$x = (editor, registry) => {\n      const changeCallbacks = Cell({});\n      const initData = () => ({\n        listeners: [],\n        previous: value$2()\n      });\n      const withCallbacks = (name, f) => {\n        updateCallbacks(name, data => {\n          f(data);\n          return data;\n        });\n      };\n      const updateCallbacks = (name, f) => {\n        const callbackMap = changeCallbacks.get();\n        const data = get$a(callbackMap, name).getOrThunk(initData);\n        const outputData = f(data);\n        callbackMap[name] = outputData;\n        changeCallbacks.set(callbackMap);\n      };\n      const fireCallbacks = (name, uid, elements) => {\n        withCallbacks(name, data => {\n          each$g(data.listeners, f => f(true, name, {\n            uid,\n            nodes: map$3(elements, elem => elem.dom)\n          }));\n        });\n      };\n      const fireNoAnnotation = name => {\n        withCallbacks(name, data => {\n          each$g(data.listeners, f => f(false, name));\n        });\n      };\n      const toggleActiveAttr = (uid, state) => {\n        each$g(findMarkers(editor, uid), span => {\n          if (state) {\n            set$2(span, dataAnnotationActive(), 'true');\n          } else {\n            remove$a(span, dataAnnotationActive());\n          }\n        });\n      };\n      const onNodeChange = last$1(() => {\n        const annotations = sort(registry.getNames());\n        each$g(annotations, name => {\n          updateCallbacks(name, data => {\n            const prev = data.previous.get();\n            identify(editor, Optional.some(name)).fold(() => {\n              prev.each(uid => {\n                fireNoAnnotation(name);\n                data.previous.clear();\n                toggleActiveAttr(uid, false);\n              });\n            }, ({uid, name, elements}) => {\n              if (!is$2(prev, uid)) {\n                prev.each(uid => toggleActiveAttr(uid, false));\n                fireCallbacks(name, uid, elements);\n                data.previous.set(uid);\n                toggleActiveAttr(uid, true);\n              }\n            });\n            return {\n              previous: data.previous,\n              listeners: data.listeners\n            };\n          });\n        });\n      }, 30);\n      editor.on('remove', () => {\n        onNodeChange.cancel();\n      });\n      editor.on('NodeChange', () => {\n        onNodeChange.throttle();\n      });\n      const addListener = (name, f) => {\n        updateCallbacks(name, data => ({\n          previous: data.previous,\n          listeners: data.listeners.concat([f])\n        }));\n      };\n      return { addListener };\n    };\n\n    const setup$w = (editor, registry) => {\n      const identifyParserNode = span => Optional.from(span.attr(dataAnnotation())).bind(registry.lookup);\n      editor.serializer.addTempAttr(dataAnnotationActive());\n      editor.serializer.addNodeFilter('span', spans => {\n        each$g(spans, span => {\n          identifyParserNode(span).each(settings => {\n            if (settings.persistent === false) {\n              span.unwrap();\n            }\n          });\n        });\n      });\n    };\n\n    const create$b = () => {\n      const annotations = {};\n      const register = (name, settings) => {\n        annotations[name] = {\n          name,\n          settings\n        };\n      };\n      const lookup = name => get$a(annotations, name).map(a => a.settings);\n      const getNames = () => keys(annotations);\n      return {\n        register,\n        lookup,\n        getNames\n      };\n    };\n\n    let unique = 0;\n    const generate$1 = prefix => {\n      const date = new Date();\n      const time = date.getTime();\n      const random = Math.floor(Math.random() * 1000000000);\n      unique++;\n      return prefix + '_' + random + unique + String(time);\n    };\n\n    const add = (element, classes) => {\n      each$g(classes, x => {\n        add$2(element, x);\n      });\n    };\n\n    const clone$2 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));\n    const shallow$1 = original => clone$2(original, false);\n    const deep$1 = original => clone$2(original, true);\n    const shallowAs = (original, tag) => {\n      const nu = SugarElement.fromTag(tag);\n      const attributes = clone$4(original);\n      setAll$1(nu, attributes);\n      return nu;\n    };\n    const mutate = (original, tag) => {\n      const nu = shallowAs(original, tag);\n      after$4(original, nu);\n      const children$1 = children(original);\n      append(nu, children$1);\n      remove$5(original);\n      return nu;\n    };\n\n    const TextWalker = (startNode, rootNode, isBoundary = never) => {\n      const walker = new DomTreeWalker(startNode, rootNode);\n      const walk = direction => {\n        let next;\n        do {\n          next = walker[direction]();\n        } while (next && !isText$8(next) && !isBoundary(next));\n        return Optional.from(next).filter(isText$8);\n      };\n      return {\n        current: () => Optional.from(walker.current()).filter(isText$8),\n        next: () => walk('next'),\n        prev: () => walk('prev'),\n        prev2: () => walk('prev2')\n      };\n    };\n\n    const TextSeeker = (dom, isBoundary) => {\n      const isBlockBoundary = isBoundary ? isBoundary : node => dom.isBlock(node) || isBr$5(node) || isContentEditableFalse$a(node);\n      const walk = (node, offset, walker, process) => {\n        if (isText$8(node)) {\n          const newOffset = process(node, offset, node.data);\n          if (newOffset !== -1) {\n            return Optional.some({\n              container: node,\n              offset: newOffset\n            });\n          }\n        }\n        return walker().bind(next => walk(next.container, next.offset, walker, process));\n      };\n      const backwards = (node, offset, process, root) => {\n        const walker = TextWalker(node, root, isBlockBoundary);\n        return walk(node, offset, () => walker.prev().map(prev => ({\n          container: prev,\n          offset: prev.length\n        })), process).getOrNull();\n      };\n      const forwards = (node, offset, process, root) => {\n        const walker = TextWalker(node, root, isBlockBoundary);\n        return walk(node, offset, () => walker.next().map(next => ({\n          container: next,\n          offset: 0\n        })), process).getOrNull();\n      };\n      return {\n        backwards,\n        forwards\n      };\n    };\n\n    const round$1 = Math.round;\n    const clone$1 = rect => {\n      if (!rect) {\n        return {\n          left: 0,\n          top: 0,\n          bottom: 0,\n          right: 0,\n          width: 0,\n          height: 0\n        };\n      }\n      return {\n        left: round$1(rect.left),\n        top: round$1(rect.top),\n        bottom: round$1(rect.bottom),\n        right: round$1(rect.right),\n        width: round$1(rect.width),\n        height: round$1(rect.height)\n      };\n    };\n    const collapse = (rect, toStart) => {\n      rect = clone$1(rect);\n      if (toStart) {\n        rect.right = rect.left;\n      } else {\n        rect.left = rect.left + rect.width;\n        rect.right = rect.left;\n      }\n      rect.width = 0;\n      return rect;\n    };\n    const isEqual = (rect1, rect2) => rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;\n    const isValidOverflow = (overflowY, rect1, rect2) => overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;\n    const isAbove$1 = (rect1, rect2) => {\n      const halfHeight = Math.min(rect2.height / 2, rect1.height / 2);\n      if (rect1.bottom - halfHeight < rect2.top) {\n        return true;\n      }\n      if (rect1.top > rect2.bottom) {\n        return false;\n      }\n      return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);\n    };\n    const isBelow$1 = (rect1, rect2) => {\n      if (rect1.top > rect2.bottom) {\n        return true;\n      }\n      if (rect1.bottom < rect2.top) {\n        return false;\n      }\n      return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);\n    };\n    const containsXY = (rect, clientX, clientY) => clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n    const boundingClientRectFromRects = rects => {\n      return foldl(rects, (acc, rect) => {\n        return acc.fold(() => Optional.some(rect), prevRect => {\n          const left = Math.min(rect.left, prevRect.left);\n          const top = Math.min(rect.top, prevRect.top);\n          const right = Math.max(rect.right, prevRect.right);\n          const bottom = Math.max(rect.bottom, prevRect.bottom);\n          return Optional.some({\n            top,\n            right,\n            bottom,\n            left,\n            width: right - left,\n            height: bottom - top\n          });\n        });\n      }, Optional.none());\n    };\n    const distanceToRectEdgeFromXY = (rect, x, y) => {\n      const cx = Math.max(Math.min(x, rect.left + rect.width), rect.left);\n      const cy = Math.max(Math.min(y, rect.top + rect.height), rect.top);\n      return Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));\n    };\n    const overlapY = (r1, r2) => Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));\n\n    const clamp$2 = (value, min, max) => Math.min(Math.max(value, min), max);\n\n    const getSelectedNode = range => {\n      const startContainer = range.startContainer, startOffset = range.startOffset;\n      if (startContainer.hasChildNodes() && range.endOffset === startOffset + 1) {\n        return startContainer.childNodes[startOffset];\n      }\n      return null;\n    };\n    const getNode$1 = (container, offset) => {\n      if (isElement$6(container) && container.hasChildNodes()) {\n        const childNodes = container.childNodes;\n        const safeOffset = clamp$2(offset, 0, childNodes.length - 1);\n        return childNodes[safeOffset];\n      } else {\n        return container;\n      }\n    };\n    const getNodeUnsafe = (container, offset) => {\n      if (offset < 0 && isElement$6(container) && container.hasChildNodes()) {\n        return undefined;\n      } else {\n        return getNode$1(container, offset);\n      }\n    };\n\n    const extendingChars = new RegExp('[\\u0300-\\u036f\\u0483-\\u0487\\u0488-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1-\\u05c2\\u05c4-\\u05c5\\u05c7\\u0610-\\u061a' + '\\u064b-\\u065f\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7-\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0' + '\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08e3-\\u0902\\u093a\\u093c' + '\\u0941-\\u0948\\u094d\\u0951-\\u0957\\u0962-\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2-\\u09e3' + '\\u0a01-\\u0a02\\u0a3c\\u0a41-\\u0a42\\u0a47-\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70-\\u0a71\\u0a75\\u0a81-\\u0a82\\u0abc' + '\\u0ac1-\\u0ac5\\u0ac7-\\u0ac8\\u0acd\\u0ae2-\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57' + '\\u0b62-\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c00\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55-\\u0c56' + '\\u0c62-\\u0c63\\u0c81\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc-\\u0ccd\\u0cd5-\\u0cd6\\u0ce2-\\u0ce3\\u0d01\\u0d3e\\u0d41-\\u0d44' + '\\u0d4d\\u0d57\\u0d62-\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9' + '\\u0ebb-\\u0ebc\\u0ec8-\\u0ecd\\u0f18-\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97' + '\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039-\\u103a\\u103d-\\u103e\\u1058-\\u1059\\u105e-\\u1060\\u1071-\\u1074' + '\\u1082\\u1085-\\u1086\\u108d\\u109d\\u135d-\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752-\\u1753\\u1772-\\u1773\\u17b4-\\u17b5' + '\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927-\\u1928\\u1932\\u1939-\\u193b\\u1a17-\\u1a18' + '\\u1a1b\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1ab0-\\u1abd\\u1ABE\\u1b00-\\u1b03\\u1b34' + '\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80-\\u1b81\\u1ba2-\\u1ba5\\u1ba8-\\u1ba9\\u1bab-\\u1bad\\u1be6\\u1be8-\\u1be9' + '\\u1bed\\u1bef-\\u1bf1\\u1c2c-\\u1c33\\u1c36-\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1cf4\\u1cf8-\\u1cf9' + '\\u1dc0-\\u1df5\\u1dfc-\\u1dff\\u200c-\\u200d\\u20d0-\\u20dc\\u20DD-\\u20E0\\u20e1\\u20E2-\\u20E4\\u20e5-\\u20f0\\u2cef-\\u2cf1' + '\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302d\\u302e-\\u302f\\u3099-\\u309a\\ua66f\\uA670-\\uA672\\ua674-\\ua67d\\ua69e-\\ua69f\\ua6f0-\\ua6f1' + '\\ua802\\ua806\\ua80b\\ua825-\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc' + '\\ua9e5\\uaa29-\\uaa2e\\uaa31-\\uaa32\\uaa35-\\uaa36\\uaa43\\uaa4c\\uaa7c\\uaab0\\uaab2-\\uaab4\\uaab7-\\uaab8\\uaabe-\\uaabf\\uaac1' + '\\uaaec-\\uaaed\\uaaf6\\uabe5\\uabe8\\uabed\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\uff9e-\\uff9f]');\n    const isExtendingChar = ch => typeof ch === 'string' && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);\n\n    const or = (...args) => {\n      return x => {\n        for (let i = 0; i < args.length; i++) {\n          if (args[i](x)) {\n            return true;\n          }\n        }\n        return false;\n      };\n    };\n    const and = (...args) => {\n      return x => {\n        for (let i = 0; i < args.length; i++) {\n          if (!args[i](x)) {\n            return false;\n          }\n        }\n        return true;\n      };\n    };\n\n    const isElement$4 = isElement$6;\n    const isCaretCandidate$2 = isCaretCandidate$3;\n    const isBlock$1 = matchStyleValues('display', 'block table');\n    const isFloated = matchStyleValues('float', 'left right');\n    const isValidElementCaretCandidate = and(isElement$4, isCaretCandidate$2, not(isFloated));\n    const isNotPre = not(matchStyleValues('white-space', 'pre pre-line pre-wrap'));\n    const isText$5 = isText$8;\n    const isBr$2 = isBr$5;\n    const nodeIndex$1 = DOMUtils.nodeIndex;\n    const resolveIndex$1 = getNodeUnsafe;\n    const createRange$1 = doc => 'createRange' in doc ? doc.createRange() : DOMUtils.DOM.createRng();\n    const isWhiteSpace$1 = chr => chr && /[\\r\\n\\t ]/.test(chr);\n    const isRange = rng => !!rng.setStart && !!rng.setEnd;\n    const isHiddenWhiteSpaceRange = range => {\n      const container = range.startContainer;\n      const offset = range.startOffset;\n      if (isWhiteSpace$1(range.toString()) && isNotPre(container.parentNode) && isText$8(container)) {\n        const text = container.data;\n        if (isWhiteSpace$1(text[offset - 1]) || isWhiteSpace$1(text[offset + 1])) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const getBrClientRect = brNode => {\n      const doc = brNode.ownerDocument;\n      const rng = createRange$1(doc);\n      const nbsp$1 = doc.createTextNode(nbsp);\n      const parentNode = brNode.parentNode;\n      parentNode.insertBefore(nbsp$1, brNode);\n      rng.setStart(nbsp$1, 0);\n      rng.setEnd(nbsp$1, 1);\n      const clientRect = clone$1(rng.getBoundingClientRect());\n      parentNode.removeChild(nbsp$1);\n      return clientRect;\n    };\n    const getBoundingClientRectWebKitText = rng => {\n      const sc = rng.startContainer;\n      const ec = rng.endContainer;\n      const so = rng.startOffset;\n      const eo = rng.endOffset;\n      if (sc === ec && isText$8(ec) && so === 0 && eo === 1) {\n        const newRng = rng.cloneRange();\n        newRng.setEndAfter(ec);\n        return getBoundingClientRect$1(newRng);\n      } else {\n        return null;\n      }\n    };\n    const isZeroRect = r => r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;\n    const getBoundingClientRect$1 = item => {\n      let clientRect;\n      const clientRects = item.getClientRects();\n      if (clientRects.length > 0) {\n        clientRect = clone$1(clientRects[0]);\n      } else {\n        clientRect = clone$1(item.getBoundingClientRect());\n      }\n      if (!isRange(item) && isBr$2(item) && isZeroRect(clientRect)) {\n        return getBrClientRect(item);\n      }\n      if (isZeroRect(clientRect) && isRange(item)) {\n        return getBoundingClientRectWebKitText(item);\n      }\n      return clientRect;\n    };\n    const collapseAndInflateWidth = (clientRect, toStart) => {\n      const newClientRect = collapse(clientRect, toStart);\n      newClientRect.width = 1;\n      newClientRect.right = newClientRect.left + 1;\n      return newClientRect;\n    };\n    const getCaretPositionClientRects = caretPosition => {\n      const clientRects = [];\n      const addUniqueAndValidRect = clientRect => {\n        if (clientRect.height === 0) {\n          return;\n        }\n        if (clientRects.length > 0) {\n          if (isEqual(clientRect, clientRects[clientRects.length - 1])) {\n            return;\n          }\n        }\n        clientRects.push(clientRect);\n      };\n      const addCharacterOffset = (container, offset) => {\n        const range = createRange$1(container.ownerDocument);\n        if (offset < container.data.length) {\n          if (isExtendingChar(container.data[offset])) {\n            return clientRects;\n          }\n          if (isExtendingChar(container.data[offset - 1])) {\n            range.setStart(container, offset);\n            range.setEnd(container, offset + 1);\n            if (!isHiddenWhiteSpaceRange(range)) {\n              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\n              return clientRects;\n            }\n          }\n        }\n        if (offset > 0) {\n          range.setStart(container, offset - 1);\n          range.setEnd(container, offset);\n          if (!isHiddenWhiteSpaceRange(range)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\n          }\n        }\n        if (offset < container.data.length) {\n          range.setStart(container, offset);\n          range.setEnd(container, offset + 1);\n          if (!isHiddenWhiteSpaceRange(range)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), true));\n          }\n        }\n      };\n      const container = caretPosition.container();\n      const offset = caretPosition.offset();\n      if (isText$5(container)) {\n        addCharacterOffset(container, offset);\n        return clientRects;\n      }\n      if (isElement$4(container)) {\n        if (caretPosition.isAtEnd()) {\n          const node = resolveIndex$1(container, offset);\n          if (isText$5(node)) {\n            addCharacterOffset(node, node.data.length);\n          }\n          if (isValidElementCaretCandidate(node) && !isBr$2(node)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\n          }\n        } else {\n          const node = resolveIndex$1(container, offset);\n          if (isText$5(node)) {\n            addCharacterOffset(node, 0);\n          }\n          if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\n            return clientRects;\n          }\n          const beforeNode = resolveIndex$1(caretPosition.container(), caretPosition.offset() - 1);\n          if (isValidElementCaretCandidate(beforeNode) && !isBr$2(beforeNode)) {\n            if (isBlock$1(beforeNode) || isBlock$1(node) || !isValidElementCaretCandidate(node)) {\n              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(beforeNode), false));\n            }\n          }\n          if (isValidElementCaretCandidate(node)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), true));\n          }\n        }\n      }\n      return clientRects;\n    };\n    const CaretPosition = (container, offset, clientRects) => {\n      const isAtStart = () => {\n        if (isText$5(container)) {\n          return offset === 0;\n        }\n        return offset === 0;\n      };\n      const isAtEnd = () => {\n        if (isText$5(container)) {\n          return offset >= container.data.length;\n        }\n        return offset >= container.childNodes.length;\n      };\n      const toRange = () => {\n        const range = createRange$1(container.ownerDocument);\n        range.setStart(container, offset);\n        range.setEnd(container, offset);\n        return range;\n      };\n      const getClientRects = () => {\n        if (!clientRects) {\n          clientRects = getCaretPositionClientRects(CaretPosition(container, offset));\n        }\n        return clientRects;\n      };\n      const isVisible = () => getClientRects().length > 0;\n      const isEqual = caretPosition => caretPosition && container === caretPosition.container() && offset === caretPosition.offset();\n      const getNode = before => resolveIndex$1(container, before ? offset - 1 : offset);\n      return {\n        container: constant(container),\n        offset: constant(offset),\n        toRange,\n        getClientRects,\n        isVisible,\n        isAtStart,\n        isAtEnd,\n        isEqual,\n        getNode\n      };\n    };\n    CaretPosition.fromRangeStart = range => CaretPosition(range.startContainer, range.startOffset);\n    CaretPosition.fromRangeEnd = range => CaretPosition(range.endContainer, range.endOffset);\n    CaretPosition.after = node => CaretPosition(node.parentNode, nodeIndex$1(node) + 1);\n    CaretPosition.before = node => CaretPosition(node.parentNode, nodeIndex$1(node));\n    CaretPosition.isAbove = (pos1, pos2) => lift2(head(pos2.getClientRects()), last$3(pos1.getClientRects()), isAbove$1).getOr(false);\n    CaretPosition.isBelow = (pos1, pos2) => lift2(last$3(pos2.getClientRects()), head(pos1.getClientRects()), isBelow$1).getOr(false);\n    CaretPosition.isAtStart = pos => pos ? pos.isAtStart() : false;\n    CaretPosition.isAtEnd = pos => pos ? pos.isAtEnd() : false;\n    CaretPosition.isTextPosition = pos => pos ? isText$8(pos.container()) : false;\n    CaretPosition.isElementPosition = pos => CaretPosition.isTextPosition(pos) === false;\n\n    const trimEmptyTextNode$1 = (dom, node) => {\n      if (isText$8(node) && node.data.length === 0) {\n        dom.remove(node);\n      }\n    };\n    const insertNode = (dom, rng, node) => {\n      rng.insertNode(node);\n      trimEmptyTextNode$1(dom, node.previousSibling);\n      trimEmptyTextNode$1(dom, node.nextSibling);\n    };\n    const insertFragment = (dom, rng, frag) => {\n      const firstChild = Optional.from(frag.firstChild);\n      const lastChild = Optional.from(frag.lastChild);\n      rng.insertNode(frag);\n      firstChild.each(child => trimEmptyTextNode$1(dom, child.previousSibling));\n      lastChild.each(child => trimEmptyTextNode$1(dom, child.nextSibling));\n    };\n    const rangeInsertNode = (dom, rng, node) => {\n      if (isDocumentFragment(node)) {\n        insertFragment(dom, rng, node);\n      } else {\n        insertNode(dom, rng, node);\n      }\n    };\n\n    const isText$4 = isText$8;\n    const isBogus = isBogus$2;\n    const nodeIndex = DOMUtils.nodeIndex;\n    const normalizedParent = node => {\n      const parentNode = node.parentNode;\n      if (isBogus(parentNode)) {\n        return normalizedParent(parentNode);\n      }\n      return parentNode;\n    };\n    const getChildNodes = node => {\n      if (!node) {\n        return [];\n      }\n      return reduce(node.childNodes, (result, node) => {\n        if (isBogus(node) && node.nodeName !== 'BR') {\n          result = result.concat(getChildNodes(node));\n        } else {\n          result.push(node);\n        }\n        return result;\n      }, []);\n    };\n    const normalizedTextOffset = (node, offset) => {\n      while (node = node.previousSibling) {\n        if (!isText$4(node)) {\n          break;\n        }\n        offset += node.data.length;\n      }\n      return offset;\n    };\n    const equal = a => b => a === b;\n    const normalizedNodeIndex = node => {\n      let nodes, index;\n      nodes = getChildNodes(normalizedParent(node));\n      index = findIndex$1(nodes, equal(node), node);\n      nodes = nodes.slice(0, index + 1);\n      const numTextFragments = reduce(nodes, (result, node, i) => {\n        if (isText$4(node) && isText$4(nodes[i - 1])) {\n          result++;\n        }\n        return result;\n      }, 0);\n      nodes = filter$4(nodes, matchNodeNames([node.nodeName]));\n      index = findIndex$1(nodes, equal(node), node);\n      return index - numTextFragments;\n    };\n    const createPathItem = node => {\n      let name;\n      if (isText$4(node)) {\n        name = 'text()';\n      } else {\n        name = node.nodeName.toLowerCase();\n      }\n      return name + '[' + normalizedNodeIndex(node) + ']';\n    };\n    const parentsUntil$1 = (root, node, predicate) => {\n      const parents = [];\n      for (node = node.parentNode; node !== root; node = node.parentNode) {\n        if (predicate && predicate(node)) {\n          break;\n        }\n        parents.push(node);\n      }\n      return parents;\n    };\n    const create$a = (root, caretPosition) => {\n      let container, offset, path = [], outputOffset, childNodes, parents;\n      container = caretPosition.container();\n      offset = caretPosition.offset();\n      if (isText$4(container)) {\n        outputOffset = normalizedTextOffset(container, offset);\n      } else {\n        childNodes = container.childNodes;\n        if (offset >= childNodes.length) {\n          outputOffset = 'after';\n          offset = childNodes.length - 1;\n        } else {\n          outputOffset = 'before';\n        }\n        container = childNodes[offset];\n      }\n      path.push(createPathItem(container));\n      parents = parentsUntil$1(root, container);\n      parents = filter$4(parents, not(isBogus$2));\n      path = path.concat(map$1(parents, node => {\n        return createPathItem(node);\n      }));\n      return path.reverse().join('/') + ',' + outputOffset;\n    };\n    const resolvePathItem = (node, name, index) => {\n      let nodes = getChildNodes(node);\n      nodes = filter$4(nodes, (node, index) => {\n        return !isText$4(node) || !isText$4(nodes[index - 1]);\n      });\n      nodes = filter$4(nodes, matchNodeNames([name]));\n      return nodes[index];\n    };\n    const findTextPosition = (container, offset) => {\n      let node = container, targetOffset = 0, dataLen;\n      while (isText$4(node)) {\n        dataLen = node.data.length;\n        if (offset >= targetOffset && offset <= targetOffset + dataLen) {\n          container = node;\n          offset = offset - targetOffset;\n          break;\n        }\n        if (!isText$4(node.nextSibling)) {\n          container = node;\n          offset = dataLen;\n          break;\n        }\n        targetOffset += dataLen;\n        node = node.nextSibling;\n      }\n      if (isText$4(container) && offset > container.data.length) {\n        offset = container.data.length;\n      }\n      return CaretPosition(container, offset);\n    };\n    const resolve$1 = (root, path) => {\n      let offset;\n      if (!path) {\n        return null;\n      }\n      const parts = path.split(',');\n      const paths = parts[0].split('/');\n      offset = parts.length > 1 ? parts[1] : 'before';\n      const container = reduce(paths, (result, value) => {\n        const match = /([\\w\\-\\(\\)]+)\\[([0-9]+)\\]/.exec(value);\n        if (!match) {\n          return null;\n        }\n        if (match[1] === 'text()') {\n          match[1] = '#text';\n        }\n        return resolvePathItem(result, match[1], parseInt(match[2], 10));\n      }, root);\n      if (!container) {\n        return null;\n      }\n      if (!isText$4(container)) {\n        if (offset === 'after') {\n          offset = nodeIndex(container) + 1;\n        } else {\n          offset = nodeIndex(container);\n        }\n        return CaretPosition(container.parentNode, offset);\n      }\n      return findTextPosition(container, parseInt(offset, 10));\n    };\n\n    const isContentEditableFalse$8 = isContentEditableFalse$a;\n    const getNormalizedTextOffset = (trim, container, offset) => {\n      let node, trimmedOffset;\n      trimmedOffset = trim(container.data.slice(0, offset)).length;\n      for (node = container.previousSibling; node && isText$8(node); node = node.previousSibling) {\n        trimmedOffset += trim(node.data).length;\n      }\n      return trimmedOffset;\n    };\n    const getPoint = (dom, trim, normalized, rng, start) => {\n      let container = rng[start ? 'startContainer' : 'endContainer'];\n      let offset = rng[start ? 'startOffset' : 'endOffset'];\n      const point = [];\n      let childNodes, after = 0;\n      const root = dom.getRoot();\n      if (isText$8(container)) {\n        point.push(normalized ? getNormalizedTextOffset(trim, container, offset) : offset);\n      } else {\n        childNodes = container.childNodes;\n        if (offset >= childNodes.length && childNodes.length) {\n          after = 1;\n          offset = Math.max(0, childNodes.length - 1);\n        }\n        point.push(dom.nodeIndex(childNodes[offset], normalized) + after);\n      }\n      for (; container && container !== root; container = container.parentNode) {\n        point.push(dom.nodeIndex(container, normalized));\n      }\n      return point;\n    };\n    const getLocation = (trim, selection, normalized, rng) => {\n      const dom = selection.dom, bookmark = {};\n      bookmark.start = getPoint(dom, trim, normalized, rng, true);\n      if (!selection.isCollapsed()) {\n        bookmark.end = getPoint(dom, trim, normalized, rng, false);\n      }\n      if (isRangeInCaretContainerBlock(rng)) {\n        bookmark.isFakeCaret = true;\n      }\n      return bookmark;\n    };\n    const findIndex = (dom, name, element) => {\n      let count = 0;\n      Tools.each(dom.select(name), node => {\n        if (node.getAttribute('data-mce-bogus') === 'all') {\n          return;\n        }\n        if (node === element) {\n          return false;\n        }\n        count++;\n      });\n      return count;\n    };\n    const moveEndPoint$1 = (rng, start) => {\n      let container, offset, childNodes;\n      const prefix = start ? 'start' : 'end';\n      container = rng[prefix + 'Container'];\n      offset = rng[prefix + 'Offset'];\n      if (isElement$6(container) && container.nodeName === 'TR') {\n        childNodes = container.childNodes;\n        container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];\n        if (container) {\n          offset = start ? 0 : container.childNodes.length;\n          rng['set' + (start ? 'Start' : 'End')](container, offset);\n        }\n      }\n    };\n    const normalizeTableCellSelection = rng => {\n      moveEndPoint$1(rng, true);\n      moveEndPoint$1(rng, false);\n      return rng;\n    };\n    const findSibling = (node, offset) => {\n      let sibling;\n      if (isElement$6(node)) {\n        node = getNode$1(node, offset);\n        if (isContentEditableFalse$8(node)) {\n          return node;\n        }\n      }\n      if (isCaretContainer$2(node)) {\n        if (isText$8(node) && isCaretContainerBlock$1(node)) {\n          node = node.parentNode;\n        }\n        sibling = node.previousSibling;\n        if (isContentEditableFalse$8(sibling)) {\n          return sibling;\n        }\n        sibling = node.nextSibling;\n        if (isContentEditableFalse$8(sibling)) {\n          return sibling;\n        }\n      }\n    };\n    const findAdjacentContentEditableFalseElm = rng => {\n      return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);\n    };\n    const getOffsetBookmark = (trim, normalized, selection) => {\n      const element = selection.getNode();\n      let name = element ? element.nodeName : null;\n      const rng = selection.getRng();\n      if (isContentEditableFalse$8(element) || name === 'IMG') {\n        return {\n          name,\n          index: findIndex(selection.dom, name, element)\n        };\n      }\n      const sibling = findAdjacentContentEditableFalseElm(rng);\n      if (sibling) {\n        name = sibling.tagName;\n        return {\n          name,\n          index: findIndex(selection.dom, name, sibling)\n        };\n      }\n      return getLocation(trim, selection, normalized, rng);\n    };\n    const getCaretBookmark = selection => {\n      const rng = selection.getRng();\n      return {\n        start: create$a(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),\n        end: create$a(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng))\n      };\n    };\n    const getRangeBookmark = selection => {\n      return { rng: selection.getRng() };\n    };\n    const createBookmarkSpan = (dom, id, filled) => {\n      const args = {\n        'data-mce-type': 'bookmark',\n        id,\n        'style': 'overflow:hidden;line-height:0px'\n      };\n      return filled ? dom.create('span', args, '&#xFEFF;') : dom.create('span', args);\n    };\n    const getPersistentBookmark = (selection, filled) => {\n      const dom = selection.dom;\n      let rng = selection.getRng();\n      const id = dom.uniqueId();\n      const collapsed = selection.isCollapsed();\n      const element = selection.getNode();\n      const name = element.nodeName;\n      if (name === 'IMG') {\n        return {\n          name,\n          index: findIndex(dom, name, element)\n        };\n      }\n      const rng2 = normalizeTableCellSelection(rng.cloneRange());\n      if (!collapsed) {\n        rng2.collapse(false);\n        const endBookmarkNode = createBookmarkSpan(dom, id + '_end', filled);\n        rangeInsertNode(dom, rng2, endBookmarkNode);\n      }\n      rng = normalizeTableCellSelection(rng);\n      rng.collapse(true);\n      const startBookmarkNode = createBookmarkSpan(dom, id + '_start', filled);\n      rangeInsertNode(dom, rng, startBookmarkNode);\n      selection.moveToBookmark({\n        id,\n        keep: true\n      });\n      return { id };\n    };\n    const getBookmark$2 = (selection, type, normalized) => {\n      if (type === 2) {\n        return getOffsetBookmark(trim$1, normalized, selection);\n      } else if (type === 3) {\n        return getCaretBookmark(selection);\n      } else if (type) {\n        return getRangeBookmark(selection);\n      } else {\n        return getPersistentBookmark(selection, false);\n      }\n    };\n    const getUndoBookmark = curry(getOffsetBookmark, identity, true);\n\n    const value$1 = value => {\n      const applyHelper = fn => fn(value);\n      const constHelper = constant(value);\n      const outputHelper = () => output;\n      const output = {\n        tag: true,\n        inner: value,\n        fold: (_onError, onValue) => onValue(value),\n        isValue: always,\n        isError: never,\n        map: mapper => Result.value(mapper(value)),\n        mapError: outputHelper,\n        bind: applyHelper,\n        exists: applyHelper,\n        forall: applyHelper,\n        getOr: constHelper,\n        or: outputHelper,\n        getOrThunk: constHelper,\n        orThunk: outputHelper,\n        getOrDie: constHelper,\n        each: fn => {\n          fn(value);\n        },\n        toOptional: () => Optional.some(value)\n      };\n      return output;\n    };\n    const error = error => {\n      const outputHelper = () => output;\n      const output = {\n        tag: false,\n        inner: error,\n        fold: (onError, _onValue) => onError(error),\n        isValue: never,\n        isError: always,\n        map: outputHelper,\n        mapError: mapper => Result.error(mapper(error)),\n        bind: outputHelper,\n        exists: never,\n        forall: always,\n        getOr: identity,\n        or: identity,\n        getOrThunk: apply$1,\n        orThunk: apply$1,\n        getOrDie: die(String(error)),\n        each: noop,\n        toOptional: Optional.none\n      };\n      return output;\n    };\n    const fromOption = (optional, err) => optional.fold(() => error(err), value$1);\n    const Result = {\n      value: value$1,\n      error,\n      fromOption\n    };\n\n    const generate = cases => {\n      if (!isArray$1(cases)) {\n        throw new Error('cases must be an array');\n      }\n      if (cases.length === 0) {\n        throw new Error('there must be at least one case');\n      }\n      const constructors = [];\n      const adt = {};\n      each$g(cases, (acase, count) => {\n        const keys$1 = keys(acase);\n        if (keys$1.length !== 1) {\n          throw new Error('one and only one name per case');\n        }\n        const key = keys$1[0];\n        const value = acase[key];\n        if (adt[key] !== undefined) {\n          throw new Error('duplicate key detected:' + key);\n        } else if (key === 'cata') {\n          throw new Error('cannot have a case named cata (sorry)');\n        } else if (!isArray$1(value)) {\n          throw new Error('case arguments must be an array');\n        }\n        constructors.push(key);\n        adt[key] = (...args) => {\n          const argLength = args.length;\n          if (argLength !== value.length) {\n            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);\n          }\n          const match = branches => {\n            const branchKeys = keys(branches);\n            if (constructors.length !== branchKeys.length) {\n              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\\nActual: ' + branchKeys.join(','));\n            }\n            const allReqd = forall(constructors, reqKey => {\n              return contains$2(branchKeys, reqKey);\n            });\n            if (!allReqd) {\n              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\\nRequired: ' + constructors.join(', '));\n            }\n            return branches[key].apply(null, args);\n          };\n          return {\n            fold: (...foldArgs) => {\n              if (foldArgs.length !== cases.length) {\n                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);\n              }\n              const target = foldArgs[count];\n              return target.apply(null, args);\n            },\n            match,\n            log: label => {\n              console.log(label, {\n                constructors,\n                constructor: key,\n                params: args\n              });\n            }\n          };\n        };\n      });\n      return adt;\n    };\n    const Adt = { generate };\n\n    Adt.generate([\n      {\n        bothErrors: [\n          'error1',\n          'error2'\n        ]\n      },\n      {\n        firstError: [\n          'error1',\n          'value2'\n        ]\n      },\n      {\n        secondError: [\n          'value1',\n          'error2'\n        ]\n      },\n      {\n        bothValues: [\n          'value1',\n          'value2'\n        ]\n      }\n    ]);\n    const partition$1 = results => {\n      const errors = [];\n      const values = [];\n      each$g(results, result => {\n        result.fold(err => {\n          errors.push(err);\n        }, value => {\n          values.push(value);\n        });\n      });\n      return {\n        errors,\n        values\n      };\n    };\n\n    const isInlinePattern = pattern => pattern.type === 'inline-command' || pattern.type === 'inline-format';\n    const isBlockPattern = pattern => pattern.type === 'block-command' || pattern.type === 'block-format';\n    const sortPatterns = patterns => sort(patterns, (a, b) => {\n      if (a.start.length === b.start.length) {\n        return 0;\n      }\n      return a.start.length > b.start.length ? -1 : 1;\n    });\n    const normalizePattern = pattern => {\n      const err = message => Result.error({\n        message,\n        pattern\n      });\n      const formatOrCmd = (name, onFormat, onCommand) => {\n        if (pattern.format !== undefined) {\n          let formats;\n          if (isArray$1(pattern.format)) {\n            if (!forall(pattern.format, isString)) {\n              return err(name + ' pattern has non-string items in the `format` array');\n            }\n            formats = pattern.format;\n          } else if (isString(pattern.format)) {\n            formats = [pattern.format];\n          } else {\n            return err(name + ' pattern has non-string `format` parameter');\n          }\n          return Result.value(onFormat(formats));\n        } else if (pattern.cmd !== undefined) {\n          if (!isString(pattern.cmd)) {\n            return err(name + ' pattern has non-string `cmd` parameter');\n          }\n          return Result.value(onCommand(pattern.cmd, pattern.value));\n        } else {\n          return err(name + ' pattern is missing both `format` and `cmd` parameters');\n        }\n      };\n      if (!isObject(pattern)) {\n        return err('Raw pattern is not an object');\n      }\n      if (!isString(pattern.start)) {\n        return err('Raw pattern is missing `start` parameter');\n      }\n      if (pattern.end !== undefined) {\n        if (!isString(pattern.end)) {\n          return err('Inline pattern has non-string `end` parameter');\n        }\n        if (pattern.start.length === 0 && pattern.end.length === 0) {\n          return err('Inline pattern has empty `start` and `end` parameters');\n        }\n        let start = pattern.start;\n        let end = pattern.end;\n        if (end.length === 0) {\n          end = start;\n          start = '';\n        }\n        return formatOrCmd('Inline', format => ({\n          type: 'inline-format',\n          start,\n          end,\n          format\n        }), (cmd, value) => ({\n          type: 'inline-command',\n          start,\n          end,\n          cmd,\n          value\n        }));\n      } else if (pattern.replacement !== undefined) {\n        if (!isString(pattern.replacement)) {\n          return err('Replacement pattern has non-string `replacement` parameter');\n        }\n        if (pattern.start.length === 0) {\n          return err('Replacement pattern has empty `start` parameter');\n        }\n        return Result.value({\n          type: 'inline-command',\n          start: '',\n          end: pattern.start,\n          cmd: 'mceInsertContent',\n          value: pattern.replacement\n        });\n      } else {\n        if (pattern.start.length === 0) {\n          return err('Block pattern has empty `start` parameter');\n        }\n        return formatOrCmd('Block', formats => ({\n          type: 'block-format',\n          start: pattern.start,\n          format: formats[0]\n        }), (command, commandValue) => ({\n          type: 'block-command',\n          start: pattern.start,\n          cmd: command,\n          value: commandValue\n        }));\n      }\n    };\n    const getBlockPatterns = patterns => sortPatterns(filter$6(patterns, isBlockPattern));\n    const getInlinePatterns = patterns => filter$6(patterns, isInlinePattern);\n    const createPatternSet = patterns => ({\n      inlinePatterns: getInlinePatterns(patterns),\n      blockPatterns: getBlockPatterns(patterns)\n    });\n    const fromRawPatterns = patterns => {\n      const normalized = partition$1(map$3(patterns, normalizePattern));\n      each$g(normalized.errors, err => console.error(err.message, err.pattern));\n      return normalized.values;\n    };\n\n    const deviceDetection$1 = detect$2().deviceType;\n    const isTouch = deviceDetection$1.isTouch();\n    const DOM$a = DOMUtils.DOM;\n    const getHash = value => {\n      const items = value.indexOf('=') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(',');\n      return foldl(items, (output, item) => {\n        const arr = item.split('=');\n        const key = arr[0];\n        const val = arr.length > 1 ? arr[1] : key;\n        output[trim$3(key)] = trim$3(val);\n        return output;\n      }, {});\n    };\n    const isRegExp = x => is$4(x, RegExp);\n    const option = name => editor => editor.options.get(name);\n    const stringOrObjectProcessor = value => isString(value) || isObject(value);\n    const bodyOptionProcessor = (editor, defaultValue = '') => value => {\n      const valid = isString(value);\n      if (valid) {\n        if (value.indexOf('=') !== -1) {\n          const bodyObj = getHash(value);\n          return {\n            value: get$a(bodyObj, editor.id).getOr(defaultValue),\n            valid\n          };\n        } else {\n          return {\n            value,\n            valid\n          };\n        }\n      } else {\n        return {\n          valid: false,\n          message: 'Must be a string.'\n        };\n      }\n    };\n    const register$7 = editor => {\n      const registerOption = editor.options.register;\n      registerOption('id', {\n        processor: 'string',\n        default: editor.id\n      });\n      registerOption('selector', { processor: 'string' });\n      registerOption('target', { processor: 'object' });\n      registerOption('suffix', { processor: 'string' });\n      registerOption('cache_suffix', { processor: 'string' });\n      registerOption('base_url', { processor: 'string' });\n      registerOption('referrer_policy', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('language_load', { processor: 'boolean' });\n      registerOption('inline', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('iframe_attrs', {\n        processor: 'object',\n        default: {}\n      });\n      registerOption('doctype', {\n        processor: 'string',\n        default: '<!DOCTYPE html>'\n      });\n      registerOption('document_base_url', {\n        processor: 'string',\n        default: editor.documentBaseUrl\n      });\n      registerOption('body_id', {\n        processor: bodyOptionProcessor(editor, 'tinymce'),\n        default: 'tinymce'\n      });\n      registerOption('body_class', {\n        processor: bodyOptionProcessor(editor),\n        default: ''\n      });\n      registerOption('content_security_policy', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('br_in_pre', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('forced_root_block', {\n        processor: value => {\n          const valid = isString(value) && isNotEmpty(value);\n          if (valid) {\n            return {\n              value,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a non-empty string.'\n            };\n          }\n        },\n        default: 'p'\n      });\n      registerOption('forced_root_block_attrs', {\n        processor: 'object',\n        default: {}\n      });\n      registerOption('br_newline_selector', {\n        processor: 'string',\n        default: '.mce-toc h2,figcaption,caption'\n      });\n      registerOption('no_newline_selector', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('keep_styles', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('end_container_on_empty_block', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('font_size_style_values', {\n        processor: 'string',\n        default: 'xx-small,x-small,small,medium,large,x-large,xx-large'\n      });\n      registerOption('font_size_legacy_values', {\n        processor: 'string',\n        default: 'xx-small,small,medium,large,x-large,xx-large,300%'\n      });\n      registerOption('font_size_classes', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('automatic_uploads', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('images_reuse_filename', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('images_replace_blob_uris', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('icons', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('icons_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_base_path', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_base_path', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_credentials', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('images_upload_handler', { processor: 'function' });\n      registerOption('language', {\n        processor: 'string',\n        default: 'en'\n      });\n      registerOption('language_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('entity_encoding', {\n        processor: 'string',\n        default: 'named'\n      });\n      registerOption('indent', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('indent_before', {\n        processor: 'string',\n        default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\n      });\n      registerOption('indent_after', {\n        processor: 'string',\n        default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\n      });\n      registerOption('indent_use_margin', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('indentation', {\n        processor: 'string',\n        default: '40px'\n      });\n      registerOption('content_css', {\n        processor: value => {\n          const valid = value === false || isString(value) || isArrayOf(value, isString);\n          if (valid) {\n            if (isString(value)) {\n              return {\n                value: map$3(value.split(','), trim$3),\n                valid\n              };\n            } else if (isArray$1(value)) {\n              return {\n                value,\n                valid\n              };\n            } else if (value === false) {\n              return {\n                value: [],\n                valid\n              };\n            } else {\n              return {\n                value,\n                valid\n              };\n            }\n          } else {\n            return {\n              valid: false,\n              message: 'Must be false, a string or an array of strings.'\n            };\n          }\n        },\n        default: isInline(editor) ? [] : ['default']\n      });\n      registerOption('content_style', { processor: 'string' });\n      registerOption('content_css_cors', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('font_css', {\n        processor: value => {\n          const valid = isString(value) || isArrayOf(value, isString);\n          if (valid) {\n            const newValue = isArray$1(value) ? value : map$3(value.split(','), trim$3);\n            return {\n              value: newValue,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a string or an array of strings.'\n            };\n          }\n        },\n        default: []\n      });\n      registerOption('inline_boundaries', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('inline_boundaries_selector', {\n        processor: 'string',\n        default: 'a[href],code,.mce-annotation'\n      });\n      registerOption('object_resizing', {\n        processor: value => {\n          const valid = isBoolean(value) || isString(value);\n          if (valid) {\n            if (value === false || deviceDetection$1.isiPhone() || deviceDetection$1.isiPad()) {\n              return {\n                value: '',\n                valid\n              };\n            } else {\n              return {\n                value: value === true ? 'table,img,figure.image,div,video,iframe' : value,\n                valid\n              };\n            }\n          } else {\n            return {\n              valid: false,\n              message: 'Must be boolean or a string'\n            };\n          }\n        },\n        default: !isTouch\n      });\n      registerOption('resize_img_proportional', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('event_root', { processor: 'object' });\n      registerOption('service_message', { processor: 'string' });\n      registerOption('theme', {\n        processor: value => value === false || isString(value) || isFunction(value),\n        default: 'silver'\n      });\n      registerOption('theme_url', { processor: 'string' });\n      registerOption('formats', { processor: 'object' });\n      registerOption('format_empty_lines', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('preview_styles', {\n        processor: value => {\n          const valid = value === false || isString(value);\n          if (valid) {\n            return {\n              value: value === false ? '' : value,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be false or a string'\n            };\n          }\n        },\n        default: 'font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow'\n      });\n      registerOption('custom_ui_selector', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('hidden_input', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('submit_patch', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('encoding', { processor: 'string' });\n      registerOption('add_form_submit_trigger', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('add_unload_trigger', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('custom_undo_redo_levels', {\n        processor: 'number',\n        default: 0\n      });\n      registerOption('disable_nodechange', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('readonly', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('plugins', {\n        processor: 'string[]',\n        default: []\n      });\n      registerOption('external_plugins', { processor: 'object' });\n      registerOption('forced_plugins', { processor: 'string[]' });\n      registerOption('model', {\n        processor: 'string',\n        default: editor.hasPlugin('rtc') ? 'plugin' : 'dom'\n      });\n      registerOption('model_url', { processor: 'string' });\n      registerOption('block_unsupported_drop', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('visual', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('visual_table_class', {\n        processor: 'string',\n        default: 'mce-item-table'\n      });\n      registerOption('visual_anchor_class', {\n        processor: 'string',\n        default: 'mce-item-anchor'\n      });\n      registerOption('iframe_aria_text', {\n        processor: 'string',\n        default: 'Rich Text Area. Press ALT-0 for help.'\n      });\n      registerOption('setup', { processor: 'function' });\n      registerOption('init_instance_callback', { processor: 'function' });\n      registerOption('url_converter', {\n        processor: 'function',\n        default: editor.convertURL\n      });\n      registerOption('url_converter_scope', {\n        processor: 'object',\n        default: editor\n      });\n      registerOption('urlconverter_callback', { processor: 'function' });\n      registerOption('allow_conditional_comments', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_html_data_urls', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_svg_data_urls', { processor: 'boolean' });\n      registerOption('allow_html_in_named_anchor', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_script_urls', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_unsafe_link_target', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('convert_fonts_to_spans', {\n        processor: 'boolean',\n        default: true,\n        deprecated: true\n      });\n      registerOption('fix_list_elements', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('preserve_cdata', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('remove_trailing_brs', { processor: 'boolean' });\n      registerOption('inline_styles', {\n        processor: 'boolean',\n        default: true,\n        deprecated: true\n      });\n      registerOption('element_format', {\n        processor: 'string',\n        default: 'html'\n      });\n      registerOption('entities', { processor: 'string' });\n      registerOption('schema', {\n        processor: 'string',\n        default: 'html5'\n      });\n      registerOption('convert_urls', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('relative_urls', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('remove_script_host', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('custom_elements', { processor: 'string' });\n      registerOption('extended_valid_elements', { processor: 'string' });\n      registerOption('invalid_elements', { processor: 'string' });\n      registerOption('invalid_styles', { processor: stringOrObjectProcessor });\n      registerOption('valid_children', { processor: 'string' });\n      registerOption('valid_classes', { processor: stringOrObjectProcessor });\n      registerOption('valid_elements', { processor: 'string' });\n      registerOption('valid_styles', { processor: stringOrObjectProcessor });\n      registerOption('verify_html', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('auto_focus', { processor: value => isString(value) || value === true });\n      registerOption('browser_spellcheck', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('protect', { processor: 'array' });\n      registerOption('images_file_types', {\n        processor: 'string',\n        default: 'jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp'\n      });\n      registerOption('deprecation_warnings', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('a11y_advanced_options', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('api_key', { processor: 'string' });\n      registerOption('paste_block_drop', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('paste_data_images', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_preprocess', { processor: 'function' });\n      registerOption('paste_postprocess', { processor: 'function' });\n      registerOption('paste_webkit_styles', {\n        processor: 'string',\n        default: 'none'\n      });\n      registerOption('paste_remove_styles_if_webkit', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_merge_formats', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('smart_paste', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_as_text', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('paste_tab_spaces', {\n        processor: 'number',\n        default: 4\n      });\n      registerOption('text_patterns', {\n        processor: value => {\n          if (isArrayOf(value, isObject) || value === false) {\n            const patterns = value === false ? [] : value;\n            return {\n              value: fromRawPatterns(patterns),\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be an array of objects or false.'\n            };\n          }\n        },\n        default: [\n          {\n            start: '*',\n            end: '*',\n            format: 'italic'\n          },\n          {\n            start: '**',\n            end: '**',\n            format: 'bold'\n          },\n          {\n            start: '#',\n            format: 'h1'\n          },\n          {\n            start: '##',\n            format: 'h2'\n          },\n          {\n            start: '###',\n            format: 'h3'\n          },\n          {\n            start: '####',\n            format: 'h4'\n          },\n          {\n            start: '#####',\n            format: 'h5'\n          },\n          {\n            start: '######',\n            format: 'h6'\n          },\n          {\n            start: '1. ',\n            cmd: 'InsertOrderedList'\n          },\n          {\n            start: '* ',\n            cmd: 'InsertUnorderedList'\n          },\n          {\n            start: '- ',\n            cmd: 'InsertUnorderedList'\n          }\n        ]\n      });\n      registerOption('noneditable_class', {\n        processor: 'string',\n        default: 'mceNonEditable'\n      });\n      registerOption('editable_class', {\n        processor: 'string',\n        default: 'mceEditable'\n      });\n      registerOption('noneditable_regexp', {\n        processor: value => {\n          if (isArrayOf(value, isRegExp)) {\n            return {\n              value,\n              valid: true\n            };\n          } else if (isRegExp(value)) {\n            return {\n              value: [value],\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a RegExp or an array of RegExp.'\n            };\n          }\n        },\n        default: []\n      });\n      registerOption('table_tab_navigation', {\n        processor: 'boolean',\n        default: true\n      });\n      editor.on('ScriptsLoaded', () => {\n        registerOption('directionality', {\n          processor: 'string',\n          default: I18n.isRtl() ? 'rtl' : undefined\n        });\n        registerOption('placeholder', {\n          processor: 'string',\n          default: DOM$a.getAttrib(editor.getElement(), 'placeholder')\n        });\n      });\n    };\n    const getIframeAttrs = option('iframe_attrs');\n    const getDocType = option('doctype');\n    const getDocumentBaseUrl = option('document_base_url');\n    const getBodyId = option('body_id');\n    const getBodyClass = option('body_class');\n    const getContentSecurityPolicy = option('content_security_policy');\n    const shouldPutBrInPre$1 = option('br_in_pre');\n    const getForcedRootBlock = option('forced_root_block');\n    const getForcedRootBlockAttrs = option('forced_root_block_attrs');\n    const getBrNewLineSelector = option('br_newline_selector');\n    const getNoNewLineSelector = option('no_newline_selector');\n    const shouldKeepStyles = option('keep_styles');\n    const shouldEndContainerOnEmptyBlock = option('end_container_on_empty_block');\n    const isAutomaticUploadsEnabled = option('automatic_uploads');\n    const shouldReuseFileName = option('images_reuse_filename');\n    const shouldReplaceBlobUris = option('images_replace_blob_uris');\n    const getIconPackName = option('icons');\n    const getIconsUrl = option('icons_url');\n    const getImageUploadUrl = option('images_upload_url');\n    const getImageUploadBasePath = option('images_upload_base_path');\n    const getImagesUploadCredentials = option('images_upload_credentials');\n    const getImagesUploadHandler = option('images_upload_handler');\n    const shouldUseContentCssCors = option('content_css_cors');\n    const getReferrerPolicy = option('referrer_policy');\n    const getLanguageCode = option('language');\n    const getLanguageUrl = option('language_url');\n    const shouldIndentUseMargin = option('indent_use_margin');\n    const getIndentation = option('indentation');\n    const getContentCss = option('content_css');\n    const getContentStyle = option('content_style');\n    const getFontCss = option('font_css');\n    const getDirectionality = option('directionality');\n    const getInlineBoundarySelector = option('inline_boundaries_selector');\n    const getObjectResizing = option('object_resizing');\n    const getResizeImgProportional = option('resize_img_proportional');\n    const getPlaceholder = option('placeholder');\n    const getEventRoot = option('event_root');\n    const getServiceMessage = option('service_message');\n    const getTheme = option('theme');\n    const getThemeUrl = option('theme_url');\n    const getModel = option('model');\n    const getModelUrl = option('model_url');\n    const isInlineBoundariesEnabled = option('inline_boundaries');\n    const getFormats = option('formats');\n    const getPreviewStyles = option('preview_styles');\n    const canFormatEmptyLines = option('format_empty_lines');\n    const getCustomUiSelector = option('custom_ui_selector');\n    const isInline = option('inline');\n    const hasHiddenInput = option('hidden_input');\n    const shouldPatchSubmit = option('submit_patch');\n    const shouldAddFormSubmitTrigger = option('add_form_submit_trigger');\n    const shouldAddUnloadTrigger = option('add_unload_trigger');\n    const getCustomUndoRedoLevels = option('custom_undo_redo_levels');\n    const shouldDisableNodeChange = option('disable_nodechange');\n    const isReadOnly$1 = option('readonly');\n    const hasContentCssCors = option('content_css_cors');\n    const getPlugins = option('plugins');\n    const getExternalPlugins$1 = option('external_plugins');\n    const shouldBlockUnsupportedDrop = option('block_unsupported_drop');\n    const isVisualAidsEnabled = option('visual');\n    const getVisualAidsTableClass = option('visual_table_class');\n    const getVisualAidsAnchorClass = option('visual_anchor_class');\n    const getIframeAriaText = option('iframe_aria_text');\n    const getSetupCallback = option('setup');\n    const getInitInstanceCallback = option('init_instance_callback');\n    const getUrlConverterCallback = option('urlconverter_callback');\n    const getAutoFocus = option('auto_focus');\n    const shouldBrowserSpellcheck = option('browser_spellcheck');\n    const getProtect = option('protect');\n    const shouldPasteBlockDrop = option('paste_block_drop');\n    const shouldPasteDataImages = option('paste_data_images');\n    const getPastePreProcess = option('paste_preprocess');\n    const getPastePostProcess = option('paste_postprocess');\n    const getPasteWebkitStyles = option('paste_webkit_styles');\n    const shouldPasteRemoveWebKitStyles = option('paste_remove_styles_if_webkit');\n    const shouldPasteMergeFormats = option('paste_merge_formats');\n    const isSmartPasteEnabled = option('smart_paste');\n    const isPasteAsTextEnabled = option('paste_as_text');\n    const getPasteTabSpaces = option('paste_tab_spaces');\n    const shouldAllowHtmlDataUrls = option('allow_html_data_urls');\n    const getTextPatterns = option('text_patterns');\n    const getNonEditableClass = option('noneditable_class');\n    const getEditableClass = option('editable_class');\n    const getNonEditableRegExps = option('noneditable_regexp');\n    const getFontStyleValues = editor => Tools.explode(editor.options.get('font_size_style_values'));\n    const getFontSizeClasses = editor => Tools.explode(editor.options.get('font_size_classes'));\n    const isEncodingXml = editor => editor.options.get('encoding') === 'xml';\n    const getAllowedImageFileTypes = editor => Tools.explode(editor.options.get('images_file_types'));\n    const hasTableTabNavigation = option('table_tab_navigation');\n\n    const isElement$3 = isElement$6;\n    const isText$3 = isText$8;\n    const removeNode$1 = node => {\n      const parentNode = node.parentNode;\n      if (parentNode) {\n        parentNode.removeChild(node);\n      }\n    };\n    const trimCount = text => {\n      const trimmedText = trim$1(text);\n      return {\n        count: text.length - trimmedText.length,\n        text: trimmedText\n      };\n    };\n    const deleteZwspChars = caretContainer => {\n      let idx;\n      while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) {\n        caretContainer.deleteData(idx, 1);\n      }\n    };\n    const removeUnchanged = (caretContainer, pos) => {\n      remove$4(caretContainer);\n      return pos;\n    };\n    const removeTextAndReposition = (caretContainer, pos) => {\n      const before = trimCount(caretContainer.data.substr(0, pos.offset()));\n      const after = trimCount(caretContainer.data.substr(pos.offset()));\n      const text = before.text + after.text;\n      if (text.length > 0) {\n        deleteZwspChars(caretContainer);\n        return CaretPosition(caretContainer, pos.offset() - before.count);\n      } else {\n        return pos;\n      }\n    };\n    const removeElementAndReposition = (caretContainer, pos) => {\n      const parentNode = pos.container();\n      const newPosition = indexOf$1(from(parentNode.childNodes), caretContainer).map(index => {\n        return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;\n      }).getOr(pos);\n      remove$4(caretContainer);\n      return newPosition;\n    };\n    const removeTextCaretContainer = (caretContainer, pos) => isText$3(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\n    const removeElementCaretContainer = (caretContainer, pos) => pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\n    const removeAndReposition = (container, pos) => CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);\n    const remove$4 = caretContainerNode => {\n      if (isElement$3(caretContainerNode) && isCaretContainer$2(caretContainerNode)) {\n        if (hasContent(caretContainerNode)) {\n          caretContainerNode.removeAttribute('data-mce-caret');\n        } else {\n          removeNode$1(caretContainerNode);\n        }\n      }\n      if (isText$3(caretContainerNode)) {\n        deleteZwspChars(caretContainerNode);\n        if (caretContainerNode.data.length === 0) {\n          removeNode$1(caretContainerNode);\n        }\n      }\n    };\n\n    const isContentEditableFalse$7 = isContentEditableFalse$a;\n    const isMedia$1 = isMedia$2;\n    const isTableCell$3 = isTableCell$5;\n    const inlineFakeCaretSelector = '*[contentEditable=false],video,audio,embed,object';\n    const getAbsoluteClientRect = (root, element, before) => {\n      const clientRect = collapse(element.getBoundingClientRect(), before);\n      let scrollX;\n      let scrollY;\n      if (root.tagName === 'BODY') {\n        const docElm = root.ownerDocument.documentElement;\n        scrollX = root.scrollLeft || docElm.scrollLeft;\n        scrollY = root.scrollTop || docElm.scrollTop;\n      } else {\n        const rootRect = root.getBoundingClientRect();\n        scrollX = root.scrollLeft - rootRect.left;\n        scrollY = root.scrollTop - rootRect.top;\n      }\n      clientRect.left += scrollX;\n      clientRect.right += scrollX;\n      clientRect.top += scrollY;\n      clientRect.bottom += scrollY;\n      clientRect.width = 1;\n      let margin = element.offsetWidth - element.clientWidth;\n      if (margin > 0) {\n        if (before) {\n          margin *= -1;\n        }\n        clientRect.left += margin;\n        clientRect.right += margin;\n      }\n      return clientRect;\n    };\n    const trimInlineCaretContainers = root => {\n      const fakeCaretTargetNodes = descendants(SugarElement.fromDom(root), inlineFakeCaretSelector);\n      for (let i = 0; i < fakeCaretTargetNodes.length; i++) {\n        const node = fakeCaretTargetNodes[i].dom;\n        let sibling = node.previousSibling;\n        if (endsWithCaretContainer$1(sibling)) {\n          const data = sibling.data;\n          if (data.length === 1) {\n            sibling.parentNode.removeChild(sibling);\n          } else {\n            sibling.deleteData(data.length - 1, 1);\n          }\n        }\n        sibling = node.nextSibling;\n        if (startsWithCaretContainer$1(sibling)) {\n          const data = sibling.data;\n          if (data.length === 1) {\n            sibling.parentNode.removeChild(sibling);\n          } else {\n            sibling.deleteData(0, 1);\n          }\n        }\n      }\n    };\n    const FakeCaret = (editor, root, isBlock, hasFocus) => {\n      const lastVisualCaret = value$2();\n      let cursorInterval;\n      let caretContainerNode;\n      const caretBlock = getForcedRootBlock(editor);\n      const dom = editor.dom;\n      const show = (before, element) => {\n        let rng;\n        hide();\n        if (isTableCell$3(element)) {\n          return null;\n        }\n        if (isBlock(element)) {\n          caretContainerNode = insertBlock(caretBlock, element, before);\n          const clientRect = getAbsoluteClientRect(root, element, before);\n          dom.setStyle(caretContainerNode, 'top', clientRect.top);\n          const caret = dom.create('div', {\n            'class': 'mce-visual-caret',\n            'data-mce-bogus': 'all'\n          });\n          dom.setStyles(caret, { ...clientRect });\n          dom.add(root, caret);\n          lastVisualCaret.set({\n            caret,\n            element,\n            before\n          });\n          if (before) {\n            dom.addClass(caret, 'mce-visual-caret-before');\n          }\n          startBlink();\n          rng = element.ownerDocument.createRange();\n          rng.setStart(caretContainerNode, 0);\n          rng.setEnd(caretContainerNode, 0);\n        } else {\n          caretContainerNode = insertInline$1(element, before);\n          rng = element.ownerDocument.createRange();\n          if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {\n            rng.setStart(caretContainerNode, 0);\n            rng.setEnd(caretContainerNode, 0);\n          } else {\n            rng.setStart(caretContainerNode, 1);\n            rng.setEnd(caretContainerNode, 1);\n          }\n          return rng;\n        }\n        return rng;\n      };\n      const hide = () => {\n        trimInlineCaretContainers(root);\n        if (caretContainerNode) {\n          remove$4(caretContainerNode);\n          caretContainerNode = null;\n        }\n        lastVisualCaret.on(caretState => {\n          dom.remove(caretState.caret);\n          lastVisualCaret.clear();\n        });\n        if (cursorInterval) {\n          clearInterval(cursorInterval);\n          cursorInterval = undefined;\n        }\n      };\n      const startBlink = () => {\n        cursorInterval = setInterval(() => {\n          lastVisualCaret.on(caretState => {\n            if (hasFocus()) {\n              dom.toggleClass(caretState.caret, 'mce-visual-caret-hidden');\n            } else {\n              dom.addClass(caretState.caret, 'mce-visual-caret-hidden');\n            }\n          });\n        }, 500);\n      };\n      const reposition = () => {\n        lastVisualCaret.on(caretState => {\n          const clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);\n          dom.setStyles(caretState.caret, { ...clientRect });\n        });\n      };\n      const destroy = () => clearInterval(cursorInterval);\n      const getCss = () => '.mce-visual-caret {' + 'position: absolute;' + 'background-color: black;' + 'background-color: currentcolor;' + '}' + '.mce-visual-caret-hidden {' + 'display: none;' + '}' + '*[data-mce-caret] {' + 'position: absolute;' + 'left: -1000px;' + 'right: auto;' + 'top: 0;' + 'margin: 0;' + 'padding: 0;' + '}';\n      return {\n        show,\n        hide,\n        getCss,\n        reposition,\n        destroy\n      };\n    };\n    const isFakeCaretTableBrowser = () => Env.browser.isFirefox();\n    const isInlineFakeCaretTarget = node => isContentEditableFalse$7(node) || isMedia$1(node);\n    const isFakeCaretTarget = node => isInlineFakeCaretTarget(node) || isTable$3(node) && isFakeCaretTableBrowser();\n\n    const isContentEditableTrue$2 = isContentEditableTrue$4;\n    const isContentEditableFalse$6 = isContentEditableFalse$a;\n    const isMedia = isMedia$2;\n    const isBlockLike = matchStyleValues('display', 'block table table-cell table-caption list-item');\n    const isCaretContainer = isCaretContainer$2;\n    const isCaretContainerBlock = isCaretContainerBlock$1;\n    const isElement$2 = isElement$6;\n    const isCaretCandidate$1 = isCaretCandidate$3;\n    const isForwards = direction => direction > 0;\n    const isBackwards = direction => direction < 0;\n    const skipCaretContainers = (walk, shallow) => {\n      let node;\n      while (node = walk(shallow)) {\n        if (!isCaretContainerBlock(node)) {\n          return node;\n        }\n      }\n      return null;\n    };\n    const findNode = (node, direction, predicateFn, rootNode, shallow) => {\n      const walker = new DomTreeWalker(node, rootNode);\n      const isCefOrCaretContainer = isContentEditableFalse$6(node) || isCaretContainerBlock(node);\n      if (isBackwards(direction)) {\n        if (isCefOrCaretContainer) {\n          node = skipCaretContainers(walker.prev.bind(walker), true);\n          if (predicateFn(node)) {\n            return node;\n          }\n        }\n        while (node = skipCaretContainers(walker.prev.bind(walker), shallow)) {\n          if (predicateFn(node)) {\n            return node;\n          }\n        }\n      }\n      if (isForwards(direction)) {\n        if (isCefOrCaretContainer) {\n          node = skipCaretContainers(walker.next.bind(walker), true);\n          if (predicateFn(node)) {\n            return node;\n          }\n        }\n        while (node = skipCaretContainers(walker.next.bind(walker), shallow)) {\n          if (predicateFn(node)) {\n            return node;\n          }\n        }\n      }\n      return null;\n    };\n    const getEditingHost = (node, rootNode) => {\n      const isCETrue = node => isContentEditableTrue$2(node.dom);\n      const isRoot = node => node.dom === rootNode;\n      return ancestor$3(SugarElement.fromDom(node), isCETrue, isRoot).map(elm => elm.dom).getOr(rootNode);\n    };\n    const getParentBlock$3 = (node, rootNode) => {\n      while (node && node !== rootNode) {\n        if (isBlockLike(node)) {\n          return node;\n        }\n        node = node.parentNode;\n      }\n      return null;\n    };\n    const isInSameBlock = (caretPosition1, caretPosition2, rootNode) => getParentBlock$3(caretPosition1.container(), rootNode) === getParentBlock$3(caretPosition2.container(), rootNode);\n    const getChildNodeAtRelativeOffset = (relativeOffset, caretPosition) => {\n      if (!caretPosition) {\n        return null;\n      }\n      const container = caretPosition.container();\n      const offset = caretPosition.offset();\n      if (!isElement$2(container)) {\n        return null;\n      }\n      return container.childNodes[offset + relativeOffset];\n    };\n    const beforeAfter = (before, node) => {\n      const range = node.ownerDocument.createRange();\n      if (before) {\n        range.setStartBefore(node);\n        range.setEndBefore(node);\n      } else {\n        range.setStartAfter(node);\n        range.setEndAfter(node);\n      }\n      return range;\n    };\n    const isNodesInSameBlock = (root, node1, node2) => getParentBlock$3(node1, root) === getParentBlock$3(node2, root);\n    const lean = (left, root, node) => {\n      const siblingName = left ? 'previousSibling' : 'nextSibling';\n      while (node && node !== root) {\n        let sibling = node[siblingName];\n        if (isCaretContainer(sibling)) {\n          sibling = sibling[siblingName];\n        }\n        if (isContentEditableFalse$6(sibling) || isMedia(sibling)) {\n          if (isNodesInSameBlock(root, sibling, node)) {\n            return sibling;\n          }\n          break;\n        }\n        if (isCaretCandidate$1(sibling)) {\n          break;\n        }\n        node = node.parentNode;\n      }\n      return null;\n    };\n    const before$2 = curry(beforeAfter, true);\n    const after$2 = curry(beforeAfter, false);\n    const normalizeRange = (direction, root, range) => {\n      let node;\n      const leanLeft = curry(lean, true, root);\n      const leanRight = curry(lean, false, root);\n      let container = range.startContainer;\n      const offset = range.startOffset;\n      if (isCaretContainerBlock$1(container)) {\n        if (!isElement$2(container)) {\n          container = container.parentNode;\n        }\n        const location = container.getAttribute('data-mce-caret');\n        if (location === 'before') {\n          node = container.nextSibling;\n          if (isFakeCaretTarget(node)) {\n            return before$2(node);\n          }\n        }\n        if (location === 'after') {\n          node = container.previousSibling;\n          if (isFakeCaretTarget(node)) {\n            return after$2(node);\n          }\n        }\n      }\n      if (!range.collapsed) {\n        return range;\n      }\n      if (isText$8(container)) {\n        if (isCaretContainer(container)) {\n          if (direction === 1) {\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n          }\n          if (direction === -1) {\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n          }\n          return range;\n        }\n        if (endsWithCaretContainer$1(container) && offset >= container.data.length - 1) {\n          if (direction === 1) {\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n          }\n          return range;\n        }\n        if (startsWithCaretContainer$1(container) && offset <= 1) {\n          if (direction === -1) {\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n          }\n          return range;\n        }\n        if (offset === container.data.length) {\n          node = leanRight(container);\n          if (node) {\n            return before$2(node);\n          }\n          return range;\n        }\n        if (offset === 0) {\n          node = leanLeft(container);\n          if (node) {\n            return after$2(node);\n          }\n          return range;\n        }\n      }\n      return range;\n    };\n    const getRelativeCefElm = (forward, caretPosition) => Optional.from(getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition)).filter(isContentEditableFalse$6);\n    const getNormalizedRangeEndPoint = (direction, root, range) => {\n      const normalizedRange = normalizeRange(direction, root, range);\n      if (direction === -1) {\n        return CaretPosition.fromRangeStart(normalizedRange);\n      }\n      return CaretPosition.fromRangeEnd(normalizedRange);\n    };\n    const getElementFromPosition = pos => Optional.from(pos.getNode()).map(SugarElement.fromDom);\n    const getElementFromPrevPosition = pos => Optional.from(pos.getNode(true)).map(SugarElement.fromDom);\n    const getVisualCaretPosition = (walkFn, caretPosition) => {\n      while (caretPosition = walkFn(caretPosition)) {\n        if (caretPosition.isVisible()) {\n          return caretPosition;\n        }\n      }\n      return caretPosition;\n    };\n    const isMoveInsideSameBlock = (from, to) => {\n      const inSameBlock = isInSameBlock(from, to);\n      if (!inSameBlock && isBr$5(from.getNode())) {\n        return true;\n      }\n      return inSameBlock;\n    };\n\n    var HDirection;\n    (function (HDirection) {\n      HDirection[HDirection['Backwards'] = -1] = 'Backwards';\n      HDirection[HDirection['Forwards'] = 1] = 'Forwards';\n    }(HDirection || (HDirection = {})));\n    const isContentEditableFalse$5 = isContentEditableFalse$a;\n    const isText$2 = isText$8;\n    const isElement$1 = isElement$6;\n    const isBr$1 = isBr$5;\n    const isCaretCandidate = isCaretCandidate$3;\n    const isAtomic = isAtomic$1;\n    const isEditableCaretCandidate = isEditableCaretCandidate$1;\n    const getParents$3 = (node, root) => {\n      const parents = [];\n      while (node && node !== root) {\n        parents.push(node);\n        node = node.parentNode;\n      }\n      return parents;\n    };\n    const nodeAtIndex = (container, offset) => {\n      if (container.hasChildNodes() && offset < container.childNodes.length) {\n        return container.childNodes[offset];\n      }\n      return null;\n    };\n    const getCaretCandidatePosition = (direction, node) => {\n      if (isForwards(direction)) {\n        if (isCaretCandidate(node.previousSibling) && !isText$2(node.previousSibling)) {\n          return CaretPosition.before(node);\n        }\n        if (isText$2(node)) {\n          return CaretPosition(node, 0);\n        }\n      }\n      if (isBackwards(direction)) {\n        if (isCaretCandidate(node.nextSibling) && !isText$2(node.nextSibling)) {\n          return CaretPosition.after(node);\n        }\n        if (isText$2(node)) {\n          return CaretPosition(node, node.data.length);\n        }\n      }\n      if (isBackwards(direction)) {\n        if (isBr$1(node)) {\n          return CaretPosition.before(node);\n        }\n        return CaretPosition.after(node);\n      }\n      return CaretPosition.before(node);\n    };\n    const moveForwardFromBr = (root, nextNode) => {\n      const nextSibling = nextNode.nextSibling;\n      if (nextSibling && isCaretCandidate(nextSibling)) {\n        if (isText$2(nextSibling)) {\n          return CaretPosition(nextSibling, 0);\n        } else {\n          return CaretPosition.before(nextSibling);\n        }\n      } else {\n        return findCaretPosition$1(HDirection.Forwards, CaretPosition.after(nextNode), root);\n      }\n    };\n    const findCaretPosition$1 = (direction, startPos, root) => {\n      let node;\n      let nextNode;\n      let innerNode;\n      let caretPosition;\n      if (!isElement$1(root) || !startPos) {\n        return null;\n      }\n      if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {\n        caretPosition = CaretPosition.after(root.lastChild);\n        if (isBackwards(direction) && isCaretCandidate(root.lastChild) && isElement$1(root.lastChild)) {\n          return isBr$1(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;\n        }\n      } else {\n        caretPosition = startPos;\n      }\n      const container = caretPosition.container();\n      let offset = caretPosition.offset();\n      if (isText$2(container)) {\n        if (isBackwards(direction) && offset > 0) {\n          return CaretPosition(container, --offset);\n        }\n        if (isForwards(direction) && offset < container.length) {\n          return CaretPosition(container, ++offset);\n        }\n        node = container;\n      } else {\n        if (isBackwards(direction) && offset > 0) {\n          nextNode = nodeAtIndex(container, offset - 1);\n          if (isCaretCandidate(nextNode)) {\n            if (!isAtomic(nextNode)) {\n              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\n              if (innerNode) {\n                if (isText$2(innerNode)) {\n                  return CaretPosition(innerNode, innerNode.data.length);\n                }\n                return CaretPosition.after(innerNode);\n              }\n            }\n            if (isText$2(nextNode)) {\n              return CaretPosition(nextNode, nextNode.data.length);\n            }\n            return CaretPosition.before(nextNode);\n          }\n        }\n        if (isForwards(direction) && offset < container.childNodes.length) {\n          nextNode = nodeAtIndex(container, offset);\n          if (isCaretCandidate(nextNode)) {\n            if (isBr$1(nextNode)) {\n              return moveForwardFromBr(root, nextNode);\n            }\n            if (!isAtomic(nextNode)) {\n              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\n              if (innerNode) {\n                if (isText$2(innerNode)) {\n                  return CaretPosition(innerNode, 0);\n                }\n                return CaretPosition.before(innerNode);\n              }\n            }\n            if (isText$2(nextNode)) {\n              return CaretPosition(nextNode, 0);\n            }\n            return CaretPosition.after(nextNode);\n          }\n        }\n        node = nextNode ? nextNode : caretPosition.getNode();\n      }\n      if (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart()) {\n        node = findNode(node, direction, always, root, true);\n        if (isEditableCaretCandidate(node, root)) {\n          return getCaretCandidatePosition(direction, node);\n        }\n      }\n      nextNode = findNode(node, direction, isEditableCaretCandidate, root);\n      const rootContentEditableFalseElm = last$2(filter$6(getParents$3(container, root), isContentEditableFalse$5));\n      if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {\n        if (isForwards(direction)) {\n          caretPosition = CaretPosition.after(rootContentEditableFalseElm);\n        } else {\n          caretPosition = CaretPosition.before(rootContentEditableFalseElm);\n        }\n        return caretPosition;\n      }\n      if (nextNode) {\n        return getCaretCandidatePosition(direction, nextNode);\n      }\n      return null;\n    };\n    const CaretWalker = root => ({\n      next: caretPosition => {\n        return findCaretPosition$1(HDirection.Forwards, caretPosition, root);\n      },\n      prev: caretPosition => {\n        return findCaretPosition$1(HDirection.Backwards, caretPosition, root);\n      }\n    });\n\n    const walkToPositionIn = (forward, root, start) => {\n      const position = forward ? CaretPosition.before(start) : CaretPosition.after(start);\n      return fromPosition(forward, root, position);\n    };\n    const afterElement = node => isBr$5(node) ? CaretPosition.before(node) : CaretPosition.after(node);\n    const isBeforeOrStart = position => {\n      if (CaretPosition.isTextPosition(position)) {\n        return position.offset() === 0;\n      } else {\n        return isCaretCandidate$3(position.getNode());\n      }\n    };\n    const isAfterOrEnd = position => {\n      if (CaretPosition.isTextPosition(position)) {\n        const container = position.container();\n        return position.offset() === container.data.length;\n      } else {\n        return isCaretCandidate$3(position.getNode(true));\n      }\n    };\n    const isBeforeAfterSameElement = (from, to) => !CaretPosition.isTextPosition(from) && !CaretPosition.isTextPosition(to) && from.getNode() === to.getNode(true);\n    const isAtBr = position => !CaretPosition.isTextPosition(position) && isBr$5(position.getNode());\n    const shouldSkipPosition = (forward, from, to) => {\n      if (forward) {\n        return !isBeforeAfterSameElement(from, to) && !isAtBr(from) && isAfterOrEnd(from) && isBeforeOrStart(to);\n      } else {\n        return !isBeforeAfterSameElement(to, from) && isBeforeOrStart(from) && isAfterOrEnd(to);\n      }\n    };\n    const fromPosition = (forward, root, pos) => {\n      const walker = CaretWalker(root);\n      return Optional.from(forward ? walker.next(pos) : walker.prev(pos));\n    };\n    const navigate = (forward, root, from) => fromPosition(forward, root, from).bind(to => {\n      if (isInSameBlock(from, to, root) && shouldSkipPosition(forward, from, to)) {\n        return fromPosition(forward, root, to);\n      } else {\n        return Optional.some(to);\n      }\n    });\n    const navigateIgnore = (forward, root, from, ignoreFilter) => navigate(forward, root, from).bind(pos => ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos));\n    const positionIn = (forward, element) => {\n      const startNode = forward ? element.firstChild : element.lastChild;\n      if (isText$8(startNode)) {\n        return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));\n      } else if (startNode) {\n        if (isCaretCandidate$3(startNode)) {\n          return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));\n        } else {\n          return walkToPositionIn(forward, element, startNode);\n        }\n      } else {\n        return Optional.none();\n      }\n    };\n    const nextPosition = curry(fromPosition, true);\n    const prevPosition = curry(fromPosition, false);\n    const firstPositionIn = curry(positionIn, true);\n    const lastPositionIn = curry(positionIn, false);\n\n    const CARET_ID$1 = '_mce_caret';\n    const isCaretNode = node => isElement$6(node) && node.id === CARET_ID$1;\n    const getParentCaretContainer = (body, node) => {\n      while (node && node !== body) {\n        if (node.id === CARET_ID$1) {\n          return node;\n        }\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    const isStringPathBookmark = bookmark => isString(bookmark.start);\n    const isRangeBookmark = bookmark => has$2(bookmark, 'rng');\n    const isIdBookmark = bookmark => has$2(bookmark, 'id');\n    const isIndexBookmark = bookmark => has$2(bookmark, 'name');\n    const isPathBookmark = bookmark => Tools.isArray(bookmark.start);\n\n    const addBogus = (dom, node) => {\n      if (isElement$6(node) && dom.isBlock(node) && !node.innerHTML) {\n        node.innerHTML = '<br data-mce-bogus=\"1\" />';\n      }\n      return node;\n    };\n    const resolveCaretPositionBookmark = (dom, bookmark) => {\n      let pos;\n      const rng = dom.createRng();\n      pos = resolve$1(dom.getRoot(), bookmark.start);\n      rng.setStart(pos.container(), pos.offset());\n      pos = resolve$1(dom.getRoot(), bookmark.end);\n      rng.setEnd(pos.container(), pos.offset());\n      return rng;\n    };\n    const insertZwsp = (node, rng) => {\n      const textNode = node.ownerDocument.createTextNode(ZWSP$1);\n      node.appendChild(textNode);\n      rng.setStart(textNode, 0);\n      rng.setEnd(textNode, 0);\n    };\n    const isEmpty$1 = node => node.hasChildNodes() === false;\n    const tryFindRangePosition = (node, rng) => lastPositionIn(node).fold(never, pos => {\n      rng.setStart(pos.container(), pos.offset());\n      rng.setEnd(pos.container(), pos.offset());\n      return true;\n    });\n    const padEmptyCaretContainer = (root, node, rng) => {\n      if (isEmpty$1(node) && getParentCaretContainer(root, node)) {\n        insertZwsp(node, rng);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const setEndPoint = (dom, start, bookmark, rng) => {\n      const point = bookmark[start ? 'start' : 'end'];\n      let i, node, offset, children;\n      const root = dom.getRoot();\n      if (point) {\n        offset = point[0];\n        for (node = root, i = point.length - 1; i >= 1; i--) {\n          children = node.childNodes;\n          if (padEmptyCaretContainer(root, node, rng)) {\n            return true;\n          }\n          if (point[i] > children.length - 1) {\n            if (padEmptyCaretContainer(root, node, rng)) {\n              return true;\n            }\n            return tryFindRangePosition(node, rng);\n          }\n          node = children[point[i]];\n        }\n        if (node.nodeType === 3) {\n          offset = Math.min(point[0], node.nodeValue.length);\n        }\n        if (node.nodeType === 1) {\n          offset = Math.min(point[0], node.childNodes.length);\n        }\n        if (start) {\n          rng.setStart(node, offset);\n        } else {\n          rng.setEnd(node, offset);\n        }\n      }\n      return true;\n    };\n    const isValidTextNode = node => isText$8(node) && node.data.length > 0;\n    const restoreEndPoint = (dom, suffix, bookmark) => {\n      let marker = dom.get(bookmark.id + '_' + suffix), node, idx, next, prev;\n      const keep = bookmark.keep;\n      let container, offset;\n      if (marker) {\n        node = marker.parentNode;\n        if (suffix === 'start') {\n          if (!keep) {\n            idx = dom.nodeIndex(marker);\n          } else {\n            if (marker.hasChildNodes()) {\n              node = marker.firstChild;\n              idx = 1;\n            } else if (isValidTextNode(marker.nextSibling)) {\n              node = marker.nextSibling;\n              idx = 0;\n            } else if (isValidTextNode(marker.previousSibling)) {\n              node = marker.previousSibling;\n              idx = marker.previousSibling.data.length;\n            } else {\n              node = marker.parentNode;\n              idx = dom.nodeIndex(marker) + 1;\n            }\n          }\n          container = node;\n          offset = idx;\n        } else {\n          if (!keep) {\n            idx = dom.nodeIndex(marker);\n          } else {\n            if (marker.hasChildNodes()) {\n              node = marker.firstChild;\n              idx = 1;\n            } else if (isValidTextNode(marker.previousSibling)) {\n              node = marker.previousSibling;\n              idx = marker.previousSibling.data.length;\n            } else {\n              node = marker.parentNode;\n              idx = dom.nodeIndex(marker);\n            }\n          }\n          container = node;\n          offset = idx;\n        }\n        if (!keep) {\n          prev = marker.previousSibling;\n          next = marker.nextSibling;\n          Tools.each(Tools.grep(marker.childNodes), node => {\n            if (isText$8(node)) {\n              node.nodeValue = node.nodeValue.replace(/\\uFEFF/g, '');\n            }\n          });\n          while (marker = dom.get(bookmark.id + '_' + suffix)) {\n            dom.remove(marker, true);\n          }\n          if (prev && next && prev.nodeType === next.nodeType && isText$8(prev) && !Env.browser.isOpera()) {\n            idx = prev.nodeValue.length;\n            prev.appendData(next.nodeValue);\n            dom.remove(next);\n            container = prev;\n            offset = idx;\n          }\n        }\n        return Optional.some(CaretPosition(container, offset));\n      } else {\n        return Optional.none();\n      }\n    };\n    const resolvePaths = (dom, bookmark) => {\n      const rng = dom.createRng();\n      if (setEndPoint(dom, true, bookmark, rng) && setEndPoint(dom, false, bookmark, rng)) {\n        return Optional.some(rng);\n      } else {\n        return Optional.none();\n      }\n    };\n    const resolveId = (dom, bookmark) => {\n      const startPos = restoreEndPoint(dom, 'start', bookmark);\n      const endPos = restoreEndPoint(dom, 'end', bookmark);\n      return lift2(startPos, endPos.or(startPos), (spos, epos) => {\n        const rng = dom.createRng();\n        rng.setStart(addBogus(dom, spos.container()), spos.offset());\n        rng.setEnd(addBogus(dom, epos.container()), epos.offset());\n        return rng;\n      });\n    };\n    const resolveIndex = (dom, bookmark) => Optional.from(dom.select(bookmark.name)[bookmark.index]).map(elm => {\n      const rng = dom.createRng();\n      rng.selectNode(elm);\n      return rng;\n    });\n    const resolve = (selection, bookmark) => {\n      const dom = selection.dom;\n      if (bookmark) {\n        if (isPathBookmark(bookmark)) {\n          return resolvePaths(dom, bookmark);\n        } else if (isStringPathBookmark(bookmark)) {\n          return Optional.some(resolveCaretPositionBookmark(dom, bookmark));\n        } else if (isIdBookmark(bookmark)) {\n          return resolveId(dom, bookmark);\n        } else if (isIndexBookmark(bookmark)) {\n          return resolveIndex(dom, bookmark);\n        } else if (isRangeBookmark(bookmark)) {\n          return Optional.some(bookmark.rng);\n        }\n      }\n      return Optional.none();\n    };\n\n    const getBookmark$1 = (selection, type, normalized) => {\n      return getBookmark$2(selection, type, normalized);\n    };\n    const moveToBookmark = (selection, bookmark) => {\n      resolve(selection, bookmark).each(rng => {\n        selection.setRng(rng);\n      });\n    };\n    const isBookmarkNode$1 = node => {\n      return isElement$6(node) && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';\n    };\n\n    const is = expected => actual => expected === actual;\n    const isNbsp = is(nbsp);\n    const isWhiteSpace = chr => chr !== '' && ' \\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\n    const isContent = chr => !isWhiteSpace(chr) && !isNbsp(chr) && !isZwsp$1(chr);\n\n    const hexColour = value => ({ value });\n    const toHex = component => {\n      const hex = component.toString(16);\n      return (hex.length === 1 ? '0' + hex : hex).toUpperCase();\n    };\n    const fromRgba = rgbaColour => {\n      const value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);\n      return hexColour(value);\n    };\n\n    const rgbRegex = /^\\s*rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)\\s*$/i;\n    const rgbaRegex = /^\\s*rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d?(?:\\.\\d+)?)\\s*\\)\\s*$/i;\n    const rgbaColour = (red, green, blue, alpha) => ({\n      red,\n      green,\n      blue,\n      alpha\n    });\n    const fromStringValues = (red, green, blue, alpha) => {\n      const r = parseInt(red, 10);\n      const g = parseInt(green, 10);\n      const b = parseInt(blue, 10);\n      const a = parseFloat(alpha);\n      return rgbaColour(r, g, b, a);\n    };\n    const fromString = rgbaString => {\n      if (rgbaString === 'transparent') {\n        return Optional.some(rgbaColour(0, 0, 0, 0));\n      }\n      const rgbMatch = rgbRegex.exec(rgbaString);\n      if (rgbMatch !== null) {\n        return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));\n      }\n      const rgbaMatch = rgbaRegex.exec(rgbaString);\n      if (rgbaMatch !== null) {\n        return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));\n      }\n      return Optional.none();\n    };\n\n    const rgbaToHexString = color => fromString(color).map(fromRgba).map(h => '#' + h.value).getOr(color);\n\n    const isNode = node => !!node.nodeType;\n    const isInlineBlock = node => {\n      return node && /^(IMG)$/.test(node.nodeName);\n    };\n    const moveStart = (dom, selection, rng) => {\n      const offset = rng.startOffset;\n      let container = rng.startContainer;\n      if (container === rng.endContainer) {\n        if (isInlineBlock(container.childNodes[offset])) {\n          return;\n        }\n      }\n      if (isElement$6(container)) {\n        const nodes = container.childNodes;\n        let walker;\n        if (offset < nodes.length) {\n          container = nodes[offset];\n          walker = new DomTreeWalker(container, dom.getParent(container, dom.isBlock));\n        } else {\n          container = nodes[nodes.length - 1];\n          walker = new DomTreeWalker(container, dom.getParent(container, dom.isBlock));\n          walker.next(true);\n        }\n        for (let node = walker.current(); node; node = walker.next()) {\n          if (isText$8(node) && !isWhiteSpaceNode$1(node)) {\n            rng.setStart(node, 0);\n            selection.setRng(rng);\n            return;\n          }\n        }\n      }\n    };\n    const getNonWhiteSpaceSibling = (node, next, inc) => {\n      if (node) {\n        const nextName = next ? 'nextSibling' : 'previousSibling';\n        for (node = inc ? node : node[nextName]; node; node = node[nextName]) {\n          if (isElement$6(node) || !isWhiteSpaceNode$1(node)) {\n            return node;\n          }\n        }\n      }\n    };\n    const isTextBlock$1 = (editor, name) => {\n      if (isNode(name)) {\n        name = name.nodeName;\n      }\n      return !!editor.schema.getTextBlockElements()[name.toLowerCase()];\n    };\n    const isValid = (ed, parent, child) => {\n      return ed.schema.isValidChild(parent, child);\n    };\n    const isWhiteSpaceNode$1 = (node, allowSpaces = false) => {\n      if (isNonNullable(node) && isText$8(node)) {\n        const data = allowSpaces ? node.data.replace(/ /g, '\\xA0') : node.data;\n        return isWhitespaceText(data);\n      } else {\n        return false;\n      }\n    };\n    const isEmptyTextNode$1 = node => {\n      return isNonNullable(node) && isText$8(node) && node.length === 0;\n    };\n    const replaceVars = (value, vars) => {\n      if (isFunction(value)) {\n        value = value(vars);\n      } else if (isNonNullable(vars)) {\n        value = value.replace(/%(\\w+)/g, (str, name) => {\n          return vars[name] || str;\n        });\n      }\n      return value;\n    };\n    const isEq$5 = (str1, str2) => {\n      str1 = str1 || '';\n      str2 = str2 || '';\n      str1 = '' + (str1.nodeName || str1);\n      str2 = '' + (str2.nodeName || str2);\n      return str1.toLowerCase() === str2.toLowerCase();\n    };\n    const normalizeStyleValue = (value, name) => {\n      if (name === 'color' || name === 'backgroundColor') {\n        value = rgbaToHexString(value);\n      }\n      if (name === 'fontWeight' && value === 700) {\n        value = 'bold';\n      }\n      if (name === 'fontFamily') {\n        value = value.replace(/[\\'\\\"]/g, '').replace(/,\\s+/g, ',');\n      }\n      return '' + value;\n    };\n    const getStyle = (dom, node, name) => {\n      return normalizeStyleValue(dom.getStyle(node, name), name);\n    };\n    const getTextDecoration = (dom, node) => {\n      let decoration;\n      dom.getParent(node, n => {\n        decoration = dom.getStyle(n, 'text-decoration');\n        return decoration && decoration !== 'none';\n      });\n      return decoration;\n    };\n    const getParents$2 = (dom, node, selector) => {\n      return dom.getParents(node, selector, dom.getRoot());\n    };\n    const isVariableFormatName = (editor, formatName) => {\n      const hasVariableValues = format => {\n        const isVariableValue = val => val.length > 1 && val.charAt(0) === '%';\n        return exists([\n          'styles',\n          'attributes'\n        ], key => get$a(format, key).exists(field => {\n          const fieldValues = isArray$1(field) ? field : values(field);\n          return exists(fieldValues, isVariableValue);\n        }));\n      };\n      return exists(editor.formatter.get(formatName), hasVariableValues);\n    };\n    const areSimilarFormats = (editor, formatName, otherFormatName) => {\n      const validKeys = [\n        'inline',\n        'block',\n        'selector',\n        'attributes',\n        'styles',\n        'classes'\n      ];\n      const filterObj = format => filter$5(format, (_, key) => exists(validKeys, validKey => validKey === key));\n      return exists(editor.formatter.get(formatName), fmt1 => {\n        const filteredFmt1 = filterObj(fmt1);\n        return exists(editor.formatter.get(otherFormatName), fmt2 => {\n          const filteredFmt2 = filterObj(fmt2);\n          return equal$1(filteredFmt1, filteredFmt2);\n        });\n      });\n    };\n    const isBlockFormat = format => hasNonNullableKey(format, 'block');\n    const isSelectorFormat = format => hasNonNullableKey(format, 'selector');\n    const isInlineFormat = format => hasNonNullableKey(format, 'inline');\n    const isMixedFormat = format => isSelectorFormat(format) && isInlineFormat(format) && is$2(get$a(format, 'mixed'), true);\n    const shouldExpandToSelector = format => isSelectorFormat(format) && format.expand !== false && !isInlineFormat(format);\n\n    const isBookmarkNode = isBookmarkNode$1;\n    const getParents$1 = getParents$2;\n    const isWhiteSpaceNode = isWhiteSpaceNode$1;\n    const isTextBlock = isTextBlock$1;\n    const isBogusBr = node => {\n      return isBr$5(node) && node.getAttribute('data-mce-bogus') && !node.nextSibling;\n    };\n    const findParentContentEditable = (dom, node) => {\n      let parent = node;\n      while (parent) {\n        if (isElement$6(parent) && dom.getContentEditable(parent)) {\n          return dom.getContentEditable(parent) === 'false' ? parent : node;\n        }\n        parent = parent.parentNode;\n      }\n      return node;\n    };\n    const walkText = (start, node, offset, predicate) => {\n      const str = node.data;\n      for (let i = offset; start ? i >= 0 : i < str.length; start ? i-- : i++) {\n        if (predicate(str.charAt(i))) {\n          return start ? i + 1 : i;\n        }\n      }\n      return -1;\n    };\n    const findSpace = (start, node, offset) => walkText(start, node, offset, c => isNbsp(c) || isWhiteSpace(c));\n    const findContent = (start, node, offset) => walkText(start, node, offset, isContent);\n    const findWordEndPoint = (dom, body, container, offset, start, includeTrailingSpaces) => {\n      let lastTextNode;\n      const rootNode = dom.getParent(container, dom.isBlock) || body;\n      const walk = (container, offset, pred) => {\n        const textSeeker = TextSeeker(dom);\n        const walker = start ? textSeeker.backwards : textSeeker.forwards;\n        return Optional.from(walker(container, offset, (text, textOffset) => {\n          if (isBookmarkNode(text.parentNode)) {\n            return -1;\n          } else {\n            lastTextNode = text;\n            return pred(start, text, textOffset);\n          }\n        }, rootNode));\n      };\n      const spaceResult = walk(container, offset, findSpace);\n      return spaceResult.bind(result => includeTrailingSpaces ? walk(result.container, result.offset + (start ? -1 : 0), findContent) : Optional.some(result)).orThunk(() => lastTextNode ? Optional.some({\n        container: lastTextNode,\n        offset: start ? 0 : lastTextNode.length\n      }) : Optional.none());\n    };\n    const findSelectorEndPoint = (dom, formatList, rng, container, siblingName) => {\n      if (isText$8(container) && isEmpty$3(container.data) && container[siblingName]) {\n        container = container[siblingName];\n      }\n      const parents = getParents$1(dom, container);\n      for (let i = 0; i < parents.length; i++) {\n        for (let y = 0; y < formatList.length; y++) {\n          const curFormat = formatList[y];\n          if (isNonNullable(curFormat.collapsed) && curFormat.collapsed !== rng.collapsed) {\n            continue;\n          }\n          if (isSelectorFormat(curFormat) && dom.is(parents[i], curFormat.selector)) {\n            return parents[i];\n          }\n        }\n      }\n      return container;\n    };\n    const findBlockEndPoint = (editor, formatList, container, siblingName) => {\n      let node = container;\n      const dom = editor.dom;\n      const root = dom.getRoot();\n      const format = formatList[0];\n      if (isBlockFormat(format)) {\n        node = format.wrapper ? null : dom.getParent(container, format.block, root);\n      }\n      if (!node) {\n        const scopeRoot = dom.getParent(container, 'LI,TD,TH');\n        node = dom.getParent(isText$8(container) ? container.parentNode : container, node => node !== root && isTextBlock(editor, node), scopeRoot);\n      }\n      if (node && isBlockFormat(format) && format.wrapper) {\n        node = getParents$1(dom, node, 'ul,ol').reverse()[0] || node;\n      }\n      if (!node) {\n        node = container;\n        while (node[siblingName] && !dom.isBlock(node[siblingName])) {\n          node = node[siblingName];\n          if (isEq$5(node, 'br')) {\n            break;\n          }\n        }\n      }\n      return node || container;\n    };\n    const isAtBlockBoundary$1 = (dom, root, container, siblingName) => {\n      const parent = container.parentNode;\n      if (isNonNullable(container[siblingName])) {\n        return false;\n      } else if (parent === root || isNullable(parent) || dom.isBlock(parent)) {\n        return true;\n      } else {\n        return isAtBlockBoundary$1(dom, root, parent, siblingName);\n      }\n    };\n    const findParentContainer = (dom, formatList, container, offset, start) => {\n      let parent = container;\n      const siblingName = start ? 'previousSibling' : 'nextSibling';\n      const root = dom.getRoot();\n      if (isText$8(container) && !isWhiteSpaceNode(container)) {\n        if (start ? offset > 0 : offset < container.data.length) {\n          return container;\n        }\n      }\n      while (true) {\n        if (!formatList[0].block_expand && dom.isBlock(parent)) {\n          return parent;\n        }\n        for (let sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {\n          const allowSpaces = isText$8(sibling) && !isAtBlockBoundary$1(dom, root, sibling, siblingName);\n          if (!isBookmarkNode(sibling) && !isBogusBr(sibling) && !isWhiteSpaceNode(sibling, allowSpaces)) {\n            return parent;\n          }\n        }\n        if (parent === root || parent.parentNode === root) {\n          container = parent;\n          break;\n        }\n        parent = parent.parentNode;\n      }\n      return container;\n    };\n    const isSelfOrParentBookmark = container => isBookmarkNode(container.parentNode) || isBookmarkNode(container);\n    const expandRng = (editor, rng, formatList, includeTrailingSpace = false) => {\n      let {startContainer, startOffset, endContainer, endOffset} = rng;\n      const dom = editor.dom;\n      const format = formatList[0];\n      if (isElement$6(startContainer) && startContainer.hasChildNodes()) {\n        startContainer = getNode$1(startContainer, startOffset);\n        if (isText$8(startContainer)) {\n          startOffset = 0;\n        }\n      }\n      if (isElement$6(endContainer) && endContainer.hasChildNodes()) {\n        endContainer = getNode$1(endContainer, rng.collapsed ? endOffset : endOffset - 1);\n        if (isText$8(endContainer)) {\n          endOffset = endContainer.nodeValue.length;\n        }\n      }\n      startContainer = findParentContentEditable(dom, startContainer);\n      endContainer = findParentContentEditable(dom, endContainer);\n      if (isSelfOrParentBookmark(startContainer)) {\n        startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;\n        if (rng.collapsed) {\n          startContainer = startContainer.previousSibling || startContainer;\n        } else {\n          startContainer = startContainer.nextSibling || startContainer;\n        }\n        if (isText$8(startContainer)) {\n          startOffset = rng.collapsed ? startContainer.length : 0;\n        }\n      }\n      if (isSelfOrParentBookmark(endContainer)) {\n        endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;\n        if (rng.collapsed) {\n          endContainer = endContainer.nextSibling || endContainer;\n        } else {\n          endContainer = endContainer.previousSibling || endContainer;\n        }\n        if (isText$8(endContainer)) {\n          endOffset = rng.collapsed ? 0 : endContainer.length;\n        }\n      }\n      if (rng.collapsed) {\n        const startPoint = findWordEndPoint(dom, editor.getBody(), startContainer, startOffset, true, includeTrailingSpace);\n        startPoint.each(({container, offset}) => {\n          startContainer = container;\n          startOffset = offset;\n        });\n        const endPoint = findWordEndPoint(dom, editor.getBody(), endContainer, endOffset, false, includeTrailingSpace);\n        endPoint.each(({container, offset}) => {\n          endContainer = container;\n          endOffset = offset;\n        });\n      }\n      if (isInlineFormat(format) || format.block_expand) {\n        if (!isInlineFormat(format) || (!isText$8(startContainer) || startOffset === 0)) {\n          startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\n        }\n        if (!isInlineFormat(format) || (!isText$8(endContainer) || endOffset === endContainer.nodeValue.length)) {\n          endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\n        }\n      }\n      if (shouldExpandToSelector(format)) {\n        startContainer = findSelectorEndPoint(dom, formatList, rng, startContainer, 'previousSibling');\n        endContainer = findSelectorEndPoint(dom, formatList, rng, endContainer, 'nextSibling');\n      }\n      if (isBlockFormat(format) || isSelectorFormat(format)) {\n        startContainer = findBlockEndPoint(editor, formatList, startContainer, 'previousSibling');\n        endContainer = findBlockEndPoint(editor, formatList, endContainer, 'nextSibling');\n        if (isBlockFormat(format)) {\n          if (!dom.isBlock(startContainer)) {\n            startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\n          }\n          if (!dom.isBlock(endContainer)) {\n            endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\n          }\n        }\n      }\n      if (isElement$6(startContainer)) {\n        startOffset = dom.nodeIndex(startContainer);\n        startContainer = startContainer.parentNode;\n      }\n      if (isElement$6(endContainer)) {\n        endOffset = dom.nodeIndex(endContainer) + 1;\n        endContainer = endContainer.parentNode;\n      }\n      return {\n        startContainer,\n        startOffset,\n        endContainer,\n        endOffset\n      };\n    };\n\n    const walk$3 = (dom, rng, callback) => {\n      const startOffset = rng.startOffset;\n      const startContainer = getNode$1(rng.startContainer, startOffset);\n      const endOffset = rng.endOffset;\n      const endContainer = getNode$1(rng.endContainer, endOffset - 1);\n      const exclude = nodes => {\n        const firstNode = nodes[0];\n        if (isText$8(firstNode) && firstNode === startContainer && startOffset >= firstNode.data.length) {\n          nodes.splice(0, 1);\n        }\n        const lastNode = nodes[nodes.length - 1];\n        if (endOffset === 0 && nodes.length > 0 && lastNode === endContainer && isText$8(lastNode)) {\n          nodes.splice(nodes.length - 1, 1);\n        }\n        return nodes;\n      };\n      const collectSiblings = (node, name, endNode) => {\n        const siblings = [];\n        for (; node && node !== endNode; node = node[name]) {\n          siblings.push(node);\n        }\n        return siblings;\n      };\n      const findEndPoint = (node, root) => dom.getParent(node, node => node.parentNode === root, root);\n      const walkBoundary = (startNode, endNode, next) => {\n        const siblingName = next ? 'nextSibling' : 'previousSibling';\n        for (let node = startNode, parent = node.parentNode; node && node !== endNode; node = parent) {\n          parent = node.parentNode;\n          const siblings = collectSiblings(node === startNode ? node : node[siblingName], siblingName);\n          if (siblings.length) {\n            if (!next) {\n              siblings.reverse();\n            }\n            callback(exclude(siblings));\n          }\n        }\n      };\n      if (startContainer === endContainer) {\n        return callback(exclude([startContainer]));\n      }\n      const ancestor = dom.findCommonAncestor(startContainer, endContainer);\n      if (dom.isChildOf(startContainer, endContainer)) {\n        return walkBoundary(startContainer, ancestor, true);\n      }\n      if (dom.isChildOf(endContainer, startContainer)) {\n        return walkBoundary(endContainer, ancestor);\n      }\n      const startPoint = findEndPoint(startContainer, ancestor) || startContainer;\n      const endPoint = findEndPoint(endContainer, ancestor) || endContainer;\n      walkBoundary(startContainer, startPoint, true);\n      const siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, 'nextSibling', endPoint === endContainer ? endPoint.nextSibling : endPoint);\n      if (siblings.length) {\n        callback(exclude(siblings));\n      }\n      walkBoundary(endContainer, endPoint);\n    };\n\n    const getRanges$1 = selection => {\n      const ranges = [];\n      if (selection) {\n        for (let i = 0; i < selection.rangeCount; i++) {\n          ranges.push(selection.getRangeAt(i));\n        }\n      }\n      return ranges;\n    };\n    const getSelectedNodes = ranges => {\n      return bind$3(ranges, range => {\n        const node = getSelectedNode(range);\n        return node ? [SugarElement.fromDom(node)] : [];\n      });\n    };\n    const hasMultipleRanges = selection => {\n      return getRanges$1(selection).length > 1;\n    };\n\n    const getCellsFromRanges = ranges => filter$6(getSelectedNodes(ranges), isTableCell$4);\n    const getCellsFromElement = elm => descendants(elm, 'td[data-mce-selected],th[data-mce-selected]');\n    const getCellsFromElementOrRanges = (ranges, element) => {\n      const selectedCells = getCellsFromElement(element);\n      return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);\n    };\n    const getCellsFromEditor = editor => getCellsFromElementOrRanges(getRanges$1(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));\n    const getClosestTable = (cell, isRoot) => ancestor$2(cell, 'table', isRoot);\n\n    const getStartNode = rng => {\n      const sc = rng.startContainer, so = rng.startOffset;\n      if (isText$8(sc)) {\n        return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();\n      } else {\n        return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);\n      }\n    };\n    const getEndNode = rng => {\n      const ec = rng.endContainer, eo = rng.endOffset;\n      if (isText$8(ec)) {\n        return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();\n      } else {\n        return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);\n      }\n    };\n    const getFirstChildren = node => {\n      return firstChild(node).fold(constant([node]), child => {\n        return [node].concat(getFirstChildren(child));\n      });\n    };\n    const getLastChildren$1 = node => {\n      return lastChild(node).fold(constant([node]), child => {\n        if (name(child) === 'br') {\n          return prevSibling(child).map(sibling => {\n            return [node].concat(getLastChildren$1(sibling));\n          }).getOr([]);\n        } else {\n          return [node].concat(getLastChildren$1(child));\n        }\n      });\n    };\n    const hasAllContentsSelected = (elm, rng) => {\n      return lift2(getStartNode(rng), getEndNode(rng), (startNode, endNode) => {\n        const start = find$2(getFirstChildren(elm), curry(eq, startNode));\n        const end = find$2(getLastChildren$1(elm), curry(eq, endNode));\n        return start.isSome() && end.isSome();\n      }).getOr(false);\n    };\n    const moveEndPoint = (dom, rng, node, start) => {\n      const root = node, walker = new DomTreeWalker(node, root);\n      const moveCaretBeforeOnEnterElementsMap = filter$5(dom.schema.getMoveCaretBeforeOnEnterElements(), (_, name) => !contains$2([\n        'td',\n        'th',\n        'table'\n      ], name.toLowerCase()));\n      do {\n        if (isText$8(node) && Tools.trim(node.nodeValue).length !== 0) {\n          if (start) {\n            rng.setStart(node, 0);\n          } else {\n            rng.setEnd(node, node.nodeValue.length);\n          }\n          return;\n        }\n        if (moveCaretBeforeOnEnterElementsMap[node.nodeName]) {\n          if (start) {\n            rng.setStartBefore(node);\n          } else {\n            if (node.nodeName === 'BR') {\n              rng.setEndBefore(node);\n            } else {\n              rng.setEndAfter(node);\n            }\n          }\n          return;\n        }\n      } while (node = start ? walker.next() : walker.prev());\n      if (root.nodeName === 'BODY') {\n        if (start) {\n          rng.setStart(root, 0);\n        } else {\n          rng.setEnd(root, root.childNodes.length);\n        }\n      }\n    };\n    const hasAnyRanges = editor => {\n      const sel = editor.selection.getSel();\n      return sel && sel.rangeCount > 0;\n    };\n    const runOnRanges = (editor, executor) => {\n      const fakeSelectionNodes = getCellsFromEditor(editor);\n      if (fakeSelectionNodes.length > 0) {\n        each$g(fakeSelectionNodes, elem => {\n          const node = elem.dom;\n          const fakeNodeRng = editor.dom.createRng();\n          fakeNodeRng.setStartBefore(node);\n          fakeNodeRng.setEndAfter(node);\n          executor(fakeNodeRng, true);\n        });\n      } else {\n        executor(editor.selection.getRng(), false);\n      }\n    };\n    const preserve = (selection, fillBookmark, executor) => {\n      const bookmark = getPersistentBookmark(selection, fillBookmark);\n      executor(bookmark);\n      selection.moveToBookmark(bookmark);\n    };\n\n    const NodeValue = (is, name) => {\n      const get = element => {\n        if (!is(element)) {\n          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\n        }\n        return getOption(element).getOr('');\n      };\n      const getOption = element => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\n      const set = (element, value) => {\n        if (!is(element)) {\n          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\n        }\n        element.dom.nodeValue = value;\n      };\n      return {\n        get,\n        getOption,\n        set\n      };\n    };\n\n    const api$1 = NodeValue(isText$9, 'text');\n    const get$3 = element => api$1.get(element);\n    const getOption = element => api$1.getOption(element);\n\n    const isZeroWidth = elem => isText$9(elem) && get$3(elem) === ZWSP$1;\n    const context = (editor, elem, wrapName, nodeName) => parent(elem).fold(() => 'skipping', parent => {\n      if (nodeName === 'br' || isZeroWidth(elem)) {\n        return 'valid';\n      } else if (isAnnotation(elem)) {\n        return 'existing';\n      } else if (isCaretNode(elem.dom)) {\n        return 'caret';\n      } else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent), wrapName)) {\n        return 'invalid-child';\n      } else {\n        return 'valid';\n      }\n    });\n\n    const applyWordGrab = (editor, rng) => {\n      const r = expandRng(editor, rng, [{ inline: 'span' }]);\n      rng.setStart(r.startContainer, r.startOffset);\n      rng.setEnd(r.endContainer, r.endOffset);\n      editor.selection.setRng(rng);\n    };\n    const makeAnnotation = (eDoc, {uid = generate$1('mce-annotation'), ...data}, annotationName, decorate) => {\n      const master = SugarElement.fromTag('span', eDoc);\n      add$2(master, annotation());\n      set$2(master, `${ dataAnnotationId() }`, uid);\n      set$2(master, `${ dataAnnotation() }`, annotationName);\n      const {attributes = {}, classes = []} = decorate(uid, data);\n      setAll$1(master, attributes);\n      add(master, classes);\n      return master;\n    };\n    const annotate = (editor, rng, annotationName, decorate, data) => {\n      const newWrappers = [];\n      const master = makeAnnotation(editor.getDoc(), data, annotationName, decorate);\n      const wrapper = value$2();\n      const finishWrapper = () => {\n        wrapper.clear();\n      };\n      const getOrOpenWrapper = () => wrapper.get().getOrThunk(() => {\n        const nu = shallow$1(master);\n        newWrappers.push(nu);\n        wrapper.set(nu);\n        return nu;\n      });\n      const processElements = elems => {\n        each$g(elems, processElement);\n      };\n      const processElement = elem => {\n        const ctx = context(editor, elem, 'span', name(elem));\n        switch (ctx) {\n        case 'invalid-child': {\n            finishWrapper();\n            const children$1 = children(elem);\n            processElements(children$1);\n            finishWrapper();\n            break;\n          }\n        case 'valid': {\n            const w = getOrOpenWrapper();\n            wrap$2(elem, w);\n            break;\n          }\n        }\n      };\n      const processNodes = nodes => {\n        const elems = map$3(nodes, SugarElement.fromDom);\n        processElements(elems);\n      };\n      walk$3(editor.dom, rng, nodes => {\n        finishWrapper();\n        processNodes(nodes);\n      });\n      return newWrappers;\n    };\n    const annotateWithBookmark = (editor, name, settings, data) => {\n      editor.undoManager.transact(() => {\n        const selection = editor.selection;\n        const initialRng = selection.getRng();\n        const hasFakeSelection = getCellsFromEditor(editor).length > 0;\n        if (initialRng.collapsed && !hasFakeSelection) {\n          applyWordGrab(editor, initialRng);\n        }\n        if (selection.getRng().collapsed && !hasFakeSelection) {\n          const wrapper = makeAnnotation(editor.getDoc(), data, name, settings.decorate);\n          set(wrapper, nbsp);\n          selection.getRng().insertNode(wrapper.dom);\n          selection.select(wrapper.dom);\n        } else {\n          preserve(selection, false, () => {\n            runOnRanges(editor, selectionRng => {\n              annotate(editor, selectionRng, name, settings.decorate, data);\n            });\n          });\n        }\n      });\n    };\n\n    const Annotator = editor => {\n      const registry = create$b();\n      setup$w(editor, registry);\n      const changes = setup$x(editor, registry);\n      return {\n        register: (name, settings) => {\n          registry.register(name, settings);\n        },\n        annotate: (name, data) => {\n          registry.lookup(name).each(settings => {\n            annotateWithBookmark(editor, name, settings, data);\n          });\n        },\n        annotationChanged: (name, callback) => {\n          changes.addListener(name, callback);\n        },\n        remove: name => {\n          const bookmark = editor.selection.getBookmark();\n          identify(editor, Optional.some(name)).each(({elements}) => {\n            each$g(elements, unwrap);\n          });\n          editor.selection.moveToBookmark(bookmark);\n        },\n        removeAll: name => {\n          const bookmark = editor.selection.getBookmark();\n          each$f(findAll(editor, name), (spans, _) => each$g(spans, unwrap));\n          editor.selection.moveToBookmark(bookmark);\n        },\n        getAll: name => {\n          const directory = findAll(editor, name);\n          return map$2(directory, elems => map$3(elems, elem => elem.dom));\n        }\n      };\n    };\n\n    const BookmarkManager = selection => {\n      return {\n        getBookmark: curry(getBookmark$1, selection),\n        moveToBookmark: curry(moveToBookmark, selection)\n      };\n    };\n    BookmarkManager.isBookmarkNode = isBookmarkNode$1;\n\n    const isXYWithinRange = (clientX, clientY, range) => {\n      if (range.collapsed) {\n        return false;\n      } else {\n        return exists(range.getClientRects(), rect => containsXY(rect, clientX, clientY));\n      }\n    };\n\n    const firePreProcess = (editor, args) => editor.dispatch('PreProcess', args);\n    const firePostProcess = (editor, args) => editor.dispatch('PostProcess', args);\n    const fireRemove = editor => editor.dispatch('remove');\n    const fireDetach = editor => editor.dispatch('detach');\n    const fireSwitchMode = (editor, mode) => editor.dispatch('SwitchMode', { mode });\n    const fireObjectResizeStart = (editor, target, width, height, origin) => {\n      editor.dispatch('ObjectResizeStart', {\n        target,\n        width,\n        height,\n        origin\n      });\n    };\n    const fireObjectResized = (editor, target, width, height, origin) => {\n      editor.dispatch('ObjectResized', {\n        target,\n        width,\n        height,\n        origin\n      });\n    };\n    const firePreInit = editor => editor.dispatch('PreInit');\n    const firePostRender = editor => editor.dispatch('PostRender');\n    const fireInit = editor => editor.dispatch('Init');\n    const firePlaceholderToggle = (editor, state) => editor.dispatch('PlaceholderToggle', { state });\n    const fireError = (editor, errorType, error) => editor.dispatch(errorType, error);\n    const fireFormatApply = (editor, format, node, vars) => editor.dispatch('FormatApply', {\n      format,\n      node,\n      vars\n    });\n    const fireFormatRemove = (editor, format, node, vars) => editor.dispatch('FormatRemove', {\n      format,\n      node,\n      vars\n    });\n    const fireBeforeSetContent = (editor, args) => editor.dispatch('BeforeSetContent', args);\n    const fireSetContent = (editor, args) => editor.dispatch('SetContent', args);\n    const fireBeforeGetContent = (editor, args) => editor.dispatch('BeforeGetContent', args);\n    const fireGetContent = (editor, args) => editor.dispatch('GetContent', args);\n    const fireAutocompleterStart = (editor, args) => editor.dispatch('AutocompleterStart', args);\n    const fireAutocompleterUpdate = (editor, args) => editor.dispatch('AutocompleterUpdate', args);\n    const fireAutocompleterEnd = editor => editor.dispatch('AutocompleterEnd');\n    const firePastePreProcess = (editor, html, internal) => editor.dispatch('PastePreProcess', {\n      content: html,\n      internal\n    });\n    const firePastePostProcess = (editor, node, internal) => editor.dispatch('PastePostProcess', {\n      node,\n      internal\n    });\n    const firePastePlainTextToggle = (editor, state) => editor.dispatch('PastePlainTextToggle', { state });\n\n    const VK = {\n      BACKSPACE: 8,\n      DELETE: 46,\n      DOWN: 40,\n      ENTER: 13,\n      ESC: 27,\n      LEFT: 37,\n      RIGHT: 39,\n      SPACEBAR: 32,\n      TAB: 9,\n      UP: 38,\n      PAGE_UP: 33,\n      PAGE_DOWN: 34,\n      END: 35,\n      HOME: 36,\n      modifierPressed: e => {\n        return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);\n      },\n      metaKeyPressed: e => {\n        return Env.os.isMacOS() || Env.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey;\n      }\n    };\n\n    const ControlSelection = (selection, editor) => {\n      const elementSelectionAttr = 'data-mce-selected';\n      const dom = editor.dom, each = Tools.each;\n      let selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;\n      let startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;\n      let width, height;\n      const editableDoc = editor.getDoc(), rootDocument = document;\n      const abs = Math.abs, round = Math.round, rootElement = editor.getBody();\n      let startScrollWidth, startScrollHeight;\n      const resizeHandles = {\n        nw: [\n          0,\n          0,\n          -1,\n          -1\n        ],\n        ne: [\n          1,\n          0,\n          1,\n          -1\n        ],\n        se: [\n          1,\n          1,\n          1,\n          1\n        ],\n        sw: [\n          0,\n          1,\n          -1,\n          1\n        ]\n      };\n      const isImage = elm => isNonNullable(elm) && (isImg(elm) || editor.dom.is(elm, 'figure.image'));\n      const isMedia = elm => isMedia$2(elm) || dom.hasClass(elm, 'mce-preview-object');\n      const isEventOnImageOutsideRange = (evt, range) => {\n        if (evt.type === 'longpress' || evt.type.indexOf('touch') === 0) {\n          const touch = evt.touches[0];\n          return isImage(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range);\n        } else {\n          return isImage(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range);\n        }\n      };\n      const contextMenuSelectImage = evt => {\n        const target = evt.target;\n        if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {\n          editor.selection.select(target);\n        }\n      };\n      const getResizeTargets = elm => {\n        if (dom.is(elm, 'figure.image')) {\n          return [elm.querySelector('img')];\n        } else if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {\n          return [\n            elm,\n            elm.firstElementChild\n          ];\n        } else {\n          return [elm];\n        }\n      };\n      const isResizable = elm => {\n        const selector = getObjectResizing(editor);\n        if (!selector) {\n          return false;\n        }\n        if (elm.getAttribute('data-mce-resize') === 'false') {\n          return false;\n        }\n        if (elm === editor.getBody()) {\n          return false;\n        }\n        if (dom.hasClass(elm, 'mce-preview-object')) {\n          return is$1(SugarElement.fromDom(elm.firstElementChild), selector);\n        } else {\n          return is$1(SugarElement.fromDom(elm), selector);\n        }\n      };\n      const createGhostElement = elm => {\n        if (isMedia(elm)) {\n          return dom.create('img', { src: Env.transparentSrc });\n        } else {\n          return elm.cloneNode(true);\n        }\n      };\n      const setSizeProp = (element, name, value) => {\n        if (isNonNullable(value)) {\n          const targets = getResizeTargets(element);\n          each$g(targets, target => {\n            if (target.style[name] || !editor.schema.isValid(target.nodeName.toLowerCase(), name)) {\n              dom.setStyle(target, name, value);\n            } else {\n              dom.setAttrib(target, name, '' + value);\n            }\n          });\n        }\n      };\n      const setGhostElmSize = (ghostElm, width, height) => {\n        setSizeProp(ghostElm, 'width', width);\n        setSizeProp(ghostElm, 'height', height);\n      };\n      const resizeGhostElement = e => {\n        let deltaX, deltaY, proportional;\n        let resizeHelperX, resizeHelperY;\n        deltaX = e.screenX - startX;\n        deltaY = e.screenY - startY;\n        width = deltaX * selectedHandle[2] + startW;\n        height = deltaY * selectedHandle[3] + startH;\n        width = width < 5 ? 5 : width;\n        height = height < 5 ? 5 : height;\n        if ((isImage(selectedElm) || isMedia(selectedElm)) && getResizeImgProportional(editor) !== false) {\n          proportional = !VK.modifierPressed(e);\n        } else {\n          proportional = VK.modifierPressed(e);\n        }\n        if (proportional) {\n          if (abs(deltaX) > abs(deltaY)) {\n            height = round(width * ratio);\n            width = round(height / ratio);\n          } else {\n            width = round(height / ratio);\n            height = round(width * ratio);\n          }\n        }\n        setGhostElmSize(selectedElmGhost, width, height);\n        resizeHelperX = selectedHandle.startPos.x + deltaX;\n        resizeHelperY = selectedHandle.startPos.y + deltaY;\n        resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;\n        resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;\n        dom.setStyles(resizeHelper, {\n          left: resizeHelperX,\n          top: resizeHelperY,\n          display: 'block'\n        });\n        resizeHelper.innerHTML = width + ' &times; ' + height;\n        if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {\n          dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));\n        }\n        if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {\n          dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));\n        }\n        deltaX = rootElement.scrollWidth - startScrollWidth;\n        deltaY = rootElement.scrollHeight - startScrollHeight;\n        if (deltaX + deltaY !== 0) {\n          dom.setStyles(resizeHelper, {\n            left: resizeHelperX - deltaX,\n            top: resizeHelperY - deltaY\n          });\n        }\n        if (!resizeStarted) {\n          fireObjectResizeStart(editor, selectedElm, startW, startH, 'corner-' + selectedHandle.name);\n          resizeStarted = true;\n        }\n      };\n      const endGhostResize = () => {\n        const wasResizeStarted = resizeStarted;\n        resizeStarted = false;\n        if (wasResizeStarted) {\n          setSizeProp(selectedElm, 'width', width);\n          setSizeProp(selectedElm, 'height', height);\n        }\n        dom.unbind(editableDoc, 'mousemove', resizeGhostElement);\n        dom.unbind(editableDoc, 'mouseup', endGhostResize);\n        if (rootDocument !== editableDoc) {\n          dom.unbind(rootDocument, 'mousemove', resizeGhostElement);\n          dom.unbind(rootDocument, 'mouseup', endGhostResize);\n        }\n        dom.remove(selectedElmGhost);\n        dom.remove(resizeHelper);\n        dom.remove(resizeBackdrop);\n        showResizeRect(selectedElm);\n        if (wasResizeStarted) {\n          fireObjectResized(editor, selectedElm, width, height, 'corner-' + selectedHandle.name);\n          dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));\n        }\n        editor.nodeChanged();\n      };\n      const showResizeRect = targetElm => {\n        unbindResizeHandleEvents();\n        const position = dom.getPos(targetElm, rootElement);\n        const selectedElmX = position.x;\n        const selectedElmY = position.y;\n        const rect = targetElm.getBoundingClientRect();\n        const targetWidth = rect.width || rect.right - rect.left;\n        const targetHeight = rect.height || rect.bottom - rect.top;\n        if (selectedElm !== targetElm) {\n          hideResizeRect();\n          selectedElm = targetElm;\n          width = height = 0;\n        }\n        const e = editor.dispatch('ObjectSelected', { target: targetElm });\n        const selectedValue = dom.getAttrib(selectedElm, elementSelectionAttr, '1');\n        if (isResizable(targetElm) && !e.isDefaultPrevented()) {\n          each(resizeHandles, (handle, name) => {\n            let handleElm;\n            const startDrag = e => {\n              const target = getResizeTargets(selectedElm)[0];\n              startX = e.screenX;\n              startY = e.screenY;\n              startW = target.clientWidth;\n              startH = target.clientHeight;\n              ratio = startH / startW;\n              selectedHandle = handle;\n              selectedHandle.name = name;\n              selectedHandle.startPos = {\n                x: targetWidth * handle[0] + selectedElmX,\n                y: targetHeight * handle[1] + selectedElmY\n              };\n              startScrollWidth = rootElement.scrollWidth;\n              startScrollHeight = rootElement.scrollHeight;\n              resizeBackdrop = dom.add(rootElement, 'div', {\n                'class': 'mce-resize-backdrop',\n                'data-mce-bogus': 'all'\n              });\n              dom.setStyles(resizeBackdrop, {\n                position: 'fixed',\n                left: '0',\n                top: '0',\n                width: '100%',\n                height: '100%'\n              });\n              selectedElmGhost = createGhostElement(selectedElm);\n              dom.addClass(selectedElmGhost, 'mce-clonedresizable');\n              dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');\n              selectedElmGhost.contentEditable = 'false';\n              dom.setStyles(selectedElmGhost, {\n                left: selectedElmX,\n                top: selectedElmY,\n                margin: 0\n              });\n              setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);\n              selectedElmGhost.removeAttribute(elementSelectionAttr);\n              rootElement.appendChild(selectedElmGhost);\n              dom.bind(editableDoc, 'mousemove', resizeGhostElement);\n              dom.bind(editableDoc, 'mouseup', endGhostResize);\n              if (rootDocument !== editableDoc) {\n                dom.bind(rootDocument, 'mousemove', resizeGhostElement);\n                dom.bind(rootDocument, 'mouseup', endGhostResize);\n              }\n              resizeHelper = dom.add(rootElement, 'div', {\n                'class': 'mce-resize-helper',\n                'data-mce-bogus': 'all'\n              }, startW + ' &times; ' + startH);\n            };\n            handleElm = dom.get('mceResizeHandle' + name);\n            if (handleElm) {\n              dom.remove(handleElm);\n            }\n            handleElm = dom.add(rootElement, 'div', {\n              'id': 'mceResizeHandle' + name,\n              'data-mce-bogus': 'all',\n              'class': 'mce-resizehandle',\n              'unselectable': true,\n              'style': 'cursor:' + name + '-resize; margin:0; padding:0'\n            });\n            dom.bind(handleElm, 'mousedown', e => {\n              e.stopImmediatePropagation();\n              e.preventDefault();\n              startDrag(e);\n            });\n            handle.elm = handleElm;\n            dom.setStyles(handleElm, {\n              left: targetWidth * handle[0] + selectedElmX - handleElm.offsetWidth / 2,\n              top: targetHeight * handle[1] + selectedElmY - handleElm.offsetHeight / 2\n            });\n          });\n        } else {\n          hideResizeRect();\n        }\n        if (!dom.getAttrib(selectedElm, elementSelectionAttr)) {\n          selectedElm.setAttribute(elementSelectionAttr, selectedValue);\n        }\n      };\n      const hideResizeRect = () => {\n        unbindResizeHandleEvents();\n        if (selectedElm) {\n          selectedElm.removeAttribute(elementSelectionAttr);\n        }\n        each$f(resizeHandles, (value, name) => {\n          const handleElm = dom.get('mceResizeHandle' + name);\n          if (handleElm) {\n            dom.unbind(handleElm);\n            dom.remove(handleElm);\n          }\n        });\n      };\n      const updateResizeRect = e => {\n        var _a;\n        let startElm, controlElm;\n        const isChildOrEqual = (node, parent) => {\n          if (node) {\n            do {\n              if (node === parent) {\n                return true;\n              }\n            } while (node = node.parentNode);\n          }\n        };\n        if (resizeStarted || editor.removed) {\n          return;\n        }\n        each(dom.select('img[data-mce-selected],hr[data-mce-selected]'), img => {\n          img.removeAttribute(elementSelectionAttr);\n        });\n        controlElm = e.type === 'mousedown' ? e.target : selection.getNode();\n        controlElm = (_a = closest$3(SugarElement.fromDom(controlElm), 'table,img,figure.image,hr,video,span.mce-preview-object').getOrUndefined()) === null || _a === void 0 ? void 0 : _a.dom;\n        if (isChildOrEqual(controlElm, rootElement)) {\n          disableGeckoResize();\n          startElm = selection.getStart(true);\n          if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {\n            showResizeRect(controlElm);\n            return;\n          }\n        }\n        hideResizeRect();\n      };\n      const unbindResizeHandleEvents = () => {\n        each$f(resizeHandles, handle => {\n          if (handle.elm) {\n            dom.unbind(handle.elm);\n            delete handle.elm;\n          }\n        });\n      };\n      const disableGeckoResize = () => {\n        try {\n          editor.getDoc().execCommand('enableObjectResizing', false, 'false');\n        } catch (ex) {\n        }\n      };\n      editor.on('init', () => {\n        disableGeckoResize();\n        const throttledUpdateResizeRect = first$1(e => {\n          if (!editor.composing) {\n            updateResizeRect(e);\n          }\n        }, 0);\n        editor.on('nodechange ResizeEditor ResizeWindow ResizeContent drop FullscreenStateChanged', throttledUpdateResizeRect.throttle);\n        editor.on('keyup compositionend', e => {\n          if (selectedElm && selectedElm.nodeName === 'TABLE') {\n            throttledUpdateResizeRect.throttle(e);\n          }\n        });\n        editor.on('hide blur', hideResizeRect);\n        editor.on('contextmenu longpress', contextMenuSelectImage, true);\n      });\n      editor.on('remove', unbindResizeHandleEvents);\n      const destroy = () => {\n        selectedElm = selectedElmGhost = resizeBackdrop = null;\n      };\n      return {\n        isResizable,\n        showResizeRect,\n        hideResizeRect,\n        updateResizeRect,\n        destroy\n      };\n    };\n\n    const setStart = (rng, situ) => {\n      situ.fold(e => {\n        rng.setStartBefore(e.dom);\n      }, (e, o) => {\n        rng.setStart(e.dom, o);\n      }, e => {\n        rng.setStartAfter(e.dom);\n      });\n    };\n    const setFinish = (rng, situ) => {\n      situ.fold(e => {\n        rng.setEndBefore(e.dom);\n      }, (e, o) => {\n        rng.setEnd(e.dom, o);\n      }, e => {\n        rng.setEndAfter(e.dom);\n      });\n    };\n    const relativeToNative = (win, startSitu, finishSitu) => {\n      const range = win.document.createRange();\n      setStart(range, startSitu);\n      setFinish(range, finishSitu);\n      return range;\n    };\n    const exactToNative = (win, start, soffset, finish, foffset) => {\n      const rng = win.document.createRange();\n      rng.setStart(start.dom, soffset);\n      rng.setEnd(finish.dom, foffset);\n      return rng;\n    };\n\n    const adt$3 = Adt.generate([\n      {\n        ltr: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      },\n      {\n        rtl: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const fromRange = (win, type, range) => type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);\n    const getRanges = (win, selection) => selection.match({\n      domRange: rng => {\n        return {\n          ltr: constant(rng),\n          rtl: Optional.none\n        };\n      },\n      relative: (startSitu, finishSitu) => {\n        return {\n          ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),\n          rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))\n        };\n      },\n      exact: (start, soffset, finish, foffset) => {\n        return {\n          ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),\n          rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))\n        };\n      }\n    });\n    const doDiagnose = (win, ranges) => {\n      const rng = ranges.ltr();\n      if (rng.collapsed) {\n        const reversed = ranges.rtl().filter(rev => rev.collapsed === false);\n        return reversed.map(rev => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));\n      } else {\n        return fromRange(win, adt$3.ltr, rng);\n      }\n    };\n    const diagnose = (win, selection) => {\n      const ranges = getRanges(win, selection);\n      return doDiagnose(win, ranges);\n    };\n    adt$3.ltr;\n    adt$3.rtl;\n\n    const create$9 = (start, soffset, finish, foffset) => ({\n      start,\n      soffset,\n      finish,\n      foffset\n    });\n    const SimRange = { create: create$9 };\n\n    const caretPositionFromPoint = (doc, x, y) => {\n      var _a, _b;\n      return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)).bind(pos => {\n        if (pos.offsetNode === null) {\n          return Optional.none();\n        }\n        const r = doc.dom.createRange();\n        r.setStart(pos.offsetNode, pos.offset);\n        r.collapse();\n        return Optional.some(r);\n      });\n    };\n    const caretRangeFromPoint = (doc, x, y) => {\n      var _a, _b;\n      return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y));\n    };\n    const availableSearch = (() => {\n      if (document.caretPositionFromPoint) {\n        return caretPositionFromPoint;\n      } else if (document.caretRangeFromPoint) {\n        return caretRangeFromPoint;\n      } else {\n        return Optional.none;\n      }\n    })();\n    const fromPoint$1 = (win, x, y) => {\n      const doc = SugarElement.fromDom(win.document);\n      return availableSearch(doc, x, y).map(rng => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));\n    };\n\n    const adt$2 = Adt.generate([\n      { before: ['element'] },\n      {\n        on: [\n          'element',\n          'offset'\n        ]\n      },\n      { after: ['element'] }\n    ]);\n    const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);\n    const getStart$2 = situ => situ.fold(identity, identity, identity);\n    const before$1 = adt$2.before;\n    const on = adt$2.on;\n    const after$1 = adt$2.after;\n    const Situ = {\n      before: before$1,\n      on,\n      after: after$1,\n      cata,\n      getStart: getStart$2\n    };\n\n    const adt$1 = Adt.generate([\n      { domRange: ['rng'] },\n      {\n        relative: [\n          'startSitu',\n          'finishSitu'\n        ]\n      },\n      {\n        exact: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const exactFromRange = simRange => adt$1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);\n    const getStart$1 = selection => selection.match({\n      domRange: rng => SugarElement.fromDom(rng.startContainer),\n      relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),\n      exact: (start, _soffset, _finish, _foffset) => start\n    });\n    const domRange = adt$1.domRange;\n    const relative = adt$1.relative;\n    const exact = adt$1.exact;\n    const getWin = selection => {\n      const start = getStart$1(selection);\n      return defaultView(start);\n    };\n    const range = SimRange.create;\n    const SimSelection = {\n      domRange,\n      relative,\n      exact,\n      exactFromRange,\n      getWin,\n      range\n    };\n\n    const beforeSpecial = (element, offset) => {\n      const name$1 = name(element);\n      if ('input' === name$1) {\n        return Situ.after(element);\n      } else if (!contains$2([\n          'br',\n          'img'\n        ], name$1)) {\n        return Situ.on(element, offset);\n      } else {\n        return offset === 0 ? Situ.before(element) : Situ.after(element);\n      }\n    };\n    const preprocessRelative = (startSitu, finishSitu) => {\n      const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);\n      const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);\n      return SimSelection.relative(start, finish);\n    };\n    const preprocessExact = (start, soffset, finish, foffset) => {\n      const startSitu = beforeSpecial(start, soffset);\n      const finishSitu = beforeSpecial(finish, foffset);\n      return SimSelection.relative(startSitu, finishSitu);\n    };\n    const preprocess = selection => selection.match({\n      domRange: rng => {\n        const start = SugarElement.fromDom(rng.startContainer);\n        const finish = SugarElement.fromDom(rng.endContainer);\n        return preprocessExact(start, rng.startOffset, finish, rng.endOffset);\n      },\n      relative: preprocessRelative,\n      exact: preprocessExact\n    });\n\n    const fromElements = (elements, scope) => {\n      const doc = scope || document;\n      const fragment = doc.createDocumentFragment();\n      each$g(elements, element => {\n        fragment.appendChild(element.dom);\n      });\n      return SugarElement.fromDom(fragment);\n    };\n\n    const toNative = selection => {\n      const win = SimSelection.getWin(selection).dom;\n      const getDomRange = (start, soffset, finish, foffset) => exactToNative(win, start, soffset, finish, foffset);\n      const filtered = preprocess(selection);\n      return diagnose(win, filtered).match({\n        ltr: getDomRange,\n        rtl: getDomRange\n      });\n    };\n    const getAtPoint = (win, x, y) => fromPoint$1(win, x, y);\n\n    const fromPoint = (clientX, clientY, doc) => getAtPoint(doc.defaultView, clientX, clientY).map(simRange => {\n      const rng = doc.createRange();\n      rng.setStart(simRange.start.dom, simRange.soffset);\n      rng.setEnd(simRange.finish.dom, simRange.foffset);\n      return rng;\n    }).getOrUndefined();\n\n    const isEq$4 = (rng1, rng2) => {\n      return rng1 && rng2 && (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) && (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);\n    };\n\n    const findParent = (node, rootNode, predicate) => {\n      while (node && node !== rootNode) {\n        if (predicate(node)) {\n          return node;\n        }\n        node = node.parentNode;\n      }\n      return null;\n    };\n    const hasParent$1 = (node, rootNode, predicate) => findParent(node, rootNode, predicate) !== null;\n    const hasParentWithName = (node, rootNode, name) => hasParent$1(node, rootNode, node => {\n      return node.nodeName === name;\n    });\n    const isTable = node => node && node.nodeName === 'TABLE';\n    const isTableCell$2 = node => node && /^(TD|TH|CAPTION)$/.test(node.nodeName);\n    const isCeFalseCaretContainer = (node, rootNode) => isCaretContainer$2(node) && hasParent$1(node, rootNode, isCaretNode) === false;\n    const hasBrBeforeAfter = (dom, node, left) => {\n      const walker = new DomTreeWalker(node, dom.getParent(node.parentNode, dom.isBlock) || dom.getRoot());\n      while (node = walker[left ? 'prev' : 'next']()) {\n        if (isBr$5(node)) {\n          return true;\n        }\n      }\n    };\n    const isPrevNode = (node, name) => node.previousSibling && node.previousSibling.nodeName === name;\n    const hasContentEditableFalseParent = (body, node) => {\n      while (node && node !== body) {\n        if (isContentEditableFalse$a(node)) {\n          return true;\n        }\n        node = node.parentNode;\n      }\n      return false;\n    };\n    const findTextNodeRelative = (dom, isAfterNode, collapsed, left, startNode) => {\n      let lastInlineElement;\n      const body = dom.getRoot();\n      let node;\n      const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\n      const parentBlockContainer = dom.getParent(startNode.parentNode, dom.isBlock) || body;\n      if (left && isBr$5(startNode) && isAfterNode && dom.isEmpty(parentBlockContainer)) {\n        return Optional.some(CaretPosition(startNode.parentNode, dom.nodeIndex(startNode)));\n      }\n      const walker = new DomTreeWalker(startNode, parentBlockContainer);\n      while (node = walker[left ? 'prev' : 'next']()) {\n        if (dom.getContentEditableParent(node) === 'false' || isCeFalseCaretContainer(node, body)) {\n          return Optional.none();\n        }\n        if (isText$8(node) && node.nodeValue.length > 0) {\n          if (hasParentWithName(node, body, 'A') === false) {\n            return Optional.some(CaretPosition(node, left ? node.nodeValue.length : 0));\n          }\n          return Optional.none();\n        }\n        if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\n          return Optional.none();\n        }\n        lastInlineElement = node;\n      }\n      if (collapsed && lastInlineElement) {\n        return Optional.some(CaretPosition(lastInlineElement, 0));\n      }\n      return Optional.none();\n    };\n    const normalizeEndPoint = (dom, collapsed, start, rng) => {\n      let container, offset;\n      const body = dom.getRoot();\n      let node;\n      let directionLeft, normalized = false;\n      container = rng[(start ? 'start' : 'end') + 'Container'];\n      offset = rng[(start ? 'start' : 'end') + 'Offset'];\n      const isAfterNode = isElement$6(container) && offset === container.childNodes.length;\n      const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\n      directionLeft = start;\n      if (isCaretContainer$2(container)) {\n        return Optional.none();\n      }\n      if (isElement$6(container) && offset > container.childNodes.length - 1) {\n        directionLeft = false;\n      }\n      if (isDocument$1(container)) {\n        container = body;\n        offset = 0;\n      }\n      if (container === body) {\n        if (directionLeft) {\n          node = container.childNodes[offset > 0 ? offset - 1 : 0];\n          if (node) {\n            if (isCaretContainer$2(node)) {\n              return Optional.none();\n            }\n            if (nonEmptyElementsMap[node.nodeName] || isTable(node)) {\n              return Optional.none();\n            }\n          }\n        }\n        if (container.hasChildNodes()) {\n          offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);\n          container = container.childNodes[offset];\n          offset = isText$8(container) && isAfterNode ? container.data.length : 0;\n          if (!collapsed && container === body.lastChild && isTable(container)) {\n            return Optional.none();\n          }\n          if (hasContentEditableFalseParent(body, container) || isCaretContainer$2(container)) {\n            return Optional.none();\n          }\n          if (container.hasChildNodes() && isTable(container) === false) {\n            node = container;\n            const walker = new DomTreeWalker(container, body);\n            do {\n              if (isContentEditableFalse$a(node) || isCaretContainer$2(node)) {\n                normalized = false;\n                break;\n              }\n              if (isText$8(node) && node.nodeValue.length > 0) {\n                offset = directionLeft ? 0 : node.nodeValue.length;\n                container = node;\n                normalized = true;\n                break;\n              }\n              if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCell$2(node)) {\n                offset = dom.nodeIndex(node);\n                container = node.parentNode;\n                if (!directionLeft) {\n                  offset++;\n                }\n                normalized = true;\n                break;\n              }\n            } while (node = directionLeft ? walker.next() : walker.prev());\n          }\n        }\n      }\n      if (collapsed) {\n        if (isText$8(container) && offset === 0) {\n          findTextNodeRelative(dom, isAfterNode, collapsed, true, container).each(pos => {\n            container = pos.container();\n            offset = pos.offset();\n            normalized = true;\n          });\n        }\n        if (isElement$6(container)) {\n          node = container.childNodes[offset];\n          if (!node) {\n            node = container.childNodes[offset - 1];\n          }\n          if (node && isBr$5(node) && !isPrevNode(node, 'A') && !hasBrBeforeAfter(dom, node, false) && !hasBrBeforeAfter(dom, node, true)) {\n            findTextNodeRelative(dom, isAfterNode, collapsed, true, node).each(pos => {\n              container = pos.container();\n              offset = pos.offset();\n              normalized = true;\n            });\n          }\n        }\n      }\n      if (directionLeft && !collapsed && isText$8(container) && offset === container.nodeValue.length) {\n        findTextNodeRelative(dom, isAfterNode, collapsed, false, container).each(pos => {\n          container = pos.container();\n          offset = pos.offset();\n          normalized = true;\n        });\n      }\n      return normalized ? Optional.some(CaretPosition(container, offset)) : Optional.none();\n    };\n    const normalize$2 = (dom, rng) => {\n      const collapsed = rng.collapsed, normRng = rng.cloneRange();\n      const startPos = CaretPosition.fromRangeStart(rng);\n      normalizeEndPoint(dom, collapsed, true, normRng).each(pos => {\n        if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {\n          normRng.setStart(pos.container(), pos.offset());\n        }\n      });\n      if (!collapsed) {\n        normalizeEndPoint(dom, collapsed, false, normRng).each(pos => {\n          normRng.setEnd(pos.container(), pos.offset());\n        });\n      }\n      if (collapsed) {\n        normRng.collapse(true);\n      }\n      return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);\n    };\n\n    const splitText = (node, offset) => {\n      return node.splitText(offset);\n    };\n    const split = rng => {\n      let startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;\n      if (startContainer === endContainer && isText$8(startContainer)) {\n        if (startOffset > 0 && startOffset < startContainer.nodeValue.length) {\n          endContainer = splitText(startContainer, startOffset);\n          startContainer = endContainer.previousSibling;\n          if (endOffset > startOffset) {\n            endOffset = endOffset - startOffset;\n            startContainer = endContainer = splitText(endContainer, endOffset).previousSibling;\n            endOffset = endContainer.nodeValue.length;\n            startOffset = 0;\n          } else {\n            endOffset = 0;\n          }\n        }\n      } else {\n        if (isText$8(startContainer) && startOffset > 0 && startOffset < startContainer.nodeValue.length) {\n          startContainer = splitText(startContainer, startOffset);\n          startOffset = 0;\n        }\n        if (isText$8(endContainer) && endOffset > 0 && endOffset < endContainer.nodeValue.length) {\n          endContainer = splitText(endContainer, endOffset).previousSibling;\n          endOffset = endContainer.nodeValue.length;\n        }\n      }\n      return {\n        startContainer,\n        startOffset,\n        endContainer,\n        endOffset\n      };\n    };\n\n    const RangeUtils = dom => {\n      const walk = (rng, callback) => {\n        return walk$3(dom, rng, callback);\n      };\n      const split$1 = split;\n      const normalize = rng => {\n        return normalize$2(dom, rng).fold(never, normalizedRng => {\n          rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);\n          rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);\n          return true;\n        });\n      };\n      return {\n        walk,\n        split: split$1,\n        normalize\n      };\n    };\n    RangeUtils.compareRanges = isEq$4;\n    RangeUtils.getCaretRangeFromPoint = fromPoint;\n    RangeUtils.getSelectedNode = getSelectedNode;\n    RangeUtils.getNode = getNode$1;\n\n    const Dimension = (name, getOffset) => {\n      const set = (element, h) => {\n        if (!isNumber(h) && !h.match(/^[0-9]+$/)) {\n          throw new Error(name + '.set accepts only positive integer values. Value was ' + h);\n        }\n        const dom = element.dom;\n        if (isSupported$1(dom)) {\n          dom.style[name] = h + 'px';\n        }\n      };\n      const get = element => {\n        const r = getOffset(element);\n        if (r <= 0 || r === null) {\n          const css = get$7(element, name);\n          return parseFloat(css) || 0;\n        }\n        return r;\n      };\n      const getOuter = get;\n      const aggregate = (element, properties) => foldl(properties, (acc, property) => {\n        const val = get$7(element, property);\n        const value = val === undefined ? 0 : parseInt(val, 10);\n        return isNaN(value) ? acc : acc + value;\n      }, 0);\n      const max = (element, value, properties) => {\n        const cumulativeInclusions = aggregate(element, properties);\n        const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;\n        return absoluteMax;\n      };\n      return {\n        set,\n        get,\n        getOuter,\n        aggregate,\n        max\n      };\n    };\n\n    const api = Dimension('height', element => {\n      const dom = element.dom;\n      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;\n    });\n    const get$2 = element => api.get(element);\n\n    const getDocument = () => SugarElement.fromDom(document);\n\n    const walkUp = (navigation, doc) => {\n      const frame = navigation.view(doc);\n      return frame.fold(constant([]), f => {\n        const parent = navigation.owner(f);\n        const rest = walkUp(navigation, parent);\n        return [f].concat(rest);\n      });\n    };\n    const pathTo = (element, navigation) => {\n      const d = navigation.owner(element);\n      return walkUp(navigation, d);\n    };\n\n    const view = doc => {\n      var _a;\n      const element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);\n      return element.map(SugarElement.fromDom);\n    };\n    const owner = element => documentOrOwner(element);\n\n    var Navigation = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        view: view,\n        owner: owner\n    });\n\n    const find = element => {\n      const doc = getDocument();\n      const scroll = get$5(doc);\n      const frames = pathTo(element, Navigation);\n      const offset = viewport(element);\n      const r = foldr(frames, (b, a) => {\n        const loc = viewport(a);\n        return {\n          left: b.left + loc.left,\n          top: b.top + loc.top\n        };\n      }, {\n        left: 0,\n        top: 0\n      });\n      return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);\n    };\n\n    const excludeFromDescend = element => name(element) === 'textarea';\n    const fireScrollIntoViewEvent = (editor, data) => {\n      const scrollEvent = editor.dispatch('ScrollIntoView', data);\n      return scrollEvent.isDefaultPrevented();\n    };\n    const fireAfterScrollIntoViewEvent = (editor, data) => {\n      editor.dispatch('AfterScrollIntoView', data);\n    };\n    const descend = (element, offset) => {\n      const children$1 = children(element);\n      if (children$1.length === 0 || excludeFromDescend(element)) {\n        return {\n          element,\n          offset\n        };\n      } else if (offset < children$1.length && !excludeFromDescend(children$1[offset])) {\n        return {\n          element: children$1[offset],\n          offset: 0\n        };\n      } else {\n        const last = children$1[children$1.length - 1];\n        if (excludeFromDescend(last)) {\n          return {\n            element,\n            offset\n          };\n        } else {\n          if (name(last) === 'img') {\n            return {\n              element: last,\n              offset: 1\n            };\n          } else if (isText$9(last)) {\n            return {\n              element: last,\n              offset: get$3(last).length\n            };\n          } else {\n            return {\n              element: last,\n              offset: children(last).length\n            };\n          }\n        }\n      }\n    };\n    const markerInfo = (element, cleanupFun) => {\n      const pos = absolute(element);\n      const height = get$2(element);\n      return {\n        element,\n        bottom: pos.top + height,\n        height,\n        pos,\n        cleanup: cleanupFun\n      };\n    };\n    const createMarker$1 = (element, offset) => {\n      const startPoint = descend(element, offset);\n      const span = SugarElement.fromHtml('<span data-mce-bogus=\"all\" style=\"display: inline-block;\">' + ZWSP$1 + '</span>');\n      before$3(startPoint.element, span);\n      return markerInfo(span, () => remove$5(span));\n    };\n    const elementMarker = element => markerInfo(SugarElement.fromDom(element), noop);\n    const withMarker = (editor, f, rng, alignToTop) => {\n      preserveWith(editor, (_s, _e) => applyWithMarker(editor, f, rng, alignToTop), rng);\n    };\n    const withScrollEvents = (editor, doc, f, marker, alignToTop) => {\n      const data = {\n        elm: marker.element.dom,\n        alignToTop\n      };\n      if (fireScrollIntoViewEvent(editor, data)) {\n        return;\n      }\n      const scrollTop = get$5(doc).top;\n      f(doc, scrollTop, marker, alignToTop);\n      fireAfterScrollIntoViewEvent(editor, data);\n    };\n    const applyWithMarker = (editor, f, rng, alignToTop) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const doc = SugarElement.fromDom(editor.getDoc());\n      reflow(body);\n      const marker = createMarker$1(SugarElement.fromDom(rng.startContainer), rng.startOffset);\n      withScrollEvents(editor, doc, f, marker, alignToTop);\n      marker.cleanup();\n    };\n    const withElement = (editor, element, f, alignToTop) => {\n      const doc = SugarElement.fromDom(editor.getDoc());\n      withScrollEvents(editor, doc, f, elementMarker(element), alignToTop);\n    };\n    const preserveWith = (editor, f, rng) => {\n      const startElement = rng.startContainer;\n      const startOffset = rng.startOffset;\n      const endElement = rng.endContainer;\n      const endOffset = rng.endOffset;\n      f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));\n      const newRng = editor.dom.createRng();\n      newRng.setStart(startElement, startOffset);\n      newRng.setEnd(endElement, endOffset);\n      editor.selection.setRng(rng);\n    };\n    const scrollToMarker = (marker, viewHeight, alignToTop, doc) => {\n      const pos = marker.pos;\n      if (alignToTop) {\n        to(pos.left, pos.top, doc);\n      } else {\n        const y = pos.top - viewHeight + marker.height;\n        to(pos.left, y, doc);\n      }\n    };\n    const intoWindowIfNeeded = (doc, scrollTop, viewHeight, marker, alignToTop) => {\n      const viewportBottom = viewHeight + scrollTop;\n      const markerTop = marker.pos.top;\n      const markerBottom = marker.bottom;\n      const largerThanViewport = markerBottom - markerTop >= viewHeight;\n      if (markerTop < scrollTop) {\n        scrollToMarker(marker, viewHeight, alignToTop !== false, doc);\n      } else if (markerTop > viewportBottom) {\n        const align = largerThanViewport ? alignToTop !== false : alignToTop === true;\n        scrollToMarker(marker, viewHeight, align, doc);\n      } else if (markerBottom > viewportBottom && !largerThanViewport) {\n        scrollToMarker(marker, viewHeight, alignToTop === true, doc);\n      }\n    };\n    const intoWindow = (doc, scrollTop, marker, alignToTop) => {\n      const viewHeight = doc.dom.defaultView.innerHeight;\n      intoWindowIfNeeded(doc, scrollTop, viewHeight, marker, alignToTop);\n    };\n    const intoFrame = (doc, scrollTop, marker, alignToTop) => {\n      const frameViewHeight = doc.dom.defaultView.innerHeight;\n      intoWindowIfNeeded(doc, scrollTop, frameViewHeight, marker, alignToTop);\n      const op = find(marker.element);\n      const viewportBounds = getBounds(window);\n      if (op.top < viewportBounds.y) {\n        intoView(marker.element, alignToTop !== false);\n      } else if (op.top > viewportBounds.bottom) {\n        intoView(marker.element, alignToTop === true);\n      }\n    };\n    const rangeIntoWindow = (editor, rng, alignToTop) => withMarker(editor, intoWindow, rng, alignToTop);\n    const elementIntoWindow = (editor, element, alignToTop) => withElement(editor, element, intoWindow, alignToTop);\n    const rangeIntoFrame = (editor, rng, alignToTop) => withMarker(editor, intoFrame, rng, alignToTop);\n    const elementIntoFrame = (editor, element, alignToTop) => withElement(editor, element, intoFrame, alignToTop);\n    const scrollElementIntoView = (editor, element, alignToTop) => {\n      const scroller = editor.inline ? elementIntoWindow : elementIntoFrame;\n      scroller(editor, element, alignToTop);\n    };\n    const scrollRangeIntoView = (editor, rng, alignToTop) => {\n      const scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;\n      scroller(editor, rng, alignToTop);\n    };\n\n    const focus$1 = element => element.dom.focus();\n    const hasFocus$1 = element => {\n      const root = getRootNode(element).dom;\n      return element.dom === root.activeElement;\n    };\n    const active$1 = (root = getDocument()) => Optional.from(root.dom.activeElement).map(SugarElement.fromDom);\n    const search = element => active$1(getRootNode(element)).filter(e => element.dom.contains(e.dom));\n\n    const clamp$1 = (offset, element) => {\n      const max = isText$9(element) ? get$3(element).length : children(element).length + 1;\n      if (offset > max) {\n        return max;\n      } else if (offset < 0) {\n        return 0;\n      }\n      return offset;\n    };\n    const normalizeRng = rng => SimSelection.range(rng.start, clamp$1(rng.soffset, rng.start), rng.finish, clamp$1(rng.foffset, rng.finish));\n    const isOrContains = (root, elm) => !isRestrictedNode(elm.dom) && (contains(root, elm) || eq(root, elm));\n    const isRngInRoot = root => rng => isOrContains(root, rng.start) && isOrContains(root, rng.finish);\n    const shouldStore = editor => editor.inline;\n    const nativeRangeToSelectionRange = r => SimSelection.range(SugarElement.fromDom(r.startContainer), r.startOffset, SugarElement.fromDom(r.endContainer), r.endOffset);\n    const readRange = win => {\n      const selection = win.getSelection();\n      const rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));\n      return rng.map(nativeRangeToSelectionRange);\n    };\n    const getBookmark = root => {\n      const win = defaultView(root);\n      return readRange(win.dom).filter(isRngInRoot(root));\n    };\n    const validate = (root, bookmark) => Optional.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);\n    const bookmarkToNativeRng = bookmark => {\n      const rng = document.createRange();\n      try {\n        rng.setStart(bookmark.start.dom, bookmark.soffset);\n        rng.setEnd(bookmark.finish.dom, bookmark.foffset);\n        return Optional.some(rng);\n      } catch (_) {\n        return Optional.none();\n      }\n    };\n    const store = editor => {\n      const newBookmark = shouldStore(editor) ? getBookmark(SugarElement.fromDom(editor.getBody())) : Optional.none();\n      editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;\n    };\n    const getRng = editor => {\n      const bookmark = editor.bookmark ? editor.bookmark : Optional.none();\n      return bookmark.bind(x => validate(SugarElement.fromDom(editor.getBody()), x)).bind(bookmarkToNativeRng);\n    };\n    const restore = editor => {\n      getRng(editor).each(rng => editor.selection.setRng(rng));\n    };\n\n    const isEditorUIElement$1 = elm => {\n      const className = elm.className.toString();\n      return className.indexOf('tox-') !== -1 || className.indexOf('mce-') !== -1;\n    };\n    const FocusManager = { isEditorUIElement: isEditorUIElement$1 };\n\n    const wrappedSetTimeout = (callback, time) => {\n      if (!isNumber(time)) {\n        time = 0;\n      }\n      return setTimeout(callback, time);\n    };\n    const wrappedSetInterval = (callback, time) => {\n      if (!isNumber(time)) {\n        time = 0;\n      }\n      return setInterval(callback, time);\n    };\n    const Delay = {\n      setEditorTimeout: (editor, callback, time) => {\n        return wrappedSetTimeout(() => {\n          if (!editor.removed) {\n            callback();\n          }\n        }, time);\n      },\n      setEditorInterval: (editor, callback, time) => {\n        const timer = wrappedSetInterval(() => {\n          if (!editor.removed) {\n            callback();\n          } else {\n            clearInterval(timer);\n          }\n        }, time);\n        return timer;\n      }\n    };\n\n    const isManualNodeChange = e => {\n      return e.type === 'nodechange' && e.selectionChange;\n    };\n    const registerPageMouseUp = (editor, throttledStore) => {\n      const mouseUpPage = () => {\n        throttledStore.throttle();\n      };\n      DOMUtils.DOM.bind(document, 'mouseup', mouseUpPage);\n      editor.on('remove', () => {\n        DOMUtils.DOM.unbind(document, 'mouseup', mouseUpPage);\n      });\n    };\n    const registerMouseUp = (editor, throttledStore) => {\n      editor.on('mouseup touchend', _e => {\n        throttledStore.throttle();\n      });\n    };\n    const registerEditorEvents = (editor, throttledStore) => {\n      registerMouseUp(editor, throttledStore);\n      editor.on('keyup NodeChange AfterSetSelectionRange', e => {\n        if (!isManualNodeChange(e)) {\n          store(editor);\n        }\n      });\n    };\n    const register$6 = editor => {\n      const throttledStore = first$1(() => {\n        store(editor);\n      }, 0);\n      editor.on('init', () => {\n        if (editor.inline) {\n          registerPageMouseUp(editor, throttledStore);\n        }\n        registerEditorEvents(editor, throttledStore);\n      });\n      editor.on('remove', () => {\n        throttledStore.cancel();\n      });\n    };\n\n    let documentFocusInHandler;\n    const DOM$9 = DOMUtils.DOM;\n    const isEditorUIElement = elm => {\n      return FocusManager.isEditorUIElement(elm);\n    };\n    const isEditorContentAreaElement = elm => {\n      const classList = elm.classList;\n      if (classList !== undefined) {\n        return classList.contains('tox-edit-area') || classList.contains('tox-edit-area__iframe') || classList.contains('mce-content-body');\n      } else {\n        return false;\n      }\n    };\n    const isUIElement = (editor, elm) => {\n      const customSelector = getCustomUiSelector(editor);\n      const parent = DOM$9.getParent(elm, elm => {\n        return isEditorUIElement(elm) || (customSelector ? editor.dom.is(elm, customSelector) : false);\n      });\n      return parent !== null;\n    };\n    const getActiveElement = editor => {\n      try {\n        const root = getRootNode(SugarElement.fromDom(editor.getElement()));\n        return active$1(root).fold(() => document.body, x => x.dom);\n      } catch (ex) {\n        return document.body;\n      }\n    };\n    const registerEvents$1 = (editorManager, e) => {\n      const editor = e.editor;\n      register$6(editor);\n      editor.on('focusin', () => {\n        const focusedEditor = editorManager.focusedEditor;\n        if (focusedEditor !== editor) {\n          if (focusedEditor) {\n            focusedEditor.dispatch('blur', { focusedEditor: editor });\n          }\n          editorManager.setActive(editor);\n          editorManager.focusedEditor = editor;\n          editor.dispatch('focus', { blurredEditor: focusedEditor });\n          editor.focus(true);\n        }\n      });\n      editor.on('focusout', () => {\n        Delay.setEditorTimeout(editor, () => {\n          const focusedEditor = editorManager.focusedEditor;\n          if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {\n            editor.dispatch('blur', { focusedEditor: null });\n            editorManager.focusedEditor = null;\n          }\n        });\n      });\n      if (!documentFocusInHandler) {\n        documentFocusInHandler = e => {\n          const activeEditor = editorManager.activeEditor;\n          if (activeEditor) {\n            getOriginalEventTarget(e).each(target => {\n              if (target.ownerDocument === document) {\n                if (target !== document.body && !isUIElement(activeEditor, target) && editorManager.focusedEditor === activeEditor) {\n                  activeEditor.dispatch('blur', { focusedEditor: null });\n                  editorManager.focusedEditor = null;\n                }\n              }\n            });\n          }\n        };\n        DOM$9.bind(document, 'focusin', documentFocusInHandler);\n      }\n    };\n    const unregisterDocumentEvents = (editorManager, e) => {\n      if (editorManager.focusedEditor === e.editor) {\n        editorManager.focusedEditor = null;\n      }\n      if (!editorManager.activeEditor) {\n        DOM$9.unbind(document, 'focusin', documentFocusInHandler);\n        documentFocusInHandler = null;\n      }\n    };\n    const setup$v = editorManager => {\n      editorManager.on('AddEditor', curry(registerEvents$1, editorManager));\n      editorManager.on('RemoveEditor', curry(unregisterDocumentEvents, editorManager));\n    };\n\n    const getContentEditableHost = (editor, node) => editor.dom.getParent(node, node => editor.dom.getContentEditable(node) === 'true');\n    const getCollapsedNode = rng => rng.collapsed ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();\n    const getFocusInElement = (root, rng) => getCollapsedNode(rng).bind(node => {\n      if (isTableSection(node)) {\n        return Optional.some(node);\n      } else if (contains(root, node) === false) {\n        return Optional.some(root);\n      } else {\n        return Optional.none();\n      }\n    });\n    const normalizeSelection$1 = (editor, rng) => {\n      getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind(elm => {\n        return firstPositionIn(elm.dom);\n      }).fold(() => {\n        editor.selection.normalize();\n        return;\n      }, caretPos => editor.selection.setRng(caretPos.toRange()));\n    };\n    const focusBody = body => {\n      if (body.setActive) {\n        try {\n          body.setActive();\n        } catch (ex) {\n          body.focus();\n        }\n      } else {\n        body.focus();\n      }\n    };\n    const hasElementFocus = elm => hasFocus$1(elm) || search(elm).isSome();\n    const hasIframeFocus = editor => editor.iframeElement && hasFocus$1(SugarElement.fromDom(editor.iframeElement));\n    const hasInlineFocus = editor => {\n      const rawBody = editor.getBody();\n      return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));\n    };\n    const hasUiFocus = editor => {\n      const dos = getRootNode(SugarElement.fromDom(editor.getElement()));\n      return active$1(dos).filter(elem => !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom)).isSome();\n    };\n    const hasFocus = editor => editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);\n    const hasEditorOrUiFocus = editor => hasFocus(editor) || hasUiFocus(editor);\n    const focusEditor = editor => {\n      const selection = editor.selection;\n      const body = editor.getBody();\n      let rng = selection.getRng();\n      editor.quirks.refreshContentEditable();\n      if (editor.bookmark !== undefined && hasFocus(editor) === false) {\n        getRng(editor).each(bookmarkRng => {\n          editor.selection.setRng(bookmarkRng);\n          rng = bookmarkRng;\n        });\n      }\n      const contentEditableHost = getContentEditableHost(editor, selection.getNode());\n      if (editor.dom.isChildOf(contentEditableHost, body)) {\n        focusBody(contentEditableHost);\n        normalizeSelection$1(editor, rng);\n        activateEditor(editor);\n        return;\n      }\n      if (!editor.inline) {\n        if (!Env.browser.isOpera()) {\n          focusBody(body);\n        }\n        editor.getWin().focus();\n      }\n      if (Env.browser.isFirefox() || editor.inline) {\n        focusBody(body);\n        normalizeSelection$1(editor, rng);\n      }\n      activateEditor(editor);\n    };\n    const activateEditor = editor => editor.editorManager.setActive(editor);\n    const focus = (editor, skipFocus) => {\n      if (editor.removed) {\n        return;\n      }\n      if (skipFocus) {\n        activateEditor(editor);\n      } else {\n        focusEditor(editor);\n      }\n    };\n\n    const getEndpointElement = (root, rng, start, real, resolve) => {\n      const container = start ? rng.startContainer : rng.endContainer;\n      const offset = start ? rng.startOffset : rng.endOffset;\n      return Optional.from(container).map(SugarElement.fromDom).map(elm => !real || !rng.collapsed ? child$1(elm, resolve(elm, offset)).getOr(elm) : elm).bind(elm => isElement$7(elm) ? Optional.some(elm) : parent(elm).filter(isElement$7)).map(elm => elm.dom).getOr(root);\n    };\n    const getStart = (root, rng, real) => getEndpointElement(root, rng, true, real, (elm, offset) => Math.min(childNodesCount(elm), offset));\n    const getEnd$1 = (root, rng, real) => getEndpointElement(root, rng, false, real, (elm, offset) => offset > 0 ? offset - 1 : offset);\n    const skipEmptyTextNodes = (node, forwards) => {\n      const orig = node;\n      while (node && isText$8(node) && node.length === 0) {\n        node = forwards ? node.nextSibling : node.previousSibling;\n      }\n      return node || orig;\n    };\n    const getNode = (root, rng) => {\n      let elm, startContainer, endContainer;\n      if (!rng) {\n        return root;\n      }\n      startContainer = rng.startContainer;\n      endContainer = rng.endContainer;\n      const startOffset = rng.startOffset;\n      const endOffset = rng.endOffset;\n      elm = rng.commonAncestorContainer;\n      if (!rng.collapsed) {\n        if (startContainer === endContainer) {\n          if (endOffset - startOffset < 2) {\n            if (startContainer.hasChildNodes()) {\n              elm = startContainer.childNodes[startOffset];\n            }\n          }\n        }\n        if (startContainer.nodeType === 3 && endContainer.nodeType === 3) {\n          if (startContainer.length === startOffset) {\n            startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);\n          } else {\n            startContainer = startContainer.parentNode;\n          }\n          if (endOffset === 0) {\n            endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);\n          } else {\n            endContainer = endContainer.parentNode;\n          }\n          if (startContainer && startContainer === endContainer) {\n            return startContainer;\n          }\n        }\n      }\n      if (elm && elm.nodeType === 3) {\n        return elm.parentNode;\n      }\n      return elm;\n    };\n    const getSelectedBlocks = (dom, rng, startElm, endElm) => {\n      let node;\n      const selectedBlocks = [];\n      const root = dom.getRoot();\n      startElm = dom.getParent(startElm || getStart(root, rng, rng.collapsed), dom.isBlock);\n      endElm = dom.getParent(endElm || getEnd$1(root, rng, rng.collapsed), dom.isBlock);\n      if (startElm && startElm !== root) {\n        selectedBlocks.push(startElm);\n      }\n      if (startElm && endElm && startElm !== endElm) {\n        node = startElm;\n        const walker = new DomTreeWalker(startElm, root);\n        while ((node = walker.next()) && node !== endElm) {\n          if (dom.isBlock(node)) {\n            selectedBlocks.push(node);\n          }\n        }\n      }\n      if (endElm && startElm !== endElm && endElm !== root) {\n        selectedBlocks.push(endElm);\n      }\n      return selectedBlocks;\n    };\n    const select = (dom, node, content) => Optional.from(node).map(node => {\n      const idx = dom.nodeIndex(node);\n      const rng = dom.createRng();\n      rng.setStart(node.parentNode, idx);\n      rng.setEnd(node.parentNode, idx + 1);\n      if (content) {\n        moveEndPoint(dom, rng, node, true);\n        moveEndPoint(dom, rng, node, false);\n      }\n      return rng;\n    });\n\n    const processRanges = (editor, ranges) => map$3(ranges, range => {\n      const evt = editor.dispatch('GetSelectionRange', { range });\n      return evt.range !== range ? evt.range : range;\n    });\n\n    const getEnd = element => name(element) === 'img' ? 1 : getOption(element).fold(() => children(element).length, v => v.length);\n    const isTextNodeWithCursorPosition = el => getOption(el).filter(text => text.trim().length !== 0 || text.indexOf(nbsp) > -1).isSome();\n    const elementsWithCursorPosition = [\n      'img',\n      'br'\n    ];\n    const isCursorPosition = elem => {\n      const hasCursorPosition = isTextNodeWithCursorPosition(elem);\n      return hasCursorPosition || contains$2(elementsWithCursorPosition, name(elem));\n    };\n\n    const first = element => descendant$1(element, isCursorPosition);\n    const last = element => descendantRtl(element, isCursorPosition);\n    const descendantRtl = (scope, predicate) => {\n      const descend = element => {\n        const children$1 = children(element);\n        for (let i = children$1.length - 1; i >= 0; i--) {\n          const child = children$1[i];\n          if (predicate(child)) {\n            return Optional.some(child);\n          }\n          const res = descend(child);\n          if (res.isSome()) {\n            return res;\n          }\n        }\n        return Optional.none();\n      };\n      return descend(scope);\n    };\n\n    const autocompleteSelector = '[data-mce-autocompleter]';\n    const create$8 = (editor, range) => {\n      if (findIn(SugarElement.fromDom(editor.getBody())).isNone()) {\n        const wrapper = SugarElement.fromHtml('<span data-mce-autocompleter=\"1\" data-mce-bogus=\"1\"></span>', editor.getDoc());\n        append$1(wrapper, SugarElement.fromDom(range.extractContents()));\n        range.insertNode(wrapper.dom);\n        parent(wrapper).each(elm => elm.dom.normalize());\n        last(wrapper).map(last => {\n          editor.selection.setCursorLocation(last.dom, getEnd(last));\n        });\n      }\n    };\n    const detect$1 = elm => closest$3(elm, autocompleteSelector);\n    const findIn = elm => descendant(elm, autocompleteSelector);\n    const remove$3 = (editor, elm) => findIn(elm).each(wrapper => {\n      const bookmark = editor.selection.getBookmark();\n      unwrap(wrapper);\n      editor.selection.moveToBookmark(bookmark);\n    });\n\n    const typeLookup = {\n      '#text': 3,\n      '#comment': 8,\n      '#cdata': 4,\n      '#pi': 7,\n      '#doctype': 10,\n      '#document-fragment': 11\n    };\n    const walk$2 = (node, root, prev) => {\n      const startName = prev ? 'lastChild' : 'firstChild';\n      const siblingName = prev ? 'prev' : 'next';\n      if (node[startName]) {\n        return node[startName];\n      }\n      if (node !== root) {\n        let sibling = node[siblingName];\n        if (sibling) {\n          return sibling;\n        }\n        for (let parent = node.parent; parent && parent !== root; parent = parent.parent) {\n          sibling = parent[siblingName];\n          if (sibling) {\n            return sibling;\n          }\n        }\n      }\n    };\n    const isEmptyTextNode = node => {\n      if (!isWhitespaceText(node.value)) {\n        return false;\n      }\n      const parentNode = node.parent;\n      if (parentNode && (parentNode.name !== 'span' || parentNode.attr('style')) && /^[ ]+$/.test(node.value)) {\n        return false;\n      }\n      return true;\n    };\n    const isNonEmptyElement = node => {\n      const isNamedAnchor = node.name === 'a' && !node.attr('href') && node.attr('id');\n      return node.attr('name') || node.attr('id') && !node.firstChild || node.attr('data-mce-bookmark') || isNamedAnchor;\n    };\n    class AstNode {\n      constructor(name, type) {\n        this.name = name;\n        this.type = type;\n        if (type === 1) {\n          this.attributes = [];\n          this.attributes.map = {};\n        }\n      }\n      static create(name, attrs) {\n        const node = new AstNode(name, typeLookup[name] || 1);\n        if (attrs) {\n          each$f(attrs, (value, attrName) => {\n            node.attr(attrName, value);\n          });\n        }\n        return node;\n      }\n      replace(node) {\n        const self = this;\n        if (node.parent) {\n          node.remove();\n        }\n        self.insert(node, self);\n        self.remove();\n        return self;\n      }\n      attr(name, value) {\n        const self = this;\n        let attrs;\n        if (typeof name !== 'string') {\n          if (name !== undefined && name !== null) {\n            each$f(name, (value, key) => {\n              self.attr(key, value);\n            });\n          }\n          return self;\n        }\n        if (attrs = self.attributes) {\n          if (value !== undefined) {\n            if (value === null) {\n              if (name in attrs.map) {\n                delete attrs.map[name];\n                let i = attrs.length;\n                while (i--) {\n                  if (attrs[i].name === name) {\n                    attrs.splice(i, 1);\n                    return self;\n                  }\n                }\n              }\n              return self;\n            }\n            if (name in attrs.map) {\n              let i = attrs.length;\n              while (i--) {\n                if (attrs[i].name === name) {\n                  attrs[i].value = value;\n                  break;\n                }\n              }\n            } else {\n              attrs.push({\n                name,\n                value\n              });\n            }\n            attrs.map[name] = value;\n            return self;\n          }\n          return attrs.map[name];\n        }\n      }\n      clone() {\n        const self = this;\n        const clone = new AstNode(self.name, self.type);\n        let selfAttrs;\n        if (selfAttrs = self.attributes) {\n          const cloneAttrs = [];\n          cloneAttrs.map = {};\n          for (let i = 0, l = selfAttrs.length; i < l; i++) {\n            const selfAttr = selfAttrs[i];\n            if (selfAttr.name !== 'id') {\n              cloneAttrs[cloneAttrs.length] = {\n                name: selfAttr.name,\n                value: selfAttr.value\n              };\n              cloneAttrs.map[selfAttr.name] = selfAttr.value;\n            }\n          }\n          clone.attributes = cloneAttrs;\n        }\n        clone.value = self.value;\n        return clone;\n      }\n      wrap(wrapper) {\n        const self = this;\n        self.parent.insert(wrapper, self);\n        wrapper.append(self);\n        return self;\n      }\n      unwrap() {\n        const self = this;\n        for (let node = self.firstChild; node;) {\n          const next = node.next;\n          self.insert(node, self, true);\n          node = next;\n        }\n        self.remove();\n      }\n      remove() {\n        const self = this, parent = self.parent, next = self.next, prev = self.prev;\n        if (parent) {\n          if (parent.firstChild === self) {\n            parent.firstChild = next;\n            if (next) {\n              next.prev = null;\n            }\n          } else {\n            prev.next = next;\n          }\n          if (parent.lastChild === self) {\n            parent.lastChild = prev;\n            if (prev) {\n              prev.next = null;\n            }\n          } else {\n            next.prev = prev;\n          }\n          self.parent = self.next = self.prev = null;\n        }\n        return self;\n      }\n      append(node) {\n        const self = this;\n        if (node.parent) {\n          node.remove();\n        }\n        const last = self.lastChild;\n        if (last) {\n          last.next = node;\n          node.prev = last;\n          self.lastChild = node;\n        } else {\n          self.lastChild = self.firstChild = node;\n        }\n        node.parent = self;\n        return node;\n      }\n      insert(node, refNode, before) {\n        if (node.parent) {\n          node.remove();\n        }\n        const parent = refNode.parent || this;\n        if (before) {\n          if (refNode === parent.firstChild) {\n            parent.firstChild = node;\n          } else {\n            refNode.prev.next = node;\n          }\n          node.prev = refNode.prev;\n          node.next = refNode;\n          refNode.prev = node;\n        } else {\n          if (refNode === parent.lastChild) {\n            parent.lastChild = node;\n          } else {\n            refNode.next.prev = node;\n          }\n          node.next = refNode.next;\n          node.prev = refNode;\n          refNode.next = node;\n        }\n        node.parent = parent;\n        return node;\n      }\n      getAll(name) {\n        const self = this;\n        const collection = [];\n        for (let node = self.firstChild; node; node = walk$2(node, self)) {\n          if (node.name === name) {\n            collection.push(node);\n          }\n        }\n        return collection;\n      }\n      children() {\n        const self = this;\n        const collection = [];\n        for (let node = self.firstChild; node; node = node.next) {\n          collection.push(node);\n        }\n        return collection;\n      }\n      empty() {\n        const self = this;\n        if (self.firstChild) {\n          const nodes = [];\n          for (let node = self.firstChild; node; node = walk$2(node, self)) {\n            nodes.push(node);\n          }\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;\n          }\n        }\n        self.firstChild = self.lastChild = null;\n        return self;\n      }\n      isEmpty(elements, whitespace = {}, predicate) {\n        const self = this;\n        let node = self.firstChild;\n        if (isNonEmptyElement(self)) {\n          return false;\n        }\n        if (node) {\n          do {\n            if (node.type === 1) {\n              if (node.attr('data-mce-bogus')) {\n                continue;\n              }\n              if (elements[node.name]) {\n                return false;\n              }\n              if (isNonEmptyElement(node)) {\n                return false;\n              }\n            }\n            if (node.type === 8) {\n              return false;\n            }\n            if (node.type === 3 && !isEmptyTextNode(node)) {\n              return false;\n            }\n            if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText(node.value)) {\n              return false;\n            }\n            if (predicate && predicate(node)) {\n              return false;\n            }\n          } while (node = walk$2(node, self));\n        }\n        return true;\n      }\n      walk(prev) {\n        return walk$2(this, null, prev);\n      }\n    }\n\n    const isConditionalComment = (html, startIndex) => /^\\s*\\[if [\\w\\W]+\\]>.*<!\\[endif\\](--!?)?>/.test(html.substr(startIndex));\n    const findCommentEndIndex = (html, isBogus, startIndex = 0) => {\n      const lcHtml = html.toLowerCase();\n      if (lcHtml.indexOf('[if ', startIndex) !== -1 && isConditionalComment(lcHtml, startIndex)) {\n        const endIfIndex = lcHtml.indexOf('[endif]', startIndex);\n        return lcHtml.indexOf('>', endIfIndex);\n      } else {\n        if (isBogus) {\n          const endIndex = lcHtml.indexOf('>', startIndex);\n          return endIndex !== -1 ? endIndex : lcHtml.length;\n        } else {\n          const endCommentRegexp = /--!?>/g;\n          endCommentRegexp.lastIndex = startIndex;\n          const match = endCommentRegexp.exec(html);\n          return match ? match.index + match[0].length : lcHtml.length;\n        }\n      }\n    };\n    const findMatchingEndTagIndex = (schema, html, startIndex) => {\n      const startTagRegExp = /<([!?\\/])?([A-Za-z0-9\\-_:.]+)/g;\n      const endTagRegExp = /(?:\\s(?:[^'\">]+(?:\"[^\"]*\"|'[^']*'))*[^\"'>]*(?:\"[^\">]*|'[^'>]*)?|\\s*|\\/)>/g;\n      const voidElements = schema.getVoidElements();\n      let count = 1, index = startIndex;\n      while (count !== 0) {\n        startTagRegExp.lastIndex = index;\n        while (true) {\n          const startMatch = startTagRegExp.exec(html);\n          if (startMatch === null) {\n            return index;\n          } else if (startMatch[1] === '!') {\n            if (startsWith(startMatch[2], '--')) {\n              index = findCommentEndIndex(html, false, startMatch.index + '!--'.length);\n            } else {\n              index = findCommentEndIndex(html, true, startMatch.index + 1);\n            }\n            break;\n          } else {\n            endTagRegExp.lastIndex = startTagRegExp.lastIndex;\n            const endMatch = endTagRegExp.exec(html);\n            if (isNull(endMatch) || endMatch.index !== startTagRegExp.lastIndex) {\n              continue;\n            }\n            if (startMatch[1] === '/') {\n              count -= 1;\n            } else if (!has$2(voidElements, startMatch[2])) {\n              count += 1;\n            }\n            index = startTagRegExp.lastIndex + endMatch[0].length;\n            break;\n          }\n        }\n      }\n      return index;\n    };\n    const trimHtml$1 = (tempAttrs, html) => {\n      const trimContentRegExp = new RegExp(['\\\\s?(' + tempAttrs.join('|') + ')=\"[^\"]+\"'].join('|'), 'gi');\n      return html.replace(trimContentRegExp, '');\n    };\n    const trimInternal = (serializer, html) => {\n      const bogusAllRegExp = /<(\\w+) [^>]*data-mce-bogus=\"all\"[^>]*>/g;\n      const schema = serializer.schema;\n      let content = trimHtml$1(serializer.getTempAttrs(), html);\n      const voidElements = schema.getVoidElements();\n      let matches;\n      while (matches = bogusAllRegExp.exec(content)) {\n        const index = bogusAllRegExp.lastIndex;\n        const matchLength = matches[0].length;\n        let endTagIndex;\n        if (voidElements[matches[1]]) {\n          endTagIndex = index;\n        } else {\n          endTagIndex = findMatchingEndTagIndex(schema, content, index);\n        }\n        content = content.substring(0, index - matchLength) + content.substring(endTagIndex);\n        bogusAllRegExp.lastIndex = index - matchLength;\n      }\n      return trim$1(content);\n    };\n    const trimExternal = trimInternal;\n\n    const trimEmptyContents = (editor, html) => {\n      const blockName = getForcedRootBlock(editor);\n      const emptyRegExp = new RegExp(`^(<${ blockName }[^>]*>(&nbsp;|&#160;|\\\\s|\\u00a0|<br \\\\/>|)<\\\\/${ blockName }>[\\r\\n]*|<br \\\\/>[\\r\\n]*)$`);\n      return html.replace(emptyRegExp, '');\n    };\n    const getContentFromBody = (editor, args, body) => {\n      let content;\n      if (args.format === 'raw') {\n        content = Tools.trim(trimExternal(editor.serializer, body.innerHTML));\n      } else if (args.format === 'text') {\n        content = editor.dom.isEmpty(body) ? '' : trim$1(body.innerText || body.textContent);\n      } else if (args.format === 'tree') {\n        content = editor.serializer.serialize(body, args);\n      } else {\n        content = trimEmptyContents(editor, editor.serializer.serialize(body, args));\n      }\n      const shouldTrim = args.format !== 'text' && !isWsPreserveElement(SugarElement.fromDom(body));\n      return shouldTrim && isString(content) ? Tools.trim(content) : content;\n    };\n    const getContentInternal = (editor, args) => Optional.from(editor.getBody()).fold(constant(args.format === 'tree' ? new AstNode('body', 11) : ''), body => getContentFromBody(editor, args, body));\n\n    const each$b = Tools.each;\n    const ElementUtils = dom => {\n      const compare = (node1, node2) => {\n        if (node1.nodeName !== node2.nodeName) {\n          return false;\n        }\n        const getAttribs = node => {\n          const attribs = {};\n          each$b(dom.getAttribs(node), attr => {\n            const name = attr.nodeName.toLowerCase();\n            if (name.indexOf('_') !== 0 && name !== 'style' && name.indexOf('data-') !== 0) {\n              attribs[name] = dom.getAttrib(node, name);\n            }\n          });\n          return attribs;\n        };\n        const compareObjects = (obj1, obj2) => {\n          let value, name;\n          for (name in obj1) {\n            if (has$2(obj1, name)) {\n              value = obj2[name];\n              if (typeof value === 'undefined') {\n                return false;\n              }\n              if (obj1[name] !== value) {\n                return false;\n              }\n              delete obj2[name];\n            }\n          }\n          for (name in obj2) {\n            if (has$2(obj2, name)) {\n              return false;\n            }\n          }\n          return true;\n        };\n        if (!compareObjects(getAttribs(node1), getAttribs(node2))) {\n          return false;\n        }\n        if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {\n          return false;\n        }\n        return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);\n      };\n      return { compare };\n    };\n\n    const makeMap$1 = Tools.makeMap;\n    const Writer = settings => {\n      const html = [];\n      settings = settings || {};\n      const indent = settings.indent;\n      const indentBefore = makeMap$1(settings.indent_before || '');\n      const indentAfter = makeMap$1(settings.indent_after || '');\n      const encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);\n      const htmlOutput = settings.element_format !== 'xhtml';\n      return {\n        start: (name, attrs, empty) => {\n          let i, l, attr, value;\n          if (indent && indentBefore[name] && html.length > 0) {\n            value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n          html.push('<', name);\n          if (attrs) {\n            for (i = 0, l = attrs.length; i < l; i++) {\n              attr = attrs[i];\n              html.push(' ', attr.name, '=\"', encode(attr.value, true), '\"');\n            }\n          }\n          if (!empty || htmlOutput) {\n            html[html.length] = '>';\n          } else {\n            html[html.length] = ' />';\n          }\n          if (empty && indent && indentAfter[name] && html.length > 0) {\n            value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n        },\n        end: name => {\n          let value;\n          html.push('</', name, '>');\n          if (indent && indentAfter[name] && html.length > 0) {\n            value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n        },\n        text: (text, raw) => {\n          if (text.length > 0) {\n            html[html.length] = raw ? text : encode(text);\n          }\n        },\n        cdata: text => {\n          html.push('<![CDATA[', text, ']]>');\n        },\n        comment: text => {\n          html.push('<!--', text, '-->');\n        },\n        pi: (name, text) => {\n          if (text) {\n            html.push('<?', name, ' ', encode(text), '?>');\n          } else {\n            html.push('<?', name, '?>');\n          }\n          if (indent) {\n            html.push('\\n');\n          }\n        },\n        doctype: text => {\n          html.push('<!DOCTYPE', text, '>', indent ? '\\n' : '');\n        },\n        reset: () => {\n          html.length = 0;\n        },\n        getContent: () => {\n          return html.join('').replace(/\\n$/, '');\n        }\n      };\n    };\n\n    const HtmlSerializer = (settings, schema = Schema()) => {\n      const writer = Writer(settings);\n      settings = settings || {};\n      settings.validate = 'validate' in settings ? settings.validate : true;\n      const serialize = node => {\n        const validate = settings.validate;\n        const handlers = {\n          3: node => {\n            writer.text(node.value, node.raw);\n          },\n          8: node => {\n            writer.comment(node.value);\n          },\n          7: node => {\n            writer.pi(node.name, node.value);\n          },\n          10: node => {\n            writer.doctype(node.value);\n          },\n          4: node => {\n            writer.cdata(node.value);\n          },\n          11: node => {\n            if (node = node.firstChild) {\n              do {\n                walk(node);\n              } while (node = node.next);\n            }\n          }\n        };\n        writer.reset();\n        const walk = node => {\n          const handler = handlers[node.type];\n          if (!handler) {\n            const name = node.name;\n            const isEmpty = name in schema.getVoidElements();\n            let attrs = node.attributes;\n            if (validate && attrs && attrs.length > 1) {\n              const sortedAttrs = [];\n              sortedAttrs.map = {};\n              const elementRule = schema.getElementRule(node.name);\n              if (elementRule) {\n                for (let i = 0, l = elementRule.attributesOrder.length; i < l; i++) {\n                  const attrName = elementRule.attributesOrder[i];\n                  if (attrName in attrs.map) {\n                    const attrValue = attrs.map[attrName];\n                    sortedAttrs.map[attrName] = attrValue;\n                    sortedAttrs.push({\n                      name: attrName,\n                      value: attrValue\n                    });\n                  }\n                }\n                for (let i = 0, l = attrs.length; i < l; i++) {\n                  const attrName = attrs[i].name;\n                  if (!(attrName in sortedAttrs.map)) {\n                    const attrValue = attrs.map[attrName];\n                    sortedAttrs.map[attrName] = attrValue;\n                    sortedAttrs.push({\n                      name: attrName,\n                      value: attrValue\n                    });\n                  }\n                }\n                attrs = sortedAttrs;\n              }\n            }\n            writer.start(name, attrs, isEmpty);\n            if (!isEmpty) {\n              let child = node.firstChild;\n              if (child) {\n                if ((name === 'pre' || name === 'textarea') && child.type === 3 && child.value[0] === '\\n') {\n                  writer.text('\\n', true);\n                }\n                do {\n                  walk(child);\n                } while (child = child.next);\n              }\n              writer.end(name);\n            }\n          } else {\n            handler(node);\n          }\n        };\n        if (node.type === 1 && !settings.inner) {\n          walk(node);\n        } else if (node.type === 3) {\n          handlers[3](node);\n        } else {\n          handlers[11](node);\n        }\n        return writer.getContent();\n      };\n      return { serialize };\n    };\n\n    const nonInheritableStyles = new Set();\n    (() => {\n      const nonInheritableStylesArr = [\n        'margin',\n        'margin-left',\n        'margin-right',\n        'margin-top',\n        'margin-bottom',\n        'padding',\n        'padding-left',\n        'padding-right',\n        'padding-top',\n        'padding-bottom',\n        'border',\n        'border-width',\n        'border-style',\n        'border-color',\n        'background',\n        'background-attachment',\n        'background-clip',\n        'background-color',\n        'background-image',\n        'background-origin',\n        'background-position',\n        'background-repeat',\n        'background-size',\n        'float',\n        'position',\n        'left',\n        'right',\n        'top',\n        'bottom',\n        'z-index',\n        'display',\n        'transform',\n        'width',\n        'max-width',\n        'min-width',\n        'height',\n        'max-height',\n        'min-height',\n        'overflow',\n        'overflow-x',\n        'overflow-y',\n        'text-overflow',\n        'vertical-align',\n        'transition',\n        'transition-delay',\n        'transition-duration',\n        'transition-property',\n        'transition-timing-function'\n      ];\n      each$g(nonInheritableStylesArr, style => {\n        nonInheritableStyles.add(style);\n      });\n    })();\n    const shorthandStyleProps = [\n      'font',\n      'text-decoration',\n      'text-emphasis'\n    ];\n    const getStyleProps = (dom, node) => keys(dom.parseStyle(dom.getAttrib(node, 'style')));\n    const isNonInheritableStyle = style => nonInheritableStyles.has(style);\n    const hasInheritableStyles = (dom, node) => forall(getStyleProps(dom, node), style => !isNonInheritableStyle(style));\n    const getLonghandStyleProps = styles => filter$6(styles, style => exists(shorthandStyleProps, prop => startsWith(style, prop)));\n    const hasStyleConflict = (dom, node, parentNode) => {\n      const nodeStyleProps = getStyleProps(dom, node);\n      const parentNodeStyleProps = getStyleProps(dom, parentNode);\n      const valueMismatch = prop => {\n        var _a, _b;\n        const nodeValue = (_a = dom.getStyle(node, prop)) !== null && _a !== void 0 ? _a : '';\n        const parentValue = (_b = dom.getStyle(parentNode, prop)) !== null && _b !== void 0 ? _b : '';\n        return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;\n      };\n      return exists(nodeStyleProps, nodeStyleProp => {\n        const propExists = props => exists(props, prop => prop === nodeStyleProp);\n        if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {\n          const longhandProps = getLonghandStyleProps(parentNodeStyleProps);\n          return exists(longhandProps, valueMismatch);\n        } else {\n          return valueMismatch(nodeStyleProp);\n        }\n      });\n    };\n\n    const isChar = (forward, predicate, pos) => Optional.from(pos.container()).filter(isText$8).exists(text => {\n      const delta = forward ? 0 : -1;\n      return predicate(text.data.charAt(pos.offset() + delta));\n    });\n    const isBeforeSpace = curry(isChar, true, isWhiteSpace);\n    const isAfterSpace = curry(isChar, false, isWhiteSpace);\n    const isEmptyText = pos => {\n      const container = pos.container();\n      return isText$8(container) && (container.data.length === 0 || isZwsp(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));\n    };\n    const matchesElementPosition = (before, predicate) => pos => Optional.from(getChildNodeAtRelativeOffset(before ? 0 : -1, pos)).filter(predicate).isSome();\n    const isImageBlock = node => isImg(node) && get$7(SugarElement.fromDom(node), 'display') === 'block';\n    const isCefNode = node => isContentEditableFalse$a(node) && !isBogusAll$1(node);\n    const isBeforeImageBlock = matchesElementPosition(true, isImageBlock);\n    const isAfterImageBlock = matchesElementPosition(false, isImageBlock);\n    const isBeforeMedia = matchesElementPosition(true, isMedia$2);\n    const isAfterMedia = matchesElementPosition(false, isMedia$2);\n    const isBeforeTable = matchesElementPosition(true, isTable$3);\n    const isAfterTable = matchesElementPosition(false, isTable$3);\n    const isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);\n    const isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);\n\n    const getLastChildren = elm => {\n      const children = [];\n      let rawNode = elm.dom;\n      while (rawNode) {\n        children.push(SugarElement.fromDom(rawNode));\n        rawNode = rawNode.lastChild;\n      }\n      return children;\n    };\n    const removeTrailingBr = elm => {\n      const allBrs = descendants(elm, 'br');\n      const brs = filter$6(getLastChildren(elm).slice(-1), isBr$4);\n      if (allBrs.length === brs.length) {\n        each$g(brs, remove$5);\n      }\n    };\n    const fillWithPaddingBr = elm => {\n      empty(elm);\n      append$1(elm, SugarElement.fromHtml('<br data-mce-bogus=\"1\">'));\n    };\n    const trimBlockTrailingBr = elm => {\n      lastChild(elm).each(lastChild => {\n        prevSibling(lastChild).each(lastChildPrevSibling => {\n          if (isBlock$2(elm) && isBr$4(lastChild) && isBlock$2(lastChildPrevSibling)) {\n            remove$5(lastChild);\n          }\n        });\n      });\n    };\n\n    const dropLast = xs => xs.slice(0, -1);\n    const parentsUntil = (start, root, predicate) => {\n      if (contains(root, start)) {\n        return dropLast(parents$1(start, elm => {\n          return predicate(elm) || eq(elm, root);\n        }));\n      } else {\n        return [];\n      }\n    };\n    const parents = (start, root) => parentsUntil(start, root, never);\n    const parentsAndSelf = (start, root) => [start].concat(parents(start, root));\n\n    const navigateIgnoreEmptyTextNodes = (forward, root, from) => navigateIgnore(forward, root, from, isEmptyText);\n    const getClosestBlock$1 = (root, pos) => find$2(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);\n    const isAtBeforeAfterBlockBoundary = (forward, root, pos) => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => getClosestBlock$1(root, pos).fold(() => isInSameBlock(newPos, pos, root.dom) === false, fromBlock => isInSameBlock(newPos, pos, root.dom) === false && contains(fromBlock, SugarElement.fromDom(newPos.container()))));\n    const isAtBlockBoundary = (forward, root, pos) => getClosestBlock$1(root, pos).fold(() => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => isInSameBlock(newPos, pos, root.dom) === false), parent => navigateIgnoreEmptyTextNodes(forward, parent.dom, pos).isNone());\n    const isAtStartOfBlock = curry(isAtBlockBoundary, false);\n    const isAtEndOfBlock = curry(isAtBlockBoundary, true);\n    const isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);\n    const isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);\n\n    const isBr = pos => getElementFromPosition(pos).exists(isBr$4);\n    const findBr = (forward, root, pos) => {\n      const parentBlocks = filter$6(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);\n      const scope = head(parentBlocks).getOr(root);\n      return fromPosition(forward, scope.dom, pos).filter(isBr);\n    };\n    const isBeforeBr$1 = (root, pos) => getElementFromPosition(pos).exists(isBr$4) || findBr(true, root, pos).isSome();\n    const isAfterBr = (root, pos) => getElementFromPrevPosition(pos).exists(isBr$4) || findBr(false, root, pos).isSome();\n    const findPreviousBr = curry(findBr, false);\n    const findNextBr = curry(findBr, true);\n\n    const isInMiddleOfText = pos => CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();\n    const getClosestBlock = (root, pos) => {\n      const parentBlocks = filter$6(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);\n      return head(parentBlocks).getOr(root);\n    };\n    const hasSpaceBefore = (root, pos) => {\n      if (isInMiddleOfText(pos)) {\n        return isAfterSpace(pos);\n      } else {\n        return isAfterSpace(pos) || prevPosition(getClosestBlock(root, pos).dom, pos).exists(isAfterSpace);\n      }\n    };\n    const hasSpaceAfter = (root, pos) => {\n      if (isInMiddleOfText(pos)) {\n        return isBeforeSpace(pos);\n      } else {\n        return isBeforeSpace(pos) || nextPosition(getClosestBlock(root, pos).dom, pos).exists(isBeforeSpace);\n      }\n    };\n    const isPreValue = value => contains$2([\n      'pre',\n      'pre-wrap'\n    ], value);\n    const isInPre = pos => getElementFromPosition(pos).bind(elm => closest$4(elm, isElement$7)).exists(elm => isPreValue(get$7(elm, 'white-space')));\n    const isAtBeginningOfBody = (root, pos) => prevPosition(root.dom, pos).isNone();\n    const isAtEndOfBody = (root, pos) => nextPosition(root.dom, pos).isNone();\n    const isAtLineBoundary = (root, pos) => isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos) || isAtEndOfBlock(root, pos) || isAfterBr(root, pos) || isBeforeBr$1(root, pos);\n    const needsToHaveNbsp = (root, pos) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtLineBoundary(root, pos) || hasSpaceBefore(root, pos) || hasSpaceAfter(root, pos);\n      }\n    };\n    const needsToBeNbspLeft = (root, pos) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtStartOfBlock(root, pos) || isBeforeBlock(root, pos) || isAfterBr(root, pos) || hasSpaceBefore(root, pos);\n      }\n    };\n    const leanRight = pos => {\n      const container = pos.container();\n      const offset = pos.offset();\n      if (isText$8(container) && offset < container.data.length) {\n        return CaretPosition(container, offset + 1);\n      } else {\n        return pos;\n      }\n    };\n    const needsToBeNbspRight = (root, pos) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtEndOfBlock(root, pos) || isAfterBlock(root, pos) || isBeforeBr$1(root, pos) || hasSpaceAfter(root, pos);\n      }\n    };\n    const needsToBeNbsp = (root, pos) => needsToBeNbspLeft(root, pos) || needsToBeNbspRight(root, leanRight(pos));\n    const isNbspAt = (text, offset) => isNbsp(text.charAt(offset));\n    const hasNbsp = pos => {\n      const container = pos.container();\n      return isText$8(container) && contains$1(container.data, nbsp);\n    };\n    const normalizeNbspMiddle = text => {\n      const chars = text.split('');\n      return map$3(chars, (chr, i) => {\n        if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent(chars[i - 1]) && isContent(chars[i + 1])) {\n          return ' ';\n        } else {\n          return chr;\n        }\n      }).join('');\n    };\n    const normalizeNbspAtStart = (root, node) => {\n      const text = node.data;\n      const firstPos = CaretPosition(node, 0);\n      if (isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos)) {\n        node.data = ' ' + text.slice(1);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbspInMiddleOfTextNode = node => {\n      const text = node.data;\n      const newText = normalizeNbspMiddle(text);\n      if (newText !== text) {\n        node.data = newText;\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbspAtEnd = (root, node) => {\n      const text = node.data;\n      const lastPos = CaretPosition(node, text.length - 1);\n      if (isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos)) {\n        node.data = text.slice(0, -1) + ' ';\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbsps = (root, pos) => Optional.some(pos).filter(hasNbsp).bind(pos => {\n      const container = pos.container();\n      const normalized = normalizeNbspAtStart(root, container) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container);\n      return normalized ? Optional.some(pos) : Optional.none();\n    });\n    const normalizeNbspsInEditor = editor => {\n      const root = SugarElement.fromDom(editor.getBody());\n      if (editor.selection.isCollapsed()) {\n        normalizeNbsps(root, CaretPosition.fromRangeStart(editor.selection.getRng())).each(pos => {\n          editor.selection.setRng(pos.toRange());\n        });\n      }\n    };\n\n    const normalize$1 = (node, offset, count) => {\n      if (count === 0) {\n        return;\n      }\n      const elm = SugarElement.fromDom(node);\n      const root = ancestor$3(elm, isBlock$2).getOr(elm);\n      const whitespace = node.data.slice(offset, offset + count);\n      const isEndOfContent = offset + count >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length));\n      const isStartOfContent = offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0));\n      node.replaceData(offset, count, normalize$4(whitespace, 4, isStartOfContent, isEndOfContent));\n    };\n    const normalizeWhitespaceAfter = (node, offset) => {\n      const content = node.data.slice(offset);\n      const whitespaceCount = content.length - lTrim(content).length;\n      normalize$1(node, offset, whitespaceCount);\n    };\n    const normalizeWhitespaceBefore = (node, offset) => {\n      const content = node.data.slice(0, offset);\n      const whitespaceCount = content.length - rTrim(content).length;\n      normalize$1(node, offset - whitespaceCount, whitespaceCount);\n    };\n    const mergeTextNodes = (prevNode, nextNode, normalizeWhitespace, mergeToPrev = true) => {\n      const whitespaceOffset = rTrim(prevNode.data).length;\n      const newNode = mergeToPrev ? prevNode : nextNode;\n      const removeNode = mergeToPrev ? nextNode : prevNode;\n      if (mergeToPrev) {\n        newNode.appendData(removeNode.data);\n      } else {\n        newNode.insertData(0, removeNode.data);\n      }\n      remove$5(SugarElement.fromDom(removeNode));\n      if (normalizeWhitespace) {\n        normalizeWhitespaceAfter(newNode, whitespaceOffset);\n      }\n      return newNode;\n    };\n\n    const needsReposition = (pos, elm) => {\n      const container = pos.container();\n      const offset = pos.offset();\n      return CaretPosition.isTextPosition(pos) === false && container === elm.parentNode && offset > CaretPosition.before(elm).offset();\n    };\n    const reposition = (elm, pos) => needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;\n    const beforeOrStartOf = node => isText$8(node) ? CaretPosition(node, 0) : CaretPosition.before(node);\n    const afterOrEndOf = node => isText$8(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);\n    const getPreviousSiblingCaretPosition = elm => {\n      if (isCaretCandidate$3(elm.previousSibling)) {\n        return Optional.some(afterOrEndOf(elm.previousSibling));\n      } else {\n        return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();\n      }\n    };\n    const getNextSiblingCaretPosition = elm => {\n      if (isCaretCandidate$3(elm.nextSibling)) {\n        return Optional.some(beforeOrStartOf(elm.nextSibling));\n      } else {\n        return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();\n      }\n    };\n    const findCaretPositionBackwardsFromElm = (rootElement, elm) => {\n      const startPosition = CaretPosition.before(elm.previousSibling ? elm.previousSibling : elm.parentNode);\n      return prevPosition(rootElement, startPosition).fold(() => nextPosition(rootElement, CaretPosition.after(elm)), Optional.some);\n    };\n    const findCaretPositionForwardsFromElm = (rootElement, elm) => nextPosition(rootElement, CaretPosition.after(elm)).fold(() => prevPosition(rootElement, CaretPosition.before(elm)), Optional.some);\n    const findCaretPositionBackwards = (rootElement, elm) => getPreviousSiblingCaretPosition(elm).orThunk(() => getNextSiblingCaretPosition(elm)).orThunk(() => findCaretPositionBackwardsFromElm(rootElement, elm));\n    const findCaretPositionForward = (rootElement, elm) => getNextSiblingCaretPosition(elm).orThunk(() => getPreviousSiblingCaretPosition(elm)).orThunk(() => findCaretPositionForwardsFromElm(rootElement, elm));\n    const findCaretPosition = (forward, rootElement, elm) => forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);\n    const findCaretPosOutsideElmAfterDelete = (forward, rootElement, elm) => findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));\n    const setSelection$1 = (editor, forward, pos) => {\n      pos.fold(() => {\n        editor.focus();\n      }, pos => {\n        editor.selection.setRng(pos.toRange(), forward);\n      });\n    };\n    const eqRawNode = rawNode => elm => elm.dom === rawNode;\n    const isBlock = (editor, elm) => elm && has$2(editor.schema.getBlockElements(), name(elm));\n    const paddEmptyBlock = elm => {\n      if (isEmpty$2(elm)) {\n        const br = SugarElement.fromHtml('<br data-mce-bogus=\"1\">');\n        empty(elm);\n        append$1(elm, br);\n        return Optional.some(CaretPosition.before(br.dom));\n      } else {\n        return Optional.none();\n      }\n    };\n    const deleteNormalized = (elm, afterDeletePosOpt, normalizeWhitespace) => {\n      const prevTextOpt = prevSibling(elm).filter(isText$9);\n      const nextTextOpt = nextSibling(elm).filter(isText$9);\n      remove$5(elm);\n      return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, (prev, next, pos) => {\n        const prevNode = prev.dom, nextNode = next.dom;\n        const offset = prevNode.data.length;\n        mergeTextNodes(prevNode, nextNode, normalizeWhitespace);\n        return pos.container() === nextNode ? CaretPosition(prevNode, offset) : pos;\n      }).orThunk(() => {\n        if (normalizeWhitespace) {\n          prevTextOpt.each(elm => normalizeWhitespaceBefore(elm.dom, elm.dom.length));\n          nextTextOpt.each(elm => normalizeWhitespaceAfter(elm.dom, 0));\n        }\n        return afterDeletePosOpt;\n      });\n    };\n    const isInlineElement = (editor, element) => has$2(editor.schema.getTextInlineElements(), name(element));\n    const deleteElement$2 = (editor, forward, elm, moveCaret = true) => {\n      const afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);\n      const parentBlock = ancestor$3(elm, curry(isBlock, editor), eqRawNode(editor.getBody()));\n      const normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, isInlineElement(editor, elm));\n      if (editor.dom.isEmpty(editor.getBody())) {\n        editor.setContent('');\n        editor.selection.setCursorLocation();\n      } else {\n        parentBlock.bind(paddEmptyBlock).fold(() => {\n          if (moveCaret) {\n            setSelection$1(editor, forward, normalizedAfterDeletePos);\n          }\n        }, paddPos => {\n          if (moveCaret) {\n            setSelection$1(editor, forward, Optional.some(paddPos));\n          }\n        });\n      }\n    };\n\n    const isRootFromElement = root => cur => eq(root, cur);\n    const getTableCells = table => descendants(table, 'td,th');\n    const getTableDetailsFromRange = (rng, isRoot) => {\n      const getTable = node => getClosestTable(SugarElement.fromDom(node), isRoot);\n      const startTable = getTable(rng.startContainer);\n      const endTable = getTable(rng.endContainer);\n      const isStartInTable = startTable.isSome();\n      const isEndInTable = endTable.isSome();\n      const isSameTable = lift2(startTable, endTable, eq).getOr(false);\n      const isMultiTable = !isSameTable && isStartInTable && isEndInTable;\n      return {\n        startTable,\n        endTable,\n        isStartInTable,\n        isEndInTable,\n        isSameTable,\n        isMultiTable\n      };\n    };\n\n    const tableCellRng = (start, end) => ({\n      start,\n      end\n    });\n    const tableSelection = (rng, table, cells) => ({\n      rng,\n      table,\n      cells\n    });\n    const deleteAction = Adt.generate([\n      {\n        singleCellTable: [\n          'rng',\n          'cell'\n        ]\n      },\n      { fullTable: ['table'] },\n      {\n        partialTable: [\n          'cells',\n          'outsideDetails'\n        ]\n      },\n      {\n        multiTable: [\n          'startTableCells',\n          'endTableCells',\n          'betweenRng'\n        ]\n      }\n    ]);\n    const getClosestCell$1 = (container, isRoot) => closest$3(SugarElement.fromDom(container), 'td,th', isRoot);\n    const isExpandedCellRng = cellRng => !eq(cellRng.start, cellRng.end);\n    const getTableFromCellRng = (cellRng, isRoot) => getClosestTable(cellRng.start, isRoot).bind(startParentTable => getClosestTable(cellRng.end, isRoot).bind(endParentTable => someIf(eq(startParentTable, endParentTable), startParentTable)));\n    const isSingleCellTable = (cellRng, isRoot) => !isExpandedCellRng(cellRng) && getTableFromCellRng(cellRng, isRoot).exists(table => {\n      const rows = table.dom.rows;\n      return rows.length === 1 && rows[0].cells.length === 1;\n    });\n    const getCellRng = (rng, isRoot) => {\n      const startCell = getClosestCell$1(rng.startContainer, isRoot);\n      const endCell = getClosestCell$1(rng.endContainer, isRoot);\n      return lift2(startCell, endCell, tableCellRng);\n    };\n    const getCellRangeFromStartTable = isRoot => startCell => getClosestTable(startCell, isRoot).bind(table => last$3(getTableCells(table)).map(endCell => tableCellRng(startCell, endCell)));\n    const getCellRangeFromEndTable = isRoot => endCell => getClosestTable(endCell, isRoot).bind(table => head(getTableCells(table)).map(startCell => tableCellRng(startCell, endCell)));\n    const getTableSelectionFromCellRng = isRoot => cellRng => getTableFromCellRng(cellRng, isRoot).map(table => tableSelection(cellRng, table, getTableCells(table)));\n    const getTableSelections = (cellRng, selectionDetails, rng, isRoot) => {\n      if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) {\n        return Optional.none();\n      } else if (selectionDetails.isSameTable) {\n        const sameTableSelection = cellRng.bind(getTableSelectionFromCellRng(isRoot));\n        return Optional.some({\n          start: sameTableSelection,\n          end: sameTableSelection\n        });\n      } else {\n        const startCell = getClosestCell$1(rng.startContainer, isRoot);\n        const endCell = getClosestCell$1(rng.endContainer, isRoot);\n        const startTableSelection = startCell.bind(getCellRangeFromStartTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\n        const endTableSelection = endCell.bind(getCellRangeFromEndTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\n        return Optional.some({\n          start: startTableSelection,\n          end: endTableSelection\n        });\n      }\n    };\n    const getCellIndex = (cells, cell) => findIndex$2(cells, x => eq(x, cell));\n    const getSelectedCells = tableSelection => lift2(getCellIndex(tableSelection.cells, tableSelection.rng.start), getCellIndex(tableSelection.cells, tableSelection.rng.end), (startIndex, endIndex) => tableSelection.cells.slice(startIndex, endIndex + 1));\n    const isSingleCellTableContentSelected = (optCellRng, rng, isRoot) => optCellRng.exists(cellRng => isSingleCellTable(cellRng, isRoot) && hasAllContentsSelected(cellRng.start, rng));\n    const unselectCells = (rng, selectionDetails) => {\n      const {startTable, endTable} = selectionDetails;\n      const otherContentRng = rng.cloneRange();\n      startTable.each(table => otherContentRng.setStartAfter(table.dom));\n      endTable.each(table => otherContentRng.setEndBefore(table.dom));\n      return otherContentRng;\n    };\n    const handleSingleTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({start, end}) => start.or(end)).bind(tableSelection => {\n      const {isSameTable} = selectionDetails;\n      const selectedCells = getSelectedCells(tableSelection).getOr([]);\n      if (isSameTable && tableSelection.cells.length === selectedCells.length) {\n        return Optional.some(deleteAction.fullTable(tableSelection.table));\n      } else if (selectedCells.length > 0) {\n        if (isSameTable) {\n          return Optional.some(deleteAction.partialTable(selectedCells, Optional.none()));\n        } else {\n          const otherContentRng = unselectCells(rng, selectionDetails);\n          return Optional.some(deleteAction.partialTable(selectedCells, Optional.some({\n            ...selectionDetails,\n            rng: otherContentRng\n          })));\n        }\n      } else {\n        return Optional.none();\n      }\n    });\n    const handleMultiTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({start, end}) => {\n      const startTableSelectedCells = start.bind(getSelectedCells).getOr([]);\n      const endTableSelectedCells = end.bind(getSelectedCells).getOr([]);\n      if (startTableSelectedCells.length > 0 && endTableSelectedCells.length > 0) {\n        const otherContentRng = unselectCells(rng, selectionDetails);\n        return Optional.some(deleteAction.multiTable(startTableSelectedCells, endTableSelectedCells, otherContentRng));\n      } else {\n        return Optional.none();\n      }\n    });\n    const getActionFromRange = (root, rng) => {\n      const isRoot = isRootFromElement(root);\n      const optCellRng = getCellRng(rng, isRoot);\n      const selectionDetails = getTableDetailsFromRange(rng, isRoot);\n      if (isSingleCellTableContentSelected(optCellRng, rng, isRoot)) {\n        return optCellRng.map(cellRng => deleteAction.singleCellTable(rng, cellRng.start));\n      } else if (selectionDetails.isMultiTable) {\n        return handleMultiTable(optCellRng, selectionDetails, rng, isRoot);\n      } else {\n        return handleSingleTable(optCellRng, selectionDetails, rng, isRoot);\n      }\n    };\n\n    const freefallRtl = root => {\n      const child = isComment$1(root) ? prevSibling(root) : lastChild(root);\n      return child.bind(freefallRtl).orThunk(() => Optional.some(root));\n    };\n    const cleanCells = cells => each$g(cells, cell => {\n      remove$a(cell, 'contenteditable');\n      fillWithPaddingBr(cell);\n    });\n    const getOutsideBlock = (editor, container) => Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(SugarElement.fromDom);\n    const handleEmptyBlock = (editor, startInTable, emptyBlock) => {\n      emptyBlock.each(block => {\n        if (startInTable) {\n          remove$5(block);\n        } else {\n          fillWithPaddingBr(block);\n          editor.selection.setCursorLocation(block.dom, 0);\n        }\n      });\n    };\n    const deleteContentInsideCell = (editor, cell, rng, isFirstCellInSelection) => {\n      const insideTableRng = rng.cloneRange();\n      if (isFirstCellInSelection) {\n        insideTableRng.setStart(rng.startContainer, rng.startOffset);\n        insideTableRng.setEndAfter(cell.dom.lastChild);\n      } else {\n        insideTableRng.setStartBefore(cell.dom.firstChild);\n        insideTableRng.setEnd(rng.endContainer, rng.endOffset);\n      }\n      deleteCellContents(editor, insideTableRng, cell, false).each(action => action());\n    };\n    const collapseAndRestoreCellSelection = editor => {\n      const selectedCells = getCellsFromEditor(editor);\n      const selectedNode = SugarElement.fromDom(editor.selection.getNode());\n      if (isTableCell$5(selectedNode.dom) && isEmpty$2(selectedNode)) {\n        editor.selection.setCursorLocation(selectedNode.dom, 0);\n      } else {\n        editor.selection.collapse(true);\n      }\n      if (selectedCells.length > 1 && exists(selectedCells, cell => eq(cell, selectedNode))) {\n        set$2(selectedNode, 'data-mce-selected', '1');\n      }\n    };\n    const emptySingleTableCells = (editor, cells, outsideDetails) => Optional.some(() => {\n      const editorRng = editor.selection.getRng();\n      const cellsToClean = outsideDetails.bind(({rng, isStartInTable}) => {\n        const outsideBlock = getOutsideBlock(editor, isStartInTable ? rng.endContainer : rng.startContainer);\n        rng.deleteContents();\n        handleEmptyBlock(editor, isStartInTable, outsideBlock.filter(isEmpty$2));\n        const endPointCell = isStartInTable ? cells[0] : cells[cells.length - 1];\n        deleteContentInsideCell(editor, endPointCell, editorRng, isStartInTable);\n        if (!isEmpty$2(endPointCell)) {\n          return Optional.some(isStartInTable ? cells.slice(1) : cells.slice(0, -1));\n        } else {\n          return Optional.none();\n        }\n      }).getOr(cells);\n      cleanCells(cellsToClean);\n      collapseAndRestoreCellSelection(editor);\n    });\n    const emptyMultiTableCells = (editor, startTableCells, endTableCells, betweenRng) => Optional.some(() => {\n      const rng = editor.selection.getRng();\n      const startCell = startTableCells[0];\n      const endCell = endTableCells[endTableCells.length - 1];\n      deleteContentInsideCell(editor, startCell, rng, true);\n      deleteContentInsideCell(editor, endCell, rng, false);\n      const startTableCellsToClean = isEmpty$2(startCell) ? startTableCells : startTableCells.slice(1);\n      const endTableCellsToClean = isEmpty$2(endCell) ? endTableCells : endTableCells.slice(0, -1);\n      cleanCells(startTableCellsToClean.concat(endTableCellsToClean));\n      betweenRng.deleteContents();\n      collapseAndRestoreCellSelection(editor);\n    });\n    const deleteCellContents = (editor, rng, cell, moveSelection = true) => Optional.some(() => {\n      rng.deleteContents();\n      const lastNode = freefallRtl(cell).getOr(cell);\n      const lastBlock = SugarElement.fromDom(editor.dom.getParent(lastNode.dom, editor.dom.isBlock));\n      if (isEmpty$2(lastBlock)) {\n        fillWithPaddingBr(lastBlock);\n        if (moveSelection) {\n          editor.selection.setCursorLocation(lastBlock.dom, 0);\n        }\n      }\n      if (!eq(cell, lastBlock)) {\n        const additionalCleanupNodes = is$2(parent(lastBlock), cell) ? [] : siblings(lastBlock);\n        each$g(additionalCleanupNodes.concat(children(cell)), node => {\n          if (!eq(node, lastBlock) && !contains(node, lastBlock) && isEmpty$2(node)) {\n            remove$5(node);\n          }\n        });\n      }\n    });\n    const deleteTableElement = (editor, table) => Optional.some(() => deleteElement$2(editor, false, table));\n    const deleteCellRange = (editor, rootElm, rng) => getActionFromRange(rootElm, rng).bind(action => action.fold(curry(deleteCellContents, editor), curry(deleteTableElement, editor), curry(emptySingleTableCells, editor), curry(emptyMultiTableCells, editor)));\n    const deleteCaptionRange = (editor, caption) => emptyElement(editor, caption);\n    const deleteTableRange = (editor, rootElm, rng, startElm) => getParentCaption(rootElm, startElm).fold(() => deleteCellRange(editor, rootElm, rng), caption => deleteCaptionRange(editor, caption));\n    const deleteRange$2 = (editor, startElm, selectedCells) => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const rng = editor.selection.getRng();\n      return selectedCells.length !== 0 ? emptySingleTableCells(editor, selectedCells, Optional.none()) : deleteTableRange(editor, rootNode, rng, startElm);\n    };\n    const getParentCell = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTableCell$4);\n    const getParentCaption = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTag('caption'));\n    const deleteBetweenCells = (editor, rootElm, forward, fromCell, from) => navigate(forward, editor.getBody(), from).bind(to => getParentCell(rootElm, SugarElement.fromDom(to.getNode())).bind(toCell => eq(toCell, fromCell) ? Optional.none() : Optional.some(noop)));\n    const emptyElement = (editor, elm) => Optional.some(() => {\n      fillWithPaddingBr(elm);\n      editor.selection.setCursorLocation(elm.dom, 0);\n    });\n    const isDeleteOfLastCharPos = (fromCaption, forward, from, to) => firstPositionIn(fromCaption.dom).bind(first => lastPositionIn(fromCaption.dom).map(last => forward ? from.isEqual(first) && to.isEqual(last) : from.isEqual(last) && to.isEqual(first))).getOr(true);\n    const emptyCaretCaption = (editor, elm) => emptyElement(editor, elm);\n    const validateCaretCaption = (rootElm, fromCaption, to) => getParentCaption(rootElm, SugarElement.fromDom(to.getNode())).fold(() => Optional.some(noop), toCaption => someIf(!eq(toCaption, fromCaption), noop));\n    const deleteCaretInsideCaption = (editor, rootElm, forward, fromCaption, from) => navigate(forward, editor.getBody(), from).fold(() => Optional.some(noop), to => isDeleteOfLastCharPos(fromCaption, forward, from, to) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to));\n    const deleteCaretCells = (editor, forward, rootElm, startElm) => {\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return getParentCell(rootElm, startElm).bind(fromCell => isEmpty$2(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from));\n    };\n    const deleteCaretCaption = (editor, forward, rootElm, fromCaption) => {\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return isEmpty$2(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from);\n    };\n    const isNearTable = (forward, pos) => forward ? isBeforeTable(pos) : isAfterTable(pos);\n    const isBeforeOrAfterTable = (editor, forward) => {\n      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos).exists(pos => isNearTable(forward, pos));\n    };\n    const deleteCaret$3 = (editor, forward, startElm) => {\n      const rootElm = SugarElement.fromDom(editor.getBody());\n      return getParentCaption(rootElm, startElm).fold(() => deleteCaretCells(editor, forward, rootElm, startElm).orThunk(() => someIf(isBeforeOrAfterTable(editor, forward), noop)), fromCaption => deleteCaretCaption(editor, forward, rootElm, fromCaption));\n    };\n    const backspaceDelete$9 = (editor, forward) => {\n      const startElm = SugarElement.fromDom(editor.selection.getStart(true));\n      const cells = getCellsFromEditor(editor);\n      return editor.selection.isCollapsed() && cells.length === 0 ? deleteCaret$3(editor, forward, startElm) : deleteRange$2(editor, startElm, cells);\n    };\n\n    const getContentEditableRoot$1 = (root, node) => {\n      while (node && node !== root) {\n        if (isContentEditableTrue$4(node) || isContentEditableFalse$a(node)) {\n          return node;\n        }\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    const traverse = (node, fn) => {\n      fn(node);\n      if (node.firstChild) {\n        traverse(node.firstChild, fn);\n      }\n      if (node.next) {\n        traverse(node.next, fn);\n      }\n    };\n    const matchNode$1 = (nodeFilters, attributeFilters, node, matches) => {\n      const name = node.name;\n      for (let ni = 0, nl = nodeFilters.length; ni < nl; ni++) {\n        const filter = nodeFilters[ni];\n        if (filter.name === name) {\n          const match = matches.nodes[name];\n          if (match) {\n            match.nodes.push(node);\n          } else {\n            matches.nodes[name] = {\n              filter,\n              nodes: [node]\n            };\n          }\n        }\n      }\n      if (node.attributes) {\n        for (let ai = 0, al = attributeFilters.length; ai < al; ai++) {\n          const filter = attributeFilters[ai];\n          const attrName = filter.name;\n          if (attrName in node.attributes.map) {\n            const match = matches.attributes[attrName];\n            if (match) {\n              match.nodes.push(node);\n            } else {\n              matches.attributes[attrName] = {\n                filter,\n                nodes: [node]\n              };\n            }\n          }\n        }\n      }\n    };\n    const findMatchingNodes = (nodeFilters, attributeFilters, node) => {\n      const matches = {\n        nodes: {},\n        attributes: {}\n      };\n      if (node.firstChild) {\n        traverse(node.firstChild, node => {\n          matchNode$1(nodeFilters, attributeFilters, node, matches);\n        });\n      }\n      return matches;\n    };\n    const runFilters = (matches, args) => {\n      const run = matchRecord => {\n        each$f(matchRecord, match => {\n          const nodes = filter$6(match.nodes, node => isNonNullable(node.parent));\n          each$g(match.filter.callbacks, callback => {\n            callback(nodes, match.filter.name, args);\n          });\n        });\n      };\n      run(matches.nodes);\n      run(matches.attributes);\n    };\n    const filter$3 = (nodeFilters, attributeFilters, node, args = {}) => {\n      const matches = findMatchingNodes(nodeFilters, attributeFilters, node);\n      runFilters(matches, args);\n    };\n\n    const paddEmptyNode = (settings, args, blockElements, node) => {\n      if (args.insert && blockElements[node.name]) {\n        node.empty().append(new AstNode('br', 1));\n      } else {\n        node.empty().append(new AstNode('#text', 3)).value = nbsp;\n      }\n    };\n    const isPaddedWithNbsp = node => hasOnlyChild(node, '#text') && node.firstChild.value === nbsp;\n    const hasOnlyChild = (node, name) => node && node.firstChild && node.firstChild === node.lastChild && node.firstChild.name === name;\n    const isPadded = (schema, node) => {\n      const rule = schema.getElementRule(node.name);\n      return rule && rule.paddEmpty;\n    };\n    const isEmpty = (schema, nonEmptyElements, whitespaceElements, node) => node.isEmpty(nonEmptyElements, whitespaceElements, node => isPadded(schema, node));\n    const isLineBreakNode = (node, blockElements) => node && (node.name in blockElements || node.name === 'br');\n\n    const removeOrUnwrapInvalidNode = (node, schema, originalNodeParent = node.parent) => {\n      if (schema.getSpecialElements()[node.name]) {\n        node.empty().remove();\n      } else {\n        const children = node.children();\n        for (const childNode of children) {\n          if (!schema.isValidChild(originalNodeParent.name, childNode.name)) {\n            removeOrUnwrapInvalidNode(childNode, schema, originalNodeParent);\n          }\n        }\n        node.unwrap();\n      }\n    };\n    const cleanInvalidNodes = (nodes, schema, onCreate = noop) => {\n      const textBlockElements = schema.getTextBlockElements();\n      const nonEmptyElements = schema.getNonEmptyElements();\n      const whitespaceElements = schema.getWhitespaceElements();\n      const nonSplittableElements = Tools.makeMap('tr,td,th,tbody,thead,tfoot,table');\n      const fixed = new Set();\n      for (let ni = 0; ni < nodes.length; ni++) {\n        const node = nodes[ni];\n        let parent;\n        let newParent;\n        let tempNode;\n        if (!node.parent || fixed.has(node)) {\n          continue;\n        }\n        if (textBlockElements[node.name] && node.parent.name === 'li') {\n          let sibling = node.next;\n          while (sibling) {\n            if (textBlockElements[sibling.name]) {\n              sibling.name = 'li';\n              fixed.add(sibling);\n              node.parent.insert(sibling, node.parent);\n            } else {\n              break;\n            }\n            sibling = sibling.next;\n          }\n          node.unwrap();\n          continue;\n        }\n        const parents = [node];\n        for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) && !nonSplittableElements[parent.name]; parent = parent.parent) {\n          parents.push(parent);\n        }\n        if (parent && parents.length > 1) {\n          if (schema.isValidChild(parent.name, node.name)) {\n            parents.reverse();\n            newParent = parents[0].clone();\n            onCreate(newParent);\n            let currentNode = newParent;\n            for (let i = 0; i < parents.length - 1; i++) {\n              if (schema.isValidChild(currentNode.name, parents[i].name)) {\n                tempNode = parents[i].clone();\n                onCreate(tempNode);\n                currentNode.append(tempNode);\n              } else {\n                tempNode = currentNode;\n              }\n              for (let childNode = parents[i].firstChild; childNode && childNode !== parents[i + 1];) {\n                const nextNode = childNode.next;\n                tempNode.append(childNode);\n                childNode = nextNode;\n              }\n              currentNode = tempNode;\n            }\n            if (!isEmpty(schema, nonEmptyElements, whitespaceElements, newParent)) {\n              parent.insert(newParent, parents[0], true);\n              parent.insert(node, newParent);\n            } else {\n              parent.insert(node, parents[0], true);\n            }\n            parent = parents[0];\n            if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent) || hasOnlyChild(parent, 'br')) {\n              parent.empty().remove();\n            }\n          } else {\n            removeOrUnwrapInvalidNode(node, schema);\n          }\n        } else if (node.parent) {\n          if (node.name === 'li') {\n            let sibling = node.prev;\n            if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {\n              sibling.append(node);\n              continue;\n            }\n            sibling = node.next;\n            if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {\n              sibling.insert(node, sibling.firstChild, true);\n              continue;\n            }\n            const wrapper = new AstNode('ul', 1);\n            onCreate(wrapper);\n            node.wrap(wrapper);\n            continue;\n          }\n          if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {\n            const wrapper = new AstNode('div', 1);\n            onCreate(wrapper);\n            node.wrap(wrapper);\n          } else {\n            removeOrUnwrapInvalidNode(node, schema);\n          }\n        }\n      }\n    };\n\n    const createRange = (sc, so, ec, eo) => {\n      const rng = document.createRange();\n      rng.setStart(sc, so);\n      rng.setEnd(ec, eo);\n      return rng;\n    };\n    const normalizeBlockSelectionRange = rng => {\n      const startPos = CaretPosition.fromRangeStart(rng);\n      const endPos = CaretPosition.fromRangeEnd(rng);\n      const rootNode = rng.commonAncestorContainer;\n      return fromPosition(false, rootNode, endPos).map(newEndPos => {\n        if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {\n          return createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());\n        } else {\n          return rng;\n        }\n      }).getOr(rng);\n    };\n    const normalize = rng => rng.collapsed ? rng : normalizeBlockSelectionRange(rng);\n\n    const hasOnlyOneChild$1 = node => {\n      return node.firstChild && node.firstChild === node.lastChild;\n    };\n    const isPaddingNode = node => {\n      return node.name === 'br' || node.value === nbsp;\n    };\n    const isPaddedEmptyBlock = (schema, node) => {\n      const blockElements = schema.getBlockElements();\n      return blockElements[node.name] && hasOnlyOneChild$1(node) && isPaddingNode(node.firstChild);\n    };\n    const isEmptyFragmentElement = (schema, node) => {\n      const nonEmptyElements = schema.getNonEmptyElements();\n      return node && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));\n    };\n    const isListFragment = (schema, fragment) => {\n      let firstChild = fragment.firstChild;\n      let lastChild = fragment.lastChild;\n      if (firstChild && firstChild.name === 'meta') {\n        firstChild = firstChild.next;\n      }\n      if (lastChild && lastChild.attr('id') === 'mce_marker') {\n        lastChild = lastChild.prev;\n      }\n      if (isEmptyFragmentElement(schema, lastChild)) {\n        lastChild = lastChild.prev;\n      }\n      if (!firstChild || firstChild !== lastChild) {\n        return false;\n      }\n      return firstChild.name === 'ul' || firstChild.name === 'ol';\n    };\n    const cleanupDomFragment = domFragment => {\n      const firstChild = domFragment.firstChild;\n      const lastChild = domFragment.lastChild;\n      if (firstChild && firstChild.nodeName === 'META') {\n        firstChild.parentNode.removeChild(firstChild);\n      }\n      if (lastChild && lastChild.id === 'mce_marker') {\n        lastChild.parentNode.removeChild(lastChild);\n      }\n      return domFragment;\n    };\n    const toDomFragment = (dom, serializer, fragment) => {\n      const html = serializer.serialize(fragment);\n      const domFragment = dom.createFragment(html);\n      return cleanupDomFragment(domFragment);\n    };\n    const listItems = elm => {\n      return filter$6(elm.childNodes, child => {\n        return child.nodeName === 'LI';\n      });\n    };\n    const isPadding = node => {\n      return node.data === nbsp || isBr$5(node);\n    };\n    const isListItemPadded = node => {\n      return node && node.firstChild && node.firstChild === node.lastChild && isPadding(node.firstChild);\n    };\n    const isEmptyOrPadded = elm => {\n      return !elm.firstChild || isListItemPadded(elm);\n    };\n    const trimListItems = elms => {\n      return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;\n    };\n    const getParentLi = (dom, node) => {\n      const parentBlock = dom.getParent(node, dom.isBlock);\n      return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;\n    };\n    const isParentBlockLi = (dom, node) => {\n      return !!getParentLi(dom, node);\n    };\n    const getSplit = (parentNode, rng) => {\n      const beforeRng = rng.cloneRange();\n      const afterRng = rng.cloneRange();\n      beforeRng.setStartBefore(parentNode);\n      afterRng.setEndAfter(parentNode);\n      return [\n        beforeRng.cloneContents(),\n        afterRng.cloneContents()\n      ];\n    };\n    const findFirstIn = (node, rootNode) => {\n      const caretPos = CaretPosition.before(node);\n      const caretWalker = CaretWalker(rootNode);\n      const newCaretPos = caretWalker.next(caretPos);\n      return newCaretPos ? newCaretPos.toRange() : null;\n    };\n    const findLastOf = (node, rootNode) => {\n      const caretPos = CaretPosition.after(node);\n      const caretWalker = CaretWalker(rootNode);\n      const newCaretPos = caretWalker.prev(caretPos);\n      return newCaretPos ? newCaretPos.toRange() : null;\n    };\n    const insertMiddle = (target, elms, rootNode, rng) => {\n      const parts = getSplit(target, rng);\n      const parentElm = target.parentNode;\n      parentElm.insertBefore(parts[0], target);\n      Tools.each(elms, li => {\n        parentElm.insertBefore(li, target);\n      });\n      parentElm.insertBefore(parts[1], target);\n      parentElm.removeChild(target);\n      return findLastOf(elms[elms.length - 1], rootNode);\n    };\n    const insertBefore$1 = (target, elms, rootNode) => {\n      const parentElm = target.parentNode;\n      Tools.each(elms, elm => {\n        parentElm.insertBefore(elm, target);\n      });\n      return findFirstIn(target, rootNode);\n    };\n    const insertAfter$1 = (target, elms, rootNode, dom) => {\n      dom.insertAfter(elms.reverse(), target);\n      return findLastOf(elms[0], rootNode);\n    };\n    const insertAtCaret$1 = (serializer, dom, rng, fragment) => {\n      const domFragment = toDomFragment(dom, serializer, fragment);\n      const liTarget = getParentLi(dom, rng.startContainer);\n      const liElms = trimListItems(listItems(domFragment.firstChild));\n      const BEGINNING = 1, END = 2;\n      const rootNode = dom.getRoot();\n      const isAt = location => {\n        const caretPos = CaretPosition.fromRangeStart(rng);\n        const caretWalker = CaretWalker(dom.getRoot());\n        const newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);\n        return newPos ? getParentLi(dom, newPos.getNode()) !== liTarget : true;\n      };\n      if (isAt(BEGINNING)) {\n        return insertBefore$1(liTarget, liElms, rootNode);\n      } else if (isAt(END)) {\n        return insertAfter$1(liTarget, liElms, rootNode, dom);\n      }\n      return insertMiddle(liTarget, liElms, rootNode, rng);\n    };\n\n    const isTableCell$1 = isTableCell$5;\n    const isTableCellContentSelected = (dom, rng, cell) => {\n      if (cell !== null) {\n        const endCell = dom.getParent(rng.endContainer, isTableCell$1);\n        return cell === endCell && hasAllContentsSelected(SugarElement.fromDom(cell), rng);\n      } else {\n        return false;\n      }\n    };\n    const validInsertion = (editor, value, parentNode) => {\n      if (parentNode.getAttribute('data-mce-bogus') === 'all') {\n        parentNode.parentNode.insertBefore(editor.dom.createFragment(value), parentNode);\n      } else {\n        const node = parentNode.firstChild;\n        const node2 = parentNode.lastChild;\n        if (!node || node === node2 && node.nodeName === 'BR') {\n          editor.dom.setHTML(parentNode, value);\n        } else {\n          editor.selection.setContent(value, { no_events: true });\n        }\n      }\n    };\n    const trimBrsFromTableCell = (dom, elm) => {\n      Optional.from(dom.getParent(elm, 'td,th')).map(SugarElement.fromDom).each(trimBlockTrailingBr);\n    };\n    const reduceInlineTextElements = (editor, merge) => {\n      const textInlineElements = editor.schema.getTextInlineElements();\n      const dom = editor.dom;\n      if (merge) {\n        const root = editor.getBody();\n        const elementUtils = ElementUtils(dom);\n        Tools.each(dom.select('*[data-mce-fragment]'), node => {\n          const isInline = isNonNullable(textInlineElements[node.nodeName.toLowerCase()]);\n          if (isInline && hasInheritableStyles(dom, node)) {\n            for (let parentNode = node.parentNode; isNonNullable(parentNode) && parentNode !== root; parentNode = parentNode.parentNode) {\n              const styleConflict = hasStyleConflict(dom, node, parentNode);\n              if (styleConflict) {\n                break;\n              }\n              if (elementUtils.compare(parentNode, node)) {\n                dom.remove(node, true);\n                break;\n              }\n            }\n          }\n        });\n      }\n    };\n    const markFragmentElements = fragment => {\n      let node = fragment;\n      while (node = node.walk()) {\n        if (node.type === 1) {\n          node.attr('data-mce-fragment', '1');\n        }\n      }\n    };\n    const unmarkFragmentElements = elm => {\n      Tools.each(elm.getElementsByTagName('*'), elm => {\n        elm.removeAttribute('data-mce-fragment');\n      });\n    };\n    const isPartOfFragment = node => {\n      return !!node.getAttribute('data-mce-fragment');\n    };\n    const canHaveChildren = (editor, node) => {\n      return node && !editor.schema.getVoidElements()[node.nodeName];\n    };\n    const moveSelectionToMarker = (editor, marker) => {\n      let nextRng;\n      const dom = editor.dom;\n      const selection = editor.selection;\n      if (!marker) {\n        return;\n      }\n      selection.scrollIntoView(marker);\n      const parentEditableElm = getContentEditableRoot$1(editor.getBody(), marker);\n      if (dom.getContentEditable(parentEditableElm) === 'false') {\n        dom.remove(marker);\n        selection.select(parentEditableElm);\n        return;\n      }\n      let rng = dom.createRng();\n      const node = marker.previousSibling;\n      if (isText$8(node)) {\n        rng.setStart(node, node.nodeValue.length);\n        const node2 = marker.nextSibling;\n        if (isText$8(node2)) {\n          node.appendData(node2.data);\n          node2.parentNode.removeChild(node2);\n        }\n      } else {\n        rng.setStartBefore(marker);\n        rng.setEndBefore(marker);\n      }\n      const findNextCaretRng = rng => {\n        let caretPos = CaretPosition.fromRangeStart(rng);\n        const caretWalker = CaretWalker(editor.getBody());\n        caretPos = caretWalker.next(caretPos);\n        if (caretPos) {\n          return caretPos.toRange();\n        }\n      };\n      const parentBlock = dom.getParent(marker, dom.isBlock);\n      dom.remove(marker);\n      if (parentBlock && dom.isEmpty(parentBlock)) {\n        empty(SugarElement.fromDom(parentBlock));\n        rng.setStart(parentBlock, 0);\n        rng.setEnd(parentBlock, 0);\n        if (!isTableCell$1(parentBlock) && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {\n          rng = nextRng;\n          dom.remove(parentBlock);\n        } else {\n          dom.add(parentBlock, dom.create('br', { 'data-mce-bogus': '1' }));\n        }\n      }\n      selection.setRng(rng);\n    };\n    const deleteSelectedContent = editor => {\n      const dom = editor.dom;\n      const rng = normalize(editor.selection.getRng());\n      editor.selection.setRng(rng);\n      const startCell = dom.getParent(rng.startContainer, isTableCell$1);\n      if (isTableCellContentSelected(dom, rng, startCell)) {\n        deleteCellContents(editor, rng, SugarElement.fromDom(startCell));\n      } else {\n        editor.getDoc().execCommand('Delete', false, null);\n      }\n    };\n    const insertHtmlAtCaret = (editor, value, details) => {\n      let parentNode;\n      let rng, node;\n      const selection = editor.selection;\n      const dom = editor.dom;\n      const parser = editor.parser;\n      const merge = details.merge;\n      const serializer = HtmlSerializer({ validate: true }, editor.schema);\n      const bookmarkHtml = '<span id=\"mce_marker\" data-mce-type=\"bookmark\">&#xFEFF;</span>';\n      if (value.indexOf('{$caret}') === -1) {\n        value += '{$caret}';\n      }\n      value = value.replace(/\\{\\$caret\\}/, bookmarkHtml);\n      rng = selection.getRng();\n      const caretElement = rng.startContainer || (rng.parentElement ? rng.parentElement() : null);\n      const body = editor.getBody();\n      if (caretElement === body && selection.isCollapsed()) {\n        if (dom.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom.isEmpty(body.firstChild)) {\n          rng = dom.createRng();\n          rng.setStart(body.firstChild, 0);\n          rng.setEnd(body.firstChild, 0);\n          selection.setRng(rng);\n        }\n      }\n      if (!selection.isCollapsed()) {\n        deleteSelectedContent(editor);\n      }\n      parentNode = selection.getNode();\n      const parserArgs = {\n        context: parentNode.nodeName.toLowerCase(),\n        data: details.data,\n        insert: true\n      };\n      const fragment = parser.parse(value, parserArgs);\n      if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom, parentNode)) {\n        rng = insertAtCaret$1(serializer, dom, selection.getRng(), fragment);\n        selection.setRng(rng);\n        return value;\n      }\n      markFragmentElements(fragment);\n      node = fragment.lastChild;\n      if (node.attr('id') === 'mce_marker') {\n        const marker = node;\n        for (node = node.prev; node; node = node.walk(true)) {\n          if (node.type === 3 || !dom.isBlock(node.name)) {\n            if (editor.schema.isValidChild(node.parent.name, 'span')) {\n              node.parent.insert(marker, node, node.name === 'br');\n            }\n            break;\n          }\n        }\n      }\n      editor._selectionOverrides.showBlockCaretContainer(parentNode);\n      if (!parserArgs.invalid) {\n        value = serializer.serialize(fragment);\n        validInsertion(editor, value, parentNode);\n      } else {\n        editor.selection.setContent(bookmarkHtml);\n        parentNode = selection.getNode();\n        const rootNode = editor.getBody();\n        if (parentNode.nodeType === 9) {\n          parentNode = node = rootNode;\n        } else {\n          node = parentNode;\n        }\n        while (node !== rootNode) {\n          parentNode = node;\n          node = node.parentNode;\n        }\n        value = parentNode === rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);\n        const root = parser.parse(value);\n        for (let markerNode = root; markerNode; markerNode = markerNode.walk()) {\n          if (markerNode.attr('id') === 'mce_marker') {\n            markerNode.replace(fragment);\n            break;\n          }\n        }\n        const toExtract = fragment.children();\n        const parent = fragment.parent.name;\n        fragment.unwrap();\n        const invalidChildren = filter$6(toExtract, node => !editor.schema.isValidChild(parent, node.name));\n        cleanInvalidNodes(invalidChildren, editor.schema);\n        filter$3(parser.getNodeFilters(), parser.getAttributeFilters(), root);\n        value = serializer.serialize(root);\n        if (parentNode === rootNode) {\n          dom.setHTML(rootNode, value);\n        } else {\n          dom.setOuterHTML(parentNode, value);\n        }\n      }\n      reduceInlineTextElements(editor, merge);\n      moveSelectionToMarker(editor, dom.get('mce_marker'));\n      unmarkFragmentElements(editor.getBody());\n      trimBrsFromTableCell(dom, selection.getStart());\n      return value;\n    };\n\n    const isTreeNode = content => content instanceof AstNode;\n\n    const moveSelection = editor => {\n      if (hasFocus(editor)) {\n        firstPositionIn(editor.getBody()).each(pos => {\n          const node = pos.getNode();\n          const caretPos = isTable$3(node) ? firstPositionIn(node).getOr(pos) : pos;\n          editor.selection.setRng(caretPos.toRange());\n        });\n      }\n    };\n    const setEditorHtml = (editor, html, noSelection) => {\n      editor.dom.setHTML(editor.getBody(), html);\n      if (noSelection !== true) {\n        moveSelection(editor);\n      }\n    };\n    const setContentString = (editor, body, content, args) => {\n      if (content.length === 0 || /^\\s+$/.test(content)) {\n        const padd = '<br data-mce-bogus=\"1\">';\n        if (body.nodeName === 'TABLE') {\n          content = '<tr><td>' + padd + '</td></tr>';\n        } else if (/^(UL|OL)$/.test(body.nodeName)) {\n          content = '<li>' + padd + '</li>';\n        }\n        const forcedRootBlockName = getForcedRootBlock(editor);\n        if (editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {\n          content = padd;\n          content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);\n        } else if (!content) {\n          content = padd;\n        }\n        setEditorHtml(editor, content, args.no_selection);\n        return {\n          content,\n          html: content\n        };\n      } else {\n        if (args.format !== 'raw') {\n          content = HtmlSerializer({ validate: false }, editor.schema).serialize(editor.parser.parse(content, {\n            isRootContent: true,\n            insert: true\n          }));\n        }\n        const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);\n        setEditorHtml(editor, trimmedHtml, args.no_selection);\n        return {\n          content: trimmedHtml,\n          html: trimmedHtml\n        };\n      }\n    };\n    const setContentTree = (editor, body, content, args) => {\n      filter$3(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);\n      const html = HtmlSerializer({ validate: false }, editor.schema).serialize(content);\n      const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? html : Tools.trim(html);\n      setEditorHtml(editor, trimmedHtml, args.no_selection);\n      return {\n        content,\n        html: trimmedHtml\n      };\n    };\n    const setContentInternal = (editor, content, args) => {\n      return Optional.from(editor.getBody()).map(body => {\n        if (isTreeNode(content)) {\n          return setContentTree(editor, body, content, args);\n        } else {\n          return setContentString(editor, body, content, args);\n        }\n      }).getOr({\n        content,\n        html: isTreeNode(args.content) ? '' : args.content\n      });\n    };\n\n    const sibling = (scope, predicate) => sibling$1(scope, predicate).isSome();\n\n    const ensureIsRoot = isRoot => isFunction(isRoot) ? isRoot : never;\n    const ancestor = (scope, transform, isRoot) => {\n      let element = scope.dom;\n      const stop = ensureIsRoot(isRoot);\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        const transformed = transform(el);\n        if (transformed.isSome()) {\n          return transformed;\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$2 = (scope, transform, isRoot) => {\n      const current = transform(scope);\n      const stop = ensureIsRoot(isRoot);\n      return current.orThunk(() => stop(scope) ? Optional.none() : ancestor(scope, transform, stop));\n    };\n\n    const isEq$3 = isEq$5;\n    const matchesUnInheritedFormatSelector = (ed, node, name) => {\n      const formatList = ed.formatter.get(name);\n      if (formatList) {\n        for (let i = 0; i < formatList.length; i++) {\n          const format = formatList[i];\n          if (isSelectorFormat(format) && format.inherit === false && ed.dom.is(node, format.selector)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const matchParents = (editor, node, name, vars, similar) => {\n      const root = editor.dom.getRoot();\n      if (node === root) {\n        return false;\n      }\n      node = editor.dom.getParent(node, node => {\n        if (matchesUnInheritedFormatSelector(editor, node, name)) {\n          return true;\n        }\n        return node.parentNode === root || !!matchNode(editor, node, name, vars, true);\n      });\n      return !!matchNode(editor, node, name, vars, similar);\n    };\n    const matchName = (dom, node, format) => {\n      if (isInlineFormat(format) && isEq$3(node, format.inline)) {\n        return true;\n      }\n      if (isBlockFormat(format) && isEq$3(node, format.block)) {\n        return true;\n      }\n      if (isSelectorFormat(format)) {\n        return isElement$6(node) && dom.is(node, format.selector);\n      }\n      return false;\n    };\n    const matchItems = (dom, node, format, itemName, similar, vars) => {\n      const items = format[itemName];\n      if (isFunction(format.onmatch)) {\n        return format.onmatch(node, format, itemName);\n      }\n      if (items) {\n        if (isUndefined(items.length)) {\n          for (const key in items) {\n            if (has$2(items, key)) {\n              const value = itemName === 'attributes' ? dom.getAttrib(node, key) : getStyle(dom, node, key);\n              const expectedValue = replaceVars(items[key], vars);\n              const isEmptyValue = isNullable(value) || isEmpty$3(value);\n              if (isEmptyValue && isNullable(expectedValue)) {\n                continue;\n              }\n              if (similar && isEmptyValue && !format.exact) {\n                return false;\n              }\n              if ((!similar || format.exact) && !isEq$3(value, normalizeStyleValue(expectedValue, key))) {\n                return false;\n              }\n            }\n          }\n        } else {\n          for (let i = 0; i < items.length; i++) {\n            if (itemName === 'attributes' ? dom.getAttrib(node, items[i]) : getStyle(dom, node, items[i])) {\n              return true;\n            }\n          }\n        }\n      }\n      return true;\n    };\n    const matchNode = (ed, node, name, vars, similar) => {\n      const formatList = ed.formatter.get(name);\n      const dom = ed.dom;\n      if (formatList && node) {\n        for (let i = 0; i < formatList.length; i++) {\n          const format = formatList[i];\n          if (matchName(ed.dom, node, format) && matchItems(dom, node, format, 'attributes', similar, vars) && matchItems(dom, node, format, 'styles', similar, vars)) {\n            const classes = format.classes;\n            if (classes) {\n              for (let x = 0; x < classes.length; x++) {\n                if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) {\n                  return;\n                }\n              }\n            }\n            return format;\n          }\n        }\n      }\n    };\n    const match$2 = (editor, name, vars, node, similar) => {\n      if (node) {\n        return matchParents(editor, node, name, vars, similar);\n      }\n      node = editor.selection.getNode();\n      if (matchParents(editor, node, name, vars, similar)) {\n        return true;\n      }\n      const startNode = editor.selection.getStart();\n      if (startNode !== node) {\n        if (matchParents(editor, startNode, name, vars, similar)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const matchAll = (editor, names, vars) => {\n      const matchedFormatNames = [];\n      const checkedMap = {};\n      const startElement = editor.selection.getStart();\n      editor.dom.getParent(startElement, node => {\n        for (let i = 0; i < names.length; i++) {\n          const name = names[i];\n          if (!checkedMap[name] && matchNode(editor, node, name, vars)) {\n            checkedMap[name] = true;\n            matchedFormatNames.push(name);\n          }\n        }\n      }, editor.dom.getRoot());\n      return matchedFormatNames;\n    };\n    const closest$1 = (editor, names) => {\n      const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\n      const match = (elm, name) => matchNode(editor, elm.dom, name) ? Optional.some(name) : Optional.none();\n      return Optional.from(editor.selection.getStart(true)).bind(rawElm => closest$2(SugarElement.fromDom(rawElm), elm => findMap(names, name => match(elm, name)), isRoot)).getOrNull();\n    };\n    const canApply = (editor, name) => {\n      const formatList = editor.formatter.get(name);\n      const dom = editor.dom;\n      if (formatList) {\n        const startNode = editor.selection.getStart();\n        const parents = getParents$2(dom, startNode);\n        for (let x = formatList.length - 1; x >= 0; x--) {\n          const format = formatList[x];\n          if (!isSelectorFormat(format)) {\n            return true;\n          }\n          for (let i = parents.length - 1; i >= 0; i--) {\n            if (dom.is(parents[i], format.selector)) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    };\n    const matchAllOnNode = (editor, node, formatNames) => foldl(formatNames, (acc, name) => {\n      const matchSimilar = isVariableFormatName(editor, name);\n      if (editor.formatter.matchNode(node, name, {}, matchSimilar)) {\n        return acc.concat([name]);\n      } else {\n        return acc;\n      }\n    }, []);\n\n    const ZWSP = ZWSP$1, CARET_ID = '_mce_caret';\n    const importNode = (ownerDocument, node) => {\n      return ownerDocument.importNode(node, true);\n    };\n    const getEmptyCaretContainers = node => {\n      const nodes = [];\n      while (node) {\n        if (node.nodeType === 3 && node.nodeValue !== ZWSP || node.childNodes.length > 1) {\n          return [];\n        }\n        if (node.nodeType === 1) {\n          nodes.push(node);\n        }\n        node = node.firstChild;\n      }\n      return nodes;\n    };\n    const isCaretContainerEmpty = node => {\n      return getEmptyCaretContainers(node).length > 0;\n    };\n    const findFirstTextNode = node => {\n      if (node) {\n        const walker = new DomTreeWalker(node, node);\n        for (node = walker.current(); node; node = walker.next()) {\n          if (isText$8(node)) {\n            return node;\n          }\n        }\n      }\n      return null;\n    };\n    const createCaretContainer = fill => {\n      const caretContainer = SugarElement.fromTag('span');\n      setAll$1(caretContainer, {\n        'id': CARET_ID,\n        'data-mce-bogus': '1',\n        'data-mce-type': 'format-caret'\n      });\n      if (fill) {\n        append$1(caretContainer, SugarElement.fromText(ZWSP));\n      }\n      return caretContainer;\n    };\n    const trimZwspFromCaretContainer = caretContainerNode => {\n      const textNode = findFirstTextNode(caretContainerNode);\n      if (textNode && textNode.nodeValue.charAt(0) === ZWSP) {\n        textNode.deleteData(0, 1);\n      }\n      return textNode;\n    };\n    const removeCaretContainerNode = (editor, node, moveCaret = true) => {\n      const dom = editor.dom, selection = editor.selection;\n      if (isCaretContainerEmpty(node)) {\n        deleteElement$2(editor, false, SugarElement.fromDom(node), moveCaret);\n      } else {\n        const rng = selection.getRng();\n        const block = dom.getParent(node, dom.isBlock);\n        const startContainer = rng.startContainer;\n        const startOffset = rng.startOffset;\n        const endContainer = rng.endContainer;\n        const endOffset = rng.endOffset;\n        const textNode = trimZwspFromCaretContainer(node);\n        dom.remove(node, true);\n        if (startContainer === textNode && startOffset > 0) {\n          rng.setStart(textNode, startOffset - 1);\n        }\n        if (endContainer === textNode && endOffset > 0) {\n          rng.setEnd(textNode, endOffset - 1);\n        }\n        if (block && dom.isEmpty(block)) {\n          fillWithPaddingBr(SugarElement.fromDom(block));\n        }\n        selection.setRng(rng);\n      }\n    };\n    const removeCaretContainer = (editor, node, moveCaret = true) => {\n      const dom = editor.dom, selection = editor.selection;\n      if (!node) {\n        node = getParentCaretContainer(editor.getBody(), selection.getStart());\n        if (!node) {\n          while (node = dom.get(CARET_ID)) {\n            removeCaretContainerNode(editor, node, false);\n          }\n        }\n      } else {\n        removeCaretContainerNode(editor, node, moveCaret);\n      }\n    };\n    const insertCaretContainerNode = (editor, caretContainer, formatNode) => {\n      const dom = editor.dom, block = dom.getParent(formatNode, curry(isTextBlock$1, editor));\n      if (block && dom.isEmpty(block)) {\n        formatNode.parentNode.replaceChild(caretContainer, formatNode);\n      } else {\n        removeTrailingBr(SugarElement.fromDom(formatNode));\n        if (dom.isEmpty(formatNode)) {\n          formatNode.parentNode.replaceChild(caretContainer, formatNode);\n        } else {\n          dom.insertAfter(caretContainer, formatNode);\n        }\n      }\n    };\n    const appendNode = (parentNode, node) => {\n      parentNode.appendChild(node);\n      return node;\n    };\n    const insertFormatNodesIntoCaretContainer = (formatNodes, caretContainer) => {\n      const innerMostFormatNode = foldr(formatNodes, (parentNode, formatNode) => {\n        return appendNode(parentNode, formatNode.cloneNode(false));\n      }, caretContainer);\n      return appendNode(innerMostFormatNode, innerMostFormatNode.ownerDocument.createTextNode(ZWSP));\n    };\n    const cleanFormatNode = (editor, caretContainer, formatNode, name, vars, similar) => {\n      const formatter = editor.formatter;\n      const dom = editor.dom;\n      const validFormats = filter$6(keys(formatter.get()), formatName => formatName !== name && !contains$1(formatName, 'removeformat'));\n      const matchedFormats = matchAllOnNode(editor, formatNode, validFormats);\n      const uniqueFormats = filter$6(matchedFormats, fmtName => !areSimilarFormats(editor, fmtName, name));\n      if (uniqueFormats.length > 0) {\n        const clonedFormatNode = formatNode.cloneNode(false);\n        dom.add(caretContainer, clonedFormatNode);\n        formatter.remove(name, vars, clonedFormatNode, similar);\n        dom.remove(clonedFormatNode);\n        return Optional.some(clonedFormatNode);\n      } else {\n        return Optional.none();\n      }\n    };\n    const applyCaretFormat = (editor, name, vars) => {\n      let caretContainer, textNode;\n      const selection = editor.selection;\n      const selectionRng = selection.getRng();\n      let offset = selectionRng.startOffset;\n      const container = selectionRng.startContainer;\n      const text = container.nodeValue;\n      caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());\n      if (caretContainer) {\n        textNode = findFirstTextNode(caretContainer);\n      }\n      const wordcharRegex = /[^\\s\\u00a0\\u00ad\\u200b\\ufeff]/;\n      if (text && offset > 0 && offset < text.length && wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {\n        const bookmark = selection.getBookmark();\n        selectionRng.collapse(true);\n        let rng = expandRng(editor, selectionRng, editor.formatter.get(name));\n        rng = split(rng);\n        editor.formatter.apply(name, vars, rng);\n        selection.moveToBookmark(bookmark);\n      } else {\n        if (!caretContainer || textNode.nodeValue !== ZWSP) {\n          caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);\n          textNode = caretContainer.firstChild;\n          selectionRng.insertNode(caretContainer);\n          offset = 1;\n          editor.formatter.apply(name, vars, caretContainer);\n        } else {\n          editor.formatter.apply(name, vars, caretContainer);\n        }\n        selection.setCursorLocation(textNode, offset);\n      }\n    };\n    const removeCaretFormat = (editor, name, vars, similar) => {\n      const dom = editor.dom;\n      const selection = editor.selection;\n      let hasContentAfter, node, formatNode;\n      const parents = [];\n      const rng = selection.getRng();\n      const container = rng.startContainer;\n      const offset = rng.startOffset;\n      node = container;\n      if (container.nodeType === 3) {\n        if (offset !== container.nodeValue.length) {\n          hasContentAfter = true;\n        }\n        node = node.parentNode;\n      }\n      while (node) {\n        if (matchNode(editor, node, name, vars, similar)) {\n          formatNode = node;\n          break;\n        }\n        if (node.nextSibling) {\n          hasContentAfter = true;\n        }\n        parents.push(node);\n        node = node.parentNode;\n      }\n      if (!formatNode) {\n        return;\n      }\n      if (hasContentAfter) {\n        const bookmark = selection.getBookmark();\n        rng.collapse(true);\n        let expandedRng = expandRng(editor, rng, editor.formatter.get(name), true);\n        expandedRng = split(expandedRng);\n        editor.formatter.remove(name, vars, expandedRng, similar);\n        selection.moveToBookmark(bookmark);\n      } else {\n        const caretContainer = getParentCaretContainer(editor.getBody(), formatNode);\n        const newCaretContainer = createCaretContainer(false).dom;\n        insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null ? caretContainer : formatNode);\n        const cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name, vars, similar);\n        const caretTextNode = insertFormatNodesIntoCaretContainer(parents.concat(cleanedFormatNode.toArray()), newCaretContainer);\n        removeCaretContainerNode(editor, caretContainer, false);\n        selection.setCursorLocation(caretTextNode, 1);\n        if (dom.isEmpty(formatNode)) {\n          dom.remove(formatNode);\n        }\n      }\n    };\n    const disableCaretContainer = (editor, keyCode) => {\n      const selection = editor.selection, body = editor.getBody();\n      removeCaretContainer(editor, null, false);\n      if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP) {\n        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));\n      }\n      if (keyCode === 37 || keyCode === 39) {\n        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));\n      }\n    };\n    const setup$u = editor => {\n      editor.on('mouseup keydown', e => {\n        disableCaretContainer(editor, e.keyCode);\n      });\n    };\n    const replaceWithCaretFormat = (targetNode, formatNodes) => {\n      const caretContainer = createCaretContainer(false);\n      const innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);\n      before$3(SugarElement.fromDom(targetNode), caretContainer);\n      remove$5(SugarElement.fromDom(targetNode));\n      return CaretPosition(innerMost, 0);\n    };\n    const isFormatElement = (editor, element) => {\n      const inlineElements = editor.schema.getTextInlineElements();\n      return has$2(inlineElements, name(element)) && !isCaretNode(element.dom) && !isBogus$2(element.dom);\n    };\n    const isEmptyCaretFormatElement = element => {\n      return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);\n    };\n\n    const postProcessHooks = {};\n    const filter$2 = filter$4;\n    const each$a = each$e;\n    const addPostProcessHook = (name, hook) => {\n      const hooks = postProcessHooks[name];\n      if (!hooks) {\n        postProcessHooks[name] = [];\n      }\n      postProcessHooks[name].push(hook);\n    };\n    const postProcess$1 = (name, editor) => {\n      each$a(postProcessHooks[name], hook => {\n        hook(editor);\n      });\n    };\n    addPostProcessHook('pre', editor => {\n      const rng = editor.selection.getRng();\n      let blocks;\n      const hasPreSibling = pre => {\n        return isPre(pre.previousSibling) && indexOf(blocks, pre.previousSibling) !== -1;\n      };\n      const joinPre = (pre1, pre2) => {\n        const sPre2 = SugarElement.fromDom(pre2);\n        const doc = documentOrOwner(sPre2).dom;\n        remove$5(sPre2);\n        append(SugarElement.fromDom(pre1), [\n          SugarElement.fromTag('br', doc),\n          SugarElement.fromTag('br', doc),\n          ...children(sPre2)\n        ]);\n      };\n      const isPre = matchNodeNames(['pre']);\n      if (!rng.collapsed) {\n        blocks = editor.selection.getSelectedBlocks();\n        each$a(filter$2(filter$2(blocks, isPre), hasPreSibling), pre => {\n          joinPre(pre.previousSibling, pre);\n        });\n      }\n    });\n\n    const each$9 = Tools.each;\n    const isElementNode$1 = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);\n    const findElementSibling = (node, siblingName) => {\n      for (let sibling = node; sibling; sibling = sibling[siblingName]) {\n        if (isText$8(sibling) && isNotEmpty(sibling.data)) {\n          return node;\n        }\n        if (isElement$6(sibling) && !isBookmarkNode$1(sibling)) {\n          return sibling;\n        }\n      }\n      return node;\n    };\n    const mergeSiblingsNodes = (dom, prev, next) => {\n      const elementUtils = ElementUtils(dom);\n      if (prev && next) {\n        prev = findElementSibling(prev, 'previousSibling');\n        next = findElementSibling(next, 'nextSibling');\n        if (elementUtils.compare(prev, next)) {\n          for (let sibling = prev.nextSibling; sibling && sibling !== next;) {\n            const tmpSibling = sibling;\n            sibling = sibling.nextSibling;\n            prev.appendChild(tmpSibling);\n          }\n          dom.remove(next);\n          Tools.each(Tools.grep(next.childNodes), node => {\n            prev.appendChild(node);\n          });\n          return prev;\n        }\n      }\n      return next;\n    };\n    const mergeSiblings = (dom, format, vars, node) => {\n      if (node && format.merge_siblings !== false) {\n        const newNode = mergeSiblingsNodes(dom, getNonWhiteSpaceSibling(node), node);\n        mergeSiblingsNodes(dom, newNode, getNonWhiteSpaceSibling(newNode, true));\n      }\n    };\n    const clearChildStyles = (dom, format, node) => {\n      if (format.clear_child_styles) {\n        const selector = format.links ? '*:not(a)' : '*';\n        each$9(dom.select(selector, node), node => {\n          if (isElementNode$1(node)) {\n            each$9(format.styles, (value, name) => {\n              dom.setStyle(node, name, '');\n            });\n          }\n        });\n      }\n    };\n    const processChildElements = (node, filter, process) => {\n      each$9(node.childNodes, node => {\n        if (isElementNode$1(node)) {\n          if (filter(node)) {\n            process(node);\n          }\n          if (node.hasChildNodes()) {\n            processChildElements(node, filter, process);\n          }\n        }\n      });\n    };\n    const unwrapEmptySpan = (dom, node) => {\n      if (node.nodeName === 'SPAN' && dom.getAttribs(node).length === 0) {\n        dom.remove(node, true);\n      }\n    };\n    const hasStyle = (dom, name) => node => !!(node && getStyle(dom, node, name));\n    const applyStyle = (dom, name, value) => node => {\n      dom.setStyle(node, name, value);\n      if (node.getAttribute('style') === '') {\n        node.removeAttribute('style');\n      }\n      unwrapEmptySpan(dom, node);\n    };\n\n    const removeResult = Adt.generate([\n      { keep: [] },\n      { rename: ['name'] },\n      { removed: [] }\n    ]);\n    const MCE_ATTR_RE = /^(src|href|style)$/;\n    const each$8 = Tools.each;\n    const isEq$2 = isEq$5;\n    const isTableCellOrRow = node => /^(TR|TH|TD)$/.test(node.nodeName);\n    const isChildOfInlineParent = (dom, node, parent) => dom.isChildOf(node, parent) && node !== parent && !dom.isBlock(parent);\n    const getContainer = (ed, rng, start) => {\n      let container = rng[start ? 'startContainer' : 'endContainer'];\n      let offset = rng[start ? 'startOffset' : 'endOffset'];\n      if (isElement$6(container)) {\n        const lastIdx = container.childNodes.length - 1;\n        if (!start && offset) {\n          offset--;\n        }\n        container = container.childNodes[offset > lastIdx ? lastIdx : offset];\n      }\n      if (isText$8(container) && start && offset >= container.nodeValue.length) {\n        container = new DomTreeWalker(container, ed.getBody()).next() || container;\n      }\n      if (isText$8(container) && !start && offset === 0) {\n        container = new DomTreeWalker(container, ed.getBody()).prev() || container;\n      }\n      return container;\n    };\n    const normalizeTableSelection = (node, start) => {\n      const prop = start ? 'firstChild' : 'lastChild';\n      if (isTableCellOrRow(node) && node[prop]) {\n        const childNode = node[prop];\n        if (node.nodeName === 'TR') {\n          return childNode[prop] || childNode;\n        } else {\n          return childNode;\n        }\n      }\n      return node;\n    };\n    const wrap$1 = (dom, node, name, attrs) => {\n      const wrapper = dom.create(name, attrs);\n      node.parentNode.insertBefore(wrapper, node);\n      wrapper.appendChild(node);\n      return wrapper;\n    };\n    const wrapWithSiblings = (dom, node, next, name, attrs) => {\n      const start = SugarElement.fromDom(node);\n      const wrapper = SugarElement.fromDom(dom.create(name, attrs));\n      const siblings = next ? nextSiblings(start) : prevSiblings(start);\n      append(wrapper, siblings);\n      if (next) {\n        before$3(start, wrapper);\n        prepend(wrapper, start);\n      } else {\n        after$4(start, wrapper);\n        append$1(wrapper, start);\n      }\n      return wrapper.dom;\n    };\n    const isColorFormatAndAnchor = (node, format) => format.links && node.nodeName === 'A';\n    const removeNode = (ed, node, format) => {\n      const parentNode = node.parentNode;\n      let rootBlockElm;\n      const dom = ed.dom;\n      const forcedRootBlock = getForcedRootBlock(ed);\n      if (isBlockFormat(format)) {\n        if (parentNode === dom.getRoot()) {\n          if (!format.list_block || !isEq$2(node, format.list_block)) {\n            each$g(from(node.childNodes), node => {\n              if (isValid(ed, forcedRootBlock, node.nodeName.toLowerCase())) {\n                if (!rootBlockElm) {\n                  rootBlockElm = wrap$1(dom, node, forcedRootBlock);\n                  dom.setAttribs(rootBlockElm, getForcedRootBlockAttrs(ed));\n                } else {\n                  rootBlockElm.appendChild(node);\n                }\n              } else {\n                rootBlockElm = null;\n              }\n            });\n          }\n        }\n      }\n      if (isMixedFormat(format) && !isEq$2(format.inline, node)) {\n        return;\n      }\n      dom.remove(node, true);\n    };\n    const removeFormatInternal = (ed, format, vars, node, compareNode) => {\n      let stylesModified;\n      const dom = ed.dom;\n      if (!matchName(dom, node, format) && !isColorFormatAndAnchor(node, format)) {\n        return removeResult.keep();\n      }\n      const elm = node;\n      if (isInlineFormat(format) && format.remove === 'all' && isArray$1(format.preserve_attributes)) {\n        const attrsToPreserve = filter$6(dom.getAttribs(elm), attr => contains$2(format.preserve_attributes, attr.name.toLowerCase()));\n        dom.removeAllAttribs(elm);\n        each$g(attrsToPreserve, attr => dom.setAttrib(elm, attr.name, attr.value));\n        if (attrsToPreserve.length > 0) {\n          return removeResult.rename('span');\n        }\n      }\n      if (format.remove !== 'all') {\n        each$8(format.styles, (value, name) => {\n          value = normalizeStyleValue(replaceVars(value, vars), name + '');\n          if (isNumber(name)) {\n            name = value;\n            compareNode = null;\n          }\n          if (format.remove_similar || (!compareNode || isEq$2(getStyle(dom, compareNode, name), value))) {\n            dom.setStyle(elm, name, '');\n          }\n          stylesModified = true;\n        });\n        if (stylesModified && dom.getAttrib(elm, 'style') === '') {\n          elm.removeAttribute('style');\n          elm.removeAttribute('data-mce-style');\n        }\n        each$8(format.attributes, (value, name) => {\n          let valueOut;\n          value = replaceVars(value, vars);\n          if (isNumber(name)) {\n            name = value;\n            compareNode = null;\n          }\n          if (format.remove_similar || (!compareNode || isEq$2(dom.getAttrib(compareNode, name), value))) {\n            if (name === 'class') {\n              value = dom.getAttrib(elm, name);\n              if (value) {\n                valueOut = '';\n                each$g(value.split(/\\s+/), cls => {\n                  if (/mce\\-\\w+/.test(cls)) {\n                    valueOut += (valueOut ? ' ' : '') + cls;\n                  }\n                });\n                if (valueOut) {\n                  dom.setAttrib(elm, name, valueOut);\n                  return;\n                }\n              }\n            }\n            if (MCE_ATTR_RE.test(name)) {\n              elm.removeAttribute('data-mce-' + name);\n            }\n            if (name === 'style' && matchNodeNames(['li'])(elm) && dom.getStyle(elm, 'list-style-type') === 'none') {\n              elm.removeAttribute(name);\n              dom.setStyle(elm, 'list-style-type', 'none');\n              return;\n            }\n            if (name === 'class') {\n              elm.removeAttribute('className');\n            }\n            elm.removeAttribute(name);\n          }\n        });\n        each$8(format.classes, value => {\n          value = replaceVars(value, vars);\n          if (!compareNode || dom.hasClass(compareNode, value)) {\n            dom.removeClass(elm, value);\n          }\n        });\n        const attrs = dom.getAttribs(elm);\n        for (let i = 0; i < attrs.length; i++) {\n          const attrName = attrs[i].nodeName;\n          if (attrName.indexOf('_') !== 0 && attrName.indexOf('data-') !== 0) {\n            return removeResult.keep();\n          }\n        }\n      }\n      if (format.remove !== 'none') {\n        removeNode(ed, elm, format);\n        return removeResult.removed();\n      }\n      return removeResult.keep();\n    };\n    const removeFormat$1 = (ed, format, vars, node, compareNode) => removeFormatInternal(ed, format, vars, node, compareNode).fold(never, newName => {\n      ed.dom.rename(node, newName);\n      return true;\n    }, always);\n    const findFormatRoot = (editor, container, name, vars, similar) => {\n      let formatRoot;\n      each$g(getParents$2(editor.dom, container.parentNode).reverse(), parent => {\n        if (!formatRoot && parent.id !== '_start' && parent.id !== '_end') {\n          const format = matchNode(editor, parent, name, vars, similar);\n          if (format && format.split !== false) {\n            formatRoot = parent;\n          }\n        }\n      });\n      return formatRoot;\n    };\n    const removeFormatFromClone = (editor, format, vars, clone) => removeFormatInternal(editor, format, vars, clone, clone).fold(constant(clone), newName => {\n      const fragment = editor.dom.createFragment();\n      fragment.appendChild(clone);\n      return editor.dom.rename(clone, newName);\n    }, constant(null));\n    const wrapAndSplit = (editor, formatList, formatRoot, container, target, split, format, vars) => {\n      let clone, lastClone, firstClone;\n      const dom = editor.dom;\n      if (formatRoot) {\n        const formatRootParent = formatRoot.parentNode;\n        for (let parent = container.parentNode; parent && parent !== formatRootParent; parent = parent.parentNode) {\n          clone = dom.clone(parent, false);\n          for (let i = 0; i < formatList.length; i++) {\n            clone = removeFormatFromClone(editor, formatList[i], vars, clone);\n            if (clone === null) {\n              break;\n            }\n          }\n          if (clone) {\n            if (lastClone) {\n              clone.appendChild(lastClone);\n            }\n            if (!firstClone) {\n              firstClone = clone;\n            }\n            lastClone = clone;\n          }\n        }\n        if (split && (!format.mixed || !dom.isBlock(formatRoot))) {\n          container = dom.split(formatRoot, container);\n        }\n        if (lastClone) {\n          target.parentNode.insertBefore(lastClone, target);\n          firstClone.appendChild(target);\n          if (isInlineFormat(format)) {\n            mergeSiblings(dom, format, vars, lastClone);\n          }\n        }\n      }\n      return container;\n    };\n    const remove$2 = (ed, name, vars, node, similar) => {\n      const formatList = ed.formatter.get(name);\n      const format = formatList[0];\n      let contentEditable = true;\n      const dom = ed.dom;\n      const selection = ed.selection;\n      const splitToFormatRoot = container => {\n        const formatRoot = findFormatRoot(ed, container, name, vars, similar);\n        return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);\n      };\n      const isRemoveBookmarkNode = node => isBookmarkNode$1(node) && isElement$6(node) && (node.id === '_start' || node.id === '_end');\n      const removeNodeFormat = node => exists(formatList, fmt => removeFormat$1(ed, fmt, vars, node, node));\n      const process = node => {\n        let lastContentEditable = true;\n        let hasContentEditableState = false;\n        if (isElement$6(node) && dom.getContentEditable(node)) {\n          lastContentEditable = contentEditable;\n          contentEditable = dom.getContentEditable(node) === 'true';\n          hasContentEditableState = true;\n        }\n        const children = from(node.childNodes);\n        if (contentEditable && !hasContentEditableState) {\n          const removed = removeNodeFormat(node);\n          const currentNodeMatches = removed || exists(formatList, f => matchName(dom, node, f));\n          const parentNode = node.parentNode;\n          if (!currentNodeMatches && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\n            removeNodeFormat(parentNode);\n          }\n        }\n        if (format.deep) {\n          if (children.length) {\n            for (let i = 0; i < children.length; i++) {\n              process(children[i]);\n            }\n            if (hasContentEditableState) {\n              contentEditable = lastContentEditable;\n            }\n          }\n        }\n        const textDecorations = [\n          'underline',\n          'line-through',\n          'overline'\n        ];\n        each$g(textDecorations, decoration => {\n          if (isElement$6(node) && ed.dom.getStyle(node, 'text-decoration') === decoration && node.parentNode && getTextDecoration(dom, node.parentNode) === decoration) {\n            removeFormat$1(ed, {\n              deep: false,\n              exact: true,\n              inline: 'span',\n              styles: { textDecoration: decoration }\n            }, null, node);\n          }\n        });\n      };\n      const unwrap = start => {\n        const node = dom.get(start ? '_start' : '_end');\n        let out = node[start ? 'firstChild' : 'lastChild'];\n        if (isRemoveBookmarkNode(out)) {\n          out = out[start ? 'firstChild' : 'lastChild'];\n        }\n        if (isText$8(out) && out.data.length === 0) {\n          out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;\n        }\n        dom.remove(node, true);\n        return out;\n      };\n      const removeRngStyle = rng => {\n        let startContainer, endContainer;\n        let expandedRng = expandRng(ed, rng, formatList, rng.collapsed);\n        if (format.split) {\n          expandedRng = split(expandedRng);\n          startContainer = getContainer(ed, expandedRng, true);\n          endContainer = getContainer(ed, expandedRng);\n          if (startContainer !== endContainer) {\n            startContainer = normalizeTableSelection(startContainer, true);\n            endContainer = normalizeTableSelection(endContainer, false);\n            if (isChildOfInlineParent(dom, startContainer, endContainer)) {\n              const marker = Optional.from(startContainer.firstChild).getOr(startContainer);\n              splitToFormatRoot(wrapWithSiblings(dom, marker, true, 'span', {\n                'id': '_start',\n                'data-mce-type': 'bookmark'\n              }));\n              unwrap(true);\n              return;\n            }\n            if (isChildOfInlineParent(dom, endContainer, startContainer)) {\n              const marker = Optional.from(endContainer.lastChild).getOr(endContainer);\n              splitToFormatRoot(wrapWithSiblings(dom, marker, false, 'span', {\n                'id': '_end',\n                'data-mce-type': 'bookmark'\n              }));\n              unwrap(false);\n              return;\n            }\n            startContainer = wrap$1(dom, startContainer, 'span', {\n              'id': '_start',\n              'data-mce-type': 'bookmark'\n            });\n            endContainer = wrap$1(dom, endContainer, 'span', {\n              'id': '_end',\n              'data-mce-type': 'bookmark'\n            });\n            const newRng = dom.createRng();\n            newRng.setStartAfter(startContainer);\n            newRng.setEndBefore(endContainer);\n            walk$3(dom, newRng, nodes => {\n              each$g(nodes, n => {\n                if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) {\n                  splitToFormatRoot(n);\n                }\n              });\n            });\n            splitToFormatRoot(startContainer);\n            splitToFormatRoot(endContainer);\n            startContainer = unwrap(true);\n            endContainer = unwrap();\n          } else {\n            startContainer = endContainer = splitToFormatRoot(startContainer);\n          }\n          expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;\n          expandedRng.startOffset = dom.nodeIndex(startContainer);\n          expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;\n          expandedRng.endOffset = dom.nodeIndex(endContainer) + 1;\n        }\n        walk$3(dom, expandedRng, nodes => {\n          each$g(nodes, process);\n        });\n      };\n      if (node) {\n        if (isNode(node)) {\n          const rng = dom.createRng();\n          rng.setStartBefore(node);\n          rng.setEndAfter(node);\n          removeRngStyle(rng);\n        } else {\n          removeRngStyle(node);\n        }\n        fireFormatRemove(ed, name, node, vars);\n        return;\n      }\n      if (dom.getContentEditable(selection.getNode()) === 'false') {\n        node = selection.getNode();\n        for (let i = 0; i < formatList.length; i++) {\n          if (formatList[i].ceFalseOverride) {\n            if (removeFormat$1(ed, formatList[i], vars, node, node)) {\n              break;\n            }\n          }\n        }\n        fireFormatRemove(ed, name, node, vars);\n        return;\n      }\n      if (!selection.isCollapsed() || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\n        preserve(selection, true, () => {\n          runOnRanges(ed, removeRngStyle);\n        });\n        if (isInlineFormat(format) && match$2(ed, name, vars, selection.getStart())) {\n          moveStart(dom, selection, selection.getRng());\n        }\n        ed.nodeChanged();\n      } else {\n        removeCaretFormat(ed, name, vars, similar);\n      }\n      fireFormatRemove(ed, name, node, vars);\n    };\n\n    const each$7 = Tools.each;\n    const mergeTextDecorationsAndColor = (dom, format, vars, node) => {\n      const processTextDecorationsAndColor = n => {\n        if (n.nodeType === 1 && n.parentNode && n.parentNode.nodeType === 1) {\n          const textDecoration = getTextDecoration(dom, n.parentNode);\n          if (dom.getStyle(n, 'color') && textDecoration) {\n            dom.setStyle(n, 'text-decoration', textDecoration);\n          } else if (dom.getStyle(n, 'text-decoration') === textDecoration) {\n            dom.setStyle(n, 'text-decoration', null);\n          }\n        }\n      };\n      if (format.styles && (format.styles.color || format.styles.textDecoration)) {\n        Tools.walk(node, processTextDecorationsAndColor, 'childNodes');\n        processTextDecorationsAndColor(node);\n      }\n    };\n    const mergeBackgroundColorAndFontSize = (dom, format, vars, node) => {\n      if (format.styles && format.styles.backgroundColor) {\n        processChildElements(node, hasStyle(dom, 'fontSize'), applyStyle(dom, 'backgroundColor', replaceVars(format.styles.backgroundColor, vars)));\n      }\n    };\n    const mergeSubSup = (dom, format, vars, node) => {\n      if (isInlineFormat(format) && (format.inline === 'sub' || format.inline === 'sup')) {\n        processChildElements(node, hasStyle(dom, 'fontSize'), applyStyle(dom, 'fontSize', ''));\n        dom.remove(dom.select(format.inline === 'sup' ? 'sub' : 'sup', node), true);\n      }\n    };\n    const mergeWithChildren = (editor, formatList, vars, node) => {\n      each$7(formatList, format => {\n        if (isInlineFormat(format)) {\n          each$7(editor.dom.select(format.inline, node), child => {\n            if (!isElementNode$1(child)) {\n              return;\n            }\n            removeFormat$1(editor, format, vars, child, format.exact ? child : null);\n          });\n        }\n        clearChildStyles(editor.dom, format, node);\n      });\n    };\n    const mergeWithParents = (editor, format, name, vars, node) => {\n      if (matchNode(editor, node.parentNode, name, vars)) {\n        if (removeFormat$1(editor, format, vars, node)) {\n          return;\n        }\n      }\n      if (format.merge_with_parents) {\n        editor.dom.getParent(node.parentNode, parent => {\n          if (matchNode(editor, parent, name, vars)) {\n            removeFormat$1(editor, format, vars, node);\n            return true;\n          }\n        });\n      }\n    };\n\n    const each$6 = Tools.each;\n    const isElementNode = node => {\n      return isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);\n    };\n    const canFormatBR = (editor, format, node, parentName) => {\n      if (canFormatEmptyLines(editor) && isInlineFormat(format)) {\n        const validBRParentElements = {\n          ...editor.schema.getTextBlockElements(),\n          td: {},\n          th: {},\n          li: {},\n          dt: {},\n          dd: {},\n          figcaption: {},\n          caption: {},\n          details: {},\n          summary: {}\n        };\n        const hasCaretNodeSibling = sibling(SugarElement.fromDom(node), sibling => isCaretNode(sibling.dom));\n        return hasNonNullableKey(validBRParentElements, parentName) && isEmpty$2(SugarElement.fromDom(node.parentNode), false) && !hasCaretNodeSibling;\n      } else {\n        return false;\n      }\n    };\n    const applyFormat$1 = (ed, name, vars, node) => {\n      const formatList = ed.formatter.get(name);\n      const format = formatList[0];\n      const isCollapsed = !node && ed.selection.isCollapsed();\n      const dom = ed.dom;\n      const selection = ed.selection;\n      const setElementFormat = (elm, fmt = format) => {\n        if (isFunction(fmt.onformat)) {\n          fmt.onformat(elm, fmt, vars, node);\n        }\n        each$6(fmt.styles, (value, name) => {\n          dom.setStyle(elm, name, replaceVars(value, vars));\n        });\n        if (fmt.styles) {\n          const styleVal = dom.getAttrib(elm, 'style');\n          if (styleVal) {\n            dom.setAttrib(elm, 'data-mce-style', styleVal);\n          }\n        }\n        each$6(fmt.attributes, (value, name) => {\n          dom.setAttrib(elm, name, replaceVars(value, vars));\n        });\n        each$6(fmt.classes, value => {\n          value = replaceVars(value, vars);\n          if (!dom.hasClass(elm, value)) {\n            dom.addClass(elm, value);\n          }\n        });\n      };\n      const applyNodeStyle = (formatList, node) => {\n        let found = false;\n        each$6(formatList, format => {\n          if (!isSelectorFormat(format)) {\n            return false;\n          }\n          if (isNonNullable(format.collapsed) && format.collapsed !== isCollapsed) {\n            return;\n          }\n          if (dom.is(node, format.selector) && !isCaretNode(node)) {\n            setElementFormat(node, format);\n            found = true;\n            return false;\n          }\n        });\n        return found;\n      };\n      const createWrapElement = wrapName => {\n        if (isString(wrapName)) {\n          const wrapElm = dom.create(wrapName);\n          setElementFormat(wrapElm);\n          return wrapElm;\n        } else {\n          return null;\n        }\n      };\n      const applyRngStyle = (dom, rng, nodeSpecific) => {\n        const newWrappers = [];\n        let contentEditable = true;\n        const wrapName = format.inline || format.block;\n        const wrapElm = createWrapElement(wrapName);\n        walk$3(dom, rng, nodes => {\n          let currentWrapElm;\n          const process = node => {\n            let hasContentEditableState = false;\n            let lastContentEditable = contentEditable;\n            const nodeName = node.nodeName.toLowerCase();\n            const parentNode = node.parentNode;\n            const parentName = parentNode.nodeName.toLowerCase();\n            if (isElement$6(node) && dom.getContentEditable(node)) {\n              lastContentEditable = contentEditable;\n              contentEditable = dom.getContentEditable(node) === 'true';\n              hasContentEditableState = true;\n            }\n            if (isBr$5(node) && !canFormatBR(ed, format, node, parentName)) {\n              currentWrapElm = null;\n              if (isBlockFormat(format)) {\n                dom.remove(node);\n              }\n              return;\n            }\n            if (isBlockFormat(format) && format.wrapper && matchNode(ed, node, name, vars)) {\n              currentWrapElm = null;\n              return;\n            }\n            if (contentEditable && !hasContentEditableState && isBlockFormat(format) && !format.wrapper && isTextBlock$1(ed, nodeName) && isValid(ed, parentName, wrapName)) {\n              const elm = dom.rename(node, wrapName);\n              setElementFormat(elm);\n              newWrappers.push(elm);\n              currentWrapElm = null;\n              return;\n            }\n            if (isSelectorFormat(format)) {\n              let found = applyNodeStyle(formatList, node);\n              if (!found && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\n                found = applyNodeStyle(formatList, parentNode);\n              }\n              if (!isInlineFormat(format) || found) {\n                currentWrapElm = null;\n                return;\n              }\n            }\n            if (contentEditable && !hasContentEditableState && isValid(ed, wrapName, nodeName) && isValid(ed, parentName, wrapName) && !(!nodeSpecific && isText$8(node) && isZwsp(node.data)) && !isCaretNode(node) && (!isInlineFormat(format) || !dom.isBlock(node))) {\n              if (!currentWrapElm) {\n                currentWrapElm = dom.clone(wrapElm, false);\n                node.parentNode.insertBefore(currentWrapElm, node);\n                newWrappers.push(currentWrapElm);\n              }\n              currentWrapElm.appendChild(node);\n            } else {\n              currentWrapElm = null;\n              each$g(from(node.childNodes), process);\n              if (hasContentEditableState) {\n                contentEditable = lastContentEditable;\n              }\n              currentWrapElm = null;\n            }\n          };\n          each$g(nodes, process);\n        });\n        if (format.links === true) {\n          each$g(newWrappers, node => {\n            const process = node => {\n              if (node.nodeName === 'A') {\n                setElementFormat(node, format);\n              }\n              each$g(from(node.childNodes), process);\n            };\n            process(node);\n          });\n        }\n        each$g(newWrappers, node => {\n          const getChildCount = node => {\n            let count = 0;\n            each$g(node.childNodes, node => {\n              if (!isEmptyTextNode$1(node) && !isBookmarkNode$1(node)) {\n                count++;\n              }\n            });\n            return count;\n          };\n          const mergeStyles = node => {\n            const childElement = find$2(node.childNodes, isElementNode).filter(child => matchName(dom, child, format));\n            return childElement.map(child => {\n              const clone = dom.clone(child, false);\n              setElementFormat(clone);\n              dom.replace(clone, node, true);\n              dom.remove(child, true);\n              return clone;\n            }).getOr(node);\n          };\n          const childCount = getChildCount(node);\n          if ((newWrappers.length > 1 || !dom.isBlock(node)) && childCount === 0) {\n            dom.remove(node, true);\n            return;\n          }\n          if (isInlineFormat(format) || isBlockFormat(format) && format.wrapper) {\n            if (!format.exact && childCount === 1) {\n              node = mergeStyles(node);\n            }\n            mergeWithChildren(ed, formatList, vars, node);\n            mergeWithParents(ed, format, name, vars, node);\n            mergeBackgroundColorAndFontSize(dom, format, vars, node);\n            mergeTextDecorationsAndColor(dom, format, vars, node);\n            mergeSubSup(dom, format, vars, node);\n            mergeSiblings(dom, format, vars, node);\n          }\n        });\n      };\n      if (dom.getContentEditable(selection.getNode()) === 'false') {\n        node = selection.getNode();\n        for (let i = 0, l = formatList.length; i < l; i++) {\n          const formatItem = formatList[i];\n          if (formatItem.ceFalseOverride && isSelectorFormat(formatItem) && dom.is(node, formatItem.selector)) {\n            setElementFormat(node, formatItem);\n            break;\n          }\n        }\n        fireFormatApply(ed, name, node, vars);\n        return;\n      }\n      if (format) {\n        if (node) {\n          if (isNode(node)) {\n            if (!applyNodeStyle(formatList, node)) {\n              const rng = dom.createRng();\n              rng.setStartBefore(node);\n              rng.setEndAfter(node);\n              applyRngStyle(dom, expandRng(ed, rng, formatList), true);\n            }\n          } else {\n            applyRngStyle(dom, node, true);\n          }\n        } else {\n          if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\n            selection.setRng(normalize(selection.getRng()));\n            preserve(selection, true, () => {\n              runOnRanges(ed, (selectionRng, fake) => {\n                const expandedRng = fake ? selectionRng : expandRng(ed, selectionRng, formatList);\n                applyRngStyle(dom, expandedRng, false);\n              });\n            });\n            moveStart(dom, selection, selection.getRng());\n            ed.nodeChanged();\n          } else {\n            applyCaretFormat(ed, name, vars);\n          }\n        }\n        postProcess$1(name, ed);\n      }\n      fireFormatApply(ed, name, node, vars);\n    };\n\n    const hasVars = value => has$2(value, 'vars');\n    const setup$t = (registeredFormatListeners, editor) => {\n      registeredFormatListeners.set({});\n      editor.on('NodeChange', e => {\n        updateAndFireChangeCallbacks(editor, e.element, registeredFormatListeners.get());\n      });\n      editor.on('FormatApply FormatRemove', e => {\n        const element = Optional.from(e.node).map(nodeOrRange => isNode(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer).bind(node => isElement$6(node) ? Optional.some(node) : Optional.from(node.parentElement)).getOrThunk(() => fallbackElement(editor));\n        updateAndFireChangeCallbacks(editor, element, registeredFormatListeners.get());\n      });\n    };\n    const fallbackElement = editor => editor.selection.getStart();\n    const matchingNode = (editor, parents, format, similar, vars) => {\n      const isMatchingNode = node => {\n        const matchingFormat = editor.formatter.matchNode(node, format, vars !== null && vars !== void 0 ? vars : {}, similar);\n        return !isUndefined(matchingFormat);\n      };\n      const isUnableToMatch = node => {\n        if (matchesUnInheritedFormatSelector(editor, node, format)) {\n          return true;\n        } else {\n          if (!similar) {\n            return isNonNullable(editor.formatter.matchNode(node, format, vars, true));\n          } else {\n            return false;\n          }\n        }\n      };\n      return findUntil$1(parents, isMatchingNode, isUnableToMatch);\n    };\n    const getParents = (editor, elm) => {\n      const element = elm !== null && elm !== void 0 ? elm : fallbackElement(editor);\n      return filter$6(getParents$2(editor.dom, element), node => isElement$6(node) && !isBogus$2(node));\n    };\n    const updateAndFireChangeCallbacks = (editor, elm, registeredCallbacks) => {\n      const parents = getParents(editor, elm);\n      each$f(registeredCallbacks, (data, format) => {\n        const runIfChanged = spec => {\n          const match = matchingNode(editor, parents, format, spec.similar, hasVars(spec) ? spec.vars : undefined);\n          const isSet = match.isSome();\n          if (spec.state.get() !== isSet) {\n            spec.state.set(isSet);\n            const node = match.getOr(elm);\n            if (hasVars(spec)) {\n              spec.callback(isSet, {\n                node,\n                format,\n                parents\n              });\n            } else {\n              each$g(spec.callbacks, callback => callback(isSet, {\n                node,\n                format,\n                parents\n              }));\n            }\n          }\n        };\n        each$g([\n          data.withSimilar,\n          data.withoutSimilar\n        ], runIfChanged);\n        each$g(data.withVars, runIfChanged);\n      });\n    };\n    const addListeners = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\n      const formatChangeItems = registeredFormatListeners.get();\n      each$g(formats.split(','), format => {\n        const group = get$a(formatChangeItems, format).getOrThunk(() => {\n          const base = {\n            withSimilar: {\n              state: Cell(false),\n              similar: true,\n              callbacks: []\n            },\n            withoutSimilar: {\n              state: Cell(false),\n              similar: false,\n              callbacks: []\n            },\n            withVars: []\n          };\n          formatChangeItems[format] = base;\n          return base;\n        });\n        const getCurrent = () => {\n          const parents = getParents(editor);\n          return matchingNode(editor, parents, format, similar, vars).isSome();\n        };\n        if (isUndefined(vars)) {\n          const toAppendTo = similar ? group.withSimilar : group.withoutSimilar;\n          toAppendTo.callbacks.push(callback);\n          if (toAppendTo.callbacks.length === 1) {\n            toAppendTo.state.set(getCurrent());\n          }\n        } else {\n          group.withVars.push({\n            state: Cell(getCurrent()),\n            similar,\n            vars,\n            callback\n          });\n        }\n      });\n      registeredFormatListeners.set(formatChangeItems);\n    };\n    const removeListeners = (registeredFormatListeners, formats, callback) => {\n      const formatChangeItems = registeredFormatListeners.get();\n      each$g(formats.split(','), format => get$a(formatChangeItems, format).each(group => {\n        formatChangeItems[format] = {\n          withSimilar: {\n            ...group.withSimilar,\n            callbacks: filter$6(group.withSimilar.callbacks, cb => cb !== callback)\n          },\n          withoutSimilar: {\n            ...group.withoutSimilar,\n            callbacks: filter$6(group.withoutSimilar.callbacks, cb => cb !== callback)\n          },\n          withVars: filter$6(group.withVars, item => item.callback !== callback)\n        };\n      }));\n      registeredFormatListeners.set(formatChangeItems);\n    };\n    const formatChangedInternal = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\n      if (registeredFormatListeners.get() === null) {\n        setup$t(registeredFormatListeners, editor);\n      }\n      addListeners(editor, registeredFormatListeners, formats, callback, similar, vars);\n      return { unbind: () => removeListeners(registeredFormatListeners, formats, callback) };\n    };\n\n    const toggle = (editor, name, vars, node) => {\n      const fmt = editor.formatter.get(name);\n      if (match$2(editor, name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {\n        remove$2(editor, name, vars, node);\n      } else {\n        applyFormat$1(editor, name, vars, node);\n      }\n    };\n\n    function _toConsumableArray(arr) {\n      if (Array.isArray(arr)) {\n        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n          arr2[i] = arr[i];\n        }\n        return arr2;\n      } else {\n        return Array.from(arr);\n      }\n    }\n    var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    var freeze = Object.freeze, seal = Object.seal, create$7 = Object.create;\n    var _ref = typeof Reflect !== 'undefined' && Reflect, apply = _ref.apply, construct = _ref.construct;\n    if (!apply) {\n      apply = function apply(fun, thisValue, args) {\n        return fun.apply(thisValue, args);\n      };\n    }\n    if (!freeze) {\n      freeze = function freeze(x) {\n        return x;\n      };\n    }\n    if (!seal) {\n      seal = function seal(x) {\n        return x;\n      };\n    }\n    if (!construct) {\n      construct = function construct(Func, args) {\n        return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();\n      };\n    }\n    var arrayForEach = unapply(Array.prototype.forEach);\n    var arrayPop = unapply(Array.prototype.pop);\n    var arrayPush = unapply(Array.prototype.push);\n    var stringToLowerCase = unapply(String.prototype.toLowerCase);\n    var stringMatch = unapply(String.prototype.match);\n    var stringReplace = unapply(String.prototype.replace);\n    var stringIndexOf = unapply(String.prototype.indexOf);\n    var stringTrim = unapply(String.prototype.trim);\n    var regExpTest = unapply(RegExp.prototype.test);\n    var typeErrorCreate = unconstruct(TypeError);\n    function unapply(func) {\n      return function (thisArg) {\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        return apply(func, thisArg, args);\n      };\n    }\n    function unconstruct(func) {\n      return function () {\n        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        return construct(func, args);\n      };\n    }\n    function addToSet(set, array) {\n      if (setPrototypeOf) {\n        setPrototypeOf(set, null);\n      }\n      var l = array.length;\n      while (l--) {\n        var element = array[l];\n        if (typeof element === 'string') {\n          var lcElement = stringToLowerCase(element);\n          if (lcElement !== element) {\n            if (!isFrozen(array)) {\n              array[l] = lcElement;\n            }\n            element = lcElement;\n          }\n        }\n        set[element] = true;\n      }\n      return set;\n    }\n    function clone(object) {\n      var newObject = create$7(null);\n      var property = void 0;\n      for (property in object) {\n        if (apply(hasOwnProperty, object, [property])) {\n          newObject[property] = object[property];\n        }\n      }\n      return newObject;\n    }\n    function lookupGetter(object, prop) {\n      while (object !== null) {\n        var desc = getOwnPropertyDescriptor(object, prop);\n        if (desc) {\n          if (desc.get) {\n            return unapply(desc.get);\n          }\n          if (typeof desc.value === 'function') {\n            return unapply(desc.value);\n          }\n        }\n        object = getPrototypeOf(object);\n      }\n      function fallbackValue(element) {\n        console.warn('fallback value for', element);\n        return null;\n      }\n      return fallbackValue;\n    }\n    var html = freeze([\n      'a',\n      'abbr',\n      'acronym',\n      'address',\n      'area',\n      'article',\n      'aside',\n      'audio',\n      'b',\n      'bdi',\n      'bdo',\n      'big',\n      'blink',\n      'blockquote',\n      'body',\n      'br',\n      'button',\n      'canvas',\n      'caption',\n      'center',\n      'cite',\n      'code',\n      'col',\n      'colgroup',\n      'content',\n      'data',\n      'datalist',\n      'dd',\n      'decorator',\n      'del',\n      'details',\n      'dfn',\n      'dialog',\n      'dir',\n      'div',\n      'dl',\n      'dt',\n      'element',\n      'em',\n      'fieldset',\n      'figcaption',\n      'figure',\n      'font',\n      'footer',\n      'form',\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'head',\n      'header',\n      'hgroup',\n      'hr',\n      'html',\n      'i',\n      'img',\n      'input',\n      'ins',\n      'kbd',\n      'label',\n      'legend',\n      'li',\n      'main',\n      'map',\n      'mark',\n      'marquee',\n      'menu',\n      'menuitem',\n      'meter',\n      'nav',\n      'nobr',\n      'ol',\n      'optgroup',\n      'option',\n      'output',\n      'p',\n      'picture',\n      'pre',\n      'progress',\n      'q',\n      'rp',\n      'rt',\n      'ruby',\n      's',\n      'samp',\n      'section',\n      'select',\n      'shadow',\n      'small',\n      'source',\n      'spacer',\n      'span',\n      'strike',\n      'strong',\n      'style',\n      'sub',\n      'summary',\n      'sup',\n      'table',\n      'tbody',\n      'td',\n      'template',\n      'textarea',\n      'tfoot',\n      'th',\n      'thead',\n      'time',\n      'tr',\n      'track',\n      'tt',\n      'u',\n      'ul',\n      'var',\n      'video',\n      'wbr'\n    ]);\n    var svg = freeze([\n      'svg',\n      'a',\n      'altglyph',\n      'altglyphdef',\n      'altglyphitem',\n      'animatecolor',\n      'animatemotion',\n      'animatetransform',\n      'circle',\n      'clippath',\n      'defs',\n      'desc',\n      'ellipse',\n      'filter',\n      'font',\n      'g',\n      'glyph',\n      'glyphref',\n      'hkern',\n      'image',\n      'line',\n      'lineargradient',\n      'marker',\n      'mask',\n      'metadata',\n      'mpath',\n      'path',\n      'pattern',\n      'polygon',\n      'polyline',\n      'radialgradient',\n      'rect',\n      'stop',\n      'style',\n      'switch',\n      'symbol',\n      'text',\n      'textpath',\n      'title',\n      'tref',\n      'tspan',\n      'view',\n      'vkern'\n    ]);\n    var svgFilters = freeze([\n      'feBlend',\n      'feColorMatrix',\n      'feComponentTransfer',\n      'feComposite',\n      'feConvolveMatrix',\n      'feDiffuseLighting',\n      'feDisplacementMap',\n      'feDistantLight',\n      'feFlood',\n      'feFuncA',\n      'feFuncB',\n      'feFuncG',\n      'feFuncR',\n      'feGaussianBlur',\n      'feImage',\n      'feMerge',\n      'feMergeNode',\n      'feMorphology',\n      'feOffset',\n      'fePointLight',\n      'feSpecularLighting',\n      'feSpotLight',\n      'feTile',\n      'feTurbulence'\n    ]);\n    var svgDisallowed = freeze([\n      'animate',\n      'color-profile',\n      'cursor',\n      'discard',\n      'fedropshadow',\n      'font-face',\n      'font-face-format',\n      'font-face-name',\n      'font-face-src',\n      'font-face-uri',\n      'foreignobject',\n      'hatch',\n      'hatchpath',\n      'mesh',\n      'meshgradient',\n      'meshpatch',\n      'meshrow',\n      'missing-glyph',\n      'script',\n      'set',\n      'solidcolor',\n      'unknown',\n      'use'\n    ]);\n    var mathMl = freeze([\n      'math',\n      'menclose',\n      'merror',\n      'mfenced',\n      'mfrac',\n      'mglyph',\n      'mi',\n      'mlabeledtr',\n      'mmultiscripts',\n      'mn',\n      'mo',\n      'mover',\n      'mpadded',\n      'mphantom',\n      'mroot',\n      'mrow',\n      'ms',\n      'mspace',\n      'msqrt',\n      'mstyle',\n      'msub',\n      'msup',\n      'msubsup',\n      'mtable',\n      'mtd',\n      'mtext',\n      'mtr',\n      'munder',\n      'munderover'\n    ]);\n    var mathMlDisallowed = freeze([\n      'maction',\n      'maligngroup',\n      'malignmark',\n      'mlongdiv',\n      'mscarries',\n      'mscarry',\n      'msgroup',\n      'mstack',\n      'msline',\n      'msrow',\n      'semantics',\n      'annotation',\n      'annotation-xml',\n      'mprescripts',\n      'none'\n    ]);\n    var text = freeze(['#text']);\n    var html$1 = freeze([\n      'accept',\n      'action',\n      'align',\n      'alt',\n      'autocapitalize',\n      'autocomplete',\n      'autopictureinpicture',\n      'autoplay',\n      'background',\n      'bgcolor',\n      'border',\n      'capture',\n      'cellpadding',\n      'cellspacing',\n      'checked',\n      'cite',\n      'class',\n      'clear',\n      'color',\n      'cols',\n      'colspan',\n      'controls',\n      'controlslist',\n      'coords',\n      'crossorigin',\n      'datetime',\n      'decoding',\n      'default',\n      'dir',\n      'disabled',\n      'disablepictureinpicture',\n      'disableremoteplayback',\n      'download',\n      'draggable',\n      'enctype',\n      'enterkeyhint',\n      'face',\n      'for',\n      'headers',\n      'height',\n      'hidden',\n      'high',\n      'href',\n      'hreflang',\n      'id',\n      'inputmode',\n      'integrity',\n      'ismap',\n      'kind',\n      'label',\n      'lang',\n      'list',\n      'loading',\n      'loop',\n      'low',\n      'max',\n      'maxlength',\n      'media',\n      'method',\n      'min',\n      'minlength',\n      'multiple',\n      'muted',\n      'name',\n      'nonce',\n      'noshade',\n      'novalidate',\n      'nowrap',\n      'open',\n      'optimum',\n      'pattern',\n      'placeholder',\n      'playsinline',\n      'poster',\n      'preload',\n      'pubdate',\n      'radiogroup',\n      'readonly',\n      'rel',\n      'required',\n      'rev',\n      'reversed',\n      'role',\n      'rows',\n      'rowspan',\n      'spellcheck',\n      'scope',\n      'selected',\n      'shape',\n      'size',\n      'sizes',\n      'span',\n      'srclang',\n      'start',\n      'src',\n      'srcset',\n      'step',\n      'style',\n      'summary',\n      'tabindex',\n      'title',\n      'translate',\n      'type',\n      'usemap',\n      'valign',\n      'value',\n      'width',\n      'xmlns',\n      'slot'\n    ]);\n    var svg$1 = freeze([\n      'accent-height',\n      'accumulate',\n      'additive',\n      'alignment-baseline',\n      'ascent',\n      'attributename',\n      'attributetype',\n      'azimuth',\n      'basefrequency',\n      'baseline-shift',\n      'begin',\n      'bias',\n      'by',\n      'class',\n      'clip',\n      'clippathunits',\n      'clip-path',\n      'clip-rule',\n      'color',\n      'color-interpolation',\n      'color-interpolation-filters',\n      'color-profile',\n      'color-rendering',\n      'cx',\n      'cy',\n      'd',\n      'dx',\n      'dy',\n      'diffuseconstant',\n      'direction',\n      'display',\n      'divisor',\n      'dur',\n      'edgemode',\n      'elevation',\n      'end',\n      'fill',\n      'fill-opacity',\n      'fill-rule',\n      'filter',\n      'filterunits',\n      'flood-color',\n      'flood-opacity',\n      'font-family',\n      'font-size',\n      'font-size-adjust',\n      'font-stretch',\n      'font-style',\n      'font-variant',\n      'font-weight',\n      'fx',\n      'fy',\n      'g1',\n      'g2',\n      'glyph-name',\n      'glyphref',\n      'gradientunits',\n      'gradienttransform',\n      'height',\n      'href',\n      'id',\n      'image-rendering',\n      'in',\n      'in2',\n      'k',\n      'k1',\n      'k2',\n      'k3',\n      'k4',\n      'kerning',\n      'keypoints',\n      'keysplines',\n      'keytimes',\n      'lang',\n      'lengthadjust',\n      'letter-spacing',\n      'kernelmatrix',\n      'kernelunitlength',\n      'lighting-color',\n      'local',\n      'marker-end',\n      'marker-mid',\n      'marker-start',\n      'markerheight',\n      'markerunits',\n      'markerwidth',\n      'maskcontentunits',\n      'maskunits',\n      'max',\n      'mask',\n      'media',\n      'method',\n      'mode',\n      'min',\n      'name',\n      'numoctaves',\n      'offset',\n      'operator',\n      'opacity',\n      'order',\n      'orient',\n      'orientation',\n      'origin',\n      'overflow',\n      'paint-order',\n      'path',\n      'pathlength',\n      'patterncontentunits',\n      'patterntransform',\n      'patternunits',\n      'points',\n      'preservealpha',\n      'preserveaspectratio',\n      'primitiveunits',\n      'r',\n      'rx',\n      'ry',\n      'radius',\n      'refx',\n      'refy',\n      'repeatcount',\n      'repeatdur',\n      'restart',\n      'result',\n      'rotate',\n      'scale',\n      'seed',\n      'shape-rendering',\n      'specularconstant',\n      'specularexponent',\n      'spreadmethod',\n      'startoffset',\n      'stddeviation',\n      'stitchtiles',\n      'stop-color',\n      'stop-opacity',\n      'stroke-dasharray',\n      'stroke-dashoffset',\n      'stroke-linecap',\n      'stroke-linejoin',\n      'stroke-miterlimit',\n      'stroke-opacity',\n      'stroke',\n      'stroke-width',\n      'style',\n      'surfacescale',\n      'systemlanguage',\n      'tabindex',\n      'targetx',\n      'targety',\n      'transform',\n      'transform-origin',\n      'text-anchor',\n      'text-decoration',\n      'text-rendering',\n      'textlength',\n      'type',\n      'u1',\n      'u2',\n      'unicode',\n      'values',\n      'viewbox',\n      'visibility',\n      'version',\n      'vert-adv-y',\n      'vert-origin-x',\n      'vert-origin-y',\n      'width',\n      'word-spacing',\n      'wrap',\n      'writing-mode',\n      'xchannelselector',\n      'ychannelselector',\n      'x',\n      'x1',\n      'x2',\n      'xmlns',\n      'y',\n      'y1',\n      'y2',\n      'z',\n      'zoomandpan'\n    ]);\n    var mathMl$1 = freeze([\n      'accent',\n      'accentunder',\n      'align',\n      'bevelled',\n      'close',\n      'columnsalign',\n      'columnlines',\n      'columnspan',\n      'denomalign',\n      'depth',\n      'dir',\n      'display',\n      'displaystyle',\n      'encoding',\n      'fence',\n      'frame',\n      'height',\n      'href',\n      'id',\n      'largeop',\n      'length',\n      'linethickness',\n      'lspace',\n      'lquote',\n      'mathbackground',\n      'mathcolor',\n      'mathsize',\n      'mathvariant',\n      'maxsize',\n      'minsize',\n      'movablelimits',\n      'notation',\n      'numalign',\n      'open',\n      'rowalign',\n      'rowlines',\n      'rowspacing',\n      'rowspan',\n      'rspace',\n      'rquote',\n      'scriptlevel',\n      'scriptminsize',\n      'scriptsizemultiplier',\n      'selection',\n      'separator',\n      'separators',\n      'stretchy',\n      'subscriptshift',\n      'supscriptshift',\n      'symmetric',\n      'voffset',\n      'width',\n      'xmlns'\n    ]);\n    var xml = freeze([\n      'xlink:href',\n      'xml:id',\n      'xlink:title',\n      'xml:space',\n      'xmlns:xlink'\n    ]);\n    var MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm);\n    var ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\n    var DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/);\n    var ARIA_ATTR = seal(/^aria-[\\-\\w]+$/);\n    var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i);\n    var IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n    var ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g);\n    var DOCTYPE_NAME = seal(/^html$/i);\n    var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {\n      return typeof obj;\n    } : function (obj) {\n      return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;\n    };\n    function _toConsumableArray$1(arr) {\n      if (Array.isArray(arr)) {\n        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n          arr2[i] = arr[i];\n        }\n        return arr2;\n      } else {\n        return Array.from(arr);\n      }\n    }\n    var getGlobal = function getGlobal() {\n      return typeof window === 'undefined' ? null : window;\n    };\n    var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n      if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n        return null;\n      }\n      var suffix = null;\n      var ATTR_NAME = 'data-tt-policy-suffix';\n      if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n        suffix = document.currentScript.getAttribute(ATTR_NAME);\n      }\n      var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n      try {\n        return trustedTypes.createPolicy(policyName, {\n          createHTML: function createHTML(html$$1) {\n            return html$$1;\n          }\n        });\n      } catch (_) {\n        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n        return null;\n      }\n    };\n    function createDOMPurify() {\n      var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n      var DOMPurify = function DOMPurify(root) {\n        return createDOMPurify(root);\n      };\n      DOMPurify.version = '2.3.6';\n      DOMPurify.removed = [];\n      if (!window || !window.document || window.document.nodeType !== 9) {\n        DOMPurify.isSupported = false;\n        return DOMPurify;\n      }\n      var originalDocument = window.document;\n      var document = window.document;\n      var DocumentFragment = window.DocumentFragment, HTMLTemplateElement = window.HTMLTemplateElement, Node = window.Node, Element = window.Element, NodeFilter = window.NodeFilter, _window$NamedNodeMap = window.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window.HTMLFormElement, DOMParser = window.DOMParser, trustedTypes = window.trustedTypes;\n      var ElementPrototype = Element.prototype;\n      var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n      var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n      var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n      var getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n      if (typeof HTMLTemplateElement === 'function') {\n        var template = document.createElement('template');\n        if (template.content && template.content.ownerDocument) {\n          document = template.content.ownerDocument;\n        }\n      }\n      var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\n      var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';\n      var _document = document, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;\n      var importNode = originalDocument.importNode;\n      var documentMode = {};\n      try {\n        documentMode = clone(document).documentMode ? document.documentMode : {};\n      } catch (_) {\n      }\n      var hooks = {};\n      DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;\n      var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR, ERB_EXPR$$1 = ERB_EXPR, DATA_ATTR$$1 = DATA_ATTR, ARIA_ATTR$$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n      var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n      var ALLOWED_TAGS = null;\n      var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));\n      var ALLOWED_ATTR = null;\n      var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));\n      var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {\n        tagNameCheck: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: null\n        },\n        attributeNameCheck: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: null\n        },\n        allowCustomizedBuiltInElements: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: false\n        }\n      }));\n      var FORBID_TAGS = null;\n      var FORBID_ATTR = null;\n      var ALLOW_ARIA_ATTR = true;\n      var ALLOW_DATA_ATTR = true;\n      var ALLOW_UNKNOWN_PROTOCOLS = false;\n      var SAFE_FOR_TEMPLATES = false;\n      var WHOLE_DOCUMENT = false;\n      var SET_CONFIG = false;\n      var FORCE_BODY = false;\n      var RETURN_DOM = false;\n      var RETURN_DOM_FRAGMENT = false;\n      var RETURN_TRUSTED_TYPE = false;\n      var SANITIZE_DOM = true;\n      var KEEP_CONTENT = true;\n      var IN_PLACE = false;\n      var USE_PROFILES = {};\n      var FORBID_CONTENTS = null;\n      var DEFAULT_FORBID_CONTENTS = addToSet({}, [\n        'annotation-xml',\n        'audio',\n        'colgroup',\n        'desc',\n        'foreignobject',\n        'head',\n        'iframe',\n        'math',\n        'mi',\n        'mn',\n        'mo',\n        'ms',\n        'mtext',\n        'noembed',\n        'noframes',\n        'noscript',\n        'plaintext',\n        'script',\n        'style',\n        'svg',\n        'template',\n        'thead',\n        'title',\n        'video',\n        'xmp'\n      ]);\n      var DATA_URI_TAGS = null;\n      var DEFAULT_DATA_URI_TAGS = addToSet({}, [\n        'audio',\n        'video',\n        'img',\n        'source',\n        'image',\n        'track'\n      ]);\n      var URI_SAFE_ATTRIBUTES = null;\n      var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\n        'alt',\n        'class',\n        'for',\n        'id',\n        'label',\n        'name',\n        'pattern',\n        'placeholder',\n        'role',\n        'summary',\n        'title',\n        'value',\n        'style',\n        'xmlns'\n      ]);\n      var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n      var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n      var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n      var NAMESPACE = HTML_NAMESPACE;\n      var IS_EMPTY_INPUT = false;\n      var PARSER_MEDIA_TYPE = void 0;\n      var SUPPORTED_PARSER_MEDIA_TYPES = [\n        'application/xhtml+xml',\n        'text/html'\n      ];\n      var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n      var transformCaseFunc = void 0;\n      var CONFIG = null;\n      var formElement = document.createElement('form');\n      var isRegexOrFunction = function isRegexOrFunction(testValue) {\n        return testValue instanceof RegExp || testValue instanceof Function;\n      };\n      var _parseConfig = function _parseConfig(cfg) {\n        if (CONFIG && CONFIG === cfg) {\n          return;\n        }\n        if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {\n          cfg = {};\n        }\n        cfg = clone(cfg);\n        ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n        ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n        URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n        DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;\n        FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;\n        FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n        FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n        USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;\n        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;\n        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;\n        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;\n        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;\n        RETURN_DOM = cfg.RETURN_DOM || false;\n        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;\n        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;\n        FORCE_BODY = cfg.FORCE_BODY || false;\n        SANITIZE_DOM = cfg.SANITIZE_DOM !== false;\n        KEEP_CONTENT = cfg.KEEP_CONTENT !== false;\n        IN_PLACE = cfg.IN_PLACE || false;\n        IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {\n          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n        }\n        PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;\n        transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {\n          return x;\n        } : stringToLowerCase;\n        if (SAFE_FOR_TEMPLATES) {\n          ALLOW_DATA_ATTR = false;\n        }\n        if (RETURN_DOM_FRAGMENT) {\n          RETURN_DOM = true;\n        }\n        if (USE_PROFILES) {\n          ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));\n          ALLOWED_ATTR = [];\n          if (USE_PROFILES.html === true) {\n            addToSet(ALLOWED_TAGS, html);\n            addToSet(ALLOWED_ATTR, html$1);\n          }\n          if (USE_PROFILES.svg === true) {\n            addToSet(ALLOWED_TAGS, svg);\n            addToSet(ALLOWED_ATTR, svg$1);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n          if (USE_PROFILES.svgFilters === true) {\n            addToSet(ALLOWED_TAGS, svgFilters);\n            addToSet(ALLOWED_ATTR, svg$1);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n          if (USE_PROFILES.mathMl === true) {\n            addToSet(ALLOWED_TAGS, mathMl);\n            addToSet(ALLOWED_ATTR, mathMl$1);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n        }\n        if (cfg.ADD_TAGS) {\n          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n            ALLOWED_TAGS = clone(ALLOWED_TAGS);\n          }\n          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n        }\n        if (cfg.ADD_ATTR) {\n          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n            ALLOWED_ATTR = clone(ALLOWED_ATTR);\n          }\n          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n        }\n        if (cfg.ADD_URI_SAFE_ATTR) {\n          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n        }\n        if (cfg.FORBID_CONTENTS) {\n          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n            FORBID_CONTENTS = clone(FORBID_CONTENTS);\n          }\n          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);\n        }\n        if (KEEP_CONTENT) {\n          ALLOWED_TAGS['#text'] = true;\n        }\n        if (WHOLE_DOCUMENT) {\n          addToSet(ALLOWED_TAGS, [\n            'html',\n            'head',\n            'body'\n          ]);\n        }\n        if (ALLOWED_TAGS.table) {\n          addToSet(ALLOWED_TAGS, ['tbody']);\n          delete FORBID_TAGS.tbody;\n        }\n        if (freeze) {\n          freeze(cfg);\n        }\n        CONFIG = cfg;\n      };\n      var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\n        'mi',\n        'mo',\n        'mn',\n        'ms',\n        'mtext'\n      ]);\n      var HTML_INTEGRATION_POINTS = addToSet({}, [\n        'foreignobject',\n        'desc',\n        'title',\n        'annotation-xml'\n      ]);\n      var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [\n        'title',\n        'style',\n        'font',\n        'a',\n        'script'\n      ]);\n      var ALL_SVG_TAGS = addToSet({}, svg);\n      addToSet(ALL_SVG_TAGS, svgFilters);\n      addToSet(ALL_SVG_TAGS, svgDisallowed);\n      var ALL_MATHML_TAGS = addToSet({}, mathMl);\n      addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n      var _checkValidNamespace = function _checkValidNamespace(element) {\n        var parent = getParentNode(element);\n        if (!parent || !parent.tagName) {\n          parent = {\n            namespaceURI: HTML_NAMESPACE,\n            tagName: 'template'\n          };\n        }\n        var tagName = stringToLowerCase(element.tagName);\n        var parentTagName = stringToLowerCase(parent.tagName);\n        if (element.namespaceURI === SVG_NAMESPACE) {\n          if (parent.namespaceURI === HTML_NAMESPACE) {\n            return tagName === 'svg';\n          }\n          if (parent.namespaceURI === MATHML_NAMESPACE) {\n            return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n          }\n          return Boolean(ALL_SVG_TAGS[tagName]);\n        }\n        if (element.namespaceURI === MATHML_NAMESPACE) {\n          if (parent.namespaceURI === HTML_NAMESPACE) {\n            return tagName === 'math';\n          }\n          if (parent.namespaceURI === SVG_NAMESPACE) {\n            return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n          }\n          return Boolean(ALL_MATHML_TAGS[tagName]);\n        }\n        if (element.namespaceURI === HTML_NAMESPACE) {\n          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n            return false;\n          }\n          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n            return false;\n          }\n          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n        }\n        return false;\n      };\n      var _forceRemove = function _forceRemove(node) {\n        arrayPush(DOMPurify.removed, { element: node });\n        try {\n          node.parentNode.removeChild(node);\n        } catch (_) {\n          try {\n            node.outerHTML = emptyHTML;\n          } catch (_) {\n            node.remove();\n          }\n        }\n      };\n      var _removeAttribute = function _removeAttribute(name, node) {\n        try {\n          arrayPush(DOMPurify.removed, {\n            attribute: node.getAttributeNode(name),\n            from: node\n          });\n        } catch (_) {\n          arrayPush(DOMPurify.removed, {\n            attribute: null,\n            from: node\n          });\n        }\n        node.removeAttribute(name);\n        if (name === 'is' && !ALLOWED_ATTR[name]) {\n          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n            try {\n              _forceRemove(node);\n            } catch (_) {\n            }\n          } else {\n            try {\n              node.setAttribute(name, '');\n            } catch (_) {\n            }\n          }\n        }\n      };\n      var _initDocument = function _initDocument(dirty) {\n        var doc = void 0;\n        var leadingWhitespace = void 0;\n        if (FORCE_BODY) {\n          dirty = '<remove></remove>' + dirty;\n        } else {\n          var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n          leadingWhitespace = matches && matches[0];\n        }\n        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {\n          dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n        }\n        var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        if (NAMESPACE === HTML_NAMESPACE) {\n          try {\n            doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n          } catch (_) {\n          }\n        }\n        if (!doc || !doc.documentElement) {\n          doc = implementation.createDocument(NAMESPACE, 'template', null);\n          try {\n            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;\n          } catch (_) {\n          }\n        }\n        var body = doc.body || doc.documentElement;\n        if (dirty && leadingWhitespace) {\n          body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n        }\n        if (NAMESPACE === HTML_NAMESPACE) {\n          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n        }\n        return WHOLE_DOCUMENT ? doc.documentElement : body;\n      };\n      var _createIterator = function _createIterator(root) {\n        return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n      };\n      var _isClobbered = function _isClobbered(elm) {\n        return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function');\n      };\n      var _isNode = function _isNode(object) {\n        return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n      };\n      var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n        if (!hooks[entryPoint]) {\n          return;\n        }\n        arrayForEach(hooks[entryPoint], function (hook) {\n          hook.call(DOMPurify, currentNode, data, CONFIG);\n        });\n      };\n      var _sanitizeElements = function _sanitizeElements(currentNode) {\n        var content = void 0;\n        _executeHook('beforeSanitizeElements', currentNode, null);\n        if (_isClobbered(currentNode)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (regExpTest(/[\\u0080-\\uFFFF]/, currentNode.nodeName)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        var tagName = transformCaseFunc(currentNode.nodeName);\n        _executeHook('uponSanitizeElement', currentNode, {\n          tagName: tagName,\n          allowedTags: ALLOWED_TAGS\n        });\n        if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n          if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {\n            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))\n              return false;\n            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))\n              return false;\n          }\n          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n            var parentNode = getParentNode(currentNode) || currentNode.parentNode;\n            var childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n            if (childNodes && parentNode) {\n              var childCount = childNodes.length;\n              for (var i = childCount - 1; i >= 0; --i) {\n                parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n              }\n            }\n          }\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n          content = currentNode.textContent;\n          content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');\n          content = stringReplace(content, ERB_EXPR$$1, ' ');\n          if (currentNode.textContent !== content) {\n            arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n            currentNode.textContent = content;\n          }\n        }\n        _executeHook('afterSanitizeElements', currentNode, null);\n        return false;\n      };\n      var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n          return false;\n        }\n        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName));\n        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName));\n        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n          if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)));\n          else {\n            return false;\n          }\n        } else if (URI_SAFE_ATTRIBUTES[lcName]);\n        else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, '')));\n        else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]);\n        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, '')));\n        else if (!value);\n        else {\n          return false;\n        }\n        return true;\n      };\n      var _basicCustomElementTest = function _basicCustomElementTest(tagName) {\n        return tagName.indexOf('-') > 0;\n      };\n      var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n        var attr = void 0;\n        var value = void 0;\n        var lcName = void 0;\n        var l = void 0;\n        _executeHook('beforeSanitizeAttributes', currentNode, null);\n        var attributes = currentNode.attributes;\n        if (!attributes) {\n          return;\n        }\n        var hookEvent = {\n          attrName: '',\n          attrValue: '',\n          keepAttr: true,\n          allowedAttributes: ALLOWED_ATTR\n        };\n        l = attributes.length;\n        while (l--) {\n          attr = attributes[l];\n          var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;\n          value = stringTrim(attr.value);\n          lcName = transformCaseFunc(name);\n          var initValue = value;\n          hookEvent.attrName = lcName;\n          hookEvent.attrValue = value;\n          hookEvent.keepAttr = true;\n          hookEvent.forceKeepAttr = undefined;\n          _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n          value = hookEvent.attrValue;\n          if (hookEvent.forceKeepAttr) {\n            continue;\n          }\n          if (!hookEvent.keepAttr) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n          if (regExpTest(/\\/>/i, value)) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n          if (SAFE_FOR_TEMPLATES) {\n            value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');\n            value = stringReplace(value, ERB_EXPR$$1, ' ');\n          }\n          var lcTag = transformCaseFunc(currentNode.nodeName);\n          if (!_isValidAttribute(lcTag, lcName, value)) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n          if (value !== initValue) {\n            try {\n              if (namespaceURI) {\n                currentNode.setAttributeNS(namespaceURI, name, value);\n              } else {\n                currentNode.setAttribute(name, value);\n              }\n            } catch (_) {\n              _removeAttribute(name, currentNode);\n            }\n          }\n        }\n        _executeHook('afterSanitizeAttributes', currentNode, null);\n      };\n      var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n        var shadowNode = void 0;\n        var shadowIterator = _createIterator(fragment);\n        _executeHook('beforeSanitizeShadowDOM', fragment, null);\n        while (shadowNode = shadowIterator.nextNode()) {\n          _executeHook('uponSanitizeShadowNode', shadowNode, null);\n          if (_sanitizeElements(shadowNode)) {\n            continue;\n          }\n          if (shadowNode.content instanceof DocumentFragment) {\n            _sanitizeShadowDOM(shadowNode.content);\n          }\n          _sanitizeAttributes(shadowNode);\n        }\n        _executeHook('afterSanitizeShadowDOM', fragment, null);\n      };\n      DOMPurify.sanitize = function (dirty, cfg) {\n        var body = void 0;\n        var importedNode = void 0;\n        var currentNode = void 0;\n        var oldNode = void 0;\n        var returnNode = void 0;\n        IS_EMPTY_INPUT = !dirty;\n        if (IS_EMPTY_INPUT) {\n          dirty = '<!-->';\n        }\n        if (typeof dirty !== 'string' && !_isNode(dirty)) {\n          if (typeof dirty.toString !== 'function') {\n            throw typeErrorCreate('toString is not a function');\n          } else {\n            dirty = dirty.toString();\n            if (typeof dirty !== 'string') {\n              throw typeErrorCreate('dirty is not a string, aborting');\n            }\n          }\n        }\n        if (!DOMPurify.isSupported) {\n          if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\n            if (typeof dirty === 'string') {\n              return window.toStaticHTML(dirty);\n            }\n            if (_isNode(dirty)) {\n              return window.toStaticHTML(dirty.outerHTML);\n            }\n          }\n          return dirty;\n        }\n        if (!SET_CONFIG) {\n          _parseConfig(cfg);\n        }\n        DOMPurify.removed = [];\n        if (typeof dirty === 'string') {\n          IN_PLACE = false;\n        }\n        if (IN_PLACE) {\n          if (dirty.nodeName) {\n            var tagName = transformCaseFunc(dirty.nodeName);\n            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n              throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\n            }\n          }\n        } else if (dirty instanceof Node) {\n          body = _initDocument('<!---->');\n          importedNode = body.ownerDocument.importNode(dirty, true);\n          if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n            body = importedNode;\n          } else if (importedNode.nodeName === 'HTML') {\n            body = importedNode;\n          } else {\n            body.appendChild(importedNode);\n          }\n        } else {\n          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) {\n            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n          }\n          body = _initDocument(dirty);\n          if (!body) {\n            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n          }\n        }\n        if (body && FORCE_BODY) {\n          _forceRemove(body.firstChild);\n        }\n        var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n        while (currentNode = nodeIterator.nextNode()) {\n          if (currentNode.nodeType === 3 && currentNode === oldNode) {\n            continue;\n          }\n          if (_sanitizeElements(currentNode)) {\n            continue;\n          }\n          if (currentNode.content instanceof DocumentFragment) {\n            _sanitizeShadowDOM(currentNode.content);\n          }\n          _sanitizeAttributes(currentNode);\n          oldNode = currentNode;\n        }\n        oldNode = null;\n        if (IN_PLACE) {\n          return dirty;\n        }\n        if (RETURN_DOM) {\n          if (RETURN_DOM_FRAGMENT) {\n            returnNode = createDocumentFragment.call(body.ownerDocument);\n            while (body.firstChild) {\n              returnNode.appendChild(body.firstChild);\n            }\n          } else {\n            returnNode = body;\n          }\n          if (ALLOWED_ATTR.shadowroot) {\n            returnNode = importNode.call(originalDocument, returnNode, true);\n          }\n          return returnNode;\n        }\n        var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n        if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n          serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n        }\n        if (SAFE_FOR_TEMPLATES) {\n          serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');\n          serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');\n        }\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n      };\n      DOMPurify.setConfig = function (cfg) {\n        _parseConfig(cfg);\n        SET_CONFIG = true;\n      };\n      DOMPurify.clearConfig = function () {\n        CONFIG = null;\n        SET_CONFIG = false;\n      };\n      DOMPurify.isValidAttribute = function (tag, attr, value) {\n        if (!CONFIG) {\n          _parseConfig({});\n        }\n        var lcTag = transformCaseFunc(tag);\n        var lcName = transformCaseFunc(attr);\n        return _isValidAttribute(lcTag, lcName, value);\n      };\n      DOMPurify.addHook = function (entryPoint, hookFunction) {\n        if (typeof hookFunction !== 'function') {\n          return;\n        }\n        hooks[entryPoint] = hooks[entryPoint] || [];\n        arrayPush(hooks[entryPoint], hookFunction);\n      };\n      DOMPurify.removeHook = function (entryPoint) {\n        if (hooks[entryPoint]) {\n          arrayPop(hooks[entryPoint]);\n        }\n      };\n      DOMPurify.removeHooks = function (entryPoint) {\n        if (hooks[entryPoint]) {\n          hooks[entryPoint] = [];\n        }\n      };\n      DOMPurify.removeAllHooks = function () {\n        hooks = {};\n      };\n      return DOMPurify;\n    }\n    var purify = createDOMPurify();\n\n    const removeAttrs = (node, names) => {\n      each$g(names, name => {\n        node.attr(name, null);\n      });\n    };\n    const addFontToSpansFilter = (domParser, styles, fontSizes) => {\n      domParser.addNodeFilter('font', nodes => {\n        each$g(nodes, node => {\n          const props = styles.parse(node.attr('style'));\n          const color = node.attr('color');\n          const face = node.attr('face');\n          const size = node.attr('size');\n          if (color) {\n            props.color = color;\n          }\n          if (face) {\n            props['font-family'] = face;\n          }\n          if (size) {\n            props['font-size'] = fontSizes[parseInt(node.attr('size'), 10) - 1];\n          }\n          node.name = 'span';\n          node.attr('style', styles.serialize(props));\n          removeAttrs(node, [\n            'color',\n            'face',\n            'size'\n          ]);\n        });\n      });\n    };\n    const addStrikeFilter = (domParser, schema, styles) => {\n      domParser.addNodeFilter('strike', nodes => {\n        const convertToSTag = schema.type !== 'html4';\n        each$g(nodes, node => {\n          if (convertToSTag) {\n            node.name = 's';\n          } else {\n            const props = styles.parse(node.attr('style'));\n            props['text-decoration'] = 'line-through';\n            node.name = 'span';\n            node.attr('style', styles.serialize(props));\n          }\n        });\n      });\n    };\n    const addFilters = (domParser, settings, schema) => {\n      const styles = Styles();\n      if (settings.convert_fonts_to_spans) {\n        addFontToSpansFilter(domParser, styles, Tools.explode(settings.font_size_legacy_values));\n      }\n      addStrikeFilter(domParser, schema, styles);\n    };\n    const register$5 = (domParser, settings, schema) => {\n      if (settings.inline_styles) {\n        addFilters(domParser, settings, schema);\n      }\n    };\n\n    const blobUriToBlob = url => {\n      return new Promise((resolve, reject) => {\n        const rejectWithError = () => {\n          reject('Cannot convert ' + url + ' to Blob. Resource might not exist or is inaccessible.');\n        };\n        try {\n          const xhr = new XMLHttpRequest();\n          xhr.open('GET', url, true);\n          xhr.responseType = 'blob';\n          xhr.onload = () => {\n            if (xhr.status === 200) {\n              resolve(xhr.response);\n            } else {\n              rejectWithError();\n            }\n          };\n          xhr.onerror = rejectWithError;\n          xhr.send();\n        } catch (ex) {\n          rejectWithError();\n        }\n      });\n    };\n    const parseDataUri$1 = uri => {\n      let type;\n      const uriParts = decodeURIComponent(uri).split(',');\n      const matches = /data:([^;]+)/.exec(uriParts[0]);\n      if (matches) {\n        type = matches[1];\n      }\n      return {\n        type,\n        data: uriParts[1]\n      };\n    };\n    const buildBlob = (type, data) => {\n      let str;\n      try {\n        str = atob(data);\n      } catch (e) {\n        return Optional.none();\n      }\n      const arr = new Uint8Array(str.length);\n      for (let i = 0; i < arr.length; i++) {\n        arr[i] = str.charCodeAt(i);\n      }\n      return Optional.some(new Blob([arr], { type }));\n    };\n    const dataUriToBlob = uri => {\n      return new Promise(resolve => {\n        const {type, data} = parseDataUri$1(uri);\n        buildBlob(type, data).fold(() => resolve(new Blob([])), resolve);\n      });\n    };\n    const uriToBlob = url => {\n      if (url.indexOf('blob:') === 0) {\n        return blobUriToBlob(url);\n      }\n      if (url.indexOf('data:') === 0) {\n        return dataUriToBlob(url);\n      }\n      return null;\n    };\n    const blobToDataUri = blob => {\n      return new Promise(resolve => {\n        const reader = new FileReader();\n        reader.onloadend = () => {\n          resolve(reader.result);\n        };\n        reader.readAsDataURL(blob);\n      });\n    };\n\n    let count$1 = 0;\n    const uniqueId$1 = prefix => {\n      return (prefix || 'blobid') + count$1++;\n    };\n    const imageToBlobInfo = (blobCache, img, resolve, reject) => {\n      let base64, blobInfo;\n      if (img.src.indexOf('blob:') === 0) {\n        blobInfo = blobCache.getByUri(img.src);\n        if (blobInfo) {\n          resolve({\n            image: img,\n            blobInfo\n          });\n        } else {\n          uriToBlob(img.src).then(blob => {\n            blobToDataUri(blob).then(dataUri => {\n              base64 = parseDataUri$1(dataUri).data;\n              blobInfo = blobCache.create(uniqueId$1(), blob, base64);\n              blobCache.add(blobInfo);\n              resolve({\n                image: img,\n                blobInfo\n              });\n            });\n          }, err => {\n            reject(err);\n          });\n        }\n        return;\n      }\n      const {data, type} = parseDataUri$1(img.src);\n      base64 = data;\n      blobInfo = blobCache.getByData(base64, type);\n      if (blobInfo) {\n        resolve({\n          image: img,\n          blobInfo\n        });\n      } else {\n        uriToBlob(img.src).then(blob => {\n          blobInfo = blobCache.create(uniqueId$1(), blob, base64);\n          blobCache.add(blobInfo);\n          resolve({\n            image: img,\n            blobInfo\n          });\n        }, err => {\n          reject(err);\n        });\n      }\n    };\n    const getAllImages = elm => {\n      return elm ? from(elm.getElementsByTagName('img')) : [];\n    };\n    const ImageScanner = (uploadStatus, blobCache) => {\n      const cachedPromises = {};\n      const findAll = (elm, predicate) => {\n        if (!predicate) {\n          predicate = always;\n        }\n        const images = filter$6(getAllImages(elm), img => {\n          const src = img.src;\n          if (img.hasAttribute('data-mce-bogus')) {\n            return false;\n          }\n          if (img.hasAttribute('data-mce-placeholder')) {\n            return false;\n          }\n          if (!src || src === Env.transparentSrc) {\n            return false;\n          }\n          if (src.indexOf('blob:') === 0) {\n            return !uploadStatus.isUploaded(src) && predicate(img);\n          }\n          if (src.indexOf('data:') === 0) {\n            return predicate(img);\n          }\n          return false;\n        });\n        const promises = map$3(images, img => {\n          if (cachedPromises[img.src] !== undefined) {\n            return new Promise(resolve => {\n              cachedPromises[img.src].then(imageInfo => {\n                if (typeof imageInfo === 'string') {\n                  return imageInfo;\n                }\n                resolve({\n                  image: img,\n                  blobInfo: imageInfo.blobInfo\n                });\n              });\n            });\n          }\n          const newPromise = new Promise((resolve, reject) => {\n            imageToBlobInfo(blobCache, img, resolve, reject);\n          }).then(result => {\n            delete cachedPromises[result.image.src];\n            return result;\n          }).catch(error => {\n            delete cachedPromises[img.src];\n            return error;\n          });\n          cachedPromises[img.src] = newPromise;\n          return newPromise;\n        });\n        return Promise.all(promises);\n      };\n      return { findAll };\n    };\n\n    const parseDataUri = uri => {\n      const matches = /data:([^;]+);base64,([a-z0-9\\+\\/=\\s]+)/i.exec(uri);\n      if (matches) {\n        return Optional.some({\n          type: matches[1],\n          data: decodeURIComponent(matches[2])\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n\n    const isBogusImage = img => isNonNullable(img.attr('data-mce-bogus'));\n    const isInternalImageSource = img => img.attr('src') === Env.transparentSrc || isNonNullable(img.attr('data-mce-placeholder'));\n    const registerBase64ImageFilter = (parser, settings) => {\n      const {blob_cache: blobCache} = settings;\n      const processImage = img => {\n        const inputSrc = img.attr('src');\n        if (isInternalImageSource(img) || isBogusImage(img)) {\n          return;\n        }\n        parseDataUri(inputSrc).bind(({type, data}) => Optional.from(blobCache.getByData(data, type)).orThunk(() => buildBlob(type, data).map(blob => {\n          const blobInfo = blobCache.create(uniqueId$1(), blob, data);\n          blobCache.add(blobInfo);\n          return blobInfo;\n        }))).each(blobInfo => {\n          img.attr('src', blobInfo.blobUri());\n        });\n      };\n      if (blobCache) {\n        parser.addAttributeFilter('src', nodes => each$g(nodes, processImage));\n      }\n    };\n    const register$4 = (parser, settings) => {\n      const schema = parser.schema;\n      if (settings.remove_trailing_brs) {\n        parser.addNodeFilter('br', (nodes, _, args) => {\n          const blockElements = Tools.extend({}, schema.getBlockElements());\n          const nonEmptyElements = schema.getNonEmptyElements();\n          const whitespaceElements = schema.getWhitespaceElements();\n          blockElements.body = 1;\n          for (let i = 0, l = nodes.length; i < l; i++) {\n            let node = nodes[i];\n            let parent = node.parent;\n            if (blockElements[node.parent.name] && node === parent.lastChild) {\n              let prev = node.prev;\n              while (prev) {\n                const prevName = prev.name;\n                if (prevName !== 'span' || prev.attr('data-mce-type') !== 'bookmark') {\n                  if (prevName === 'br') {\n                    node = null;\n                  }\n                  break;\n                }\n                prev = prev.prev;\n              }\n              if (node) {\n                node.remove();\n                if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent)) {\n                  const elementRule = schema.getElementRule(parent.name);\n                  if (elementRule) {\n                    if (elementRule.removeEmpty) {\n                      parent.remove();\n                    } else if (elementRule.paddEmpty) {\n                      paddEmptyNode(settings, args, blockElements, parent);\n                    }\n                  }\n                }\n              }\n            } else {\n              let lastParent = node;\n              while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {\n                lastParent = parent;\n                if (blockElements[parent.name]) {\n                  break;\n                }\n                parent = parent.parent;\n              }\n              if (lastParent === parent) {\n                const textNode = new AstNode('#text', 3);\n                textNode.value = nbsp;\n                node.replace(textNode);\n              }\n            }\n          }\n        });\n      }\n      parser.addAttributeFilter('href', nodes => {\n        let i = nodes.length;\n        const appendRel = rel => {\n          const parts = rel.split(' ').filter(p => p.length > 0);\n          return parts.concat(['noopener']).sort().join(' ');\n        };\n        const addNoOpener = rel => {\n          const newRel = rel ? Tools.trim(rel) : '';\n          if (!/\\b(noopener)\\b/g.test(newRel)) {\n            return appendRel(newRel);\n          } else {\n            return newRel;\n          }\n        };\n        if (!settings.allow_unsafe_link_target) {\n          while (i--) {\n            const node = nodes[i];\n            if (node.name === 'a' && node.attr('target') === '_blank') {\n              node.attr('rel', addNoOpener(node.attr('rel')));\n            }\n          }\n        }\n      });\n      if (!settings.allow_html_in_named_anchor) {\n        parser.addAttributeFilter('id,name', nodes => {\n          let i = nodes.length, sibling, prevSibling, parent, node;\n          while (i--) {\n            node = nodes[i];\n            if (node.name === 'a' && node.firstChild && !node.attr('href')) {\n              parent = node.parent;\n              sibling = node.lastChild;\n              do {\n                prevSibling = sibling.prev;\n                parent.insert(sibling, node);\n                sibling = prevSibling;\n              } while (sibling);\n            }\n          }\n        });\n      }\n      if (settings.fix_list_elements) {\n        parser.addNodeFilter('ul,ol', nodes => {\n          let i = nodes.length, node, parentNode;\n          while (i--) {\n            node = nodes[i];\n            parentNode = node.parent;\n            if (parentNode.name === 'ul' || parentNode.name === 'ol') {\n              if (node.prev && node.prev.name === 'li') {\n                node.prev.append(node);\n              } else {\n                const li = new AstNode('li', 1);\n                li.attr('style', 'list-style-type: none');\n                node.wrap(li);\n              }\n            }\n          }\n        });\n      }\n      if (settings.validate && schema.getValidClasses()) {\n        parser.addAttributeFilter('class', nodes => {\n          const validClasses = schema.getValidClasses();\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            const classList = node.attr('class').split(' ');\n            let classValue = '';\n            for (let ci = 0; ci < classList.length; ci++) {\n              const className = classList[ci];\n              let valid = false;\n              let validClassesMap = validClasses['*'];\n              if (validClassesMap && validClassesMap[className]) {\n                valid = true;\n              }\n              validClassesMap = validClasses[node.name];\n              if (!valid && validClassesMap && validClassesMap[className]) {\n                valid = true;\n              }\n              if (valid) {\n                if (classValue) {\n                  classValue += ' ';\n                }\n                classValue += className;\n              }\n            }\n            if (!classValue.length) {\n              classValue = null;\n            }\n            node.attr('class', classValue);\n          }\n        });\n      }\n      registerBase64ImageFilter(parser, settings);\n    };\n\n    const each$5 = Tools.each, trim = Tools.trim;\n    const queryParts = 'source protocol authority userInfo user password host port relative path directory file query anchor'.split(' ');\n    const DEFAULT_PORTS = {\n      ftp: 21,\n      http: 80,\n      https: 443,\n      mailto: 25\n    };\n    const safeSvgDataUrlElements = [\n      'img',\n      'video'\n    ];\n    const blockSvgDataUris = (allowSvgDataUrls, tagName) => {\n      if (isNonNullable(allowSvgDataUrls)) {\n        return !allowSvgDataUrls;\n      } else {\n        return isNonNullable(tagName) ? !contains$2(safeSvgDataUrlElements, tagName) : true;\n      }\n    };\n    const decodeUri = encodedUri => {\n      try {\n        return decodeURIComponent(encodedUri);\n      } catch (ex) {\n        return unescape(encodedUri);\n      }\n    };\n    const isInvalidUri = (settings, uri, tagName) => {\n      const decodedUri = decodeUri(uri);\n      if (settings.allow_script_urls) {\n        return false;\n      } else if (/((java|vb)script|mhtml):/i.test(decodedUri)) {\n        return true;\n      } else if (settings.allow_html_data_urls) {\n        return false;\n      } else if (/^data:image\\//i.test(decodedUri)) {\n        return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\\/svg\\+xml/i.test(decodedUri);\n      } else {\n        return /^data:/i.test(decodedUri);\n      }\n    };\n    class URI {\n      constructor(url, settings) {\n        url = trim(url);\n        this.settings = settings || {};\n        const baseUri = this.settings.base_uri;\n        const self = this;\n        if (/^([\\w\\-]+):([^\\/]{2})/i.test(url) || /^\\s*#/.test(url)) {\n          self.source = url;\n          return;\n        }\n        const isProtocolRelative = url.indexOf('//') === 0;\n        if (url.indexOf('/') === 0 && !isProtocolRelative) {\n          url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;\n        }\n        if (!/^[\\w\\-]*:?\\/\\//.test(url)) {\n          const baseUrl = this.settings.base_uri ? this.settings.base_uri.path : new URI(document.location.href).directory;\n          if (this.settings.base_uri && this.settings.base_uri.protocol == '') {\n            url = '//mce_host' + self.toAbsPath(baseUrl, url);\n          } else {\n            const match = /([^#?]*)([#?]?.*)/.exec(url);\n            url = (baseUri && baseUri.protocol || 'http') + '://mce_host' + self.toAbsPath(baseUrl, match[1]) + match[2];\n          }\n        }\n        url = url.replace(/@@/g, '(mce_at)');\n        const urlMatch = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@\\/]*):?([^:@\\/]*))?@)?(\\[[a-zA-Z0-9:.%]+\\]|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/.exec(url);\n        each$5(queryParts, (v, i) => {\n          let part = urlMatch[i];\n          if (part) {\n            part = part.replace(/\\(mce_at\\)/g, '@@');\n          }\n          self[v] = part;\n        });\n        if (baseUri) {\n          if (!self.protocol) {\n            self.protocol = baseUri.protocol;\n          }\n          if (!self.userInfo) {\n            self.userInfo = baseUri.userInfo;\n          }\n          if (!self.port && self.host === 'mce_host') {\n            self.port = baseUri.port;\n          }\n          if (!self.host || self.host === 'mce_host') {\n            self.host = baseUri.host;\n          }\n          self.source = '';\n        }\n        if (isProtocolRelative) {\n          self.protocol = '';\n        }\n      }\n      static parseDataUri(uri) {\n        let type;\n        const uriComponents = decodeURIComponent(uri).split(',');\n        const matches = /data:([^;]+)/.exec(uriComponents[0]);\n        if (matches) {\n          type = matches[1];\n        }\n        return {\n          type,\n          data: uriComponents[1]\n        };\n      }\n      static isDomSafe(uri, context, options = {}) {\n        if (options.allow_script_urls) {\n          return true;\n        } else {\n          const decodedUri = Entities.decode(uri).replace(/[\\s\\u0000-\\u001F]+/g, '');\n          return !isInvalidUri(options, decodedUri, context);\n        }\n      }\n      static getDocumentBaseUrl(loc) {\n        let baseUrl;\n        if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {\n          baseUrl = loc.href;\n        } else {\n          baseUrl = loc.protocol + '//' + loc.host + loc.pathname;\n        }\n        if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(baseUrl)) {\n          baseUrl = baseUrl.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\n          if (!/[\\/\\\\]$/.test(baseUrl)) {\n            baseUrl += '/';\n          }\n        }\n        return baseUrl;\n      }\n      setPath(path) {\n        const pathMatch = /^(.*?)\\/?(\\w+)?$/.exec(path);\n        this.path = pathMatch[0];\n        this.directory = pathMatch[1];\n        this.file = pathMatch[2];\n        this.source = '';\n        this.getURI();\n      }\n      toRelative(uri) {\n        let output;\n        if (uri === './') {\n          return uri;\n        }\n        const relativeUri = new URI(uri, { base_uri: this });\n        if (relativeUri.host !== 'mce_host' && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== '') {\n          return relativeUri.getURI();\n        }\n        const tu = this.getURI(), uu = relativeUri.getURI();\n        if (tu === uu || tu.charAt(tu.length - 1) === '/' && tu.substr(0, tu.length - 1) === uu) {\n          return tu;\n        }\n        output = this.toRelPath(this.path, relativeUri.path);\n        if (relativeUri.query) {\n          output += '?' + relativeUri.query;\n        }\n        if (relativeUri.anchor) {\n          output += '#' + relativeUri.anchor;\n        }\n        return output;\n      }\n      toAbsolute(uri, noHost) {\n        const absoluteUri = new URI(uri, { base_uri: this });\n        return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));\n      }\n      isSameOrigin(uri) {\n        if (this.host == uri.host && this.protocol == uri.protocol) {\n          if (this.port == uri.port) {\n            return true;\n          }\n          const defaultPort = DEFAULT_PORTS[this.protocol];\n          if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      toRelPath(base, path) {\n        let breakPoint = 0, out = '', i, l;\n        const normalizedBase = base.substring(0, base.lastIndexOf('/')).split('/');\n        const items = path.split('/');\n        if (normalizedBase.length >= items.length) {\n          for (i = 0, l = normalizedBase.length; i < l; i++) {\n            if (i >= items.length || normalizedBase[i] !== items[i]) {\n              breakPoint = i + 1;\n              break;\n            }\n          }\n        }\n        if (normalizedBase.length < items.length) {\n          for (i = 0, l = items.length; i < l; i++) {\n            if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {\n              breakPoint = i + 1;\n              break;\n            }\n          }\n        }\n        if (breakPoint === 1) {\n          return path;\n        }\n        for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {\n          out += '../';\n        }\n        for (i = breakPoint - 1, l = items.length; i < l; i++) {\n          if (i !== breakPoint - 1) {\n            out += '/' + items[i];\n          } else {\n            out += items[i];\n          }\n        }\n        return out;\n      }\n      toAbsPath(base, path) {\n        let i, nb = 0, o = [], outPath;\n        const tr = /\\/$/.test(path) ? '/' : '';\n        let normalizedBase = base.split('/');\n        const normalizedPath = path.split('/');\n        each$5(normalizedBase, k => {\n          if (k) {\n            o.push(k);\n          }\n        });\n        normalizedBase = o;\n        for (i = normalizedPath.length - 1, o = []; i >= 0; i--) {\n          if (normalizedPath[i].length === 0 || normalizedPath[i] === '.') {\n            continue;\n          }\n          if (normalizedPath[i] === '..') {\n            nb++;\n            continue;\n          }\n          if (nb > 0) {\n            nb--;\n            continue;\n          }\n          o.push(normalizedPath[i]);\n        }\n        i = normalizedBase.length - nb;\n        if (i <= 0) {\n          outPath = reverse(o).join('/');\n        } else {\n          outPath = normalizedBase.slice(0, i).join('/') + '/' + reverse(o).join('/');\n        }\n        if (outPath.indexOf('/') !== 0) {\n          outPath = '/' + outPath;\n        }\n        if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {\n          outPath += tr;\n        }\n        return outPath;\n      }\n      getURI(noProtoHost = false) {\n        let s;\n        if (!this.source || noProtoHost) {\n          s = '';\n          if (!noProtoHost) {\n            if (this.protocol) {\n              s += this.protocol + '://';\n            } else {\n              s += '//';\n            }\n            if (this.userInfo) {\n              s += this.userInfo + '@';\n            }\n            if (this.host) {\n              s += this.host;\n            }\n            if (this.port) {\n              s += ':' + this.port;\n            }\n          }\n          if (this.path) {\n            s += this.path;\n          }\n          if (this.query) {\n            s += '?' + this.query;\n          }\n          if (this.anchor) {\n            s += '#' + this.anchor;\n          }\n          this.source = s;\n        }\n        return this.source;\n      }\n    }\n\n    const makeMap = Tools.makeMap, each$4 = Tools.each, explode$1 = Tools.explode, extend$1 = Tools.extend;\n    const basePurifyConfig = {\n      IN_PLACE: true,\n      ALLOW_UNKNOWN_PROTOCOLS: true,\n      ALLOWED_TAGS: [\n        '#comment',\n        '#cdata-section',\n        'body'\n      ],\n      ALLOWED_ATTR: []\n    };\n    const filteredUrlAttrs = Tools.makeMap('src,href,data,background,action,formaction,poster,xlink:href');\n    const internalElementAttr = 'data-mce-type';\n    const getPurifyConfig = (settings, mimeType) => {\n      const config = { ...basePurifyConfig };\n      config.PARSER_MEDIA_TYPE = mimeType;\n      if (settings.allow_script_urls) {\n        config.ALLOWED_URI_REGEXP = /.*/;\n      } else if (settings.allow_html_data_urls) {\n        config.ALLOWED_URI_REGEXP = /^(?!(\\w+script|mhtml):)/i;\n      }\n      return config;\n    };\n    const setupPurify = (settings, schema) => {\n      const purify$1 = purify();\n      const validate = settings.validate;\n      let uid = 0;\n      purify$1.addHook('uponSanitizeElement', (ele, evt) => {\n        var _a, _b;\n        if (ele.nodeType === COMMENT && !settings.allow_conditional_comments && /^\\[if/i.test(ele.nodeValue)) {\n          ele.nodeValue = ' ' + ele.nodeValue;\n        }\n        const tagName = evt.tagName;\n        if (ele.nodeType !== ELEMENT || tagName === 'body') {\n          return;\n        }\n        const element = SugarElement.fromDom(ele);\n        const isInternalElement = has$1(element, internalElementAttr);\n        const bogus = get$9(element, 'data-mce-bogus');\n        if (!isInternalElement && isString(bogus)) {\n          if (bogus === 'all') {\n            remove$5(element);\n          } else {\n            unwrap(element);\n          }\n          return;\n        }\n        const rule = schema.getElementRule(tagName.toLowerCase());\n        if (validate && !rule) {\n          unwrap(element);\n          return;\n        } else {\n          evt.allowedTags[tagName] = true;\n        }\n        if (validate && !isInternalElement) {\n          each$g((_a = rule.attributesForced) !== null && _a !== void 0 ? _a : [], attr => {\n            set$2(element, attr.name, attr.value === '{$uid}' ? `mce_${ uid++ }` : attr.value);\n          });\n          each$g((_b = rule.attributesDefault) !== null && _b !== void 0 ? _b : [], attr => {\n            if (!has$1(element, attr.name)) {\n              set$2(element, attr.name, attr.value === '{$uid}' ? `mce_${ uid++ }` : attr.value);\n            }\n          });\n          if (rule.attributesRequired && !exists(rule.attributesRequired, attr => has$1(element, attr))) {\n            unwrap(element);\n            return;\n          }\n          if (rule.removeEmptyAttrs && hasNone(element)) {\n            unwrap(element);\n            return;\n          }\n          if (rule.outputName && rule.outputName !== tagName.toLowerCase()) {\n            mutate(element, rule.outputName);\n          }\n        }\n      });\n      purify$1.addHook('uponSanitizeAttribute', (ele, evt) => {\n        const tagName = ele.tagName.toLowerCase();\n        const {attrName, attrValue} = evt;\n        evt.keepAttr = !validate || schema.isValid(tagName, attrName) || startsWith(attrName, 'data-') || startsWith(attrName, 'aria-');\n        if (attrName in filteredUrlAttrs && isInvalidUri(settings, attrValue, tagName)) {\n          evt.keepAttr = false;\n        }\n        if (evt.keepAttr) {\n          evt.allowedAttributes[attrName] = true;\n          if (attrName in schema.getBoolAttrs()) {\n            evt.attrValue = attrName;\n          }\n          if (settings.allow_svg_data_urls && startsWith(attrValue, 'data:image/svg+xml')) {\n            evt.forceKeepAttr = true;\n          }\n        } else if (ele.hasAttribute(internalElementAttr) && (attrName === 'id' || attrName === 'class' || attrName === 'style')) {\n          evt.forceKeepAttr = true;\n        }\n      });\n      return purify$1;\n    };\n    const transferChildren = (parent, nativeParent, specialElements) => {\n      const parentName = parent.name;\n      const isSpecial = parentName in specialElements && parentName !== 'title' && parentName !== 'textarea';\n      const childNodes = nativeParent.childNodes;\n      for (let ni = 0, nl = childNodes.length; ni < nl; ni++) {\n        const nativeChild = childNodes[ni];\n        const child = new AstNode(nativeChild.nodeName.toLowerCase(), nativeChild.nodeType);\n        if (isElement$6(nativeChild)) {\n          const attributes = nativeChild.attributes;\n          for (let ai = 0, al = attributes.length; ai < al; ai++) {\n            const attr = attributes[ai];\n            child.attr(attr.name, attr.value);\n          }\n        } else if (isText$8(nativeChild)) {\n          child.value = nativeChild.data;\n          if (isSpecial) {\n            child.raw = true;\n          }\n        } else if (isComment(nativeChild) || isCData(nativeChild) || isPi(nativeChild)) {\n          child.value = nativeChild.data;\n        }\n        transferChildren(child, nativeChild, specialElements);\n        parent.append(child);\n      }\n    };\n    const walkTree = (root, preprocessors, postprocessors) => {\n      const traverseOrder = [];\n      for (let node = root, lastNode = node; isNonNullable(node); lastNode = node, node = node.walk()) {\n        each$g(preprocessors, preprocess => preprocess(node));\n        if (isNullable(node.parent) && node !== root) {\n          node = lastNode;\n        } else {\n          traverseOrder.push(node);\n        }\n      }\n      for (let i = traverseOrder.length - 1; i >= 0; i--) {\n        const node = traverseOrder[i];\n        each$g(postprocessors, postprocess => postprocess(node));\n      }\n    };\n    const whitespaceCleaner = (root, schema, settings, args) => {\n      const validate = settings.validate;\n      const nonEmptyElements = schema.getNonEmptyElements();\n      const whitespaceElements = schema.getWhitespaceElements();\n      const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\n      const allWhiteSpaceRegExp = /[ \\t\\r\\n]+/g;\n      const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n      const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n      const hasWhitespaceParent = node => {\n        node = node.parent;\n        while (isNonNullable(node)) {\n          if (node.name in whitespaceElements) {\n            return true;\n          } else {\n            node = node.parent;\n          }\n        }\n        return false;\n      };\n      const isAtEdgeOfBlock = (node, start) => {\n        const neighbour = start ? node.prev : node.next;\n        if (isNonNullable(neighbour)) {\n          return false;\n        }\n        return node.parent.name in blockElements && (node.parent !== root || args.isRootContent);\n      };\n      const preprocess = node => {\n        if (node.type === 3) {\n          if (!hasWhitespaceParent(node)) {\n            let text = node.value;\n            text = text.replace(allWhiteSpaceRegExp, ' ');\n            if (isLineBreakNode(node.prev, blockElements) || isAtEdgeOfBlock(node, true)) {\n              text = text.replace(startWhiteSpaceRegExp, '');\n            }\n            if (text.length === 0) {\n              node.remove();\n            } else {\n              node.value = text;\n            }\n          }\n        }\n      };\n      const postprocess = node => {\n        var _a;\n        if (node.type === 1) {\n          const elementRule = schema.getElementRule(node.name);\n          if (validate && elementRule) {\n            const isNodeEmpty = isEmpty(schema, nonEmptyElements, whitespaceElements, node);\n            if (elementRule.removeEmpty && isNodeEmpty) {\n              if (blockElements[node.name]) {\n                node.remove();\n              } else {\n                node.unwrap();\n              }\n            } else if (elementRule.paddEmpty && (isNodeEmpty || isPaddedWithNbsp(node))) {\n              paddEmptyNode(settings, args, blockElements, node);\n            }\n          }\n        } else if (node.type === 3) {\n          if (!hasWhitespaceParent(node)) {\n            let text = node.value;\n            if (blockElements[(_a = node.next) === null || _a === void 0 ? void 0 : _a.name] || isAtEdgeOfBlock(node, false)) {\n              text = text.replace(endWhiteSpaceRegExp, '');\n            }\n            if (text.length === 0) {\n              node.remove();\n            } else {\n              node.value = text;\n            }\n          }\n        }\n      };\n      return [\n        preprocess,\n        postprocess\n      ];\n    };\n    const getRootBlockName = (settings, args) => {\n      var _a;\n      const name = (_a = args.forced_root_block) !== null && _a !== void 0 ? _a : settings.forced_root_block;\n      if (name === false) {\n        return '';\n      } else if (name === true) {\n        return 'p';\n      } else {\n        return name;\n      }\n    };\n    const DomParser = (settings = {}, schema = Schema()) => {\n      const nodeFilters = {};\n      const attributeFilters = [];\n      const defaultedSettings = {\n        validate: true,\n        root_name: 'body',\n        ...settings\n      };\n      const parser = new DOMParser();\n      const purify = setupPurify(defaultedSettings, schema);\n      const parseAndSanitizeWithContext = (html, rootName, format = 'html') => {\n        const mimeType = format === 'xhtml' ? 'application/xhtml+xml' : 'text/html';\n        const isSpecialRoot = has$2(schema.getSpecialElements(), rootName.toLowerCase());\n        const content = isSpecialRoot ? `<${ rootName }>${ html }</${ rootName }>` : html;\n        const wrappedHtml = format === 'xhtml' ? `<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>${ content }</body></html>` : `<body>${ content }</body>`;\n        const body = parser.parseFromString(wrappedHtml, mimeType).body;\n        purify.sanitize(body, getPurifyConfig(defaultedSettings, mimeType));\n        purify.removed = [];\n        return isSpecialRoot ? body.firstChild : body;\n      };\n      const addNodeFilter = (name, callback) => {\n        each$4(explode$1(name), name => {\n          let list = nodeFilters[name];\n          if (!list) {\n            nodeFilters[name] = list = [];\n          }\n          list.push(callback);\n        });\n      };\n      const getNodeFilters = () => {\n        const out = [];\n        for (const name in nodeFilters) {\n          if (has$2(nodeFilters, name)) {\n            out.push({\n              name,\n              callbacks: nodeFilters[name]\n            });\n          }\n        }\n        return out;\n      };\n      const addAttributeFilter = (name, callback) => {\n        each$4(explode$1(name), name => {\n          let i;\n          for (i = 0; i < attributeFilters.length; i++) {\n            if (attributeFilters[i].name === name) {\n              attributeFilters[i].callbacks.push(callback);\n              return;\n            }\n          }\n          attributeFilters.push({\n            name,\n            callbacks: [callback]\n          });\n        });\n      };\n      const getAttributeFilters = () => [].concat(attributeFilters);\n      const findInvalidChildren = (node, invalidChildren) => {\n        const parent = node.parent;\n        if (parent && schema.children[node.name] && !schema.isValidChild(parent.name, node.name)) {\n          invalidChildren.push(node);\n        }\n      };\n      const addRootBlocks = (rootNode, rootBlockName) => {\n        const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\n        const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n        const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n        let node = rootNode.firstChild, rootBlockNode = null;\n        const trim = rootBlock => {\n          if (rootBlock) {\n            node = rootBlock.firstChild;\n            if (node && node.type === 3) {\n              node.value = node.value.replace(startWhiteSpaceRegExp, '');\n            }\n            node = rootBlock.lastChild;\n            if (node && node.type === 3) {\n              node.value = node.value.replace(endWhiteSpaceRegExp, '');\n            }\n          }\n        };\n        if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {\n          return;\n        }\n        while (node) {\n          const next = node.next;\n          if (node.type === 3 || node.type === 1 && node.name !== 'p' && !blockElements[node.name] && !node.attr(internalElementAttr)) {\n            if (!rootBlockNode) {\n              rootBlockNode = new AstNode(rootBlockName, 1);\n              rootBlockNode.attr(defaultedSettings.forced_root_block_attrs);\n              rootNode.insert(rootBlockNode, node);\n              rootBlockNode.append(node);\n            } else {\n              rootBlockNode.append(node);\n            }\n          } else {\n            trim(rootBlockNode);\n            rootBlockNode = null;\n          }\n          node = next;\n        }\n        trim(rootBlockNode);\n      };\n      const parse = (html, args = {}) => {\n        var _a;\n        const validate = defaultedSettings.validate;\n        const rootName = (_a = args.context) !== null && _a !== void 0 ? _a : defaultedSettings.root_name;\n        const element = parseAndSanitizeWithContext(html, rootName, args.format);\n        const rootNode = new AstNode(rootName, 11);\n        transferChildren(rootNode, element, schema.getSpecialElements());\n        const [whitespacePre, whitespacePost] = whitespaceCleaner(rootNode, schema, defaultedSettings, args);\n        const invalidChildren = [];\n        const invalidFinder = validate ? node => findInvalidChildren(node, invalidChildren) : noop;\n        const nodeFilters = getNodeFilters();\n        const matches = {\n          nodes: {},\n          attributes: {}\n        };\n        const matchFinder = node => matchNode$1(nodeFilters, attributeFilters, node, matches);\n        walkTree(rootNode, [\n          whitespacePre,\n          matchFinder\n        ], [\n          whitespacePost,\n          invalidFinder\n        ]);\n        invalidChildren.reverse();\n        if (validate && invalidChildren.length > 0) {\n          if (args.context) {\n            const {\n              pass: topLevelChildren,\n              fail: otherChildren\n            } = partition$2(invalidChildren, child => child.parent === rootNode);\n            cleanInvalidNodes(otherChildren, schema, matchFinder);\n            args.invalid = topLevelChildren.length > 0;\n          } else {\n            cleanInvalidNodes(invalidChildren, schema, matchFinder);\n          }\n        }\n        const rootBlockName = getRootBlockName(defaultedSettings, args);\n        if (rootBlockName && (rootNode.name === 'body' || args.isRootContent)) {\n          addRootBlocks(rootNode, rootBlockName);\n        }\n        if (!args.invalid) {\n          runFilters(matches, args);\n        }\n        return rootNode;\n      };\n      const exports = {\n        schema,\n        addAttributeFilter,\n        getAttributeFilters,\n        addNodeFilter,\n        getNodeFilters,\n        parse\n      };\n      register$4(exports, defaultedSettings);\n      register$5(exports, defaultedSettings, schema);\n      return exports;\n    };\n\n    const serializeContent = content => isTreeNode(content) ? HtmlSerializer({ validate: false }).serialize(content) : content;\n    const withSerializedContent = (content, fireEvent) => {\n      const serializedContent = serializeContent(content);\n      const eventArgs = fireEvent(serializedContent);\n      if (eventArgs.isDefaultPrevented()) {\n        return eventArgs;\n      } else if (isTreeNode(content)) {\n        if (eventArgs.content !== serializedContent) {\n          const rootNode = DomParser({\n            validate: false,\n            forced_root_block: false\n          }).parse(eventArgs.content, { context: content.name });\n          return {\n            ...eventArgs,\n            content: rootNode\n          };\n        } else {\n          return {\n            ...eventArgs,\n            content\n          };\n        }\n      } else {\n        return eventArgs;\n      }\n    };\n    const preProcessGetContent = (editor, args) => {\n      if (args.no_events) {\n        return Result.value(args);\n      } else {\n        const eventArgs = fireBeforeGetContent(editor, args);\n        if (eventArgs.isDefaultPrevented()) {\n          return Result.error(fireGetContent(editor, {\n            content: '',\n            ...eventArgs\n          }).content);\n        } else {\n          return Result.value(eventArgs);\n        }\n      }\n    };\n    const postProcessGetContent = (editor, content, args) => {\n      if (args.no_events) {\n        return content;\n      } else {\n        const processedEventArgs = withSerializedContent(content, c => fireGetContent(editor, {\n          ...args,\n          content: c\n        }));\n        return processedEventArgs.content;\n      }\n    };\n    const preProcessSetContent = (editor, args) => {\n      if (args.no_events) {\n        return Result.value(args);\n      } else {\n        const processedEventArgs = withSerializedContent(args.content, content => fireBeforeSetContent(editor, {\n          ...args,\n          content\n        }));\n        if (processedEventArgs.isDefaultPrevented()) {\n          fireSetContent(editor, processedEventArgs);\n          return Result.error(undefined);\n        } else {\n          return Result.value(processedEventArgs);\n        }\n      }\n    };\n    const postProcessSetContent = (editor, content, args) => {\n      if (!args.no_events) {\n        fireSetContent(editor, {\n          ...args,\n          content\n        });\n      }\n    };\n\n    const tableModel = (element, width, rows) => ({\n      element,\n      width,\n      rows\n    });\n    const tableRow = (element, cells) => ({\n      element,\n      cells\n    });\n    const cellPosition = (x, y) => ({\n      x,\n      y\n    });\n    const getSpan = (td, key) => {\n      const value = parseInt(get$9(td, key), 10);\n      return isNaN(value) ? 1 : value;\n    };\n    const fillout = (table, x, y, tr, td) => {\n      const rowspan = getSpan(td, 'rowspan');\n      const colspan = getSpan(td, 'colspan');\n      const rows = table.rows;\n      for (let y2 = y; y2 < y + rowspan; y2++) {\n        if (!rows[y2]) {\n          rows[y2] = tableRow(deep$1(tr), []);\n        }\n        for (let x2 = x; x2 < x + colspan; x2++) {\n          const cells = rows[y2].cells;\n          cells[x2] = y2 === y && x2 === x ? td : shallow$1(td);\n        }\n      }\n    };\n    const cellExists = (table, x, y) => {\n      const rows = table.rows;\n      const cells = rows[y] ? rows[y].cells : [];\n      return !!cells[x];\n    };\n    const skipCellsX = (table, x, y) => {\n      while (cellExists(table, x, y)) {\n        x++;\n      }\n      return x;\n    };\n    const getWidth = rows => {\n      return foldl(rows, (acc, row) => {\n        return row.cells.length > acc ? row.cells.length : acc;\n      }, 0);\n    };\n    const findElementPos = (table, element) => {\n      const rows = table.rows;\n      for (let y = 0; y < rows.length; y++) {\n        const cells = rows[y].cells;\n        for (let x = 0; x < cells.length; x++) {\n          if (eq(cells[x], element)) {\n            return Optional.some(cellPosition(x, y));\n          }\n        }\n      }\n      return Optional.none();\n    };\n    const extractRows = (table, sx, sy, ex, ey) => {\n      const newRows = [];\n      const rows = table.rows;\n      for (let y = sy; y <= ey; y++) {\n        const cells = rows[y].cells;\n        const slice = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);\n        newRows.push(tableRow(rows[y].element, slice));\n      }\n      return newRows;\n    };\n    const subTable = (table, startPos, endPos) => {\n      const sx = startPos.x, sy = startPos.y;\n      const ex = endPos.x, ey = endPos.y;\n      const newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);\n      return tableModel(table.element, getWidth(newRows), newRows);\n    };\n    const createDomTable = (table, rows) => {\n      const tableElement = shallow$1(table.element);\n      const tableBody = SugarElement.fromTag('tbody');\n      append(tableBody, rows);\n      append$1(tableElement, tableBody);\n      return tableElement;\n    };\n    const modelRowsToDomRows = table => {\n      return map$3(table.rows, row => {\n        const cells = map$3(row.cells, cell => {\n          const td = deep$1(cell);\n          remove$a(td, 'colspan');\n          remove$a(td, 'rowspan');\n          return td;\n        });\n        const tr = shallow$1(row.element);\n        append(tr, cells);\n        return tr;\n      });\n    };\n    const fromDom = tableElm => {\n      const table = tableModel(shallow$1(tableElm), 0, []);\n      each$g(descendants(tableElm, 'tr'), (tr, y) => {\n        each$g(descendants(tr, 'td,th'), (td, x) => {\n          fillout(table, skipCellsX(table, x, y), y, tr, td);\n        });\n      });\n      return tableModel(table.element, getWidth(table.rows), table.rows);\n    };\n    const toDom = table => {\n      return createDomTable(table, modelRowsToDomRows(table));\n    };\n    const subsection = (table, startElement, endElement) => {\n      return findElementPos(table, startElement).bind(startPos => {\n        return findElementPos(table, endElement).map(endPos => {\n          return subTable(table, startPos, endPos);\n        });\n      });\n    };\n\n    const findParentListContainer = parents => find$2(parents, elm => name(elm) === 'ul' || name(elm) === 'ol');\n    const getFullySelectedListWrappers = (parents, rng) => find$2(parents, elm => name(elm) === 'li' && hasAllContentsSelected(elm, rng)).fold(constant([]), _li => findParentListContainer(parents).map(listCont => {\n      const listElm = SugarElement.fromTag(name(listCont));\n      const listStyles = filter$5(getAllRaw(listCont), (_style, name) => startsWith(name, 'list-style'));\n      setAll(listElm, listStyles);\n      return [\n        SugarElement.fromTag('li'),\n        listElm\n      ];\n    }).getOr([]));\n    const wrap = (innerElm, elms) => {\n      const wrapped = foldl(elms, (acc, elm) => {\n        append$1(elm, acc);\n        return elm;\n      }, innerElm);\n      return elms.length > 0 ? fromElements([wrapped]) : wrapped;\n    };\n    const directListWrappers = commonAnchorContainer => {\n      if (isListItem(commonAnchorContainer)) {\n        return parent(commonAnchorContainer).filter(isList).fold(constant([]), listElm => [\n          commonAnchorContainer,\n          listElm\n        ]);\n      } else {\n        return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];\n      }\n    };\n    const getWrapElements = (rootNode, rng) => {\n      const commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);\n      const parents = parentsAndSelf(commonAnchorContainer, rootNode);\n      const wrapElements = filter$6(parents, elm => isInline$1(elm) || isHeading(elm));\n      const listWrappers = getFullySelectedListWrappers(parents, rng);\n      const allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));\n      return map$3(allWrappers, shallow$1);\n    };\n    const emptyFragment = () => fromElements([]);\n    const getFragmentFromRange = (rootNode, rng) => wrap(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng));\n    const getParentTable = (rootElm, cell) => ancestor$2(cell, 'table', curry(eq, rootElm));\n    const getTableFragment = (rootNode, selectedTableCells) => getParentTable(rootNode, selectedTableCells[0]).bind(tableElm => {\n      const firstCell = selectedTableCells[0];\n      const lastCell = selectedTableCells[selectedTableCells.length - 1];\n      const fullTableModel = fromDom(tableElm);\n      return subsection(fullTableModel, firstCell, lastCell).map(sectionedTableModel => fromElements([toDom(sectionedTableModel)]));\n    }).getOrThunk(emptyFragment);\n    const getSelectionFragment = (rootNode, ranges) => ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0]);\n    const read$3 = (rootNode, ranges) => {\n      const selectedCells = getCellsFromElementOrRanges(ranges, rootNode);\n      return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges);\n    };\n\n    const isCollapsibleWhitespace = (text, index) => index >= 0 && index < text.length && isWhiteSpace(text.charAt(index));\n    const getInnerText = bin => {\n      return trim$1(bin.innerText);\n    };\n    const getContextNodeName = parentBlockOpt => parentBlockOpt.map(block => block.nodeName).getOr('div').toLowerCase();\n    const getTextContent = editor => Optional.from(editor.selection.getRng()).map(rng => {\n      const parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));\n      const body = editor.getBody();\n      const contextNodeName = getContextNodeName(parentBlockOpt);\n      const bin = editor.dom.add(body, contextNodeName, {\n        'data-mce-bogus': 'all',\n        'style': 'overflow: hidden; opacity: 0;'\n      }, rng.cloneContents());\n      const text = getInnerText(bin);\n      const nonRenderedText = trim$1(bin.textContent);\n      editor.dom.remove(bin);\n      if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {\n        const parentBlock = parentBlockOpt.getOr(body);\n        const parentBlockText = getInnerText(parentBlock);\n        const textIndex = parentBlockText.indexOf(text);\n        if (textIndex === -1) {\n          return text;\n        } else {\n          const hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);\n          const hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text.length);\n          return (hasProceedingSpace ? ' ' : '') + text + (hasTrailingSpace ? ' ' : '');\n        }\n      } else {\n        return text;\n      }\n    }).getOr('');\n    const getSerializedContent = (editor, args) => {\n      const rng = editor.selection.getRng(), tmpElm = editor.dom.create('body');\n      const sel = editor.selection.getSel();\n      const ranges = processRanges(editor, getRanges$1(sel));\n      const fragment = args.contextual ? read$3(SugarElement.fromDom(editor.getBody()), ranges).dom : rng.cloneContents();\n      if (fragment) {\n        tmpElm.appendChild(fragment);\n      }\n      return editor.selection.serializer.serialize(tmpElm, args);\n    };\n    const extractSelectedContent = (editor, args) => {\n      if (args.format === 'text') {\n        return getTextContent(editor);\n      } else {\n        const content = getSerializedContent(editor, args);\n        if (args.format === 'tree') {\n          return content;\n        } else {\n          return editor.selection.isCollapsed() ? '' : content;\n        }\n      }\n    };\n    const setupArgs$3 = (args, format) => ({\n      ...args,\n      format,\n      get: true,\n      selection: true,\n      getInner: true\n    });\n    const getSelectedContentInternal = (editor, format, args = {}) => {\n      const defaultedArgs = setupArgs$3(args, format);\n      return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\n        const content = extractSelectedContent(editor, updatedArgs);\n        return postProcessGetContent(editor, content, updatedArgs);\n      });\n    };\n\n    const KEEP = 0, INSERT = 1, DELETE = 2;\n    const diff = (left, right) => {\n      const size = left.length + right.length + 2;\n      const vDown = new Array(size);\n      const vUp = new Array(size);\n      const snake = (start, end, diag) => {\n        return {\n          start,\n          end,\n          diag\n        };\n      };\n      const buildScript = (start1, end1, start2, end2, script) => {\n        const middle = getMiddleSnake(start1, end1, start2, end2);\n        if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {\n          let i = start1;\n          let j = start2;\n          while (i < end1 || j < end2) {\n            if (i < end1 && j < end2 && left[i] === right[j]) {\n              script.push([\n                KEEP,\n                left[i]\n              ]);\n              ++i;\n              ++j;\n            } else {\n              if (end1 - start1 > end2 - start2) {\n                script.push([\n                  DELETE,\n                  left[i]\n                ]);\n                ++i;\n              } else {\n                script.push([\n                  INSERT,\n                  right[j]\n                ]);\n                ++j;\n              }\n            }\n          }\n        } else {\n          buildScript(start1, middle.start, start2, middle.start - middle.diag, script);\n          for (let i2 = middle.start; i2 < middle.end; ++i2) {\n            script.push([\n              KEEP,\n              left[i2]\n            ]);\n          }\n          buildScript(middle.end, end1, middle.end - middle.diag, end2, script);\n        }\n      };\n      const buildSnake = (start, diag, end1, end2) => {\n        let end = start;\n        while (end - diag < end2 && end < end1 && left[end] === right[end - diag]) {\n          ++end;\n        }\n        return snake(start, end, diag);\n      };\n      const getMiddleSnake = (start1, end1, start2, end2) => {\n        const m = end1 - start1;\n        const n = end2 - start2;\n        if (m === 0 || n === 0) {\n          return null;\n        }\n        const delta = m - n;\n        const sum = n + m;\n        const offset = (sum % 2 === 0 ? sum : sum + 1) / 2;\n        vDown[1 + offset] = start1;\n        vUp[1 + offset] = end1 + 1;\n        let d, k, i, x, y;\n        for (d = 0; d <= offset; ++d) {\n          for (k = -d; k <= d; k += 2) {\n            i = k + offset;\n            if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {\n              vDown[i] = vDown[i + 1];\n            } else {\n              vDown[i] = vDown[i - 1] + 1;\n            }\n            x = vDown[i];\n            y = x - start1 + start2 - k;\n            while (x < end1 && y < end2 && left[x] === right[y]) {\n              vDown[i] = ++x;\n              ++y;\n            }\n            if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {\n              if (vUp[i - delta] <= vDown[i]) {\n                return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);\n              }\n            }\n          }\n          for (k = delta - d; k <= delta + d; k += 2) {\n            i = k + offset - delta;\n            if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {\n              vUp[i] = vUp[i + 1] - 1;\n            } else {\n              vUp[i] = vUp[i - 1];\n            }\n            x = vUp[i] - 1;\n            y = x - start1 + start2 - k;\n            while (x >= start1 && y >= start2 && left[x] === right[y]) {\n              vUp[i] = x--;\n              y--;\n            }\n            if (delta % 2 === 0 && -d <= k && k <= d) {\n              if (vUp[i] <= vDown[i + delta]) {\n                return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n              }\n            }\n          }\n        }\n      };\n      const script = [];\n      buildScript(0, left.length, 0, right.length, script);\n      return script;\n    };\n\n    const getOuterHtml = elm => {\n      if (isElement$6(elm)) {\n        return elm.outerHTML;\n      } else if (isText$8(elm)) {\n        return Entities.encodeRaw(elm.data, false);\n      } else if (isComment(elm)) {\n        return '<!--' + elm.data + '-->';\n      }\n      return '';\n    };\n    const createFragment = html => {\n      let node;\n      const container = document.createElement('div');\n      const frag = document.createDocumentFragment();\n      if (html) {\n        container.innerHTML = html;\n      }\n      while (node = container.firstChild) {\n        frag.appendChild(node);\n      }\n      return frag;\n    };\n    const insertAt = (elm, html, index) => {\n      const fragment = createFragment(html);\n      if (elm.hasChildNodes() && index < elm.childNodes.length) {\n        const target = elm.childNodes[index];\n        target.parentNode.insertBefore(fragment, target);\n      } else {\n        elm.appendChild(fragment);\n      }\n    };\n    const removeAt = (elm, index) => {\n      if (elm.hasChildNodes() && index < elm.childNodes.length) {\n        const target = elm.childNodes[index];\n        target.parentNode.removeChild(target);\n      }\n    };\n    const applyDiff = (diff, elm) => {\n      let index = 0;\n      each$g(diff, action => {\n        if (action[0] === KEEP) {\n          index++;\n        } else if (action[0] === INSERT) {\n          insertAt(elm, action[1], index);\n          index++;\n        } else if (action[0] === DELETE) {\n          removeAt(elm, index);\n        }\n      });\n    };\n    const read$2 = elm => {\n      return filter$6(map$3(from(elm.childNodes), getOuterHtml), item => {\n        return item.length > 0;\n      });\n    };\n    const write = (fragments, elm) => {\n      const currentFragments = map$3(from(elm.childNodes), getOuterHtml);\n      applyDiff(diff(currentFragments, fragments), elm);\n      return elm;\n    };\n\n    const lazyTempDocument = cached(() => document.implementation.createHTMLDocument('undo'));\n    const hasIframes = html => {\n      return html.indexOf('</iframe>') !== -1;\n    };\n    const createFragmentedLevel = fragments => {\n      return {\n        type: 'fragmented',\n        fragments,\n        content: '',\n        bookmark: null,\n        beforeBookmark: null\n      };\n    };\n    const createCompleteLevel = content => {\n      return {\n        type: 'complete',\n        fragments: null,\n        content,\n        bookmark: null,\n        beforeBookmark: null\n      };\n    };\n    const createFromEditor = editor => {\n      const fragments = read$2(editor.getBody());\n      const trimmedFragments = bind$3(fragments, html => {\n        const trimmed = trimInternal(editor.serializer, html);\n        return trimmed.length > 0 ? [trimmed] : [];\n      });\n      const content = trimmedFragments.join('');\n      return hasIframes(content) ? createFragmentedLevel(trimmedFragments) : createCompleteLevel(content);\n    };\n    const applyToEditor = (editor, level, before) => {\n      const bookmark = before ? level.beforeBookmark : level.bookmark;\n      if (level.type === 'fragmented') {\n        write(level.fragments, editor.getBody());\n      } else {\n        editor.setContent(level.content, {\n          format: 'raw',\n          no_selection: isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true\n        });\n      }\n      editor.selection.moveToBookmark(bookmark);\n    };\n    const getLevelContent = level => {\n      return level.type === 'fragmented' ? level.fragments.join('') : level.content;\n    };\n    const getCleanLevelContent = level => {\n      const elm = SugarElement.fromTag('body', lazyTempDocument());\n      set(elm, getLevelContent(level));\n      each$g(descendants(elm, '*[data-mce-bogus]'), unwrap);\n      return get$6(elm);\n    };\n    const hasEqualContent = (level1, level2) => getLevelContent(level1) === getLevelContent(level2);\n    const hasEqualCleanedContent = (level1, level2) => getCleanLevelContent(level1) === getCleanLevelContent(level2);\n    const isEq$1 = (level1, level2) => {\n      if (!level1 || !level2) {\n        return false;\n      } else if (hasEqualContent(level1, level2)) {\n        return true;\n      } else {\n        return hasEqualCleanedContent(level1, level2);\n      }\n    };\n\n    const isUnlocked = locks => locks.get() === 0;\n\n    const setTyping = (undoManager, typing, locks) => {\n      if (isUnlocked(locks)) {\n        undoManager.typing = typing;\n      }\n    };\n    const endTyping = (undoManager, locks) => {\n      if (undoManager.typing) {\n        setTyping(undoManager, false, locks);\n        undoManager.add();\n      }\n    };\n    const endTypingLevelIgnoreLocks = undoManager => {\n      if (undoManager.typing) {\n        undoManager.typing = false;\n        undoManager.add();\n      }\n    };\n\n    const beforeChange$1 = (editor, locks, beforeBookmark) => {\n      if (isUnlocked(locks)) {\n        beforeBookmark.set(getUndoBookmark(editor.selection));\n      }\n    };\n    const addUndoLevel$1 = (editor, undoManager, index, locks, beforeBookmark, level, event) => {\n      const currentLevel = createFromEditor(editor);\n      level = level || {};\n      level = Tools.extend(level, currentLevel);\n      if (isUnlocked(locks) === false || editor.removed) {\n        return null;\n      }\n      const lastLevel = undoManager.data[index.get()];\n      if (editor.dispatch('BeforeAddUndo', {\n          level,\n          lastLevel,\n          originalEvent: event\n        }).isDefaultPrevented()) {\n        return null;\n      }\n      if (lastLevel && isEq$1(lastLevel, level)) {\n        return null;\n      }\n      if (undoManager.data[index.get()]) {\n        beforeBookmark.get().each(bm => {\n          undoManager.data[index.get()].beforeBookmark = bm;\n        });\n      }\n      const customUndoRedoLevels = getCustomUndoRedoLevels(editor);\n      if (customUndoRedoLevels) {\n        if (undoManager.data.length > customUndoRedoLevels) {\n          for (let i = 0; i < undoManager.data.length - 1; i++) {\n            undoManager.data[i] = undoManager.data[i + 1];\n          }\n          undoManager.data.length--;\n          index.set(undoManager.data.length);\n        }\n      }\n      level.bookmark = getUndoBookmark(editor.selection);\n      if (index.get() < undoManager.data.length - 1) {\n        undoManager.data.length = index.get() + 1;\n      }\n      undoManager.data.push(level);\n      index.set(undoManager.data.length - 1);\n      const args = {\n        level,\n        lastLevel,\n        originalEvent: event\n      };\n      if (index.get() > 0) {\n        editor.setDirty(true);\n        editor.dispatch('AddUndo', args);\n        editor.dispatch('change', args);\n      } else {\n        editor.dispatch('AddUndo', args);\n      }\n      return level;\n    };\n    const clear$1 = (editor, undoManager, index) => {\n      undoManager.data = [];\n      index.set(0);\n      undoManager.typing = false;\n      editor.dispatch('ClearUndos');\n    };\n    const extra$1 = (editor, undoManager, index, callback1, callback2) => {\n      if (undoManager.transact(callback1)) {\n        const bookmark = undoManager.data[index.get()].bookmark;\n        const lastLevel = undoManager.data[index.get() - 1];\n        applyToEditor(editor, lastLevel, true);\n        if (undoManager.transact(callback2)) {\n          undoManager.data[index.get() - 1].beforeBookmark = bookmark;\n        }\n      }\n    };\n    const redo$1 = (editor, index, data) => {\n      let level;\n      if (index.get() < data.length - 1) {\n        index.set(index.get() + 1);\n        level = data[index.get()];\n        applyToEditor(editor, level, false);\n        editor.setDirty(true);\n        editor.dispatch('Redo', { level });\n      }\n      return level;\n    };\n    const undo$1 = (editor, undoManager, locks, index) => {\n      let level;\n      if (undoManager.typing) {\n        undoManager.add();\n        undoManager.typing = false;\n        setTyping(undoManager, false, locks);\n      }\n      if (index.get() > 0) {\n        index.set(index.get() - 1);\n        level = undoManager.data[index.get()];\n        applyToEditor(editor, level, true);\n        editor.setDirty(true);\n        editor.dispatch('Undo', { level });\n      }\n      return level;\n    };\n    const reset$1 = undoManager => {\n      undoManager.clear();\n      undoManager.add();\n    };\n    const hasUndo$1 = (editor, undoManager, index) => index.get() > 0 || undoManager.typing && undoManager.data[0] && !isEq$1(createFromEditor(editor), undoManager.data[0]);\n    const hasRedo$1 = (undoManager, index) => index.get() < undoManager.data.length - 1 && !undoManager.typing;\n    const transact$1 = (undoManager, locks, callback) => {\n      endTyping(undoManager, locks);\n      undoManager.beforeChange();\n      undoManager.ignore(callback);\n      return undoManager.add();\n    };\n    const ignore$1 = (locks, callback) => {\n      try {\n        locks.set(locks.get() + 1);\n        callback();\n      } finally {\n        locks.set(locks.get() - 1);\n      }\n    };\n\n    const addVisualInternal = (editor, elm) => {\n      const dom = editor.dom;\n      const scope = isNonNullable(elm) ? elm : editor.getBody();\n      if (isUndefined(editor.hasVisual)) {\n        editor.hasVisual = isVisualAidsEnabled(editor);\n      }\n      each$g(dom.select('table,a', scope), matchedElm => {\n        switch (matchedElm.nodeName) {\n        case 'TABLE':\n          const cls = getVisualAidsTableClass(editor);\n          const value = dom.getAttrib(matchedElm, 'border');\n          if ((!value || value === '0') && editor.hasVisual) {\n            dom.addClass(matchedElm, cls);\n          } else {\n            dom.removeClass(matchedElm, cls);\n          }\n          break;\n        case 'A':\n          if (!dom.getAttrib(matchedElm, 'href')) {\n            const value = dom.getAttrib(matchedElm, 'name') || matchedElm.id;\n            const cls = getVisualAidsAnchorClass(editor);\n            if (value && editor.hasVisual) {\n              dom.addClass(matchedElm, cls);\n            } else {\n              dom.removeClass(matchedElm, cls);\n            }\n          }\n          break;\n        }\n      });\n      editor.dispatch('VisualAid', {\n        element: elm,\n        hasVisual: editor.hasVisual\n      });\n    };\n\n    const makePlainAdaptor = editor => ({\n      init: { bindEvents: noop },\n      undoManager: {\n        beforeChange: (locks, beforeBookmark) => beforeChange$1(editor, locks, beforeBookmark),\n        add: (undoManager, index, locks, beforeBookmark, level, event) => addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event),\n        undo: (undoManager, locks, index) => undo$1(editor, undoManager, locks, index),\n        redo: (index, data) => redo$1(editor, index, data),\n        clear: (undoManager, index) => clear$1(editor, undoManager, index),\n        reset: undoManager => reset$1(undoManager),\n        hasUndo: (undoManager, index) => hasUndo$1(editor, undoManager, index),\n        hasRedo: (undoManager, index) => hasRedo$1(undoManager, index),\n        transact: (undoManager, locks, callback) => transact$1(undoManager, locks, callback),\n        ignore: (locks, callback) => ignore$1(locks, callback),\n        extra: (undoManager, index, callback1, callback2) => extra$1(editor, undoManager, index, callback1, callback2)\n      },\n      formatter: {\n        match: (name, vars, node, similar) => match$2(editor, name, vars, node, similar),\n        matchAll: (names, vars) => matchAll(editor, names, vars),\n        matchNode: (node, name, vars, similar) => matchNode(editor, node, name, vars, similar),\n        canApply: name => canApply(editor, name),\n        closest: names => closest$1(editor, names),\n        apply: (name, vars, node) => applyFormat$1(editor, name, vars, node),\n        remove: (name, vars, node, similar) => remove$2(editor, name, vars, node, similar),\n        toggle: (name, vars, node) => toggle(editor, name, vars, node),\n        formatChanged: (registeredFormatListeners, formats, callback, similar, vars) => formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar, vars)\n      },\n      editor: {\n        getContent: args => getContentInternal(editor, args),\n        setContent: (content, args) => setContentInternal(editor, content, args),\n        insertContent: (value, details) => insertHtmlAtCaret(editor, value, details),\n        addVisual: elm => addVisualInternal(editor, elm)\n      },\n      selection: { getContent: (format, args) => getSelectedContentInternal(editor, format, args) },\n      autocompleter: {\n        addDecoration: range => create$8(editor, range),\n        removeDecoration: () => remove$3(editor, SugarElement.fromDom(editor.getBody()))\n      },\n      raw: { getModel: () => Optional.none() }\n    });\n    const makeRtcAdaptor = rtcEditor => {\n      const defaultVars = vars => isObject(vars) ? vars : {};\n      const {init, undoManager, formatter, editor, selection, autocompleter, raw} = rtcEditor;\n      return {\n        init: { bindEvents: init.bindEvents },\n        undoManager: {\n          beforeChange: undoManager.beforeChange,\n          add: undoManager.add,\n          undo: undoManager.undo,\n          redo: undoManager.redo,\n          clear: undoManager.clear,\n          reset: undoManager.reset,\n          hasUndo: undoManager.hasUndo,\n          hasRedo: undoManager.hasRedo,\n          transact: (_undoManager, _locks, fn) => undoManager.transact(fn),\n          ignore: (_locks, callback) => undoManager.ignore(callback),\n          extra: (_undoManager, _index, callback1, callback2) => undoManager.extra(callback1, callback2)\n        },\n        formatter: {\n          match: (name, vars, _node, similar) => formatter.match(name, defaultVars(vars), similar),\n          matchAll: formatter.matchAll,\n          matchNode: formatter.matchNode,\n          canApply: name => formatter.canApply(name),\n          closest: names => formatter.closest(names),\n          apply: (name, vars, _node) => formatter.apply(name, defaultVars(vars)),\n          remove: (name, vars, _node, _similar) => formatter.remove(name, defaultVars(vars)),\n          toggle: (name, vars, _node) => formatter.toggle(name, defaultVars(vars)),\n          formatChanged: (_rfl, formats, callback, similar, vars) => formatter.formatChanged(formats, callback, similar, vars)\n        },\n        editor: {\n          getContent: args => editor.getContent(args),\n          setContent: (content, args) => {\n            return {\n              content: editor.setContent(content, args),\n              html: ''\n            };\n          },\n          insertContent: (content, _details) => {\n            editor.insertContent(content);\n            return '';\n          },\n          addVisual: editor.addVisual\n        },\n        selection: { getContent: (_format, args) => selection.getContent(args) },\n        autocompleter: {\n          addDecoration: autocompleter.addDecoration,\n          removeDecoration: autocompleter.removeDecoration\n        },\n        raw: { getModel: () => Optional.some(raw.getRawModel()) }\n      };\n    };\n    const makeNoopAdaptor = () => {\n      const nul = constant(null);\n      const empty = constant('');\n      return {\n        init: { bindEvents: noop },\n        undoManager: {\n          beforeChange: noop,\n          add: nul,\n          undo: nul,\n          redo: nul,\n          clear: noop,\n          reset: noop,\n          hasUndo: never,\n          hasRedo: never,\n          transact: nul,\n          ignore: noop,\n          extra: noop\n        },\n        formatter: {\n          match: never,\n          matchAll: constant([]),\n          matchNode: constant(undefined),\n          canApply: never,\n          closest: empty,\n          apply: noop,\n          remove: noop,\n          toggle: noop,\n          formatChanged: constant({ unbind: noop })\n        },\n        editor: {\n          getContent: empty,\n          setContent: constant({\n            content: '',\n            html: ''\n          }),\n          insertContent: constant(''),\n          addVisual: noop\n        },\n        selection: { getContent: empty },\n        autocompleter: {\n          addDecoration: noop,\n          removeDecoration: noop\n        },\n        raw: { getModel: constant(Optional.none()) }\n      };\n    };\n    const isRtc = editor => has$2(editor.plugins, 'rtc');\n    const getRtcSetup = editor => get$a(editor.plugins, 'rtc').bind(rtcPlugin => Optional.from(rtcPlugin.setup));\n    const setup$s = editor => {\n      const editorCast = editor;\n      return getRtcSetup(editor).fold(() => {\n        editorCast.rtcInstance = makePlainAdaptor(editor);\n        return Optional.none();\n      }, setup => {\n        editorCast.rtcInstance = makeNoopAdaptor();\n        return Optional.some(() => setup().then(rtcEditor => {\n          editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);\n          return rtcEditor.rtc.isRemote;\n        }));\n      });\n    };\n    const getRtcInstanceWithFallback = editor => editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);\n    const getRtcInstanceWithError = editor => {\n      const rtcInstance = editor.rtcInstance;\n      if (!rtcInstance) {\n        throw new Error('Failed to get RTC instance not yet initialized.');\n      } else {\n        return rtcInstance;\n      }\n    };\n    const beforeChange = (editor, locks, beforeBookmark) => {\n      getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);\n    };\n    const addUndoLevel = (editor, undoManager, index, locks, beforeBookmark, level, event) => getRtcInstanceWithError(editor).undoManager.add(undoManager, index, locks, beforeBookmark, level, event);\n    const undo = (editor, undoManager, locks, index) => getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);\n    const redo = (editor, index, data) => getRtcInstanceWithError(editor).undoManager.redo(index, data);\n    const clear = (editor, undoManager, index) => {\n      getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);\n    };\n    const reset = (editor, undoManager) => {\n      getRtcInstanceWithError(editor).undoManager.reset(undoManager);\n    };\n    const hasUndo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);\n    const hasRedo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);\n    const transact = (editor, undoManager, locks, callback) => getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);\n    const ignore = (editor, locks, callback) => {\n      getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);\n    };\n    const extra = (editor, undoManager, index, callback1, callback2) => {\n      getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);\n    };\n    const matchFormat = (editor, name, vars, node, similar) => getRtcInstanceWithError(editor).formatter.match(name, vars, node, similar);\n    const matchAllFormats = (editor, names, vars) => getRtcInstanceWithError(editor).formatter.matchAll(names, vars);\n    const matchNodeFormat = (editor, node, name, vars, similar) => getRtcInstanceWithError(editor).formatter.matchNode(node, name, vars, similar);\n    const canApplyFormat = (editor, name) => getRtcInstanceWithError(editor).formatter.canApply(name);\n    const closestFormat = (editor, names) => getRtcInstanceWithError(editor).formatter.closest(names);\n    const applyFormat = (editor, name, vars, node) => {\n      getRtcInstanceWithError(editor).formatter.apply(name, vars, node);\n    };\n    const removeFormat = (editor, name, vars, node, similar) => {\n      getRtcInstanceWithError(editor).formatter.remove(name, vars, node, similar);\n    };\n    const toggleFormat = (editor, name, vars, node) => {\n      getRtcInstanceWithError(editor).formatter.toggle(name, vars, node);\n    };\n    const formatChanged = (editor, registeredFormatListeners, formats, callback, similar, vars) => getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar, vars);\n    const getContent$2 = (editor, args) => getRtcInstanceWithFallback(editor).editor.getContent(args);\n    const setContent$2 = (editor, content, args) => getRtcInstanceWithFallback(editor).editor.setContent(content, args);\n    const insertContent$1 = (editor, value, details) => getRtcInstanceWithFallback(editor).editor.insertContent(value, details);\n    const getSelectedContent = (editor, format, args) => getRtcInstanceWithError(editor).selection.getContent(format, args);\n    const addVisual$1 = (editor, elm) => getRtcInstanceWithError(editor).editor.addVisual(elm);\n    const bindEvents = editor => getRtcInstanceWithError(editor).init.bindEvents();\n    const addAutocompleterDecoration = (editor, range) => getRtcInstanceWithError(editor).autocompleter.addDecoration(range);\n    const removeAutocompleterDecoration = editor => getRtcInstanceWithError(editor).autocompleter.removeDecoration();\n\n    const getContent$1 = (editor, args = {}) => {\n      const format = args.format ? args.format : 'html';\n      return getSelectedContent(editor, format, args);\n    };\n\n    const removeEmpty = text => {\n      if (text.dom.length === 0) {\n        remove$5(text);\n        return Optional.none();\n      } else {\n        return Optional.some(text);\n      }\n    };\n    const walkPastBookmark = (node, start) => node.filter(elm => BookmarkManager.isBookmarkNode(elm.dom)).bind(start ? nextSibling : prevSibling);\n    const merge$1 = (outer, inner, rng, start) => {\n      const outerElm = outer.dom;\n      const innerElm = inner.dom;\n      const oldLength = start ? outerElm.length : innerElm.length;\n      if (start) {\n        mergeTextNodes(outerElm, innerElm, false, !start);\n        rng.setStart(innerElm, oldLength);\n      } else {\n        mergeTextNodes(innerElm, outerElm, false, !start);\n        rng.setEnd(innerElm, oldLength);\n      }\n    };\n    const normalizeTextIfRequired = (inner, start) => {\n      parent(inner).each(root => {\n        const text = inner.dom;\n        if (start && needsToBeNbspLeft(root, CaretPosition(text, 0))) {\n          normalizeWhitespaceAfter(text, 0);\n        } else if (!start && needsToBeNbspRight(root, CaretPosition(text, text.length))) {\n          normalizeWhitespaceBefore(text, text.length);\n        }\n      });\n    };\n    const mergeAndNormalizeText = (outerNode, innerNode, rng, start) => {\n      outerNode.bind(outer => {\n        const normalizer = start ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;\n        normalizer(outer.dom, start ? outer.dom.length : 0);\n        return innerNode.filter(isText$9).map(inner => merge$1(outer, inner, rng, start));\n      }).orThunk(() => {\n        const innerTextNode = walkPastBookmark(innerNode, start).or(innerNode).filter(isText$9);\n        return innerTextNode.map(inner => normalizeTextIfRequired(inner, start));\n      });\n    };\n    const rngSetContent = (rng, fragment) => {\n      const firstChild = Optional.from(fragment.firstChild).map(SugarElement.fromDom);\n      const lastChild = Optional.from(fragment.lastChild).map(SugarElement.fromDom);\n      rng.deleteContents();\n      rng.insertNode(fragment);\n      const prevText = firstChild.bind(prevSibling).filter(isText$9).bind(removeEmpty);\n      const nextText = lastChild.bind(nextSibling).filter(isText$9).bind(removeEmpty);\n      mergeAndNormalizeText(prevText, firstChild, rng, true);\n      mergeAndNormalizeText(nextText, lastChild, rng, false);\n      rng.collapse(false);\n    };\n    const setupArgs$2 = (args, content) => ({\n      format: 'html',\n      ...args,\n      set: true,\n      selection: true,\n      content\n    });\n    const cleanContent = (editor, args) => {\n      if (args.format !== 'raw') {\n        const rng = editor.selection.getRng();\n        const contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);\n        const contextArgs = contextBlock ? { context: contextBlock.nodeName.toLowerCase() } : {};\n        const node = editor.parser.parse(args.content, {\n          forced_root_block: false,\n          ...contextArgs,\n          ...args\n        });\n        return HtmlSerializer({ validate: false }, editor.schema).serialize(node);\n      } else {\n        return args.content;\n      }\n    };\n    const setContent$1 = (editor, content, args = {}) => {\n      const defaultedArgs = setupArgs$2(args, content);\n      preProcessSetContent(editor, defaultedArgs).each(updatedArgs => {\n        const cleanedContent = cleanContent(editor, updatedArgs);\n        const rng = editor.selection.getRng();\n        rngSetContent(rng, rng.createContextualFragment(cleanedContent));\n        editor.selection.setRng(rng);\n        scrollRangeIntoView(editor, rng);\n        postProcessSetContent(editor, cleanedContent, updatedArgs);\n      });\n    };\n\n    const deleteFromCallbackMap = (callbackMap, selector, callback) => {\n      if (callbackMap && has$2(callbackMap, selector)) {\n        const newCallbacks = filter$6(callbackMap[selector], cb => cb !== callback);\n        if (newCallbacks.length === 0) {\n          delete callbackMap[selector];\n        } else {\n          callbackMap[selector] = newCallbacks;\n        }\n      }\n    };\n    var SelectorChanged = (dom, editor) => {\n      let selectorChangedData;\n      let currentSelectors;\n      const findMatchingNode = (selector, nodes) => find$2(nodes, node => dom.is(node, selector));\n      const getParents = elem => dom.getParents(elem, null, dom.getRoot());\n      return {\n        selectorChangedWithUnbind: (selector, callback) => {\n          if (!selectorChangedData) {\n            selectorChangedData = {};\n            currentSelectors = {};\n            editor.on('NodeChange', e => {\n              const node = e.element;\n              const parents = getParents(node);\n              const matchedSelectors = {};\n              Tools.each(selectorChangedData, (callbacks, selector) => {\n                findMatchingNode(selector, parents).each(node => {\n                  if (!currentSelectors[selector]) {\n                    each$g(callbacks, callback => {\n                      callback(true, {\n                        node,\n                        selector,\n                        parents\n                      });\n                    });\n                    currentSelectors[selector] = callbacks;\n                  }\n                  matchedSelectors[selector] = callbacks;\n                });\n              });\n              Tools.each(currentSelectors, (callbacks, selector) => {\n                if (!matchedSelectors[selector]) {\n                  delete currentSelectors[selector];\n                  Tools.each(callbacks, callback => {\n                    callback(false, {\n                      node,\n                      selector,\n                      parents\n                    });\n                  });\n                }\n              });\n            });\n          }\n          if (!selectorChangedData[selector]) {\n            selectorChangedData[selector] = [];\n          }\n          selectorChangedData[selector].push(callback);\n          findMatchingNode(selector, getParents(editor.selection.getStart())).each(() => {\n            currentSelectors[selector] = selectorChangedData[selector];\n          });\n          return {\n            unbind: () => {\n              deleteFromCallbackMap(selectorChangedData, selector, callback);\n              deleteFromCallbackMap(currentSelectors, selector, callback);\n            }\n          };\n        }\n      };\n    };\n\n    const isAttachedToDom = node => {\n      return !!(node && node.ownerDocument) && contains(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));\n    };\n    const isValidRange = rng => {\n      if (!rng) {\n        return false;\n      } else {\n        return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);\n      }\n    };\n    const EditorSelection = (dom, win, serializer, editor) => {\n      let selectedRange;\n      let explicitRange;\n      const {selectorChangedWithUnbind} = SelectorChanged(dom, editor);\n      const setCursorLocation = (node, offset) => {\n        const rng = dom.createRng();\n        if (isNonNullable(node) && isNonNullable(offset)) {\n          rng.setStart(node, offset);\n          rng.setEnd(node, offset);\n          setRng(rng);\n          collapse(false);\n        } else {\n          moveEndPoint(dom, rng, editor.getBody(), true);\n          setRng(rng);\n        }\n      };\n      const getContent = args => getContent$1(editor, args);\n      const setContent = (content, args) => setContent$1(editor, content, args);\n      const getStart$1 = real => getStart(editor.getBody(), getRng$1(), real);\n      const getEnd = real => getEnd$1(editor.getBody(), getRng$1(), real);\n      const getBookmark = (type, normalized) => bookmarkManager.getBookmark(type, normalized);\n      const moveToBookmark = bookmark => bookmarkManager.moveToBookmark(bookmark);\n      const select$1 = (node, content) => {\n        select(dom, node, content).each(setRng);\n        return node;\n      };\n      const isCollapsed = () => {\n        const rng = getRng$1(), sel = getSel();\n        if (!rng || rng.item) {\n          return false;\n        }\n        if (rng.compareEndPoints) {\n          return rng.compareEndPoints('StartToEnd', rng) === 0;\n        }\n        return !sel || rng.collapsed;\n      };\n      const collapse = toStart => {\n        const rng = getRng$1();\n        rng.collapse(!!toStart);\n        setRng(rng);\n      };\n      const getSel = () => win.getSelection ? win.getSelection() : win.document.selection;\n      const getRng$1 = () => {\n        let selection, rng, elm;\n        const tryCompareBoundaryPoints = (how, sourceRange, destinationRange) => {\n          try {\n            return sourceRange.compareBoundaryPoints(how, destinationRange);\n          } catch (ex) {\n            return -1;\n          }\n        };\n        const doc = win.document;\n        if (editor.bookmark !== undefined && hasFocus(editor) === false) {\n          const bookmark = getRng(editor);\n          if (bookmark.isSome()) {\n            return bookmark.map(r => processRanges(editor, [r])[0]).getOr(doc.createRange());\n          }\n        }\n        try {\n          if ((selection = getSel()) && !isRestrictedNode(selection.anchorNode)) {\n            if (selection.rangeCount > 0) {\n              rng = selection.getRangeAt(0);\n            } else {\n              rng = selection.createRange ? selection.createRange() : doc.createRange();\n            }\n            rng = processRanges(editor, [rng])[0];\n          }\n        } catch (ex) {\n        }\n        if (!rng) {\n          rng = doc.createRange();\n        }\n        if (rng.setStart && rng.startContainer.nodeType === 9 && rng.collapsed) {\n          elm = dom.getRoot();\n          rng.setStart(elm, 0);\n          rng.setEnd(elm, 0);\n        }\n        if (selectedRange && explicitRange) {\n          if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {\n            rng = explicitRange;\n          } else {\n            selectedRange = null;\n            explicitRange = null;\n          }\n        }\n        return rng;\n      };\n      const setRng = (rng, forward) => {\n        let node;\n        if (!isValidRange(rng)) {\n          return;\n        }\n        const sel = getSel();\n        const evt = editor.dispatch('SetSelectionRange', {\n          range: rng,\n          forward\n        });\n        rng = evt.range;\n        if (sel) {\n          explicitRange = rng;\n          try {\n            sel.removeAllRanges();\n            sel.addRange(rng);\n          } catch (ex) {\n          }\n          if (forward === false && sel.extend) {\n            sel.collapse(rng.endContainer, rng.endOffset);\n            sel.extend(rng.startContainer, rng.startOffset);\n          }\n          selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;\n        }\n        if (!rng.collapsed && rng.startContainer === rng.endContainer && sel.setBaseAndExtent) {\n          if (rng.endOffset - rng.startOffset < 2) {\n            if (rng.startContainer.hasChildNodes()) {\n              node = rng.startContainer.childNodes[rng.startOffset];\n              if (node && node.tagName === 'IMG') {\n                sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);\n                if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {\n                  sel.setBaseAndExtent(node, 0, node, 1);\n                }\n              }\n            }\n          }\n        }\n        editor.dispatch('AfterSetSelectionRange', {\n          range: rng,\n          forward\n        });\n      };\n      const setNode = elm => {\n        setContent(dom.getOuterHTML(elm));\n        return elm;\n      };\n      const getNode$1 = () => getNode(editor.getBody(), getRng$1());\n      const getSelectedBlocks$1 = (startElm, endElm) => getSelectedBlocks(dom, getRng$1(), startElm, endElm);\n      const isForward = () => {\n        const sel = getSel();\n        const anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;\n        const focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;\n        if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {\n          return true;\n        }\n        const anchorRange = dom.createRng();\n        anchorRange.setStart(anchorNode, sel.anchorOffset);\n        anchorRange.collapse(true);\n        const focusRange = dom.createRng();\n        focusRange.setStart(focusNode, sel.focusOffset);\n        focusRange.collapse(true);\n        return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;\n      };\n      const normalize = () => {\n        const rng = getRng$1();\n        const sel = getSel();\n        if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {\n          const normRng = normalize$2(dom, rng);\n          normRng.each(normRng => {\n            setRng(normRng, isForward());\n          });\n          return normRng.getOr(rng);\n        }\n        return rng;\n      };\n      const selectorChanged = (selector, callback) => {\n        selectorChangedWithUnbind(selector, callback);\n        return exports;\n      };\n      const getScrollContainer = () => {\n        let scrollContainer;\n        let node = dom.getRoot();\n        while (node && node.nodeName !== 'BODY') {\n          if (node.scrollHeight > node.clientHeight) {\n            scrollContainer = node;\n            break;\n          }\n          node = node.parentNode;\n        }\n        return scrollContainer;\n      };\n      const scrollIntoView = (elm, alignToTop) => {\n        if (isNonNullable(elm)) {\n          scrollElementIntoView(editor, elm, alignToTop);\n        } else {\n          scrollRangeIntoView(editor, getRng$1(), alignToTop);\n        }\n      };\n      const placeCaretAt = (clientX, clientY) => setRng(fromPoint(clientX, clientY, editor.getDoc()));\n      const getBoundingClientRect = () => {\n        const rng = getRng$1();\n        return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();\n      };\n      const destroy = () => {\n        win = selectedRange = explicitRange = null;\n        controlSelection.destroy();\n      };\n      const exports = {\n        bookmarkManager: null,\n        controlSelection: null,\n        dom,\n        win,\n        serializer,\n        editor,\n        collapse,\n        setCursorLocation,\n        getContent,\n        setContent,\n        getBookmark,\n        moveToBookmark,\n        select: select$1,\n        isCollapsed,\n        isForward,\n        setNode,\n        getNode: getNode$1,\n        getSel,\n        setRng,\n        getRng: getRng$1,\n        getStart: getStart$1,\n        getEnd,\n        getSelectedBlocks: getSelectedBlocks$1,\n        normalize,\n        selectorChanged,\n        selectorChangedWithUnbind,\n        getScrollContainer,\n        scrollIntoView,\n        placeCaretAt,\n        getBoundingClientRect,\n        destroy\n      };\n      const bookmarkManager = BookmarkManager(exports);\n      const controlSelection = ControlSelection(exports, editor);\n      exports.bookmarkManager = bookmarkManager;\n      exports.controlSelection = controlSelection;\n      return exports;\n    };\n\n    const register$3 = (htmlParser, settings, dom) => {\n      htmlParser.addAttributeFilter('data-mce-tabindex', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          node.attr('tabindex', node.attr('data-mce-tabindex'));\n          node.attr(name, null);\n        }\n      });\n      htmlParser.addAttributeFilter('src,href,style', (nodes, name) => {\n        const internalName = 'data-mce-' + name;\n        const urlConverter = settings.url_converter;\n        const urlConverterScope = settings.url_converter_scope;\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          let value = node.attr(internalName);\n          if (value !== undefined) {\n            node.attr(name, value.length > 0 ? value : null);\n            node.attr(internalName, null);\n          } else {\n            value = node.attr(name);\n            if (name === 'style') {\n              value = dom.serializeStyle(dom.parseStyle(value), node.name);\n            } else if (urlConverter) {\n              value = urlConverter.call(urlConverterScope, value, name, node.name);\n            }\n            node.attr(name, value.length > 0 ? value : null);\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('class', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          let value = node.attr('class');\n          if (value) {\n            value = node.attr('class').replace(/(?:^|\\s)mce-item-\\w+(?!\\S)/g, '');\n            node.attr('class', value.length > 0 ? value : null);\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('data-mce-type', (nodes, name, args) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (node.attr('data-mce-type') === 'bookmark' && !args.cleanup) {\n            const hasChildren = Optional.from(node.firstChild).exists(firstChild => !isZwsp(firstChild.value));\n            if (hasChildren) {\n              node.unwrap();\n            } else {\n              node.remove();\n            }\n          }\n        }\n      });\n      htmlParser.addNodeFilter('noscript', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i].firstChild;\n          if (node) {\n            node.value = Entities.decode(node.value);\n          }\n        }\n      });\n      htmlParser.addNodeFilter('script,style', (nodes, name) => {\n        const trim = value => {\n          return value.replace(/(<!--\\[CDATA\\[|\\]\\]-->)/g, '\\n').replace(/^[\\r\\n]*|[\\r\\n]*$/g, '').replace(/^\\s*((<!--)?(\\s*\\/\\/)?\\s*<!\\[CDATA\\[|(<!--\\s*)?\\/\\*\\s*<!\\[CDATA\\[\\s*\\*\\/|(\\/\\/)?\\s*<!--|\\/\\*\\s*<!--\\s*\\*\\/)\\s*[\\r\\n]*/gi, '').replace(/\\s*(\\/\\*\\s*\\]\\]>\\s*\\*\\/(-->)?|\\s*\\/\\/\\s*\\]\\]>(-->)?|\\/\\/\\s*(-->)?|\\]\\]>|\\/\\*\\s*-->\\s*\\*\\/|\\s*-->\\s*)\\s*$/g, '');\n        };\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          const value = node.firstChild ? node.firstChild.value : '';\n          if (name === 'script') {\n            const type = node.attr('type');\n            if (type) {\n              node.attr('type', type === 'mce-no/type' ? null : type.replace(/^mce\\-/, ''));\n            }\n            if (settings.element_format === 'xhtml' && value.length > 0) {\n              node.firstChild.value = '// <![CDATA[\\n' + trim(value) + '\\n// ]]>';\n            }\n          } else {\n            if (settings.element_format === 'xhtml' && value.length > 0) {\n              node.firstChild.value = '<!--\\n' + trim(value) + '\\n-->';\n            }\n          }\n        }\n      });\n      htmlParser.addNodeFilter('#comment', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (settings.preserve_cdata && node.value.indexOf('[CDATA[') === 0) {\n            node.name = '#cdata';\n            node.type = 4;\n            node.value = dom.decode(node.value.replace(/^\\[CDATA\\[|\\]\\]$/g, ''));\n          } else if (node.value.indexOf('mce:protected ') === 0) {\n            node.name = '#text';\n            node.type = 3;\n            node.raw = true;\n            node.value = unescape(node.value).substr(14);\n          }\n        }\n      });\n      htmlParser.addNodeFilter('xml:namespace,input', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (node.type === 7) {\n            node.remove();\n          } else if (node.type === 1) {\n            if (name === 'input' && !node.attr('type')) {\n              node.attr('type', 'text');\n            }\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('data-mce-type', nodes => {\n        each$g(nodes, node => {\n          if (node.attr('data-mce-type') === 'format-caret') {\n            if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {\n              node.remove();\n            } else {\n              node.unwrap();\n            }\n          }\n        });\n      });\n      htmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style,' + 'data-mce-selected,data-mce-expando,' + 'data-mce-type,data-mce-resize,data-mce-placeholder', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          nodes[i].attr(name, null);\n        }\n      });\n    };\n    const trimTrailingBr = rootNode => {\n      const isBr = node => {\n        return node && node.name === 'br';\n      };\n      const brNode1 = rootNode.lastChild;\n      if (isBr(brNode1)) {\n        const brNode2 = brNode1.prev;\n        if (isBr(brNode2)) {\n          brNode1.remove();\n          brNode2.remove();\n        }\n      }\n    };\n\n    const preProcess$1 = (editor, node, args) => {\n      let oldDoc;\n      const dom = editor.dom;\n      let clonedNode = node.cloneNode(true);\n      const impl = document.implementation;\n      if (impl.createHTMLDocument) {\n        const doc = impl.createHTMLDocument('');\n        Tools.each(clonedNode.nodeName === 'BODY' ? clonedNode.childNodes : [clonedNode], node => {\n          doc.body.appendChild(doc.importNode(node, true));\n        });\n        if (clonedNode.nodeName !== 'BODY') {\n          clonedNode = doc.body.firstChild;\n        } else {\n          clonedNode = doc.body;\n        }\n        oldDoc = dom.doc;\n        dom.doc = doc;\n      }\n      firePreProcess(editor, {\n        ...args,\n        node: clonedNode\n      });\n      if (oldDoc) {\n        dom.doc = oldDoc;\n      }\n      return clonedNode;\n    };\n    const shouldFireEvent = (editor, args) => {\n      return editor && editor.hasEventListeners('PreProcess') && !args.no_events;\n    };\n    const process$1 = (editor, node, args) => {\n      return shouldFireEvent(editor, args) ? preProcess$1(editor, node, args) : node;\n    };\n\n    const addTempAttr = (htmlParser, tempAttrs, name) => {\n      if (Tools.inArray(tempAttrs, name) === -1) {\n        htmlParser.addAttributeFilter(name, (nodes, name) => {\n          let i = nodes.length;\n          while (i--) {\n            nodes[i].attr(name, null);\n          }\n        });\n        tempAttrs.push(name);\n      }\n    };\n    const postProcess = (editor, args, content) => {\n      if (!args.no_events && editor) {\n        const outArgs = firePostProcess(editor, {\n          ...args,\n          content\n        });\n        return outArgs.content;\n      } else {\n        return content;\n      }\n    };\n    const getHtmlFromNode = (dom, node, args) => {\n      const html = trim$1(args.getInner ? node.innerHTML : dom.getOuterHTML(node));\n      return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html : Tools.trim(html);\n    };\n    const parseHtml = (htmlParser, html, args) => {\n      const parserArgs = args.selection ? {\n        forced_root_block: false,\n        ...args\n      } : args;\n      const rootNode = htmlParser.parse(html, parserArgs);\n      trimTrailingBr(rootNode);\n      return rootNode;\n    };\n    const serializeNode = (settings, schema, node) => {\n      const htmlSerializer = HtmlSerializer(settings, schema);\n      return htmlSerializer.serialize(node);\n    };\n    const toHtml = (editor, settings, schema, rootNode, args) => {\n      const content = serializeNode(settings, schema, rootNode);\n      return postProcess(editor, args, content);\n    };\n    const DomSerializerImpl = (settings, editor) => {\n      const tempAttrs = ['data-mce-selected'];\n      const dom = editor && editor.dom ? editor.dom : DOMUtils.DOM;\n      const schema = editor && editor.schema ? editor.schema : Schema(settings);\n      settings.entity_encoding = settings.entity_encoding || 'named';\n      settings.remove_trailing_brs = 'remove_trailing_brs' in settings ? settings.remove_trailing_brs : true;\n      const htmlParser = DomParser(settings, schema);\n      register$3(htmlParser, settings, dom);\n      const serialize = (node, parserArgs = {}) => {\n        const args = {\n          format: 'html',\n          ...parserArgs\n        };\n        const targetNode = process$1(editor, node, args);\n        const html = getHtmlFromNode(dom, targetNode, args);\n        const rootNode = parseHtml(htmlParser, html, args);\n        return args.format === 'tree' ? rootNode : toHtml(editor, settings, schema, rootNode, args);\n      };\n      return {\n        schema,\n        addNodeFilter: htmlParser.addNodeFilter,\n        addAttributeFilter: htmlParser.addAttributeFilter,\n        serialize: serialize,\n        addRules: schema.addValidElements,\n        setRules: schema.setValidElements,\n        addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),\n        getTempAttrs: constant(tempAttrs),\n        getNodeFilters: htmlParser.getNodeFilters,\n        getAttributeFilters: htmlParser.getAttributeFilters\n      };\n    };\n\n    const DomSerializer = (settings, editor) => {\n      const domSerializer = DomSerializerImpl(settings, editor);\n      return {\n        schema: domSerializer.schema,\n        addNodeFilter: domSerializer.addNodeFilter,\n        addAttributeFilter: domSerializer.addAttributeFilter,\n        serialize: domSerializer.serialize,\n        addRules: domSerializer.addRules,\n        setRules: domSerializer.setRules,\n        addTempAttr: domSerializer.addTempAttr,\n        getTempAttrs: domSerializer.getTempAttrs,\n        getNodeFilters: domSerializer.getNodeFilters,\n        getAttributeFilters: domSerializer.getAttributeFilters\n      };\n    };\n\n    const defaultFormat$1 = 'html';\n    const setupArgs$1 = (args, format) => ({\n      ...args,\n      format,\n      get: true,\n      getInner: true\n    });\n    const getContent = (editor, args = {}) => {\n      const format = args.format ? args.format : defaultFormat$1;\n      const defaultedArgs = setupArgs$1(args, format);\n      return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\n        const content = getContent$2(editor, updatedArgs);\n        return postProcessGetContent(editor, content, updatedArgs);\n      });\n    };\n\n    const defaultFormat = 'html';\n    const setupArgs = (args, content) => ({\n      format: defaultFormat,\n      ...args,\n      set: true,\n      content\n    });\n    const setContent = (editor, content, args = {}) => {\n      const defaultedArgs = setupArgs(args, content);\n      return preProcessSetContent(editor, defaultedArgs).map(updatedArgs => {\n        const result = setContent$2(editor, updatedArgs.content, updatedArgs);\n        postProcessSetContent(editor, result.html, updatedArgs);\n        return result.content;\n      }).getOr(content);\n    };\n\n    const removedOptions = ('autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,' + 'boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,' + 'force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,' + 'non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,' + 'tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,' + 'paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists').split(',');\n    const removedPlugins = 'bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor'.split(',');\n    const getRemovedOptions = options => {\n      const settingNames = filter$6(removedOptions, setting => has$2(options, setting));\n      const forcedRootBlock = options.forced_root_block;\n      if (forcedRootBlock === false || forcedRootBlock === '') {\n        settingNames.push('forced_root_block (false only)');\n      }\n      return sort(settingNames);\n    };\n    const getRemovedPlugins = options => {\n      const plugins = Tools.makeMap(options.plugins, ' ');\n      const hasPlugin = plugin => has$2(plugins, plugin);\n      const pluginNames = filter$6(removedPlugins, hasPlugin);\n      return sort(pluginNames);\n    };\n    const logRemovedWarnings = (rawOptions, normalizedOptions) => {\n      const removedOptions = getRemovedOptions(rawOptions);\n      const removedPlugins = getRemovedPlugins(normalizedOptions);\n      const hasRemovedPlugins = removedPlugins.length > 0;\n      const hasRemovedOptions = removedOptions.length > 0;\n      const isLegacyMobileTheme = normalizedOptions.theme === 'mobile';\n      if (hasRemovedPlugins || hasRemovedOptions || isLegacyMobileTheme) {\n        const listJoiner = '\\n- ';\n        const themesMessage = isLegacyMobileTheme ? `\\n\\nThemes:${ listJoiner }mobile` : '';\n        const pluginsMessage = hasRemovedPlugins ? `\\n\\nPlugins:${ listJoiner }${ removedPlugins.join(listJoiner) }` : '';\n        const optionsMessage = hasRemovedOptions ? `\\n\\nOptions:${ listJoiner }${ removedOptions.join(listJoiner) }` : '';\n        console.warn('The following deprecated features are currently enabled and have been removed in TinyMCE 6.0. These features will no longer work and should be removed from the TinyMCE configuration. ' + 'See https://www.tiny.cloud/docs/tinymce/6/migration-from-5x/ for more information.' + themesMessage + pluginsMessage + optionsMessage);\n      }\n    };\n    const logWarnings = (rawOptions, normalizedOptions) => {\n      logRemovedWarnings(rawOptions, normalizedOptions);\n    };\n\n    const DOM$8 = DOMUtils.DOM;\n    const restoreOriginalStyles = editor => {\n      DOM$8.setStyle(editor.id, 'display', editor.orgDisplay);\n    };\n    const safeDestroy = x => Optional.from(x).each(x => x.destroy());\n    const clearDomReferences = editor => {\n      editor.contentAreaContainer = editor.formElement = editor.container = editor.editorContainer = null;\n      editor.bodyElement = editor.contentDocument = editor.contentWindow = null;\n      editor.iframeElement = editor.targetElm = null;\n      if (editor.selection) {\n        editor.selection = editor.selection.win = editor.selection.dom = editor.selection.dom.doc = null;\n      }\n    };\n    const restoreForm = editor => {\n      const form = editor.formElement;\n      if (form) {\n        if (form._mceOldSubmit) {\n          form.submit = form._mceOldSubmit;\n          form._mceOldSubmit = null;\n        }\n        DOM$8.unbind(form, 'submit reset', editor.formEventDelegate);\n      }\n    };\n    const remove$1 = editor => {\n      if (!editor.removed) {\n        const {_selectionOverrides, editorUpload} = editor;\n        const body = editor.getBody();\n        const element = editor.getElement();\n        if (body) {\n          editor.save({ is_removing: true });\n        }\n        editor.removed = true;\n        editor.unbindAllNativeEvents();\n        if (editor.hasHiddenInput && element) {\n          DOM$8.remove(element.nextSibling);\n        }\n        fireRemove(editor);\n        editor.editorManager.remove(editor);\n        if (!editor.inline && body) {\n          restoreOriginalStyles(editor);\n        }\n        fireDetach(editor);\n        DOM$8.remove(editor.getContainer());\n        safeDestroy(_selectionOverrides);\n        safeDestroy(editorUpload);\n        editor.destroy();\n      }\n    };\n    const destroy = (editor, automatic) => {\n      const {selection, dom} = editor;\n      if (editor.destroyed) {\n        return;\n      }\n      if (!automatic && !editor.removed) {\n        editor.remove();\n        return;\n      }\n      if (!automatic) {\n        editor.editorManager.off('beforeunload', editor._beforeUnload);\n        if (editor.theme && editor.theme.destroy) {\n          editor.theme.destroy();\n        }\n        safeDestroy(selection);\n        safeDestroy(dom);\n      }\n      restoreForm(editor);\n      clearDomReferences(editor);\n      editor.destroyed = true;\n    };\n\n    const CreateIconManager = () => {\n      const lookup = {};\n      const add = (id, iconPack) => {\n        lookup[id] = iconPack;\n      };\n      const get = id => {\n        if (lookup[id]) {\n          return lookup[id];\n        }\n        return { icons: {} };\n      };\n      const has = id => has$2(lookup, id);\n      return {\n        add,\n        get,\n        has\n      };\n    };\n    const IconManager = CreateIconManager();\n\n    const ModelManager = AddOnManager.ModelManager;\n\n    const getProp = (propName, elm) => {\n      const rawElm = elm.dom;\n      return rawElm[propName];\n    };\n    const getComputedSizeProp = (propName, elm) => parseInt(get$7(elm, propName), 10);\n    const getClientWidth = curry(getProp, 'clientWidth');\n    const getClientHeight = curry(getProp, 'clientHeight');\n    const getMarginTop = curry(getComputedSizeProp, 'margin-top');\n    const getMarginLeft = curry(getComputedSizeProp, 'margin-left');\n    const getBoundingClientRect = elm => elm.dom.getBoundingClientRect();\n    const isInsideElementContentArea = (bodyElm, clientX, clientY) => {\n      const clientWidth = getClientWidth(bodyElm);\n      const clientHeight = getClientHeight(bodyElm);\n      return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;\n    };\n    const transpose = (inline, elm, clientX, clientY) => {\n      const clientRect = getBoundingClientRect(elm);\n      const deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;\n      const deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;\n      const x = clientX - deltaX;\n      const y = clientY - deltaY;\n      return {\n        x,\n        y\n      };\n    };\n    const isXYInContentArea = (editor, clientX, clientY) => {\n      const bodyElm = SugarElement.fromDom(editor.getBody());\n      const targetElm = editor.inline ? bodyElm : documentElement(bodyElm);\n      const transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);\n      return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);\n    };\n    const fromDomSafe = node => Optional.from(node).map(SugarElement.fromDom);\n    const isEditorAttachedToDom = editor => {\n      const rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();\n      return fromDomSafe(rawContainer).map(inBody).getOr(false);\n    };\n\n    const NotificationManagerImpl = () => {\n      const unimplemented = () => {\n        throw new Error('Theme did not provide a NotificationManager implementation.');\n      };\n      return {\n        open: unimplemented,\n        close: unimplemented,\n        getArgs: unimplemented\n      };\n    };\n\n    const NotificationManager = editor => {\n      const notifications = [];\n      const getImplementation = () => {\n        const theme = editor.theme;\n        return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();\n      };\n      const getTopNotification = () => {\n        return Optional.from(notifications[0]);\n      };\n      const isEqual = (a, b) => {\n        return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;\n      };\n      const reposition = () => {\n        each$g(notifications, notification => {\n          notification.reposition();\n        });\n      };\n      const addNotification = notification => {\n        notifications.push(notification);\n      };\n      const closeNotification = notification => {\n        findIndex$2(notifications, otherNotification => {\n          return otherNotification === notification;\n        }).each(index => {\n          notifications.splice(index, 1);\n        });\n      };\n      const open = (spec, fireEvent = true) => {\n        if (editor.removed || !isEditorAttachedToDom(editor)) {\n          return;\n        }\n        if (fireEvent) {\n          editor.dispatch('BeforeOpenNotification', { notification: spec });\n        }\n        return find$2(notifications, notification => {\n          return isEqual(getImplementation().getArgs(notification), spec);\n        }).getOrThunk(() => {\n          editor.editorManager.setActive(editor);\n          const notification = getImplementation().open(spec, () => {\n            closeNotification(notification);\n            reposition();\n            getTopNotification().fold(() => editor.focus(), top => focus$1(SugarElement.fromDom(top.getEl())));\n          });\n          addNotification(notification);\n          reposition();\n          editor.dispatch('OpenNotification', { notification: { ...notification } });\n          return notification;\n        });\n      };\n      const close = () => {\n        getTopNotification().each(notification => {\n          getImplementation().close(notification);\n          closeNotification(notification);\n          reposition();\n        });\n      };\n      const getNotifications = constant(notifications);\n      const registerEvents = editor => {\n        editor.on('SkinLoaded', () => {\n          const serviceMessage = getServiceMessage(editor);\n          if (serviceMessage) {\n            open({\n              text: serviceMessage,\n              type: 'warning',\n              timeout: 0\n            }, false);\n          }\n          reposition();\n        });\n        editor.on('show ResizeEditor ResizeWindow NodeChange', () => {\n          requestAnimationFrame(reposition);\n        });\n        editor.on('remove', () => {\n          each$g(notifications.slice(), notification => {\n            getImplementation().close(notification);\n          });\n        });\n      };\n      registerEvents(editor);\n      return {\n        open,\n        close,\n        getNotifications\n      };\n    };\n\n    const PluginManager = AddOnManager.PluginManager;\n\n    const ThemeManager = AddOnManager.ThemeManager;\n\n    var WindowManagerImpl = () => {\n      const unimplemented = () => {\n        throw new Error('Theme did not provide a WindowManager implementation.');\n      };\n      return {\n        open: unimplemented,\n        openUrl: unimplemented,\n        alert: unimplemented,\n        confirm: unimplemented,\n        close: unimplemented,\n        getParams: unimplemented,\n        setParams: unimplemented\n      };\n    };\n\n    const WindowManager = editor => {\n      let dialogs = [];\n      const getImplementation = () => {\n        const theme = editor.theme;\n        return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();\n      };\n      const funcBind = (scope, f) => {\n        return (...args) => {\n          return f ? f.apply(scope, args) : undefined;\n        };\n      };\n      const fireOpenEvent = dialog => {\n        editor.dispatch('OpenWindow', { dialog });\n      };\n      const fireCloseEvent = dialog => {\n        editor.dispatch('CloseWindow', { dialog });\n      };\n      const addDialog = dialog => {\n        dialogs.push(dialog);\n        fireOpenEvent(dialog);\n      };\n      const closeDialog = dialog => {\n        fireCloseEvent(dialog);\n        dialogs = filter$6(dialogs, otherDialog => {\n          return otherDialog !== dialog;\n        });\n        if (dialogs.length === 0) {\n          editor.focus();\n        }\n      };\n      const getTopDialog = () => {\n        return Optional.from(dialogs[dialogs.length - 1]);\n      };\n      const storeSelectionAndOpenDialog = openDialog => {\n        editor.editorManager.setActive(editor);\n        store(editor);\n        editor.ui.show();\n        const dialog = openDialog();\n        addDialog(dialog);\n        return dialog;\n      };\n      const open = (args, params) => {\n        return storeSelectionAndOpenDialog(() => getImplementation().open(args, params, closeDialog));\n      };\n      const openUrl = args => {\n        return storeSelectionAndOpenDialog(() => getImplementation().openUrl(args, closeDialog));\n      };\n      const alert = (message, callback, scope) => {\n        const windowManagerImpl = getImplementation();\n        windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));\n      };\n      const confirm = (message, callback, scope) => {\n        const windowManagerImpl = getImplementation();\n        windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));\n      };\n      const close = () => {\n        getTopDialog().each(dialog => {\n          getImplementation().close(dialog);\n          closeDialog(dialog);\n        });\n      };\n      editor.on('remove', () => {\n        each$g(dialogs, dialog => {\n          getImplementation().close(dialog);\n        });\n      });\n      return {\n        open,\n        openUrl,\n        alert,\n        confirm,\n        close\n      };\n    };\n\n    const displayNotification = (editor, message) => {\n      editor.notificationManager.open({\n        type: 'error',\n        text: message\n      });\n    };\n    const displayError = (editor, message) => {\n      if (editor._skinLoaded) {\n        displayNotification(editor, message);\n      } else {\n        editor.on('SkinLoaded', () => {\n          displayNotification(editor, message);\n        });\n      }\n    };\n    const uploadError = (editor, message) => {\n      displayError(editor, I18n.translate([\n        'Failed to upload image: {0}',\n        message\n      ]));\n    };\n    const logError = (editor, errorType, msg) => {\n      fireError(editor, errorType, { message: msg });\n      console.error(msg);\n    };\n    const createLoadError = (type, url, name) => name ? `Failed to load ${ type }: ${ name } from url ${ url }` : `Failed to load ${ type } url: ${ url }`;\n    const pluginLoadError = (editor, url, name) => {\n      logError(editor, 'PluginLoadError', createLoadError('plugin', url, name));\n    };\n    const iconsLoadError = (editor, url, name) => {\n      logError(editor, 'IconsLoadError', createLoadError('icons', url, name));\n    };\n    const languageLoadError = (editor, url, name) => {\n      logError(editor, 'LanguageLoadError', createLoadError('language', url, name));\n    };\n    const themeLoadError = (editor, url, name) => {\n      logError(editor, 'ThemeLoadError', createLoadError('theme', url, name));\n    };\n    const modelLoadError = (editor, url, name) => {\n      logError(editor, 'ModelLoadError', createLoadError('model', url, name));\n    };\n    const pluginInitError = (editor, name, err) => {\n      const message = I18n.translate([\n        'Failed to initialize plugin: {0}',\n        name\n      ]);\n      fireError(editor, 'PluginLoadError', { message });\n      initError(message, err);\n      displayError(editor, message);\n    };\n    const initError = (message, ...x) => {\n      const console = window.console;\n      if (console) {\n        if (console.error) {\n          console.error(message, ...x);\n        } else {\n          console.log(message, ...x);\n        }\n      }\n    };\n\n    const isContentCssSkinName = url => /^[a-z0-9\\-]+$/i.test(url);\n    const getContentCssUrls = editor => {\n      return transformToUrls(editor, getContentCss(editor));\n    };\n    const getFontCssUrls = editor => {\n      return transformToUrls(editor, getFontCss(editor));\n    };\n    const transformToUrls = (editor, cssLinks) => {\n      const skinUrl = editor.editorManager.baseURL + '/skins/content';\n      const suffix = editor.editorManager.suffix;\n      const contentCssFile = `content${ suffix }.css`;\n      const inline = editor.inline === true;\n      return map$3(cssLinks, url => {\n        if (isContentCssSkinName(url) && !inline) {\n          return `${ skinUrl }/${ url }/${ contentCssFile }`;\n        } else {\n          return editor.documentBaseURI.toAbsolute(url);\n        }\n      });\n    };\n    const appendContentCssFromSettings = editor => {\n      editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));\n    };\n\n    const filter$1 = always;\n    const bind$1 = (element, event, handler) => bind$2(element, event, filter$1, handler);\n\n    const UploadStatus = () => {\n      const PENDING = 1, UPLOADED = 2;\n      let blobUriStatuses = {};\n      const createStatus = (status, resultUri) => {\n        return {\n          status,\n          resultUri\n        };\n      };\n      const hasBlobUri = blobUri => {\n        return blobUri in blobUriStatuses;\n      };\n      const getResultUri = blobUri => {\n        const result = blobUriStatuses[blobUri];\n        return result ? result.resultUri : null;\n      };\n      const isPending = blobUri => {\n        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;\n      };\n      const isUploaded = blobUri => {\n        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;\n      };\n      const markPending = blobUri => {\n        blobUriStatuses[blobUri] = createStatus(PENDING, null);\n      };\n      const markUploaded = (blobUri, resultUri) => {\n        blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);\n      };\n      const removeFailed = blobUri => {\n        delete blobUriStatuses[blobUri];\n      };\n      const destroy = () => {\n        blobUriStatuses = {};\n      };\n      return {\n        hasBlobUri,\n        getResultUri,\n        isPending,\n        isUploaded,\n        markPending,\n        markUploaded,\n        removeFailed,\n        destroy\n      };\n    };\n\n    let count = 0;\n    const seed = () => {\n      const rnd = () => {\n        return Math.round(Math.random() * 4294967295).toString(36);\n      };\n      const now = new Date().getTime();\n      return 's' + now.toString(36) + rnd() + rnd() + rnd();\n    };\n    const uuid = prefix => {\n      return prefix + count++ + seed();\n    };\n\n    const BlobCache = () => {\n      let cache = [];\n      const mimeToExt = mime => {\n        const mimes = {\n          'image/jpeg': 'jpg',\n          'image/jpg': 'jpg',\n          'image/gif': 'gif',\n          'image/png': 'png',\n          'image/apng': 'apng',\n          'image/avif': 'avif',\n          'image/svg+xml': 'svg',\n          'image/webp': 'webp',\n          'image/bmp': 'bmp',\n          'image/tiff': 'tiff'\n        };\n        return mimes[mime.toLowerCase()] || 'dat';\n      };\n      const create = (o, blob, base64, name, filename) => {\n        if (isString(o)) {\n          const id = o;\n          return toBlobInfo({\n            id,\n            name,\n            filename,\n            blob,\n            base64\n          });\n        } else if (isObject(o)) {\n          return toBlobInfo(o);\n        } else {\n          throw new Error('Unknown input type');\n        }\n      };\n      const toBlobInfo = o => {\n        if (!o.blob || !o.base64) {\n          throw new Error('blob and base64 representations of the image are required for BlobInfo to be created');\n        }\n        const id = o.id || uuid('blobid');\n        const name = o.name || id;\n        const blob = o.blob;\n        return {\n          id: constant(id),\n          name: constant(name),\n          filename: constant(o.filename || name + '.' + mimeToExt(blob.type)),\n          blob: constant(blob),\n          base64: constant(o.base64),\n          blobUri: constant(o.blobUri || URL.createObjectURL(blob)),\n          uri: constant(o.uri)\n        };\n      };\n      const add = blobInfo => {\n        if (!get(blobInfo.id())) {\n          cache.push(blobInfo);\n        }\n      };\n      const findFirst = predicate => find$2(cache, predicate).getOrUndefined();\n      const get = id => findFirst(cachedBlobInfo => cachedBlobInfo.id() === id);\n      const getByUri = blobUri => findFirst(blobInfo => blobInfo.blobUri() === blobUri);\n      const getByData = (base64, type) => findFirst(blobInfo => blobInfo.base64() === base64 && blobInfo.blob().type === type);\n      const removeByUri = blobUri => {\n        cache = filter$6(cache, blobInfo => {\n          if (blobInfo.blobUri() === blobUri) {\n            URL.revokeObjectURL(blobInfo.blobUri());\n            return false;\n          }\n          return true;\n        });\n      };\n      const destroy = () => {\n        each$g(cache, cachedBlobInfo => {\n          URL.revokeObjectURL(cachedBlobInfo.blobUri());\n        });\n        cache = [];\n      };\n      return {\n        create,\n        add,\n        get,\n        getByUri,\n        getByData,\n        findFirst,\n        removeByUri,\n        destroy\n      };\n    };\n\n    const Uploader = (uploadStatus, settings) => {\n      const pendingPromises = {};\n      const pathJoin = (path1, path2) => {\n        if (path1) {\n          return path1.replace(/\\/$/, '') + '/' + path2.replace(/^\\//, '');\n        }\n        return path2;\n      };\n      const defaultHandler = (blobInfo, progress) => new Promise((success, failure) => {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', settings.url);\n        xhr.withCredentials = settings.credentials;\n        xhr.upload.onprogress = e => {\n          progress(e.loaded / e.total * 100);\n        };\n        xhr.onerror = () => {\n          failure('Image upload failed due to a XHR Transport error. Code: ' + xhr.status);\n        };\n        xhr.onload = () => {\n          if (xhr.status < 200 || xhr.status >= 300) {\n            failure('HTTP Error: ' + xhr.status);\n            return;\n          }\n          const json = JSON.parse(xhr.responseText);\n          if (!json || !isString(json.location)) {\n            failure('Invalid JSON: ' + xhr.responseText);\n            return;\n          }\n          success(pathJoin(settings.basePath, json.location));\n        };\n        const formData = new FormData();\n        formData.append('file', blobInfo.blob(), blobInfo.filename());\n        xhr.send(formData);\n      });\n      const noUpload = () => new Promise(resolve => {\n        resolve([]);\n      });\n      const handlerSuccess = (blobInfo, url) => ({\n        url,\n        blobInfo,\n        status: true\n      });\n      const handlerFailure = (blobInfo, error) => ({\n        url: '',\n        blobInfo,\n        status: false,\n        error\n      });\n      const resolvePending = (blobUri, result) => {\n        Tools.each(pendingPromises[blobUri], resolve => {\n          resolve(result);\n        });\n        delete pendingPromises[blobUri];\n      };\n      const uploadBlobInfo = (blobInfo, handler, openNotification) => {\n        uploadStatus.markPending(blobInfo.blobUri());\n        return new Promise(resolve => {\n          let notification;\n          let progress;\n          try {\n            const closeNotification = () => {\n              if (notification) {\n                notification.close();\n                progress = noop;\n              }\n            };\n            const success = url => {\n              closeNotification();\n              uploadStatus.markUploaded(blobInfo.blobUri(), url);\n              resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));\n              resolve(handlerSuccess(blobInfo, url));\n            };\n            const failure = error => {\n              closeNotification();\n              uploadStatus.removeFailed(blobInfo.blobUri());\n              resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error));\n              resolve(handlerFailure(blobInfo, error));\n            };\n            progress = percent => {\n              if (percent < 0 || percent > 100) {\n                return;\n              }\n              Optional.from(notification).orThunk(() => Optional.from(openNotification).map(apply$1)).each(n => {\n                notification = n;\n                n.progressBar.value(percent);\n              });\n            };\n            handler(blobInfo, progress).then(success, err => {\n              failure(isString(err) ? { message: err } : err);\n            });\n          } catch (ex) {\n            resolve(handlerFailure(blobInfo, ex));\n          }\n        });\n      };\n      const isDefaultHandler = handler => handler === defaultHandler;\n      const pendingUploadBlobInfo = blobInfo => {\n        const blobUri = blobInfo.blobUri();\n        return new Promise(resolve => {\n          pendingPromises[blobUri] = pendingPromises[blobUri] || [];\n          pendingPromises[blobUri].push(resolve);\n        });\n      };\n      const uploadBlobs = (blobInfos, openNotification) => {\n        blobInfos = Tools.grep(blobInfos, blobInfo => !uploadStatus.isUploaded(blobInfo.blobUri()));\n        return Promise.all(Tools.map(blobInfos, blobInfo => uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, settings.handler, openNotification)));\n      };\n      const upload = (blobInfos, openNotification) => !settings.url && isDefaultHandler(settings.handler) ? noUpload() : uploadBlobs(blobInfos, openNotification);\n      if (isFunction(settings.handler) === false) {\n        settings.handler = defaultHandler;\n      }\n      return { upload };\n    };\n\n    const openNotification = editor => () => editor.notificationManager.open({\n      text: editor.translate('Image uploading...'),\n      type: 'info',\n      timeout: -1,\n      progressBar: true\n    });\n    const createUploader = (editor, uploadStatus) => Uploader(uploadStatus, {\n      url: getImageUploadUrl(editor),\n      basePath: getImageUploadBasePath(editor),\n      credentials: getImagesUploadCredentials(editor),\n      handler: getImagesUploadHandler(editor)\n    });\n    const ImageUploader = editor => {\n      const uploadStatus = UploadStatus();\n      const uploader = createUploader(editor, uploadStatus);\n      return { upload: (blobInfos, showNotification = true) => uploader.upload(blobInfos, showNotification ? openNotification(editor) : undefined) };\n    };\n\n    const UploadChangeHandler = editor => {\n      const lastChangedLevel = Cell(null);\n      editor.on('change AddUndo', e => {\n        lastChangedLevel.set({ ...e.level });\n      });\n      const fireIfChanged = () => {\n        const data = editor.undoManager.data;\n        last$3(data).filter(level => {\n          return !isEq$1(lastChangedLevel.get(), level);\n        }).each(level => {\n          editor.setDirty(true);\n          editor.dispatch('change', {\n            level,\n            lastLevel: get$b(data, data.length - 2).getOrNull()\n          });\n        });\n      };\n      return { fireIfChanged };\n    };\n    const EditorUpload = editor => {\n      const blobCache = BlobCache();\n      let uploader, imageScanner;\n      const uploadStatus = UploadStatus();\n      const urlFilters = [];\n      const changeHandler = UploadChangeHandler(editor);\n      const aliveGuard = callback => {\n        return result => {\n          if (editor.selection) {\n            return callback(result);\n          }\n          return [];\n        };\n      };\n      const cacheInvalidator = url => url + (url.indexOf('?') === -1 ? '?' : '&') + new Date().getTime();\n      const replaceString = (content, search, replace) => {\n        let index = 0;\n        do {\n          index = content.indexOf(search, index);\n          if (index !== -1) {\n            content = content.substring(0, index) + replace + content.substr(index + search.length);\n            index += replace.length - search.length + 1;\n          }\n        } while (index !== -1);\n        return content;\n      };\n      const replaceImageUrl = (content, targetUrl, replacementUrl) => {\n        const replacementString = `src=\"${ replacementUrl }\"${ replacementUrl === Env.transparentSrc ? ' data-mce-placeholder=\"1\"' : '' }`;\n        content = replaceString(content, `src=\"${ targetUrl }\"`, replacementString);\n        content = replaceString(content, 'data-mce-src=\"' + targetUrl + '\"', 'data-mce-src=\"' + replacementUrl + '\"');\n        return content;\n      };\n      const replaceUrlInUndoStack = (targetUrl, replacementUrl) => {\n        each$g(editor.undoManager.data, level => {\n          if (level.type === 'fragmented') {\n            level.fragments = map$3(level.fragments, fragment => replaceImageUrl(fragment, targetUrl, replacementUrl));\n          } else {\n            level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);\n          }\n        });\n      };\n      const replaceImageUriInView = (image, resultUri) => {\n        const src = editor.convertURL(resultUri, 'src');\n        replaceUrlInUndoStack(image.src, resultUri);\n        setAll$1(SugarElement.fromDom(image), {\n          'src': shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,\n          'data-mce-src': src\n        });\n      };\n      const uploadImages = () => {\n        if (!uploader) {\n          uploader = createUploader(editor, uploadStatus);\n        }\n        return scanForImages().then(aliveGuard(imageInfos => {\n          const blobInfos = map$3(imageInfos, imageInfo => imageInfo.blobInfo);\n          return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard(result => {\n            const imagesToRemove = [];\n            const filteredResult = map$3(result, (uploadInfo, index) => {\n              const blobInfo = imageInfos[index].blobInfo;\n              const image = imageInfos[index].image;\n              let removed = false;\n              if (uploadInfo.status && shouldReplaceBlobUris(editor)) {\n                blobCache.removeByUri(image.src);\n                if (isRtc(editor)) ; else {\n                  replaceImageUriInView(image, uploadInfo.url);\n                }\n              } else if (uploadInfo.error) {\n                if (uploadInfo.error.remove) {\n                  replaceUrlInUndoStack(image.getAttribute('src'), Env.transparentSrc);\n                  imagesToRemove.push(image);\n                  removed = true;\n                }\n                uploadError(editor, uploadInfo.error.message);\n              }\n              return {\n                element: image,\n                status: uploadInfo.status,\n                uploadUri: uploadInfo.url,\n                blobInfo,\n                removed\n              };\n            });\n            if (filteredResult.length > 0) {\n              changeHandler.fireIfChanged();\n            }\n            if (imagesToRemove.length > 0 && !isRtc(editor)) {\n              editor.undoManager.transact(() => {\n                each$g(imagesToRemove, element => {\n                  editor.dom.remove(element);\n                  blobCache.removeByUri(element.src);\n                });\n              });\n            }\n            return filteredResult;\n          }));\n        }));\n      };\n      const uploadImagesAuto = () => isAutomaticUploadsEnabled(editor) ? uploadImages() : Promise.resolve([]);\n      const isValidDataUriImage = imgElm => forall(urlFilters, filter => filter(imgElm));\n      const addFilter = filter => {\n        urlFilters.push(filter);\n      };\n      const scanForImages = () => {\n        if (!imageScanner) {\n          imageScanner = ImageScanner(uploadStatus, blobCache);\n        }\n        return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(result => {\n          result = filter$6(result, resultItem => {\n            if (typeof resultItem === 'string') {\n              displayError(editor, resultItem);\n              return false;\n            }\n            return true;\n          });\n          if (isRtc(editor)) ; else {\n            each$g(result, resultItem => {\n              replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());\n              resultItem.image.src = resultItem.blobInfo.blobUri();\n              resultItem.image.removeAttribute('data-mce-src');\n            });\n          }\n          return result;\n        }));\n      };\n      const destroy = () => {\n        blobCache.destroy();\n        uploadStatus.destroy();\n        imageScanner = uploader = null;\n      };\n      const replaceBlobUris = content => {\n        return content.replace(/src=\"(blob:[^\"]+)\"/g, (match, blobUri) => {\n          const resultUri = uploadStatus.getResultUri(blobUri);\n          if (resultUri) {\n            return 'src=\"' + resultUri + '\"';\n          }\n          let blobInfo = blobCache.getByUri(blobUri);\n          if (!blobInfo) {\n            blobInfo = foldl(editor.editorManager.get(), (result, editor) => {\n              return result || editor.editorUpload && editor.editorUpload.blobCache.getByUri(blobUri);\n            }, null);\n          }\n          if (blobInfo) {\n            const blob = blobInfo.blob();\n            return 'src=\"data:' + blob.type + ';base64,' + blobInfo.base64() + '\"';\n          }\n          return match;\n        });\n      };\n      editor.on('SetContent', () => {\n        if (isAutomaticUploadsEnabled(editor)) {\n          uploadImagesAuto();\n        } else {\n          scanForImages();\n        }\n      });\n      editor.on('RawSaveContent', e => {\n        e.content = replaceBlobUris(e.content);\n      });\n      editor.on('GetContent', e => {\n        if (e.source_view || e.format === 'raw' || e.format === 'tree') {\n          return;\n        }\n        e.content = replaceBlobUris(e.content);\n      });\n      editor.on('PostRender', () => {\n        editor.parser.addNodeFilter('img', images => {\n          each$g(images, img => {\n            const src = img.attr('src');\n            if (blobCache.getByUri(src)) {\n              return;\n            }\n            const resultUri = uploadStatus.getResultUri(src);\n            if (resultUri) {\n              img.attr('src', resultUri);\n            }\n          });\n        });\n      });\n      return {\n        blobCache,\n        addFilter,\n        uploadImages,\n        uploadImagesAuto,\n        scanForImages,\n        destroy\n      };\n    };\n\n    const get$1 = editor => {\n      const dom = editor.dom;\n      const schemaType = editor.schema.type;\n      const formats = {\n        valigntop: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'top' }\n          }],\n        valignmiddle: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'middle' }\n          }],\n        valignbottom: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'bottom' }\n          }],\n        alignleft: [\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-left',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',\n            styles: { textAlign: 'left' },\n            inherit: false,\n            preview: false\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: { float: 'left' },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginLeft: '0px',\n              marginRight: 'auto'\n            },\n            onformat: table => {\n              dom.setStyle(table, 'float', null);\n            },\n            preview: 'font-family font-size'\n          }\n        ],\n        aligncenter: [\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',\n            styles: { textAlign: 'center' },\n            inherit: false,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-center',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: {\n              display: 'block',\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: false\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: 'font-family font-size'\n          }\n        ],\n        alignright: [\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-right',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',\n            styles: { textAlign: 'right' },\n            inherit: false,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: { float: 'right' },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginRight: '0px',\n              marginLeft: 'auto'\n            },\n            onformat: table => {\n              dom.setStyle(table, 'float', null);\n            },\n            preview: 'font-family font-size'\n          }\n        ],\n        alignjustify: [{\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',\n            styles: { textAlign: 'justify' },\n            inherit: false,\n            preview: 'font-family font-size'\n          }],\n        bold: [\n          {\n            inline: 'strong',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          },\n          {\n            inline: 'span',\n            styles: { fontWeight: 'bold' }\n          },\n          {\n            inline: 'b',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        italic: [\n          {\n            inline: 'em',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          },\n          {\n            inline: 'span',\n            styles: { fontStyle: 'italic' }\n          },\n          {\n            inline: 'i',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        underline: [\n          {\n            inline: 'span',\n            styles: { textDecoration: 'underline' },\n            exact: true\n          },\n          {\n            inline: 'u',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        strikethrough: (() => {\n          const span = {\n            inline: 'span',\n            styles: { textDecoration: 'line-through' },\n            exact: true\n          };\n          const strike = {\n            inline: 'strike',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          };\n          const s = {\n            inline: 's',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          };\n          return schemaType !== 'html4' ? [\n            s,\n            span,\n            strike\n          ] : [\n            span,\n            s,\n            strike\n          ];\n        })(),\n        forecolor: {\n          inline: 'span',\n          styles: { color: '%value' },\n          links: true,\n          remove_similar: true,\n          clear_child_styles: true\n        },\n        hilitecolor: {\n          inline: 'span',\n          styles: { backgroundColor: '%value' },\n          links: true,\n          remove_similar: true,\n          clear_child_styles: true\n        },\n        fontname: {\n          inline: 'span',\n          toggle: false,\n          styles: { fontFamily: '%value' },\n          clear_child_styles: true\n        },\n        fontsize: {\n          inline: 'span',\n          toggle: false,\n          styles: { fontSize: '%value' },\n          clear_child_styles: true\n        },\n        lineheight: {\n          selector: 'h1,h2,h3,h4,h5,h6,p,li,td,th,div',\n          styles: { lineHeight: '%value' }\n        },\n        fontsize_class: {\n          inline: 'span',\n          attributes: { class: '%value' }\n        },\n        blockquote: {\n          block: 'blockquote',\n          wrapper: true,\n          remove: 'all'\n        },\n        subscript: { inline: 'sub' },\n        superscript: { inline: 'sup' },\n        code: { inline: 'code' },\n        link: {\n          inline: 'a',\n          selector: 'a',\n          remove: 'all',\n          split: true,\n          deep: true,\n          onmatch: (node, _fmt, _itemName) => {\n            return isElement$6(node) && node.hasAttribute('href');\n          },\n          onformat: (elm, _fmt, vars) => {\n            Tools.each(vars, (value, key) => {\n              dom.setAttrib(elm, key, value);\n            });\n          }\n        },\n        lang: {\n          inline: 'span',\n          clear_child_styles: true,\n          remove_similar: true,\n          attributes: {\n            'lang': '%value',\n            'data-mce-lang': vars => {\n              var _a;\n              return (_a = vars === null || vars === void 0 ? void 0 : vars.customValue) !== null && _a !== void 0 ? _a : null;\n            }\n          }\n        },\n        removeformat: [\n          {\n            selector: 'b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small',\n            remove: 'all',\n            split: true,\n            expand: false,\n            block_expand: true,\n            deep: true\n          },\n          {\n            selector: 'span',\n            attributes: [\n              'style',\n              'class'\n            ],\n            remove: 'empty',\n            split: true,\n            expand: false,\n            deep: true\n          },\n          {\n            selector: '*',\n            attributes: [\n              'style',\n              'class'\n            ],\n            split: false,\n            expand: false,\n            deep: true\n          }\n        ]\n      };\n      Tools.each('p h1 h2 h3 h4 h5 h6 div address pre dt dd samp'.split(/\\s/), name => {\n        formats[name] = {\n          block: name,\n          remove: 'all'\n        };\n      });\n      return formats;\n    };\n\n    const genericBase = {\n      remove_similar: true,\n      inherit: false\n    };\n    const cellBase = {\n      selector: 'td,th',\n      ...genericBase\n    };\n    const cellFormats = {\n      tablecellbackgroundcolor: {\n        styles: { backgroundColor: '%value' },\n        ...cellBase\n      },\n      tablecellverticalalign: {\n        styles: { 'vertical-align': '%value' },\n        ...cellBase\n      },\n      tablecellbordercolor: {\n        styles: { borderColor: '%value' },\n        ...cellBase\n      },\n      tablecellclass: {\n        classes: ['%value'],\n        ...cellBase\n      },\n      tableclass: {\n        selector: 'table',\n        classes: ['%value'],\n        ...genericBase\n      },\n      tablecellborderstyle: {\n        styles: { borderStyle: '%value' },\n        ...cellBase\n      },\n      tablecellborderwidth: {\n        styles: { borderWidth: '%value' },\n        ...cellBase\n      }\n    };\n    const get = constant(cellFormats);\n\n    const FormatRegistry = editor => {\n      const formats = {};\n      const get$2 = name => isNonNullable(name) ? formats[name] : formats;\n      const has = name => has$2(formats, name);\n      const register = (name, format) => {\n        if (name) {\n          if (!isString(name)) {\n            each$f(name, (format, name) => {\n              register(name, format);\n            });\n          } else {\n            if (!isArray$1(format)) {\n              format = [format];\n            }\n            each$g(format, format => {\n              if (isUndefined(format.deep)) {\n                format.deep = !isSelectorFormat(format);\n              }\n              if (isUndefined(format.split)) {\n                format.split = !isSelectorFormat(format) || isInlineFormat(format);\n              }\n              if (isUndefined(format.remove) && isSelectorFormat(format) && !isInlineFormat(format)) {\n                format.remove = 'none';\n              }\n              if (isSelectorFormat(format) && isInlineFormat(format)) {\n                format.mixed = true;\n                format.block_expand = true;\n              }\n              if (isString(format.classes)) {\n                format.classes = format.classes.split(/\\s+/);\n              }\n            });\n            formats[name] = format;\n          }\n        }\n      };\n      const unregister = name => {\n        if (name && formats[name]) {\n          delete formats[name];\n        }\n        return formats;\n      };\n      register(get$1(editor));\n      register(get());\n      register(getFormats(editor));\n      return {\n        get: get$2,\n        has,\n        register,\n        unregister\n      };\n    };\n\n    const each$3 = Tools.each;\n    const dom = DOMUtils.DOM;\n    const parsedSelectorToHtml = (ancestry, editor) => {\n      let elm, item, fragment;\n      const schema = editor && editor.schema || Schema({});\n      const decorate = (elm, item) => {\n        if (item.classes.length) {\n          dom.addClass(elm, item.classes.join(' '));\n        }\n        dom.setAttribs(elm, item.attrs);\n      };\n      const createElement = sItem => {\n        item = typeof sItem === 'string' ? {\n          name: sItem,\n          classes: [],\n          attrs: {}\n        } : sItem;\n        const elm = dom.create(item.name);\n        decorate(elm, item);\n        return elm;\n      };\n      const getRequiredParent = (elm, candidate) => {\n        const name = typeof elm !== 'string' ? elm.nodeName.toLowerCase() : elm;\n        const elmRule = schema.getElementRule(name);\n        const parentsRequired = elmRule && elmRule.parentsRequired;\n        if (parentsRequired && parentsRequired.length) {\n          return candidate && Tools.inArray(parentsRequired, candidate) !== -1 ? candidate : parentsRequired[0];\n        } else {\n          return false;\n        }\n      };\n      const wrapInHtml = (elm, ancestry, siblings) => {\n        let parent, parentCandidate;\n        const ancestor = ancestry.length > 0 && ancestry[0];\n        const ancestorName = ancestor && ancestor.name;\n        const parentRequired = getRequiredParent(elm, ancestorName);\n        if (parentRequired) {\n          if (ancestorName === parentRequired) {\n            parentCandidate = ancestry[0];\n            ancestry = ancestry.slice(1);\n          } else {\n            parentCandidate = parentRequired;\n          }\n        } else if (ancestor) {\n          parentCandidate = ancestry[0];\n          ancestry = ancestry.slice(1);\n        } else if (!siblings) {\n          return elm;\n        }\n        if (parentCandidate) {\n          parent = createElement(parentCandidate);\n          parent.appendChild(elm);\n        }\n        if (siblings) {\n          if (!parent) {\n            parent = dom.create('div');\n            parent.appendChild(elm);\n          }\n          Tools.each(siblings, sibling => {\n            const siblingElm = createElement(sibling);\n            parent.insertBefore(siblingElm, elm);\n          });\n        }\n        return wrapInHtml(parent, ancestry, parentCandidate && parentCandidate.siblings);\n      };\n      if (ancestry && ancestry.length) {\n        item = ancestry[0];\n        elm = createElement(item);\n        fragment = dom.create('div');\n        fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), item.siblings));\n        return fragment;\n      } else {\n        return '';\n      }\n    };\n    const parseSelectorItem = item => {\n      let tagName;\n      const obj = {\n        classes: [],\n        attrs: {}\n      };\n      item = obj.selector = Tools.trim(item);\n      if (item !== '*') {\n        tagName = item.replace(/(?:([#\\.]|::?)([\\w\\-]+)|(\\[)([^\\]]+)\\]?)/g, ($0, $1, $2, $3, $4) => {\n          switch ($1) {\n          case '#':\n            obj.attrs.id = $2;\n            break;\n          case '.':\n            obj.classes.push($2);\n            break;\n          case ':':\n            if (Tools.inArray('checked disabled enabled read-only required'.split(' '), $2) !== -1) {\n              obj.attrs[$2] = $2;\n            }\n            break;\n          }\n          if ($3 === '[') {\n            const m = $4.match(/([\\w\\-]+)(?:\\=\\\"([^\\\"]+))?/);\n            if (m) {\n              obj.attrs[m[1]] = m[2];\n            }\n          }\n          return '';\n        });\n      }\n      obj.name = tagName || 'div';\n      return obj;\n    };\n    const parseSelector = selector => {\n      if (!selector || typeof selector !== 'string') {\n        return [];\n      }\n      selector = selector.split(/\\s*,\\s*/)[0];\n      selector = selector.replace(/\\s*(~\\+|~|\\+|>)\\s*/g, '$1');\n      return Tools.map(selector.split(/(?:>|\\s+(?![^\\[\\]]+\\]))/), item => {\n        const siblings = Tools.map(item.split(/(?:~\\+|~|\\+)/), parseSelectorItem);\n        const obj = siblings.pop();\n        if (siblings.length) {\n          obj.siblings = siblings;\n        }\n        return obj;\n      }).reverse();\n    };\n    const getCssText = (editor, format) => {\n      let name, previewFrag;\n      let previewCss = '', parentFontSize;\n      let previewStyles = getPreviewStyles(editor);\n      if (previewStyles === '') {\n        return '';\n      }\n      const removeVars = val => {\n        return val.replace(/%(\\w+)/g, '');\n      };\n      if (typeof format === 'string') {\n        format = editor.formatter.get(format);\n        if (!format) {\n          return;\n        }\n        format = format[0];\n      }\n      if ('preview' in format) {\n        const previewOpt = get$a(format, 'preview');\n        if (is$2(previewOpt, false)) {\n          return '';\n        } else {\n          previewStyles = previewOpt.getOr(previewStyles);\n        }\n      }\n      name = format.block || format.inline || 'span';\n      const items = parseSelector(format.selector);\n      if (items.length) {\n        if (!items[0].name) {\n          items[0].name = name;\n        }\n        name = format.selector;\n        previewFrag = parsedSelectorToHtml(items, editor);\n      } else {\n        previewFrag = parsedSelectorToHtml([name], editor);\n      }\n      const previewElm = dom.select(name, previewFrag)[0] || previewFrag.firstChild;\n      each$3(format.styles, (value, name) => {\n        const newValue = removeVars(value);\n        if (newValue) {\n          dom.setStyle(previewElm, name, newValue);\n        }\n      });\n      each$3(format.attributes, (value, name) => {\n        const newValue = removeVars(value);\n        if (newValue) {\n          dom.setAttrib(previewElm, name, newValue);\n        }\n      });\n      each$3(format.classes, value => {\n        const newValue = removeVars(value);\n        if (!dom.hasClass(previewElm, newValue)) {\n          dom.addClass(previewElm, newValue);\n        }\n      });\n      editor.dispatch('PreviewFormats');\n      dom.setStyles(previewFrag, {\n        position: 'absolute',\n        left: -65535\n      });\n      editor.getBody().appendChild(previewFrag);\n      parentFontSize = dom.getStyle(editor.getBody(), 'fontSize', true);\n      parentFontSize = /px$/.test(parentFontSize) ? parseInt(parentFontSize, 10) : 0;\n      each$3(previewStyles.split(' '), name => {\n        let value = dom.getStyle(previewElm, name, true);\n        if (name === 'background-color' && /transparent|rgba\\s*\\([^)]+,\\s*0\\)/.test(value)) {\n          value = dom.getStyle(editor.getBody(), name, true);\n          if (rgbaToHexString(value).toLowerCase() === '#ffffff') {\n            return;\n          }\n        }\n        if (name === 'color') {\n          if (rgbaToHexString(value).toLowerCase() === '#000000') {\n            return;\n          }\n        }\n        if (name === 'font-size') {\n          if (/em|%$/.test(value)) {\n            if (parentFontSize === 0) {\n              return;\n            }\n            const numValue = parseFloat(value) / (/%$/.test(value) ? 100 : 1);\n            value = numValue * parentFontSize + 'px';\n          }\n        }\n        if (name === 'border' && value) {\n          previewCss += 'padding:0 2px;';\n        }\n        previewCss += name + ':' + value + ';';\n      });\n      editor.dispatch('AfterPreviewFormats');\n      dom.remove(previewFrag);\n      return previewCss;\n    };\n\n    const setup$r = editor => {\n      editor.addShortcut('meta+b', '', 'Bold');\n      editor.addShortcut('meta+i', '', 'Italic');\n      editor.addShortcut('meta+u', '', 'Underline');\n      for (let i = 1; i <= 6; i++) {\n        editor.addShortcut('access+' + i, '', [\n          'FormatBlock',\n          false,\n          'h' + i\n        ]);\n      }\n      editor.addShortcut('access+7', '', [\n        'FormatBlock',\n        false,\n        'p'\n      ]);\n      editor.addShortcut('access+8', '', [\n        'FormatBlock',\n        false,\n        'div'\n      ]);\n      editor.addShortcut('access+9', '', [\n        'FormatBlock',\n        false,\n        'address'\n      ]);\n    };\n\n    const Formatter = editor => {\n      const formats = FormatRegistry(editor);\n      const formatChangeState = Cell(null);\n      setup$r(editor);\n      setup$u(editor);\n      return {\n        get: formats.get,\n        has: formats.has,\n        register: formats.register,\n        unregister: formats.unregister,\n        apply: (name, vars, node) => {\n          applyFormat(editor, name, vars, node);\n        },\n        remove: (name, vars, node, similar) => {\n          removeFormat(editor, name, vars, node, similar);\n        },\n        toggle: (name, vars, node) => {\n          toggleFormat(editor, name, vars, node);\n        },\n        match: (name, vars, node, similar) => matchFormat(editor, name, vars, node, similar),\n        closest: names => closestFormat(editor, names),\n        matchAll: (names, vars) => matchAllFormats(editor, names, vars),\n        matchNode: (node, name, vars, similar) => matchNodeFormat(editor, node, name, vars, similar),\n        canApply: name => canApplyFormat(editor, name),\n        formatChanged: (formats, callback, similar, vars) => formatChanged(editor, formatChangeState, formats, callback, similar, vars),\n        getCssText: curry(getCssText, editor)\n      };\n    };\n\n    const shouldIgnoreCommand = cmd => {\n      switch (cmd.toLowerCase()) {\n      case 'undo':\n      case 'redo':\n      case 'mcefocus':\n        return true;\n      default:\n        return false;\n      }\n    };\n    const registerEvents = (editor, undoManager, locks) => {\n      const isFirstTypedCharacter = Cell(false);\n      const addNonTypingUndoLevel = e => {\n        setTyping(undoManager, false, locks);\n        undoManager.add({}, e);\n      };\n      editor.on('init', () => {\n        undoManager.add();\n      });\n      editor.on('BeforeExecCommand', e => {\n        const cmd = e.command;\n        if (!shouldIgnoreCommand(cmd)) {\n          endTyping(undoManager, locks);\n          undoManager.beforeChange();\n        }\n      });\n      editor.on('ExecCommand', e => {\n        const cmd = e.command;\n        if (!shouldIgnoreCommand(cmd)) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      editor.on('ObjectResizeStart cut', () => {\n        undoManager.beforeChange();\n      });\n      editor.on('SaveContent ObjectResized blur', addNonTypingUndoLevel);\n      editor.on('dragend', addNonTypingUndoLevel);\n      editor.on('keyup', e => {\n        const keyCode = e.keyCode;\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey) {\n          addNonTypingUndoLevel();\n          editor.nodeChanged();\n        }\n        if (keyCode === 46 || keyCode === 8) {\n          editor.nodeChanged();\n        }\n        if (isFirstTypedCharacter.get() && undoManager.typing && isEq$1(createFromEditor(editor), undoManager.data[0]) === false) {\n          if (editor.isDirty() === false) {\n            editor.setDirty(true);\n          }\n          editor.dispatch('TypingUndo');\n          isFirstTypedCharacter.set(false);\n          editor.nodeChanged();\n        }\n      });\n      editor.on('keydown', e => {\n        const keyCode = e.keyCode;\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {\n          if (undoManager.typing) {\n            addNonTypingUndoLevel(e);\n          }\n          return;\n        }\n        const modKey = e.ctrlKey && !e.altKey || e.metaKey;\n        if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {\n          undoManager.beforeChange();\n          setTyping(undoManager, true, locks);\n          undoManager.add({}, e);\n          isFirstTypedCharacter.set(true);\n        }\n      });\n      editor.on('mousedown', e => {\n        if (undoManager.typing) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      const isInsertReplacementText = event => event.inputType === 'insertReplacementText';\n      const isInsertTextDataNull = event => event.inputType === 'insertText' && event.data === null;\n      const isInsertFromPasteOrDrop = event => event.inputType === 'insertFromPaste' || event.inputType === 'insertFromDrop';\n      editor.on('input', e => {\n        if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      editor.on('AddUndo Undo Redo ClearUndos', e => {\n        if (!e.isDefaultPrevented()) {\n          editor.nodeChanged();\n        }\n      });\n    };\n    const addKeyboardShortcuts = editor => {\n      editor.addShortcut('meta+z', '', 'Undo');\n      editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');\n    };\n\n    const UndoManager = editor => {\n      const beforeBookmark = value$2();\n      const locks = Cell(0);\n      const index = Cell(0);\n      const undoManager = {\n        data: [],\n        typing: false,\n        beforeChange: () => {\n          beforeChange(editor, locks, beforeBookmark);\n        },\n        add: (level, event) => {\n          return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);\n        },\n        undo: () => {\n          return undo(editor, undoManager, locks, index);\n        },\n        redo: () => {\n          return redo(editor, index, undoManager.data);\n        },\n        clear: () => {\n          clear(editor, undoManager, index);\n        },\n        reset: () => {\n          reset(editor, undoManager);\n        },\n        hasUndo: () => {\n          return hasUndo(editor, undoManager, index);\n        },\n        hasRedo: () => {\n          return hasRedo(editor, undoManager, index);\n        },\n        transact: callback => {\n          return transact(editor, undoManager, locks, callback);\n        },\n        ignore: callback => {\n          ignore(editor, locks, callback);\n        },\n        extra: (callback1, callback2) => {\n          extra(editor, undoManager, index, callback1, callback2);\n        }\n      };\n      if (!isRtc(editor)) {\n        registerEvents(editor, undoManager, locks);\n      }\n      addKeyboardShortcuts(editor);\n      return undoManager;\n    };\n\n    const nonTypingKeycodes = [\n      9,\n      27,\n      VK.HOME,\n      VK.END,\n      19,\n      20,\n      44,\n      144,\n      145,\n      33,\n      34,\n      45,\n      16,\n      17,\n      18,\n      91,\n      92,\n      93,\n      VK.DOWN,\n      VK.UP,\n      VK.LEFT,\n      VK.RIGHT\n    ].concat(Env.browser.isFirefox() ? [224] : []);\n    const placeholderAttr = 'data-mce-placeholder';\n    const isKeyboardEvent = e => e.type === 'keydown' || e.type === 'keyup';\n    const isDeleteEvent = e => {\n      const keyCode = e.keyCode;\n      return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;\n    };\n    const isNonTypingKeyboardEvent = e => {\n      if (isKeyboardEvent(e)) {\n        const keyCode = e.keyCode;\n        return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains$2(nonTypingKeycodes, keyCode));\n      } else {\n        return false;\n      }\n    };\n    const isTypingKeyboardEvent = e => isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === 'keyup' && e.keyCode === 229);\n    const isVisuallyEmpty = (dom, rootElm, forcedRootBlock) => {\n      if (isEmpty$2(SugarElement.fromDom(rootElm), false)) {\n        const firstElement = rootElm.firstElementChild;\n        if (!firstElement) {\n          return true;\n        } else if (dom.getStyle(rootElm.firstElementChild, 'padding-left') || dom.getStyle(rootElm.firstElementChild, 'padding-right')) {\n          return false;\n        } else {\n          return forcedRootBlock === firstElement.nodeName.toLowerCase();\n        }\n      } else {\n        return false;\n      }\n    };\n    const setup$q = editor => {\n      const dom = editor.dom;\n      const rootBlock = getForcedRootBlock(editor);\n      const placeholder = getPlaceholder(editor);\n      const updatePlaceholder = (e, initial) => {\n        if (isNonTypingKeyboardEvent(e)) {\n          return;\n        }\n        const body = editor.getBody();\n        const showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom, body, rootBlock);\n        const isPlaceholderShown = dom.getAttrib(body, placeholderAttr) !== '';\n        if (isPlaceholderShown !== showPlaceholder || initial) {\n          dom.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);\n          dom.setAttrib(body, 'aria-placeholder', showPlaceholder ? placeholder : null);\n          firePlaceholderToggle(editor, showPlaceholder);\n          editor.on(showPlaceholder ? 'keydown' : 'keyup', updatePlaceholder);\n          editor.off(showPlaceholder ? 'keyup' : 'keydown', updatePlaceholder);\n        }\n      };\n      if (placeholder) {\n        editor.on('init', e => {\n          updatePlaceholder(e, true);\n          editor.on('change SetContent ExecCommand', updatePlaceholder);\n          editor.on('paste', e => Delay.setEditorTimeout(editor, () => updatePlaceholder(e)));\n        });\n      }\n    };\n\n    const strongRtl = /[\\u0591-\\u07FF\\uFB1D-\\uFDFF\\uFE70-\\uFEFC]/;\n    const hasStrongRtl = text => strongRtl.test(text);\n\n    const isInlineTarget = (editor, elm) => is$1(SugarElement.fromDom(elm), getInlineBoundarySelector(editor));\n    const isRtl = element => DOMUtils.DOM.getStyle(element, 'direction', true) === 'rtl' || hasStrongRtl(element.textContent);\n    const findInlineParents = (isInlineTarget, rootNode, pos) => filter$6(DOMUtils.DOM.getParents(pos.container(), '*', rootNode), isInlineTarget);\n    const findRootInline = (isInlineTarget, rootNode, pos) => {\n      const parents = findInlineParents(isInlineTarget, rootNode, pos);\n      return Optional.from(parents[parents.length - 1]);\n    };\n    const hasSameParentBlock = (rootNode, node1, node2) => {\n      const block1 = getParentBlock$3(node1, rootNode);\n      const block2 = getParentBlock$3(node2, rootNode);\n      return block1 && block1 === block2;\n    };\n    const isAtZwsp = pos => isBeforeInline(pos) || isAfterInline(pos);\n    const normalizePosition = (forward, pos) => {\n      if (!pos) {\n        return pos;\n      }\n      const container = pos.container(), offset = pos.offset();\n      if (forward) {\n        if (isCaretContainerInline(container)) {\n          if (isText$8(container.nextSibling)) {\n            return CaretPosition(container.nextSibling, 0);\n          } else {\n            return CaretPosition.after(container);\n          }\n        } else {\n          return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;\n        }\n      } else {\n        if (isCaretContainerInline(container)) {\n          if (isText$8(container.previousSibling)) {\n            return CaretPosition(container.previousSibling, container.previousSibling.data.length);\n          } else {\n            return CaretPosition.before(container);\n          }\n        } else {\n          return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;\n        }\n      }\n    };\n    const normalizeForwards = curry(normalizePosition, true);\n    const normalizeBackwards = curry(normalizePosition, false);\n\n    const execCommandIgnoreInputEvents = (editor, command) => {\n      const inputBlocker = e => e.stopImmediatePropagation();\n      editor.on('beforeinput input', inputBlocker, true);\n      editor.getDoc().execCommand(command);\n      editor.off('beforeinput input', inputBlocker);\n    };\n    const execDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'Delete');\n    const execForwardDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'ForwardDelete');\n    const isBeforeRoot = rootNode => elm => eq(rootNode, SugarElement.fromDom(elm.dom.parentNode));\n    const isTextBlockOrListItem = element => isTextBlock$2(element) || isListItem(element);\n    const getParentBlock$2 = (rootNode, elm) => {\n      if (contains(rootNode, elm)) {\n        return closest$4(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));\n      } else {\n        return Optional.none();\n      }\n    };\n    const placeCaretInEmptyBody = editor => {\n      const body = editor.getBody();\n      const node = body.firstChild && editor.dom.isBlock(body.firstChild) ? body.firstChild : body;\n      editor.selection.setCursorLocation(node, 0);\n    };\n    const paddEmptyBody = editor => {\n      if (editor.dom.isEmpty(editor.getBody())) {\n        editor.setContent('');\n        placeCaretInEmptyBody(editor);\n      }\n    };\n    const willDeleteLastPositionInElement = (forward, fromPos, elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\n      const normalizedFirstPos = normalizePosition(true, firstPos);\n      const normalizedLastPos = normalizePosition(false, lastPos);\n      const normalizedFromPos = normalizePosition(false, fromPos);\n      if (forward) {\n        return nextPosition(elm, normalizedFromPos).exists(nextPos => nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos));\n      } else {\n        return prevPosition(elm, normalizedFromPos).exists(prevPos => prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos));\n      }\n    }).getOr(true);\n\n    const blockPosition = (block, position) => ({\n      block,\n      position\n    });\n    const blockBoundary = (from, to) => ({\n      from,\n      to\n    });\n    const getBlockPosition = (rootNode, pos) => {\n      const rootElm = SugarElement.fromDom(rootNode);\n      const containerElm = SugarElement.fromDom(pos.container());\n      return getParentBlock$2(rootElm, containerElm).map(block => blockPosition(block, pos));\n    };\n    const isDifferentBlocks = blockBoundary => eq(blockBoundary.from.block, blockBoundary.to.block) === false;\n    const hasSameParent = blockBoundary => parent(blockBoundary.from.block).bind(parent1 => parent(blockBoundary.to.block).filter(parent2 => eq(parent1, parent2))).isSome();\n    const isEditable$2 = blockBoundary => isContentEditableFalse$a(blockBoundary.from.block.dom) === false && isContentEditableFalse$a(blockBoundary.to.block.dom) === false;\n    const skipLastBr = (rootNode, forward, blockPosition) => {\n      if (isBr$5(blockPosition.position.getNode()) && isEmpty$2(blockPosition.block) === false) {\n        return positionIn(false, blockPosition.block.dom).bind(lastPositionInBlock => {\n          if (lastPositionInBlock.isEqual(blockPosition.position)) {\n            return fromPosition(forward, rootNode, lastPositionInBlock).bind(to => getBlockPosition(rootNode, to));\n          } else {\n            return Optional.some(blockPosition);\n          }\n        }).getOr(blockPosition);\n      } else {\n        return blockPosition;\n      }\n    };\n    const readFromRange = (rootNode, forward, rng) => {\n      const fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));\n      const toBlockPos = fromBlockPos.bind(blockPos => fromPosition(forward, rootNode, blockPos.position).bind(to => getBlockPosition(rootNode, to).map(blockPos => skipLastBr(rootNode, forward, blockPos))));\n      return lift2(fromBlockPos, toBlockPos, blockBoundary).filter(blockBoundary => isDifferentBlocks(blockBoundary) && hasSameParent(blockBoundary) && isEditable$2(blockBoundary));\n    };\n    const read$1 = (rootNode, forward, rng) => rng.collapsed ? readFromRange(rootNode, forward, rng) : Optional.none();\n\n    const getChildrenUntilBlockBoundary = block => {\n      const children$1 = children(block);\n      return findIndex$2(children$1, isBlock$2).fold(constant(children$1), index => children$1.slice(0, index));\n    };\n    const extractChildren = block => {\n      const children = getChildrenUntilBlockBoundary(block);\n      each$g(children, remove$5);\n      return children;\n    };\n    const removeEmptyRoot = (rootNode, block) => {\n      const parents = parentsAndSelf(block, rootNode);\n      return find$2(parents.reverse(), element => isEmpty$2(element)).each(remove$5);\n    };\n    const isEmptyBefore = el => filter$6(prevSiblings(el), el => !isEmpty$2(el)).length === 0;\n    const nestedBlockMerge = (rootNode, fromBlock, toBlock, insertionPoint) => {\n      if (isEmpty$2(toBlock)) {\n        fillWithPaddingBr(toBlock);\n        return firstPositionIn(toBlock.dom);\n      }\n      if (isEmptyBefore(insertionPoint) && isEmpty$2(fromBlock)) {\n        before$3(insertionPoint, SugarElement.fromTag('br'));\n      }\n      const position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));\n      each$g(extractChildren(fromBlock), child => {\n        before$3(insertionPoint, child);\n      });\n      removeEmptyRoot(rootNode, fromBlock);\n      return position;\n    };\n    const sidelongBlockMerge = (rootNode, fromBlock, toBlock) => {\n      if (isEmpty$2(toBlock)) {\n        remove$5(toBlock);\n        if (isEmpty$2(fromBlock)) {\n          fillWithPaddingBr(fromBlock);\n        }\n        return firstPositionIn(fromBlock.dom);\n      }\n      const position = lastPositionIn(toBlock.dom);\n      each$g(extractChildren(fromBlock), child => {\n        append$1(toBlock, child);\n      });\n      removeEmptyRoot(rootNode, fromBlock);\n      return position;\n    };\n    const findInsertionPoint = (toBlock, block) => {\n      const parentsAndSelf$1 = parentsAndSelf(block, toBlock);\n      return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);\n    };\n    const getInsertionPoint = (fromBlock, toBlock) => contains(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();\n    const trimBr = (first, block) => {\n      positionIn(first, block.dom).map(position => position.getNode()).map(SugarElement.fromDom).filter(isBr$4).each(remove$5);\n    };\n    const mergeBlockInto = (rootNode, fromBlock, toBlock) => {\n      trimBr(true, fromBlock);\n      trimBr(false, toBlock);\n      return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock), curry(nestedBlockMerge, rootNode, fromBlock, toBlock));\n    };\n    const mergeBlocks = (rootNode, forward, block1, block2) => forward ? mergeBlockInto(rootNode, block2, block1) : mergeBlockInto(rootNode, block1, block2);\n\n    const backspaceDelete$8 = (editor, forward) => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const position = read$1(rootNode.dom, forward, editor.selection.getRng()).map(blockBoundary => () => {\n        mergeBlocks(rootNode, forward, blockBoundary.from.block, blockBoundary.to.block).each(pos => {\n          editor.selection.setRng(pos.toRange());\n        });\n      });\n      return position;\n    };\n\n    const deleteRangeMergeBlocks = (rootNode, selection) => {\n      const rng = selection.getRng();\n      return lift2(getParentBlock$2(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$2(rootNode, SugarElement.fromDom(rng.endContainer)), (block1, block2) => {\n        if (eq(block1, block2) === false) {\n          return Optional.some(() => {\n            rng.deleteContents();\n            mergeBlocks(rootNode, true, block1, block2).each(pos => {\n              selection.setRng(pos.toRange());\n            });\n          });\n        } else {\n          return Optional.none();\n        }\n      }).getOr(Optional.none());\n    };\n    const isRawNodeInTable = (root, rawNode) => {\n      const node = SugarElement.fromDom(rawNode);\n      const isRoot = curry(eq, root);\n      return ancestor$3(node, isTableCell$4, isRoot).isSome();\n    };\n    const isSelectionInTable = (root, rng) => isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);\n    const isEverythingSelected = (root, rng) => {\n      const noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();\n      const noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();\n      return !isSelectionInTable(root, rng) && noPrevious && noNext;\n    };\n    const emptyEditor = editor => {\n      return Optional.some(() => {\n        editor.setContent('');\n        editor.selection.setCursorLocation();\n      });\n    };\n    const deleteRange$1 = editor => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const rng = editor.selection.getRng();\n      return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection);\n    };\n    const backspaceDelete$7 = (editor, _forward) => editor.selection.isCollapsed() ? Optional.none() : deleteRange$1(editor);\n\n    const isContentEditableTrue$1 = isContentEditableTrue$4;\n    const isContentEditableFalse$4 = isContentEditableFalse$a;\n    const showCaret = (direction, editor, node, before, scrollIntoView) => Optional.from(editor._selectionOverrides.showCaret(direction, node, before, scrollIntoView));\n    const getNodeRange = node => {\n      const rng = node.ownerDocument.createRange();\n      rng.selectNode(node);\n      return rng;\n    };\n    const selectNode = (editor, node) => {\n      const e = editor.dispatch('BeforeObjectSelected', { target: node });\n      if (e.isDefaultPrevented()) {\n        return Optional.none();\n      }\n      return Optional.some(getNodeRange(node));\n    };\n    const renderCaretAtRange = (editor, range, scrollIntoView) => {\n      const normalizedRange = normalizeRange(1, editor.getBody(), range);\n      const caretPosition = CaretPosition.fromRangeStart(normalizedRange);\n      const caretPositionNode = caretPosition.getNode();\n      if (isInlineFakeCaretTarget(caretPositionNode)) {\n        return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);\n      }\n      const caretPositionBeforeNode = caretPosition.getNode(true);\n      if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {\n        return showCaret(1, editor, caretPositionBeforeNode, false, false);\n      }\n      const ceRoot = editor.dom.getParent(caretPosition.getNode(), node => isContentEditableFalse$4(node) || isContentEditableTrue$1(node));\n      if (isInlineFakeCaretTarget(ceRoot)) {\n        return showCaret(1, editor, ceRoot, false, scrollIntoView);\n      }\n      return Optional.none();\n    };\n    const renderRangeCaret = (editor, range, scrollIntoView) => range.collapsed ? renderCaretAtRange(editor, range, scrollIntoView).getOr(range) : range;\n\n    const isBeforeBoundary = pos => isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);\n    const isAfterBoundary = pos => isAfterContentEditableFalse(pos) || isAfterMedia(pos);\n    const trimEmptyTextNode = (dom, node) => {\n      if (isText$8(node) && node.data.length === 0) {\n        dom.remove(node);\n      }\n    };\n    const deleteContentAndShowCaret = (editor, range, node, direction, forward, peekCaretPosition) => {\n      showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each(caretRange => {\n        if (range.collapsed) {\n          const deleteRange = range.cloneRange();\n          if (forward) {\n            deleteRange.setEnd(caretRange.startContainer, caretRange.startOffset);\n          } else {\n            deleteRange.setStart(caretRange.endContainer, caretRange.endOffset);\n          }\n          deleteRange.deleteContents();\n        } else {\n          range.deleteContents();\n        }\n        editor.selection.setRng(caretRange);\n      });\n      trimEmptyTextNode(editor.dom, node);\n    };\n    const deleteBoundaryText = (editor, forward) => {\n      const range = editor.selection.getRng();\n      if (!isText$8(range.commonAncestorContainer)) {\n        return Optional.none();\n      }\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const caretWalker = CaretWalker(editor.getBody());\n      const getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);\n      const isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      const nextCaretPosition = normalizePosition(forward, getNextPosFn(caretPosition));\n      if (!nextCaretPosition || !isMoveInsideSameBlock(caretPosition, nextCaretPosition)) {\n        return Optional.none();\n      } else if (isBeforeFn(nextCaretPosition)) {\n        return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, nextCaretPosition));\n      }\n      const peekCaretPosition = getNextPosFn(nextCaretPosition);\n      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\n        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {\n          return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, peekCaretPosition));\n        }\n      }\n      return Optional.none();\n    };\n    const backspaceDelete$6 = (editor, forward) => deleteBoundaryText(editor, forward);\n\n    const isCompoundElement = node => isTableCell$4(SugarElement.fromDom(node)) || isListItem(SugarElement.fromDom(node));\n    const DeleteAction = Adt.generate([\n      { remove: ['element'] },\n      { moveToElement: ['element'] },\n      { moveToPosition: ['position'] }\n    ]);\n    const isAtContentEditableBlockCaret = (forward, from) => {\n      const elm = from.getNode(forward === false);\n      const caretLocation = forward ? 'after' : 'before';\n      return isElement$6(elm) && elm.getAttribute('data-mce-caret') === caretLocation;\n    };\n    const isDeleteFromCefDifferentBlocks = (root, forward, from, to) => {\n      const inSameBlock = elm => isInline$1(SugarElement.fromDom(elm)) && !isInSameBlock(from, to, root);\n      return getRelativeCefElm(!forward, from).fold(() => getRelativeCefElm(forward, to).fold(never, inSameBlock), inSameBlock);\n    };\n    const deleteEmptyBlockOrMoveToCef = (root, forward, from, to) => {\n      const toCefElm = to.getNode(forward === false);\n      return getParentBlock$2(SugarElement.fromDom(root), SugarElement.fromDom(from.getNode())).map(blockElm => isEmpty$2(blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm)).orThunk(() => Optional.some(DeleteAction.moveToElement(toCefElm)));\n    };\n    const findCefPosition = (root, forward, from) => fromPosition(forward, root, from).bind(to => {\n      if (isCompoundElement(to.getNode())) {\n        return Optional.none();\n      } else if (isDeleteFromCefDifferentBlocks(root, forward, from, to)) {\n        return Optional.none();\n      } else if (forward && isContentEditableFalse$a(to.getNode())) {\n        return deleteEmptyBlockOrMoveToCef(root, forward, from, to);\n      } else if (forward === false && isContentEditableFalse$a(to.getNode(true))) {\n        return deleteEmptyBlockOrMoveToCef(root, forward, from, to);\n      } else if (forward && isAfterContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      } else if (forward === false && isBeforeContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      } else {\n        return Optional.none();\n      }\n    });\n    const getContentEditableBlockAction = (forward, elm) => {\n      if (forward && isContentEditableFalse$a(elm.nextSibling)) {\n        return Optional.some(DeleteAction.moveToElement(elm.nextSibling));\n      } else if (forward === false && isContentEditableFalse$a(elm.previousSibling)) {\n        return Optional.some(DeleteAction.moveToElement(elm.previousSibling));\n      } else {\n        return Optional.none();\n      }\n    };\n    const skipMoveToActionFromInlineCefToContent = (root, from, deleteAction) => deleteAction.fold(elm => Optional.some(DeleteAction.remove(elm)), elm => Optional.some(DeleteAction.moveToElement(elm)), to => {\n      if (isInSameBlock(from, to, root)) {\n        return Optional.none();\n      } else {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      }\n    });\n    const getContentEditableAction = (root, forward, from) => {\n      if (isAtContentEditableBlockCaret(forward, from)) {\n        return getContentEditableBlockAction(forward, from.getNode(forward === false)).fold(() => findCefPosition(root, forward, from), Optional.some);\n      } else {\n        return findCefPosition(root, forward, from).bind(deleteAction => skipMoveToActionFromInlineCefToContent(root, from, deleteAction));\n      }\n    };\n    const read = (root, forward, rng) => {\n      const normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);\n      const from = CaretPosition.fromRangeStart(normalizedRange);\n      const rootElement = SugarElement.fromDom(root);\n      if (forward === false && isAfterContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.remove(from.getNode(true)));\n      } else if (forward && isBeforeContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.remove(from.getNode()));\n      } else if (forward === false && isBeforeContentEditableFalse(from) && isAfterBr(rootElement, from)) {\n        return findPreviousBr(rootElement, from).map(br => DeleteAction.remove(br.getNode()));\n      } else if (forward && isAfterContentEditableFalse(from) && isBeforeBr$1(rootElement, from)) {\n        return findNextBr(rootElement, from).map(br => DeleteAction.remove(br.getNode()));\n      } else {\n        return getContentEditableAction(root, forward, from);\n      }\n    };\n\n    const deleteElement$1 = (editor, forward) => element => {\n      editor._selectionOverrides.hideFakeCaret();\n      deleteElement$2(editor, forward, SugarElement.fromDom(element));\n      return true;\n    };\n    const moveToElement = (editor, forward) => element => {\n      const pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);\n      editor.selection.setRng(pos.toRange());\n      return true;\n    };\n    const moveToPosition = editor => pos => {\n      editor.selection.setRng(pos.toRange());\n      return true;\n    };\n    const getAncestorCe = (editor, node) => Optional.from(getContentEditableRoot$1(editor.getBody(), node));\n    const backspaceDeleteCaret = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse$a).fold(() => read(editor.getBody(), forward, editor.selection.getRng()).map(deleteAction => () => deleteAction.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor))), () => Optional.some(noop));\n    };\n    const deleteOffscreenSelection = rootElement => {\n      each$g(descendants(rootElement, '.mce-offscreen-selection'), remove$5);\n    };\n    const backspaceDeleteRange = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      if (isContentEditableFalse$a(selectedNode) && !isTableCell$5(selectedNode)) {\n        const hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse$a);\n        return hasCefAncestor.fold(() => Optional.some(() => {\n          deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));\n          deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode()));\n          paddEmptyBody(editor);\n        }), () => Optional.some(noop));\n      }\n      return Optional.none();\n    };\n    const paddEmptyElement = editor => {\n      const dom = editor.dom, selection = editor.selection;\n      const ceRoot = getContentEditableRoot$1(editor.getBody(), selection.getNode());\n      if (isContentEditableTrue$4(ceRoot) && dom.isBlock(ceRoot) && dom.isEmpty(ceRoot)) {\n        const br = dom.create('br', { 'data-mce-bogus': '1' });\n        dom.setHTML(ceRoot, '');\n        ceRoot.appendChild(br);\n        selection.setRng(CaretPosition.before(br).toRange());\n      }\n      return true;\n    };\n    const backspaceDelete$5 = (editor, forward) => {\n      if (editor.selection.isCollapsed()) {\n        return backspaceDeleteCaret(editor, forward);\n      } else {\n        return backspaceDeleteRange(editor, forward);\n      }\n    };\n\n    const deleteCaret$2 = (editor, forward) => {\n      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return fromPosition(forward, editor.getBody(), fromPos).filter(pos => forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos)).bind(pos => Optional.from(getChildNodeAtRelativeOffset(forward ? 0 : -1, pos))).map(elm => () => editor.selection.select(elm));\n    };\n    const backspaceDelete$4 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : Optional.none();\n\n    const isText$1 = isText$8;\n    const startsWithCaretContainer = node => isText$1(node) && node.data[0] === ZWSP$1;\n    const endsWithCaretContainer = node => isText$1(node) && node.data[node.data.length - 1] === ZWSP$1;\n    const createZwsp = node => node.ownerDocument.createTextNode(ZWSP$1);\n    const insertBefore = node => {\n      if (isText$1(node.previousSibling)) {\n        if (endsWithCaretContainer(node.previousSibling)) {\n          return node.previousSibling;\n        } else {\n          node.previousSibling.appendData(ZWSP$1);\n          return node.previousSibling;\n        }\n      } else if (isText$1(node)) {\n        if (startsWithCaretContainer(node)) {\n          return node;\n        } else {\n          node.insertData(0, ZWSP$1);\n          return node;\n        }\n      } else {\n        const newNode = createZwsp(node);\n        node.parentNode.insertBefore(newNode, node);\n        return newNode;\n      }\n    };\n    const insertAfter = node => {\n      if (isText$1(node.nextSibling)) {\n        if (startsWithCaretContainer(node.nextSibling)) {\n          return node.nextSibling;\n        } else {\n          node.nextSibling.insertData(0, ZWSP$1);\n          return node.nextSibling;\n        }\n      } else if (isText$1(node)) {\n        if (endsWithCaretContainer(node)) {\n          return node;\n        } else {\n          node.appendData(ZWSP$1);\n          return node;\n        }\n      } else {\n        const newNode = createZwsp(node);\n        if (node.nextSibling) {\n          node.parentNode.insertBefore(newNode, node.nextSibling);\n        } else {\n          node.parentNode.appendChild(newNode);\n        }\n        return newNode;\n      }\n    };\n    const insertInline = (before, node) => before ? insertBefore(node) : insertAfter(node);\n    const insertInlineBefore = curry(insertInline, true);\n    const insertInlineAfter = curry(insertInline, false);\n\n    const insertInlinePos = (pos, before) => {\n      if (isText$8(pos.container())) {\n        return insertInline(before, pos.container());\n      } else {\n        return insertInline(before, pos.getNode());\n      }\n    };\n    const isPosCaretContainer = (pos, caret) => {\n      const caretNode = caret.get();\n      return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);\n    };\n    const renderCaret = (caret, location) => location.fold(element => {\n      remove$4(caret.get());\n      const text = insertInlineBefore(element);\n      caret.set(text);\n      return Optional.some(CaretPosition(text, text.length - 1));\n    }, element => firstPositionIn(element).map(pos => {\n      if (!isPosCaretContainer(pos, caret)) {\n        remove$4(caret.get());\n        const text = insertInlinePos(pos, true);\n        caret.set(text);\n        return CaretPosition(text, 1);\n      } else {\n        return CaretPosition(caret.get(), 1);\n      }\n    }), element => lastPositionIn(element).map(pos => {\n      if (!isPosCaretContainer(pos, caret)) {\n        remove$4(caret.get());\n        const text = insertInlinePos(pos, false);\n        caret.set(text);\n        return CaretPosition(text, text.length - 1);\n      } else {\n        return CaretPosition(caret.get(), caret.get().length - 1);\n      }\n    }), element => {\n      remove$4(caret.get());\n      const text = insertInlineAfter(element);\n      caret.set(text);\n      return Optional.some(CaretPosition(text, 1));\n    });\n\n    const evaluateUntil = (fns, args) => {\n      for (let i = 0; i < fns.length; i++) {\n        const result = fns[i].apply(null, args);\n        if (result.isSome()) {\n          return result;\n        }\n      }\n      return Optional.none();\n    };\n\n    const Location = Adt.generate([\n      { before: ['element'] },\n      { start: ['element'] },\n      { end: ['element'] },\n      { after: ['element'] }\n    ]);\n    const rescope$1 = (rootNode, node) => {\n      const parentBlock = getParentBlock$3(node, rootNode);\n      return parentBlock ? parentBlock : rootNode;\n    };\n    const before = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeForwards(pos);\n      const scope = rescope$1(rootNode, nPos.container());\n      return findRootInline(isInlineTarget, scope, nPos).fold(() => nextPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.before(inline)), Optional.none);\n    };\n    const isNotInsideFormatCaretContainer = (rootNode, elm) => getParentCaretContainer(rootNode, elm) === null;\n    const findInsideRootInline = (isInlineTarget, rootNode, pos) => findRootInline(isInlineTarget, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));\n    const start$1 = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeBackwards(pos);\n      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\n        const prevPos = prevPosition(inline, nPos);\n        return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();\n      });\n    };\n    const end = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeForwards(pos);\n      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\n        const nextPos = nextPosition(inline, nPos);\n        return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();\n      });\n    };\n    const after = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeBackwards(pos);\n      const scope = rescope$1(rootNode, nPos.container());\n      return findRootInline(isInlineTarget, scope, nPos).fold(() => prevPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.after(inline)), Optional.none);\n    };\n    const isValidLocation = location => isRtl(getElement(location)) === false;\n    const readLocation = (isInlineTarget, rootNode, pos) => {\n      const location = evaluateUntil([\n        before,\n        start$1,\n        end,\n        after\n      ], [\n        isInlineTarget,\n        rootNode,\n        pos\n      ]);\n      return location.filter(isValidLocation);\n    };\n    const getElement = location => location.fold(identity, identity, identity, identity);\n    const getName = location => location.fold(constant('before'), constant('start'), constant('end'), constant('after'));\n    const outside = location => location.fold(Location.before, Location.before, Location.after, Location.after);\n    const inside = location => location.fold(Location.start, Location.start, Location.end, Location.end);\n    const isEq = (location1, location2) => getName(location1) === getName(location2) && getElement(location1) === getElement(location2);\n    const betweenInlines = (forward, isInlineTarget, rootNode, from, to, location) => lift2(findRootInline(isInlineTarget, rootNode, from), findRootInline(isInlineTarget, rootNode, to), (fromInline, toInline) => {\n      if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {\n        return Location.after(forward ? fromInline : toInline);\n      } else {\n        return location;\n      }\n    }).getOr(location);\n    const skipNoMovement = (fromLocation, toLocation) => fromLocation.fold(always, fromLocation => !isEq(fromLocation, toLocation));\n    const findLocationTraverse = (forward, isInlineTarget, rootNode, fromLocation, pos) => {\n      const from = normalizePosition(forward, pos);\n      const to = fromPosition(forward, rootNode, from).map(curry(normalizePosition, forward));\n      const location = to.fold(() => fromLocation.map(outside), to => readLocation(isInlineTarget, rootNode, to).map(curry(betweenInlines, forward, isInlineTarget, rootNode, from, to)).filter(curry(skipNoMovement, fromLocation)));\n      return location.filter(isValidLocation);\n    };\n    const findLocationSimple = (forward, location) => {\n      if (forward) {\n        return location.fold(compose(Optional.some, Location.start), Optional.none, compose(Optional.some, Location.after), Optional.none);\n      } else {\n        return location.fold(Optional.none, compose(Optional.some, Location.before), Optional.none, compose(Optional.some, Location.end));\n      }\n    };\n    const findLocation$1 = (forward, isInlineTarget, rootNode, pos) => {\n      const from = normalizePosition(forward, pos);\n      const fromLocation = readLocation(isInlineTarget, rootNode, from);\n      return readLocation(isInlineTarget, rootNode, from).bind(curry(findLocationSimple, forward)).orThunk(() => findLocationTraverse(forward, isInlineTarget, rootNode, fromLocation, pos));\n    };\n\n    const hasSelectionModifyApi = editor => {\n      return isFunction(editor.selection.getSel().modify);\n    };\n    const moveRel = (forward, selection, pos) => {\n      const delta = forward ? 1 : -1;\n      selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());\n      selection.getSel().modify('move', forward ? 'forward' : 'backward', 'word');\n      return true;\n    };\n    const moveByWord = (forward, editor) => {\n      const rng = editor.selection.getRng();\n      const pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n      if (!hasSelectionModifyApi(editor)) {\n        return false;\n      } else if (forward && isBeforeInline(pos)) {\n        return moveRel(true, editor.selection, pos);\n      } else if (!forward && isAfterInline(pos)) {\n        return moveRel(false, editor.selection, pos);\n      } else {\n        return false;\n      }\n    };\n\n    var BreakType;\n    (function (BreakType) {\n      BreakType[BreakType['Br'] = 0] = 'Br';\n      BreakType[BreakType['Block'] = 1] = 'Block';\n      BreakType[BreakType['Wrap'] = 2] = 'Wrap';\n      BreakType[BreakType['Eol'] = 3] = 'Eol';\n    }(BreakType || (BreakType = {})));\n    const flip = (direction, positions) => direction === HDirection.Backwards ? reverse(positions) : positions;\n    const walk$1 = (direction, caretWalker, pos) => direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);\n    const getBreakType = (scope, direction, currentPos, nextPos) => {\n      if (isBr$5(nextPos.getNode(direction === HDirection.Forwards))) {\n        return BreakType.Br;\n      } else if (isInSameBlock(currentPos, nextPos) === false) {\n        return BreakType.Block;\n      } else {\n        return BreakType.Wrap;\n      }\n    };\n    const getPositionsUntil = (predicate, direction, scope, start) => {\n      const caretWalker = CaretWalker(scope);\n      let currentPos = start;\n      const positions = [];\n      while (currentPos) {\n        const nextPos = walk$1(direction, caretWalker, currentPos);\n        if (!nextPos) {\n          break;\n        }\n        if (isBr$5(nextPos.getNode(false))) {\n          if (direction === HDirection.Forwards) {\n            return {\n              positions: flip(direction, positions).concat([nextPos]),\n              breakType: BreakType.Br,\n              breakAt: Optional.some(nextPos)\n            };\n          } else {\n            return {\n              positions: flip(direction, positions),\n              breakType: BreakType.Br,\n              breakAt: Optional.some(nextPos)\n            };\n          }\n        }\n        if (!nextPos.isVisible()) {\n          currentPos = nextPos;\n          continue;\n        }\n        if (predicate(currentPos, nextPos)) {\n          const breakType = getBreakType(scope, direction, currentPos, nextPos);\n          return {\n            positions: flip(direction, positions),\n            breakType,\n            breakAt: Optional.some(nextPos)\n          };\n        }\n        positions.push(nextPos);\n        currentPos = nextPos;\n      }\n      return {\n        positions: flip(direction, positions),\n        breakType: BreakType.Eol,\n        breakAt: Optional.none()\n      };\n    };\n    const getAdjacentLinePositions = (direction, getPositionsUntilBreak, scope, start) => getPositionsUntilBreak(scope, start).breakAt.map(pos => {\n      const positions = getPositionsUntilBreak(scope, pos).positions;\n      return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);\n    }).getOr([]);\n    const findClosestHorizontalPositionFromPoint = (positions, x) => foldl(positions, (acc, newPos) => acc.fold(() => Optional.some(newPos), lastPos => lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), (lastRect, newRect) => {\n      const lastDist = Math.abs(x - lastRect.left);\n      const newDist = Math.abs(x - newRect.left);\n      return newDist <= lastDist ? newPos : lastPos;\n    }).or(acc)), Optional.none());\n    const findClosestHorizontalPosition = (positions, pos) => head(pos.getClientRects()).bind(targetRect => findClosestHorizontalPositionFromPoint(positions, targetRect.left));\n    const getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);\n    const getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);\n    const getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);\n    const getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);\n    const isAtFirstLine = (scope, pos) => getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();\n    const isAtLastLine = (scope, pos) => getPositionsUntilNextLine(scope, pos).breakAt.isNone();\n    const getFirstLinePositions = scope => firstPositionIn(scope).map(pos => [pos].concat(getPositionsUntilNextLine(scope, pos).positions)).getOr([]);\n    const getLastLinePositions = scope => lastPositionIn(scope).map(pos => getPositionsUntilPreviousLine(scope, pos).positions.concat(pos)).getOr([]);\n\n    const isContentEditableFalse$3 = isContentEditableFalse$a;\n    const distanceToRectLeft$1 = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\n    const distanceToRectRight$1 = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\n    const isNodeClientRect = rect => hasNonNullableKey(rect, 'node');\n    const findClosestClientRect = (clientRects, clientX) => reduce(clientRects, (oldClientRect, clientRect) => {\n      const oldDistance = Math.min(distanceToRectLeft$1(oldClientRect, clientX), distanceToRectRight$1(oldClientRect, clientX));\n      const newDistance = Math.min(distanceToRectLeft$1(clientRect, clientX), distanceToRectRight$1(clientRect, clientX));\n      if (newDistance === oldDistance && isNodeClientRect(clientRect) && isContentEditableFalse$3(clientRect.node)) {\n        return clientRect;\n      }\n      if (newDistance < oldDistance) {\n        return clientRect;\n      }\n      return oldClientRect;\n    });\n\n    const getNodeClientRects = node => {\n      const toArrayWithNode = clientRects => {\n        return map$3(clientRects, rect => {\n          const clientRect = clone$1(rect);\n          clientRect.node = node;\n          return clientRect;\n        });\n      };\n      if (isElement$6(node)) {\n        return toArrayWithNode(node.getClientRects());\n      } else if (isText$8(node)) {\n        const rng = node.ownerDocument.createRange();\n        rng.setStart(node, 0);\n        rng.setEnd(node, node.data.length);\n        return toArrayWithNode(rng.getClientRects());\n      } else {\n        return [];\n      }\n    };\n    const getClientRects = nodes => bind$3(nodes, getNodeClientRects);\n\n    var VDirection;\n    (function (VDirection) {\n      VDirection[VDirection['Up'] = -1] = 'Up';\n      VDirection[VDirection['Down'] = 1] = 'Down';\n    }(VDirection || (VDirection = {})));\n    const findUntil = (direction, root, predicateFn, node) => {\n      while (node = findNode(node, direction, isEditableCaretCandidate$1, root)) {\n        if (predicateFn(node)) {\n          return;\n        }\n      }\n    };\n    const walkUntil = (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) => {\n      let line = 0;\n      const result = [];\n      const add = node => {\n        let clientRects = getClientRects([node]);\n        if (direction === -1) {\n          clientRects = clientRects.reverse();\n        }\n        for (let i = 0; i < clientRects.length; i++) {\n          const clientRect = clientRects[i];\n          if (isBeflowFn(clientRect, targetClientRect)) {\n            continue;\n          }\n          if (result.length > 0 && isAboveFn(clientRect, last$2(result))) {\n            line++;\n          }\n          clientRect.line = line;\n          if (predicateFn(clientRect)) {\n            return true;\n          }\n          result.push(clientRect);\n        }\n      };\n      const targetClientRect = last$2(caretPosition.getClientRects());\n      if (!targetClientRect) {\n        return result;\n      }\n      const node = caretPosition.getNode();\n      add(node);\n      findUntil(direction, root, add, node);\n      return result;\n    };\n    const aboveLineNumber = (lineNumber, clientRect) => clientRect.line > lineNumber;\n    const isLineNumber = (lineNumber, clientRect) => clientRect.line === lineNumber;\n    const upUntil = curry(walkUntil, VDirection.Up, isAbove$1, isBelow$1);\n    const downUntil = curry(walkUntil, VDirection.Down, isBelow$1, isAbove$1);\n    const positionsUntil = (direction, root, predicateFn, node) => {\n      const caretWalker = CaretWalker(root);\n      let walkFn;\n      let isBelowFn;\n      let isAboveFn;\n      let caretPosition;\n      const result = [];\n      let line = 0;\n      const getClientRect = caretPosition => {\n        if (direction === 1) {\n          return last$2(caretPosition.getClientRects());\n        }\n        return last$2(caretPosition.getClientRects());\n      };\n      if (direction === 1) {\n        walkFn = caretWalker.next;\n        isBelowFn = isBelow$1;\n        isAboveFn = isAbove$1;\n        caretPosition = CaretPosition.after(node);\n      } else {\n        walkFn = caretWalker.prev;\n        isBelowFn = isAbove$1;\n        isAboveFn = isBelow$1;\n        caretPosition = CaretPosition.before(node);\n      }\n      const targetClientRect = getClientRect(caretPosition);\n      do {\n        if (!caretPosition.isVisible()) {\n          continue;\n        }\n        const rect = getClientRect(caretPosition);\n        if (isAboveFn(rect, targetClientRect)) {\n          continue;\n        }\n        if (result.length > 0 && isBelowFn(rect, last$2(result))) {\n          line++;\n        }\n        const clientRect = clone$1(rect);\n        clientRect.position = caretPosition;\n        clientRect.line = line;\n        if (predicateFn(clientRect)) {\n          return result;\n        }\n        result.push(clientRect);\n      } while (caretPosition = walkFn(caretPosition));\n      return result;\n    };\n    const isAboveLine = lineNumber => clientRect => aboveLineNumber(lineNumber, clientRect);\n    const isLine = lineNumber => clientRect => isLineNumber(lineNumber, clientRect);\n\n    const moveToRange = (editor, rng) => {\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, editor.selection.getRng());\n    };\n    const renderRangeCaretOpt = (editor, range, scrollIntoView) => Optional.some(renderRangeCaret(editor, range, scrollIntoView));\n    const moveHorizontally = (editor, direction, range, isBefore, isAfter, isElement) => {\n      const forwards = direction === HDirection.Forwards;\n      const caretWalker = CaretWalker(editor.getBody());\n      const getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);\n      const isBeforeFn = forwards ? isBefore : isAfter;\n      if (!range.collapsed) {\n        const node = getSelectedNode(range);\n        if (isElement(node)) {\n          return showCaret(direction, editor, node, direction === HDirection.Backwards, false);\n        }\n      }\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      if (isBeforeFn(caretPosition)) {\n        return selectNode(editor, caretPosition.getNode(!forwards));\n      }\n      const nextCaretPosition = normalizePosition(forwards, getNextPosFn(caretPosition));\n      const rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);\n      if (!nextCaretPosition) {\n        return rangeIsInContainerBlock ? Optional.some(range) : Optional.none();\n      }\n      if (isBeforeFn(nextCaretPosition)) {\n        return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);\n      }\n      const peekCaretPosition = getNextPosFn(nextCaretPosition);\n      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\n        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {\n          return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);\n        }\n      }\n      if (rangeIsInContainerBlock) {\n        return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);\n      }\n      return Optional.none();\n    };\n    const moveVertically = (editor, direction, range, isBefore, isAfter, isElement) => {\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      const caretClientRect = last$2(caretPosition.getClientRects());\n      const forwards = direction === VDirection.Down;\n      if (!caretClientRect) {\n        return Optional.none();\n      }\n      const walkerFn = forwards ? downUntil : upUntil;\n      const linePositions = walkerFn(editor.getBody(), isAboveLine(1), caretPosition);\n      const nextLinePositions = filter$6(linePositions, isLine(1));\n      const clientX = caretClientRect.left;\n      const nextLineRect = findClosestClientRect(nextLinePositions, clientX);\n      if (nextLineRect && isElement(nextLineRect.node)) {\n        const dist1 = Math.abs(clientX - nextLineRect.left);\n        const dist2 = Math.abs(clientX - nextLineRect.right);\n        return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);\n      }\n      let currentNode;\n      if (isBefore(caretPosition)) {\n        currentNode = caretPosition.getNode();\n      } else if (isAfter(caretPosition)) {\n        currentNode = caretPosition.getNode(true);\n      } else {\n        currentNode = getSelectedNode(range);\n      }\n      if (currentNode) {\n        const caretPositions = positionsUntil(direction, editor.getBody(), isAboveLine(1), currentNode);\n        let closestNextLineRect = findClosestClientRect(filter$6(caretPositions, isLine(1)), clientX);\n        if (closestNextLineRect) {\n          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\n        }\n        closestNextLineRect = last$2(filter$6(caretPositions, isLine(0)));\n        if (closestNextLineRect) {\n          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\n        }\n      }\n      if (nextLinePositions.length === 0) {\n        return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore).map(pos => renderRangeCaret(editor, pos.toRange(), false));\n      }\n      return Optional.none();\n    };\n    const getLineEndPoint = (editor, forward) => {\n      const rng = editor.selection.getRng();\n      const from = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n      const host = getEditingHost(from.container(), editor.getBody());\n      if (forward) {\n        const lineInfo = getPositionsUntilNextLine(host, from);\n        return last$3(lineInfo.positions);\n      } else {\n        const lineInfo = getPositionsUntilPreviousLine(host, from);\n        return head(lineInfo.positions);\n      }\n    };\n    const moveToLineEndPoint$3 = (editor, forward, isElementPosition) => getLineEndPoint(editor, forward).filter(isElementPosition).exists(pos => {\n      editor.selection.setRng(pos.toRange());\n      return true;\n    });\n\n    const setCaretPosition = (editor, pos) => {\n      const rng = editor.dom.createRng();\n      rng.setStart(pos.container(), pos.offset());\n      rng.setEnd(pos.container(), pos.offset());\n      editor.selection.setRng(rng);\n    };\n    const setSelected = (state, elm) => {\n      if (state) {\n        elm.setAttribute('data-mce-selected', 'inline-boundary');\n      } else {\n        elm.removeAttribute('data-mce-selected');\n      }\n    };\n    const renderCaretLocation = (editor, caret, location) => renderCaret(caret, location).map(pos => {\n      setCaretPosition(editor, pos);\n      return location;\n    });\n    const findLocation = (editor, caret, forward) => {\n      const rootNode = editor.getBody();\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const location = findLocation$1(forward, isInlineTarget$1, rootNode, from);\n      return location.bind(location => renderCaretLocation(editor, caret, location));\n    };\n    const toggleInlines = (isInlineTarget, dom, elms) => {\n      const inlineBoundaries = map$3(descendants(SugarElement.fromDom(dom.getRoot()), '*[data-mce-selected=\"inline-boundary\"]'), e => e.dom);\n      const selectedInlines = filter$6(inlineBoundaries, isInlineTarget);\n      const targetInlines = filter$6(elms, isInlineTarget);\n      each$g(difference(selectedInlines, targetInlines), curry(setSelected, false));\n      each$g(difference(targetInlines, selectedInlines), curry(setSelected, true));\n    };\n    const safeRemoveCaretContainer = (editor, caret) => {\n      if (editor.selection.isCollapsed() && editor.composing !== true && caret.get()) {\n        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        if (CaretPosition.isTextPosition(pos) && isAtZwsp(pos) === false) {\n          setCaretPosition(editor, removeAndReposition(caret.get(), pos));\n          caret.set(null);\n        }\n      }\n    };\n    const renderInsideInlineCaret = (isInlineTarget, editor, caret, elms) => {\n      if (editor.selection.isCollapsed()) {\n        const inlines = filter$6(elms, isInlineTarget);\n        each$g(inlines, _inline => {\n          const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n          readLocation(isInlineTarget, editor.getBody(), pos).bind(location => renderCaretLocation(editor, caret, location));\n        });\n      }\n    };\n    const move$2 = (editor, caret, forward) => isInlineBoundariesEnabled(editor) ? findLocation(editor, caret, forward).isSome() : false;\n    const moveWord = (forward, editor, _caret) => isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;\n    const setupSelectedState = editor => {\n      const caret = Cell(null);\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      editor.on('NodeChange', e => {\n        if (isInlineBoundariesEnabled(editor)) {\n          toggleInlines(isInlineTarget$1, editor.dom, e.parents);\n          safeRemoveCaretContainer(editor, caret);\n          renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);\n        }\n      });\n      return caret;\n    };\n    const moveNextWord = curry(moveWord, true);\n    const movePrevWord = curry(moveWord, false);\n    const moveToLineEndPoint$2 = (editor, forward, caret) => {\n      if (isInlineBoundariesEnabled(editor)) {\n        const linePoint = getLineEndPoint(editor, forward).getOrThunk(() => {\n          const rng = editor.selection.getRng();\n          return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n        });\n        return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists(loc => {\n          const outsideLoc = outside(loc);\n          return renderCaret(caret, outsideLoc).exists(pos => {\n            setCaretPosition(editor, pos);\n            return true;\n          });\n        });\n      } else {\n        return false;\n      }\n    };\n\n    const rangeFromPositions = (from, to) => {\n      const range = document.createRange();\n      range.setStart(from.container(), from.offset());\n      range.setEnd(to.container(), to.offset());\n      return range;\n    };\n    const hasOnlyTwoOrLessPositionsLeft = elm => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\n      const normalizedFirstPos = normalizePosition(true, firstPos);\n      const normalizedLastPos = normalizePosition(false, lastPos);\n      return nextPosition(elm, normalizedFirstPos).forall(pos => pos.isEqual(normalizedLastPos));\n    }).getOr(true);\n    const setCaretLocation = (editor, caret) => location => renderCaret(caret, location).map(pos => () => setCaretPosition(editor, pos));\n    const deleteFromTo = (editor, caret, from, to) => {\n      const rootNode = editor.getBody();\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      editor.undoManager.ignore(() => {\n        editor.selection.setRng(rangeFromPositions(from, to));\n        execDeleteCommand(editor);\n        readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng())).map(inside).bind(setCaretLocation(editor, caret)).each(call);\n      });\n      editor.nodeChanged();\n    };\n    const rescope = (rootNode, node) => {\n      const parentBlock = getParentBlock$3(node, rootNode);\n      return parentBlock ? parentBlock : rootNode;\n    };\n    const backspaceDeleteCollapsed = (editor, caret, forward, from) => {\n      const rootNode = rescope(editor.getBody(), from.container());\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const fromLocation = readLocation(isInlineTarget$1, rootNode, from);\n      const location = fromLocation.bind(location => {\n        if (forward) {\n          return location.fold(constant(Optional.some(inside(location))), Optional.none, constant(Optional.some(outside(location))), Optional.none);\n        } else {\n          return location.fold(Optional.none, constant(Optional.some(outside(location))), Optional.none, constant(Optional.some(inside(location))));\n        }\n      });\n      return location.map(setCaretLocation(editor, caret)).getOrThunk(() => {\n        const toPosition = navigate(forward, rootNode, from);\n        const toLocation = toPosition.bind(pos => readLocation(isInlineTarget$1, rootNode, pos));\n        return lift2(fromLocation, toLocation, () => findRootInline(isInlineTarget$1, rootNode, from).bind(elm => {\n          if (hasOnlyTwoOrLessPositionsLeft(elm)) {\n            return Optional.some(() => {\n              deleteElement$2(editor, forward, SugarElement.fromDom(elm));\n            });\n          } else {\n            return Optional.none();\n          }\n        })).getOrThunk(() => toLocation.bind(() => toPosition.map(to => {\n          return () => {\n            if (forward) {\n              deleteFromTo(editor, caret, from, to);\n            } else {\n              deleteFromTo(editor, caret, to, from);\n            }\n          };\n        })));\n      });\n    };\n    const backspaceDelete$3 = (editor, caret, forward) => {\n      if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {\n        const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n        return backspaceDeleteCollapsed(editor, caret, forward, from);\n      }\n      return Optional.none();\n    };\n\n    const getParentInlines = (rootElm, startElm) => {\n      const parents = parentsAndSelf(startElm, rootElm);\n      return findIndex$2(parents, isBlock$2).fold(constant(parents), index => parents.slice(0, index));\n    };\n    const hasOnlyOneChild = elm => childNodesCount(elm) === 1;\n    const deleteLastPosition = (forward, editor, target, parentInlines) => {\n      const isFormatElement$1 = curry(isFormatElement, editor);\n      const formatNodes = map$3(filter$6(parentInlines, isFormatElement$1), elm => elm.dom);\n      if (formatNodes.length === 0) {\n        deleteElement$2(editor, forward, target);\n      } else {\n        const pos = replaceWithCaretFormat(target.dom, formatNodes);\n        editor.selection.setRng(pos.toRange());\n      }\n    };\n    const deleteCaret$1 = (editor, forward) => {\n      const rootElm = SugarElement.fromDom(editor.getBody());\n      const startElm = SugarElement.fromDom(editor.selection.getStart());\n      const parentInlines = filter$6(getParentInlines(rootElm, startElm), hasOnlyOneChild);\n      return last$3(parentInlines).bind(target => {\n        const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {\n          return Optional.some(() => deleteLastPosition(forward, editor, target, parentInlines));\n        } else {\n          return Optional.none();\n        }\n      });\n    };\n    const backspaceDelete$2 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : Optional.none();\n\n    const deleteElement = (editor, forward, element) => {\n      return Optional.some(() => {\n        editor._selectionOverrides.hideFakeCaret();\n        deleteElement$2(editor, forward, SugarElement.fromDom(element));\n      });\n    };\n    const deleteCaret = (editor, forward) => {\n      const isNearMedia = forward ? isBeforeMedia : isAfterMedia;\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());\n      if (isNearMedia(fromPos)) {\n        return deleteElement(editor, forward, fromPos.getNode(!forward));\n      } else {\n        return Optional.from(normalizePosition(forward, fromPos)).filter(pos => isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos)).map(pos => () => deleteElement(editor, forward, pos.getNode(!forward)));\n      }\n    };\n    const deleteRange = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      return isMedia$2(selectedNode) ? deleteElement(editor, forward, selectedNode) : Optional.none();\n    };\n    const backspaceDelete$1 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret(editor, forward) : deleteRange(editor, forward);\n\n    const isEditable$1 = target => closest$4(target, elm => isContentEditableTrue$4(elm.dom) || isContentEditableFalse$a(elm.dom)).exists(elm => isContentEditableTrue$4(elm.dom));\n    const parseIndentValue = value => {\n      const number = parseInt(value, 10);\n      return isNaN(number) ? 0 : number;\n    };\n    const getIndentStyleName = (useMargin, element) => {\n      const indentStyleName = useMargin || isTable$2(element) ? 'margin' : 'padding';\n      const suffix = get$7(element, 'direction') === 'rtl' ? '-right' : '-left';\n      return indentStyleName + suffix;\n    };\n    const indentElement = (dom, command, useMargin, value, unit, element) => {\n      const indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));\n      if (command === 'outdent') {\n        const styleValue = Math.max(0, parseIndentValue(element.style[indentStyleName]) - value);\n        dom.setStyle(element, indentStyleName, styleValue ? styleValue + unit : '');\n      } else {\n        const styleValue = parseIndentValue(element.style[indentStyleName]) + value + unit;\n        dom.setStyle(element, indentStyleName, styleValue);\n      }\n    };\n    const validateBlocks = (editor, blocks) => forall(blocks, block => {\n      const indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);\n      const intentValue = getRaw$1(block, indentStyleName).map(parseIndentValue).getOr(0);\n      const contentEditable = editor.dom.getContentEditable(block.dom);\n      return contentEditable !== 'false' && intentValue > 0;\n    });\n    const canOutdent = editor => {\n      const blocks = getBlocksToIndent(editor);\n      return !editor.mode.isReadOnly() && (blocks.length > 1 || validateBlocks(editor, blocks));\n    };\n    const isListComponent = el => isList(el) || isListItem(el);\n    const parentIsListComponent = el => parent(el).exists(isListComponent);\n    const getBlocksToIndent = editor => filter$6(fromDom$1(editor.selection.getSelectedBlocks()), el => !isListComponent(el) && !parentIsListComponent(el) && isEditable$1(el));\n    const handle = (editor, command) => {\n      const {dom} = editor;\n      const indentation = getIndentation(editor);\n      const indentUnit = /[a-z%]+$/i.exec(indentation)[0];\n      const indentValue = parseInt(indentation, 10);\n      const useMargin = shouldIndentUseMargin(editor);\n      each$g(getBlocksToIndent(editor), block => {\n        indentElement(dom, command, useMargin, indentValue, indentUnit, block.dom);\n      });\n    };\n    const indent = editor => handle(editor, 'indent');\n    const outdent = editor => handle(editor, 'outdent');\n\n    const backspaceDelete = editor => {\n      if (editor.selection.isCollapsed() && canOutdent(editor)) {\n        const dom = editor.dom;\n        const rng = editor.selection.getRng();\n        const pos = CaretPosition.fromRangeStart(rng);\n        const block = dom.getParent(rng.startContainer, dom.isBlock);\n        if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos)) {\n          return Optional.some(() => outdent(editor));\n        }\n      }\n      return Optional.none();\n    };\n\n    const findAction = (editor, caret, forward) => findMap([\n      backspaceDelete,\n      backspaceDelete$5,\n      backspaceDelete$6,\n      (editor, forward) => backspaceDelete$3(editor, caret, forward),\n      backspaceDelete$8,\n      backspaceDelete$9,\n      backspaceDelete$4,\n      backspaceDelete$1,\n      backspaceDelete$7,\n      backspaceDelete$2\n    ], item => item(editor, forward));\n    const deleteCommand = (editor, caret) => {\n      const result = findAction(editor, caret, false);\n      result.fold(() => {\n        execDeleteCommand(editor);\n        paddEmptyBody(editor);\n      }, call);\n    };\n    const forwardDeleteCommand = (editor, caret) => {\n      const result = findAction(editor, caret, true);\n      result.fold(() => execForwardDeleteCommand(editor), call);\n    };\n    const setup$p = (editor, caret) => {\n      editor.addCommand('delete', () => {\n        deleteCommand(editor, caret);\n      });\n      editor.addCommand('forwardDelete', () => {\n        forwardDeleteCommand(editor, caret);\n      });\n    };\n\n    const SIGNIFICANT_MOVE = 5;\n    const LONGPRESS_DELAY = 400;\n    const getTouch = event => {\n      if (event.touches === undefined || event.touches.length !== 1) {\n        return Optional.none();\n      }\n      return Optional.some(event.touches[0]);\n    };\n    const isFarEnough = (touch, data) => {\n      const distX = Math.abs(touch.clientX - data.x);\n      const distY = Math.abs(touch.clientY - data.y);\n      return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;\n    };\n    const setup$o = editor => {\n      const startData = value$2();\n      const longpressFired = Cell(false);\n      const debounceLongpress = last$1(e => {\n        editor.dispatch('longpress', {\n          ...e,\n          type: 'longpress'\n        });\n        longpressFired.set(true);\n      }, LONGPRESS_DELAY);\n      editor.on('touchstart', e => {\n        getTouch(e).each(touch => {\n          debounceLongpress.cancel();\n          const data = {\n            x: touch.clientX,\n            y: touch.clientY,\n            target: e.target\n          };\n          debounceLongpress.throttle(e);\n          longpressFired.set(false);\n          startData.set(data);\n        });\n      }, true);\n      editor.on('touchmove', e => {\n        debounceLongpress.cancel();\n        getTouch(e).each(touch => {\n          startData.on(data => {\n            if (isFarEnough(touch, data)) {\n              startData.clear();\n              longpressFired.set(false);\n              editor.dispatch('longpresscancel');\n            }\n          });\n        });\n      }, true);\n      editor.on('touchend touchcancel', e => {\n        debounceLongpress.cancel();\n        if (e.type === 'touchcancel') {\n          return;\n        }\n        startData.get().filter(data => data.target.isEqualNode(e.target)).each(() => {\n          if (longpressFired.get()) {\n            e.preventDefault();\n          } else {\n            editor.dispatch('tap', {\n              ...e,\n              type: 'tap'\n            });\n          }\n        });\n      }, true);\n    };\n\n    const isBlockElement = (blockElements, node) => has$2(blockElements, node.nodeName);\n    const isValidTarget = (blockElements, node) => {\n      if (isText$8(node)) {\n        return true;\n      } else if (isElement$6(node)) {\n        return !isBlockElement(blockElements, node) && !isBookmarkNode$1(node);\n      } else {\n        return false;\n      }\n    };\n    const hasBlockParent = (blockElements, root, node) => {\n      return exists(parents(SugarElement.fromDom(node), SugarElement.fromDom(root)), elm => {\n        return isBlockElement(blockElements, elm.dom);\n      });\n    };\n    const shouldRemoveTextNode = (blockElements, node) => {\n      if (isText$8(node)) {\n        if (node.nodeValue.length === 0) {\n          return true;\n        } else if (/^\\s+$/.test(node.nodeValue) && (!node.nextSibling || isBlockElement(blockElements, node.nextSibling))) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const addRootBlocks = editor => {\n      const dom = editor.dom, selection = editor.selection;\n      const schema = editor.schema, blockElements = schema.getBlockElements();\n      let node = selection.getStart();\n      const rootNode = editor.getBody();\n      let rootBlockNode, tempNode, wrapped;\n      const forcedRootBlock = getForcedRootBlock(editor);\n      if (!node || !isElement$6(node)) {\n        return;\n      }\n      const rootNodeName = rootNode.nodeName.toLowerCase();\n      if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, node)) {\n        return;\n      }\n      const rng = selection.getRng();\n      const startContainer = rng.startContainer;\n      const startOffset = rng.startOffset;\n      const endContainer = rng.endContainer;\n      const endOffset = rng.endOffset;\n      const restoreSelection = hasFocus(editor);\n      node = rootNode.firstChild;\n      while (node) {\n        if (isValidTarget(blockElements, node)) {\n          if (shouldRemoveTextNode(blockElements, node)) {\n            tempNode = node;\n            node = node.nextSibling;\n            dom.remove(tempNode);\n            continue;\n          }\n          if (!rootBlockNode) {\n            rootBlockNode = dom.create(forcedRootBlock, getForcedRootBlockAttrs(editor));\n            node.parentNode.insertBefore(rootBlockNode, node);\n            wrapped = true;\n          }\n          tempNode = node;\n          node = node.nextSibling;\n          rootBlockNode.appendChild(tempNode);\n        } else {\n          rootBlockNode = null;\n          node = node.nextSibling;\n        }\n      }\n      if (wrapped && restoreSelection) {\n        rng.setStart(startContainer, startOffset);\n        rng.setEnd(endContainer, endOffset);\n        selection.setRng(rng);\n        editor.nodeChanged();\n      }\n    };\n    const setup$n = editor => {\n      editor.on('NodeChange', curry(addRootBlocks, editor));\n    };\n\n    const hasClass = checkClassName => node => (' ' + node.attr('class') + ' ').indexOf(checkClassName) !== -1;\n    const replaceMatchWithSpan = (editor, content, cls) => {\n      return function (match) {\n        const args = arguments, index = args[args.length - 2];\n        const prevChar = index > 0 ? content.charAt(index - 1) : '';\n        if (prevChar === '\"') {\n          return match;\n        }\n        if (prevChar === '>') {\n          const findStartTagIndex = content.lastIndexOf('<', index);\n          if (findStartTagIndex !== -1) {\n            const tagHtml = content.substring(findStartTagIndex, index);\n            if (tagHtml.indexOf('contenteditable=\"false\"') !== -1) {\n              return match;\n            }\n          }\n        }\n        return '<span class=\"' + cls + '\" data-mce-content=\"' + editor.dom.encode(args[0]) + '\">' + editor.dom.encode(typeof args[1] === 'string' ? args[1] : args[0]) + '</span>';\n      };\n    };\n    const convertRegExpsToNonEditable = (editor, nonEditableRegExps, e) => {\n      let i = nonEditableRegExps.length, content = e.content;\n      if (e.format === 'raw') {\n        return;\n      }\n      while (i--) {\n        content = content.replace(nonEditableRegExps[i], replaceMatchWithSpan(editor, content, getNonEditableClass(editor)));\n      }\n      e.content = content;\n    };\n    const setup$m = editor => {\n      const contentEditableAttrName = 'contenteditable';\n      const editClass = ' ' + Tools.trim(getEditableClass(editor)) + ' ';\n      const nonEditClass = ' ' + Tools.trim(getNonEditableClass(editor)) + ' ';\n      const hasEditClass = hasClass(editClass);\n      const hasNonEditClass = hasClass(nonEditClass);\n      const nonEditableRegExps = getNonEditableRegExps(editor);\n      if (nonEditableRegExps.length > 0) {\n        editor.on('BeforeSetContent', e => {\n          convertRegExpsToNonEditable(editor, nonEditableRegExps, e);\n        });\n      }\n      editor.parser.addAttributeFilter('class', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (hasEditClass(node)) {\n            node.attr(contentEditableAttrName, 'true');\n          } else if (hasNonEditClass(node)) {\n            node.attr(contentEditableAttrName, 'false');\n          }\n        }\n      });\n      editor.serializer.addAttributeFilter(contentEditableAttrName, nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (!hasEditClass(node) && !hasNonEditClass(node)) {\n            continue;\n          }\n          if (nonEditableRegExps.length > 0 && node.attr('data-mce-content')) {\n            node.name = '#text';\n            node.type = 3;\n            node.raw = true;\n            node.value = node.attr('data-mce-content');\n          } else {\n            node.attr(contentEditableAttrName, null);\n          }\n        }\n      });\n    };\n\n    const findBlockCaretContainer = editor => descendant(SugarElement.fromDom(editor.getBody()), '*[data-mce-caret]').map(elm => elm.dom).getOrNull();\n    const showBlockCaretContainer = (editor, blockCaretContainer) => {\n      if (blockCaretContainer.hasAttribute('data-mce-caret')) {\n        showCaretContainerBlock(blockCaretContainer);\n        editor.selection.setRng(editor.selection.getRng());\n        editor.selection.scrollIntoView(blockCaretContainer);\n      }\n    };\n    const handleBlockContainer = (editor, e) => {\n      const blockCaretContainer = findBlockCaretContainer(editor);\n      if (!blockCaretContainer) {\n        return;\n      }\n      if (e.type === 'compositionstart') {\n        e.preventDefault();\n        e.stopPropagation();\n        showBlockCaretContainer(editor, blockCaretContainer);\n        return;\n      }\n      if (hasContent(blockCaretContainer)) {\n        showBlockCaretContainer(editor, blockCaretContainer);\n        editor.undoManager.add();\n      }\n    };\n    const setup$l = editor => {\n      editor.on('keyup compositionstart', curry(handleBlockContainer, editor));\n    };\n\n    const isContentEditableFalse$2 = isContentEditableFalse$a;\n    const moveToCeFalseHorizontally = (direction, editor, range) => moveHorizontally(editor, direction, range, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$2);\n    const moveToCeFalseVertically = (direction, editor, range) => {\n      const isBefore = caretPosition => isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);\n      const isAfter = caretPosition => isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);\n      return moveVertically(editor, direction, range, isBefore, isAfter, isContentEditableFalse$2);\n    };\n    const createTextBlock = editor => {\n      const textBlock = editor.dom.create(getForcedRootBlock(editor));\n      textBlock.innerHTML = '<br data-mce-bogus=\"1\">';\n      return textBlock;\n    };\n    const exitPreBlock = (editor, direction, range) => {\n      const caretWalker = CaretWalker(editor.getBody());\n      const getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 ? caretWalker.next : caretWalker.prev);\n      if (range.collapsed) {\n        const pre = editor.dom.getParent(range.startContainer, 'PRE');\n        if (!pre) {\n          return;\n        }\n        const caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range));\n        if (!caretPos) {\n          const newBlock = SugarElement.fromDom(createTextBlock(editor));\n          if (direction === 1) {\n            after$4(SugarElement.fromDom(pre), newBlock);\n          } else {\n            before$3(SugarElement.fromDom(pre), newBlock);\n          }\n          editor.selection.select(newBlock.dom, true);\n          editor.selection.collapse();\n        }\n      }\n    };\n    const getHorizontalRange = (editor, forward) => {\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const range = editor.selection.getRng();\n      return moveToCeFalseHorizontally(direction, editor, range).orThunk(() => {\n        exitPreBlock(editor, direction, range);\n        return Optional.none();\n      });\n    };\n    const getVerticalRange = (editor, down) => {\n      const direction = down ? 1 : -1;\n      const range = editor.selection.getRng();\n      return moveToCeFalseVertically(direction, editor, range).orThunk(() => {\n        exitPreBlock(editor, direction, range);\n        return Optional.none();\n      });\n    };\n    const moveH$2 = (editor, forward) => getHorizontalRange(editor, forward).exists(newRange => {\n      moveToRange(editor, newRange);\n      return true;\n    });\n    const moveV$3 = (editor, down) => getVerticalRange(editor, down).exists(newRange => {\n      moveToRange(editor, newRange);\n      return true;\n    });\n    const moveToLineEndPoint$1 = (editor, forward) => {\n      const isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;\n      return moveToLineEndPoint$3(editor, forward, isCefPosition);\n    };\n\n    const isTarget = node => contains$2(['figcaption'], name(node));\n    const rangeBefore = target => {\n      const rng = document.createRange();\n      rng.setStartBefore(target.dom);\n      rng.setEndBefore(target.dom);\n      return rng;\n    };\n    const insertElement = (root, elm, forward) => {\n      if (forward) {\n        append$1(root, elm);\n      } else {\n        prepend(root, elm);\n      }\n    };\n    const insertEmptyLine = (root, forward, blockName, attrs) => {\n      const block = SugarElement.fromTag(blockName);\n      const br = SugarElement.fromTag('br');\n      setAll$1(block, attrs);\n      append$1(block, br);\n      insertElement(root, block, forward);\n      return rangeBefore(br);\n    };\n    const getClosestTargetBlock = (pos, root) => {\n      const isRoot = curry(eq, root);\n      return closest$4(SugarElement.fromDom(pos.container()), isBlock$2, isRoot).filter(isTarget);\n    };\n    const isAtFirstOrLastLine = (root, forward, pos) => forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);\n    const moveCaretToNewEmptyLine = (editor, forward) => {\n      const root = SugarElement.fromDom(editor.getBody());\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      const rootBlock = getForcedRootBlock(editor);\n      const rootBlockAttrs = getForcedRootBlockAttrs(editor);\n      return getClosestTargetBlock(pos, root).exists(() => {\n        if (isAtFirstOrLastLine(root, forward, pos)) {\n          const rng = insertEmptyLine(root, forward, rootBlock, rootBlockAttrs);\n          editor.selection.setRng(rng);\n          return true;\n        } else {\n          return false;\n        }\n      });\n    };\n    const moveV$2 = (editor, forward) => {\n      if (editor.selection.isCollapsed()) {\n        return moveCaretToNewEmptyLine(editor, forward);\n      } else {\n        return false;\n      }\n    };\n\n    const baseKeyPattern = {\n      shiftKey: false,\n      altKey: false,\n      ctrlKey: false,\n      metaKey: false,\n      keyCode: 0\n    };\n    const defaultPatterns = patterns => map$3(patterns, pattern => ({\n      ...baseKeyPattern,\n      action: noop,\n      ...pattern\n    }));\n    const defaultDelayedPatterns = patterns => map$3(patterns, pattern => ({\n      ...baseKeyPattern,\n      action: () => Optional.none(),\n      ...pattern\n    }));\n    const matchesEvent = (pattern, evt) => evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;\n    const match$1 = (patterns, evt) => bind$3(defaultPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\n    const matchDelayed = (patterns, evt) => bind$3(defaultDelayedPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\n    const action = (f, ...x) => () => f.apply(null, x);\n    const execute = (patterns, evt) => find$2(match$1(patterns, evt), pattern => pattern.action());\n    const executeWithDelayedAction = (patterns, evt) => findMap(matchDelayed(patterns, evt), pattern => pattern.action());\n\n    const moveH$1 = (editor, forward) => {\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const range = editor.selection.getRng();\n      return moveHorizontally(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\n        moveToRange(editor, newRange);\n        return true;\n      });\n    };\n    const moveV$1 = (editor, down) => {\n      const direction = down ? 1 : -1;\n      const range = editor.selection.getRng();\n      return moveVertically(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\n        moveToRange(editor, newRange);\n        return true;\n      });\n    };\n    const moveToLineEndPoint = (editor, forward) => {\n      const isNearMedia = forward ? isAfterMedia : isBeforeMedia;\n      return moveToLineEndPoint$3(editor, forward, isNearMedia);\n    };\n\n    const adt = Adt.generate([\n      { none: ['current'] },\n      { first: ['current'] },\n      {\n        middle: [\n          'current',\n          'target'\n        ]\n      },\n      { last: ['current'] }\n    ]);\n    const none = current => adt.none(current);\n    const CellLocation = {\n      ...adt,\n      none\n    };\n\n    const firstLayer = (scope, selector) => {\n      return filterFirstLayer(scope, selector, always);\n    };\n    const filterFirstLayer = (scope, selector, predicate) => {\n      return bind$3(children(scope), x => {\n        if (is$1(x, selector)) {\n          return predicate(x) ? [x] : [];\n        } else {\n          return filterFirstLayer(x, selector, predicate);\n        }\n      });\n    };\n\n    const lookup$1 = (tags, element, isRoot = never) => {\n      if (isRoot(element)) {\n        return Optional.none();\n      }\n      if (contains$2(tags, name(element))) {\n        return Optional.some(element);\n      }\n      const isRootOrUpperTable = elm => is$1(elm, 'table') || isRoot(elm);\n      return ancestor$2(element, tags.join(','), isRootOrUpperTable);\n    };\n    const cell = (element, isRoot) => lookup$1([\n      'td',\n      'th'\n    ], element, isRoot);\n    const cells = ancestor => firstLayer(ancestor, 'th,td');\n    const table = (element, isRoot) => closest$3(element, 'table', isRoot);\n\n    const walk = (all, current, index, direction, isEligible = always) => {\n      const forwards = direction === 1;\n      if (!forwards && index <= 0) {\n        return CellLocation.first(all[0]);\n      } else if (forwards && index >= all.length - 1) {\n        return CellLocation.last(all[all.length - 1]);\n      } else {\n        const newIndex = index + direction;\n        const elem = all[newIndex];\n        return isEligible(elem) ? CellLocation.middle(current, elem) : walk(all, current, newIndex, direction, isEligible);\n      }\n    };\n    const detect = (current, isRoot) => {\n      return table(current, isRoot).bind(table => {\n        const all = cells(table);\n        const index = findIndex$2(all, x => eq(current, x));\n        return index.map(index => ({\n          index,\n          all\n        }));\n      });\n    };\n    const next = (current, isEligible, isRoot) => {\n      const detection = detect(current, isRoot);\n      return detection.fold(() => {\n        return CellLocation.none(current);\n      }, info => {\n        return walk(info.all, current, info.index, 1, isEligible);\n      });\n    };\n    const prev = (current, isEligible, isRoot) => {\n      const detection = detect(current, isRoot);\n      return detection.fold(() => {\n        return CellLocation.none();\n      }, info => {\n        return walk(info.all, current, info.index, -1, isEligible);\n      });\n    };\n\n    const closest = target => closest$3(target, '[contenteditable]');\n    const isEditable = (element, assumeEditable = false) => {\n      if (inBody(element)) {\n        return element.dom.isContentEditable;\n      } else {\n        return closest(element).fold(constant(assumeEditable), editable => getRaw(editable) === 'true');\n      }\n    };\n    const getRaw = element => element.dom.contentEditable;\n\n    const deflate = (rect, delta) => ({\n      left: rect.left - delta,\n      top: rect.top - delta,\n      right: rect.right + delta * 2,\n      bottom: rect.bottom + delta * 2,\n      width: rect.width + delta,\n      height: rect.height + delta\n    });\n    const getCorners = (getYAxisValue, tds) => bind$3(tds, td => {\n      const rect = deflate(clone$1(td.getBoundingClientRect()), -1);\n      return [\n        {\n          x: rect.left,\n          y: getYAxisValue(rect),\n          cell: td\n        },\n        {\n          x: rect.right,\n          y: getYAxisValue(rect),\n          cell: td\n        }\n      ];\n    });\n    const findClosestCorner = (corners, x, y) => foldl(corners, (acc, newCorner) => acc.fold(() => Optional.some(newCorner), oldCorner => {\n      const oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));\n      const newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));\n      return Optional.some(newDist < oldDist ? newCorner : oldCorner);\n    }), Optional.none());\n    const getClosestCell = (getYAxisValue, isTargetCorner, table, x, y) => {\n      const cells = descendants(SugarElement.fromDom(table), 'td,th,caption').map(e => e.dom);\n      const corners = filter$6(getCorners(getYAxisValue, cells), corner => isTargetCorner(corner, y));\n      return findClosestCorner(corners, x, y).map(corner => corner.cell);\n    };\n    const getBottomValue = rect => rect.bottom;\n    const getTopValue = rect => rect.top;\n    const isAbove = (corner, y) => corner.y < y;\n    const isBelow = (corner, y) => corner.y > y;\n    const getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);\n    const getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);\n    const findClosestPositionInAboveCell = (table, pos) => head(pos.getClientRects()).bind(rect => getClosestCellAbove(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getLastLinePositions(cell), pos));\n    const findClosestPositionInBelowCell = (table, pos) => last$3(pos.getClientRects()).bind(rect => getClosestCellBelow(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getFirstLinePositions(cell), pos));\n\n    const hasNextBreak = (getPositionsUntil, scope, lineInfo) => lineInfo.breakAt.exists(breakPos => getPositionsUntil(scope, breakPos).breakAt.isSome());\n    const startsWithWrapBreak = lineInfo => lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;\n    const startsWithBrBreak = lineInfo => lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;\n    const isAtTableCellLine = (getPositionsUntil, scope, pos) => {\n      const lineInfo = getPositionsUntil(scope, pos);\n      if (startsWithWrapBreak(lineInfo) || !isBr$5(pos.getNode()) && startsWithBrBreak(lineInfo)) {\n        return !hasNextBreak(getPositionsUntil, scope, lineInfo);\n      } else {\n        return lineInfo.breakAt.isNone();\n      }\n    };\n    const isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);\n    const isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);\n    const isCaretAtStartOrEndOfTable = (forward, rng, table) => {\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      return positionIn(!forward, table).exists(pos => pos.isEqual(caretPos));\n    };\n    const navigateHorizontally = (editor, forward, table, _td) => {\n      const rng = editor.selection.getRng();\n      const direction = forward ? 1 : -1;\n      if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {\n        showCaret(direction, editor, table, !forward, false).each(newRng => {\n          moveToRange(editor, newRng);\n        });\n        return true;\n      }\n      return false;\n    };\n    const getClosestAbovePosition = (root, table, start) => findClosestPositionInAboveCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table)), rect.left))).getOr(CaretPosition.before(table));\n    const getClosestBelowPosition = (root, table, start) => findClosestPositionInBelowCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table)), rect.left))).getOr(CaretPosition.after(table));\n    const getTable = (previous, pos) => {\n      const node = pos.getNode(previous);\n      return isElement$6(node) && node.nodeName === 'TABLE' ? Optional.some(node) : Optional.none();\n    };\n    const renderBlock = (down, editor, table) => {\n      const forcedRootBlock = getForcedRootBlock(editor);\n      editor.undoManager.transact(() => {\n        const element = SugarElement.fromTag(forcedRootBlock);\n        setAll$1(element, getForcedRootBlockAttrs(editor));\n        append$1(element, SugarElement.fromTag('br'));\n        if (down) {\n          after$4(SugarElement.fromDom(table), element);\n        } else {\n          before$3(SugarElement.fromDom(table), element);\n        }\n        const rng = editor.dom.createRng();\n        rng.setStart(element.dom, 0);\n        rng.setEnd(element.dom, 0);\n        moveToRange(editor, rng);\n      });\n    };\n    const moveCaret = (editor, down, pos) => {\n      const table = down ? getTable(true, pos) : getTable(false, pos);\n      const last = down === false;\n      table.fold(() => moveToRange(editor, pos.toRange()), table => positionIn(last, editor.getBody()).filter(lastPos => lastPos.isEqual(pos)).fold(() => moveToRange(editor, pos.toRange()), _ => renderBlock(down, editor, table)));\n    };\n    const navigateVertically = (editor, down, table, td) => {\n      const rng = editor.selection.getRng();\n      const pos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (!down && isAtFirstTableCellLine(td, pos)) {\n        const newPos = getClosestAbovePosition(root, table, pos);\n        moveCaret(editor, down, newPos);\n        return true;\n      } else if (down && isAtLastTableCellLine(td, pos)) {\n        const newPos = getClosestBelowPosition(root, table, pos);\n        moveCaret(editor, down, newPos);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const move$1 = (editor, forward, mover) => Optional.from(editor.dom.getParent(editor.selection.getNode(), 'td,th')).bind(td => Optional.from(editor.dom.getParent(td, 'table')).map(table => mover(editor, forward, table, td))).getOr(false);\n    const moveH = (editor, forward) => move$1(editor, forward, navigateHorizontally);\n    const moveV = (editor, forward) => move$1(editor, forward, navigateVertically);\n    const getCellFirstCursorPosition = cell => {\n      const selection = SimSelection.exact(cell, 0, cell, 0);\n      return toNative(selection);\n    };\n    const tabGo = (editor, isRoot, cell) => {\n      return cell.fold(Optional.none, Optional.none, (_current, next) => {\n        return first(next).map(cell => {\n          return getCellFirstCursorPosition(cell);\n        });\n      }, current => {\n        editor.execCommand('mceTableInsertRowAfter');\n        return tabForward(editor, isRoot, current);\n      });\n    };\n    const tabForward = (editor, isRoot, cell) => tabGo(editor, isRoot, next(cell, isEditable));\n    const tabBackward = (editor, isRoot, cell) => tabGo(editor, isRoot, prev(cell, isEditable));\n    const handleTab = (editor, forward) => {\n      const rootElements = [\n        'table',\n        'li',\n        'dl'\n      ];\n      const body = SugarElement.fromDom(editor.getBody());\n      const isRoot = element => {\n        const name$1 = name(element);\n        return eq(element, body) || contains$2(rootElements, name$1);\n      };\n      const rng = editor.selection.getRng();\n      const container = SugarElement.fromDom(!forward ? rng.startContainer : rng.endContainer);\n      return cell(container, isRoot).map(cell => {\n        table(cell, isRoot).each(table => {\n          editor.model.table.clearSelectedCells(table.dom);\n        });\n        editor.selection.collapse(!forward);\n        const navigation = !forward ? tabBackward : tabForward;\n        const rng = navigation(editor, isRoot, cell);\n        rng.each(range => {\n          editor.selection.setRng(range);\n        });\n        return true;\n      }).getOr(false);\n    };\n\n    const executeKeydownOverride$4 = (editor, caret, evt) => {\n      const os = detect$2().os;\n      execute([\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH$2, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH$2, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$3, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$3, editor, true)\n        },\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV, editor, true)\n        },\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH$1, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH$1, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$1, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$1, editor, true)\n        },\n        {\n          keyCode: VK.RIGHT,\n          action: action(move$2, editor, caret, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(move$2, editor, caret, false)\n        },\n        {\n          keyCode: VK.RIGHT,\n          ctrlKey: !os.isMacOS(),\n          altKey: os.isMacOS(),\n          action: action(moveNextWord, editor, caret)\n        },\n        {\n          keyCode: VK.LEFT,\n          ctrlKey: !os.isMacOS(),\n          altKey: os.isMacOS(),\n          action: action(movePrevWord, editor, caret)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$2, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$2, editor, true)\n        }\n      ], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$k = (editor, caret) => {\n      editor.on('keydown', evt => {\n        if (evt.isDefaultPrevented() === false) {\n          executeKeydownOverride$4(editor, caret, evt);\n        }\n      });\n    };\n\n    const point = (container, offset) => ({\n      container,\n      offset\n    });\n\n    const DOM$7 = DOMUtils.DOM;\n    const alwaysNext = startNode => node => startNode === node ? -1 : 0;\n    const isBoundary = dom => node => dom.isBlock(node) || contains$2([\n      'BR',\n      'IMG',\n      'HR',\n      'INPUT'\n    ], node.nodeName) || dom.getContentEditable(node) === 'false';\n    const textBefore = (node, offset, rootNode) => {\n      if (isText$8(node) && offset >= 0) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, prev.container.data.length));\n      }\n    };\n    const textAfter = (node, offset, rootNode) => {\n      if (isText$8(node) && offset >= node.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, 0));\n      }\n    };\n    const scanLeft = (node, offset, rootNode) => {\n      if (!isText$8(node)) {\n        return Optional.none();\n      }\n      const text = node.textContent;\n      if (offset >= 0 && offset <= text.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).bind(prev => {\n          const prevText = prev.container.data;\n          return scanLeft(prev.container, offset + prevText.length, rootNode);\n        });\n      }\n    };\n    const scanRight = (node, offset, rootNode) => {\n      if (!isText$8(node)) {\n        return Optional.none();\n      }\n      const text = node.textContent;\n      if (offset <= text.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).bind(next => scanRight(next.container, offset - text.length, rootNode));\n      }\n    };\n    const repeatLeft = (dom, node, offset, process, rootNode) => {\n      const search = TextSeeker(dom, isBoundary(dom));\n      return Optional.from(search.backwards(node, offset, process, rootNode));\n    };\n\n    const isValidTextRange = rng => rng.collapsed && rng.startContainer.nodeType === 3;\n    const getText = rng => rng.toString().replace(/\\u00A0/g, ' ').replace(/\\uFEFF/g, '');\n    const isWhitespace = chr => chr !== '' && ' \\xA0\\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\n\n    const stripTriggerChar = (text, triggerCh) => text.substring(triggerCh.length);\n    const findChar = (text, index, ch) => {\n      let i;\n      for (i = index - 1; i >= 0; i--) {\n        const char = text.charAt(i);\n        if (isWhitespace(char)) {\n          return Optional.none();\n        }\n        if (char === ch) {\n          break;\n        }\n      }\n      return Optional.some(i);\n    };\n    const findStart = (dom, initRange, ch, minChars = 0) => {\n      if (!isValidTextRange(initRange)) {\n        return Optional.none();\n      }\n      const findTriggerChIndex = (element, offset, text) => findChar(text, offset, ch).getOr(offset);\n      const root = dom.getParent(initRange.startContainer, dom.isBlock) || dom.getRoot();\n      return repeatLeft(dom, initRange.startContainer, initRange.startOffset, findTriggerChIndex, root).bind(spot => {\n        const range = initRange.cloneRange();\n        range.setStart(spot.container, spot.offset);\n        range.setEnd(initRange.endContainer, initRange.endOffset);\n        if (range.collapsed) {\n          return Optional.none();\n        }\n        const text = getText(range);\n        const triggerCharIndex = text.lastIndexOf(ch);\n        if (triggerCharIndex !== 0 || stripTriggerChar(text, ch).length < minChars) {\n          return Optional.none();\n        } else {\n          return Optional.some({\n            text: stripTriggerChar(text, ch),\n            range,\n            triggerChar: ch\n          });\n        }\n      });\n    };\n    const getContext = (dom, initRange, ch, minChars = 0) => detect$1(SugarElement.fromDom(initRange.startContainer)).fold(() => findStart(dom, initRange, ch, minChars), elm => {\n      const range = dom.createRng();\n      range.selectNode(elm.dom);\n      const text = getText(range);\n      return Optional.some({\n        range,\n        text: stripTriggerChar(text, ch),\n        triggerChar: ch\n      });\n    });\n\n    const isText = node => node.nodeType === TEXT;\n    const isElement = node => node.nodeType === ELEMENT;\n    const toLast = node => {\n      if (isText(node)) {\n        return point(node, node.data.length);\n      } else {\n        const children = node.childNodes;\n        return children.length > 0 ? toLast(children[children.length - 1]) : point(node, children.length);\n      }\n    };\n    const toLeaf = (node, offset) => {\n      const children = node.childNodes;\n      if (children.length > 0 && offset < children.length) {\n        return toLeaf(children[offset], 0);\n      } else if (children.length > 0 && isElement(node) && children.length === offset) {\n        return toLast(children[children.length - 1]);\n      } else {\n        return point(node, offset);\n      }\n    };\n\n    const isPreviousCharContent = (dom, leaf) => repeatLeft(dom, leaf.container, leaf.offset, (element, offset) => offset === 0 ? -1 : offset, dom.getRoot()).filter(spot => {\n      const char = spot.container.data.charAt(spot.offset - 1);\n      return !isWhitespace(char);\n    }).isSome();\n    const isStartOfWord = dom => rng => {\n      const leaf = toLeaf(rng.startContainer, rng.startOffset);\n      return !isPreviousCharContent(dom, leaf);\n    };\n    const getTriggerContext = (dom, initRange, database) => findMap(database.triggerChars, ch => getContext(dom, initRange, ch));\n    const lookup = (editor, getDatabase) => {\n      const database = getDatabase();\n      const rng = editor.selection.getRng();\n      return getTriggerContext(editor.dom, rng, database).bind(context => lookupWithContext(editor, getDatabase, context));\n    };\n    const lookupWithContext = (editor, getDatabase, context, fetchOptions = {}) => {\n      const database = getDatabase();\n      const rng = editor.selection.getRng();\n      const startText = rng.startContainer.nodeValue;\n      const autocompleters = filter$6(database.lookupByChar(context.triggerChar), autocompleter => context.text.length >= autocompleter.minChars && autocompleter.matches.getOrThunk(() => isStartOfWord(editor.dom))(context.range, startText, context.text));\n      if (autocompleters.length === 0) {\n        return Optional.none();\n      }\n      const lookupData = Promise.all(map$3(autocompleters, ac => {\n        const fetchResult = ac.fetch(context.text, ac.maxResults, fetchOptions);\n        return fetchResult.then(results => ({\n          matchText: context.text,\n          items: results,\n          columns: ac.columns,\n          onAction: ac.onAction,\n          highlightOn: ac.highlightOn\n        }));\n      }));\n      return Optional.some({\n        lookupData,\n        context\n      });\n    };\n\n    var SimpleResultType;\n    (function (SimpleResultType) {\n      SimpleResultType[SimpleResultType['Error'] = 0] = 'Error';\n      SimpleResultType[SimpleResultType['Value'] = 1] = 'Value';\n    }(SimpleResultType || (SimpleResultType = {})));\n    const fold$1 = (res, onError, onValue) => res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);\n    const partition = results => {\n      const values = [];\n      const errors = [];\n      each$g(results, obj => {\n        fold$1(obj, err => errors.push(err), val => values.push(val));\n      });\n      return {\n        values,\n        errors\n      };\n    };\n    const mapError = (res, f) => {\n      if (res.stype === SimpleResultType.Error) {\n        return {\n          stype: SimpleResultType.Error,\n          serror: f(res.serror)\n        };\n      } else {\n        return res;\n      }\n    };\n    const map = (res, f) => {\n      if (res.stype === SimpleResultType.Value) {\n        return {\n          stype: SimpleResultType.Value,\n          svalue: f(res.svalue)\n        };\n      } else {\n        return res;\n      }\n    };\n    const bind = (res, f) => {\n      if (res.stype === SimpleResultType.Value) {\n        return f(res.svalue);\n      } else {\n        return res;\n      }\n    };\n    const bindError = (res, f) => {\n      if (res.stype === SimpleResultType.Error) {\n        return f(res.serror);\n      } else {\n        return res;\n      }\n    };\n    const svalue = v => ({\n      stype: SimpleResultType.Value,\n      svalue: v\n    });\n    const serror = e => ({\n      stype: SimpleResultType.Error,\n      serror: e\n    });\n    const toResult = res => fold$1(res, Result.error, Result.value);\n    const fromResult = res => res.fold(serror, svalue);\n    const SimpleResult = {\n      fromResult,\n      toResult,\n      svalue,\n      partition,\n      serror,\n      bind,\n      bindError,\n      map,\n      mapError,\n      fold: fold$1\n    };\n\n    const formatObj = input => {\n      return isObject(input) && keys(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);\n    };\n    const formatErrors = errors => {\n      const es = errors.length > 10 ? errors.slice(0, 10).concat([{\n          path: [],\n          getErrorInfo: constant('... (only showing first ten failures)')\n        }]) : errors;\n      return map$3(es, e => {\n        return 'Failed path: (' + e.path.join(' > ') + ')\\n' + e.getErrorInfo();\n      });\n    };\n\n    const nu = (path, getErrorInfo) => {\n      return SimpleResult.serror([{\n          path,\n          getErrorInfo\n        }]);\n    };\n    const missingRequired = (path, key, obj) => nu(path, () => 'Could not find valid *required* value for \"' + key + '\" in ' + formatObj(obj));\n    const missingKey = (path, key) => nu(path, () => 'Choice schema did not contain choice key: \"' + key + '\"');\n    const missingBranch = (path, branches, branch) => nu(path, () => 'The chosen schema: \"' + branch + '\" did not exist in branches: ' + formatObj(branches));\n    const custom = (path, err) => nu(path, constant(err));\n\n    const chooseFrom = (path, input, branches, ch) => {\n      const fields = get$a(branches, ch);\n      return fields.fold(() => missingBranch(path, branches, ch), vp => vp.extract(path.concat(['branch: ' + ch]), input));\n    };\n    const choose$1 = (key, branches) => {\n      const extract = (path, input) => {\n        const choice = get$a(input, key);\n        return choice.fold(() => missingKey(path, key), chosen => chooseFrom(path, input, branches, chosen));\n      };\n      const toString = () => 'chooseOn(' + key + '). Possible values: ' + keys(branches);\n      return {\n        extract,\n        toString\n      };\n    };\n\n    const shallow = (old, nu) => {\n      return nu;\n    };\n    const deep = (old, nu) => {\n      const bothObjects = isPlainObject(old) && isPlainObject(nu);\n      return bothObjects ? deepMerge(old, nu) : nu;\n    };\n    const baseMerge = merger => {\n      return (...objects) => {\n        if (objects.length === 0) {\n          throw new Error(`Can't merge zero objects`);\n        }\n        const ret = {};\n        for (let j = 0; j < objects.length; j++) {\n          const curObject = objects[j];\n          for (const key in curObject) {\n            if (has$2(curObject, key)) {\n              ret[key] = merger(ret[key], curObject[key]);\n            }\n          }\n        }\n        return ret;\n      };\n    };\n    const deepMerge = baseMerge(deep);\n    const merge = baseMerge(shallow);\n\n    const required = () => ({\n      tag: 'required',\n      process: {}\n    });\n    const defaultedThunk = fallbackThunk => ({\n      tag: 'defaultedThunk',\n      process: fallbackThunk\n    });\n    const defaulted$1 = fallback => defaultedThunk(constant(fallback));\n    const asOption = () => ({\n      tag: 'option',\n      process: {}\n    });\n\n    const mergeValues = (values, base) => values.length > 0 ? SimpleResult.svalue(deepMerge(base, merge.apply(undefined, values))) : SimpleResult.svalue(base);\n    const mergeErrors = errors => compose(SimpleResult.serror, flatten)(errors);\n    const consolidateObj = (objects, base) => {\n      const partition = SimpleResult.partition(objects);\n      return partition.errors.length > 0 ? mergeErrors(partition.errors) : mergeValues(partition.values, base);\n    };\n    const consolidateArr = objects => {\n      const partitions = SimpleResult.partition(objects);\n      return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : SimpleResult.svalue(partitions.values);\n    };\n    const ResultCombine = {\n      consolidateObj,\n      consolidateArr\n    };\n\n    const field$1 = (key, newKey, presence, prop) => ({\n      tag: 'field',\n      key,\n      newKey,\n      presence,\n      prop\n    });\n    const customField$1 = (newKey, instantiator) => ({\n      tag: 'custom',\n      newKey,\n      instantiator\n    });\n    const fold = (value, ifField, ifCustom) => {\n      switch (value.tag) {\n      case 'field':\n        return ifField(value.key, value.newKey, value.presence, value.prop);\n      case 'custom':\n        return ifCustom(value.newKey, value.instantiator);\n      }\n    };\n\n    const value = validator => {\n      const extract = (path, val) => {\n        return SimpleResult.bindError(validator(val), err => custom(path, err));\n      };\n      const toString = constant('val');\n      return {\n        extract,\n        toString\n      };\n    };\n    const anyValue$1 = value(SimpleResult.svalue);\n\n    const requiredAccess = (path, obj, key, bundle) => get$a(obj, key).fold(() => missingRequired(path, key, obj), bundle);\n    const fallbackAccess = (obj, key, fallback, bundle) => {\n      const v = get$a(obj, key).getOrThunk(() => fallback(obj));\n      return bundle(v);\n    };\n    const optionAccess = (obj, key, bundle) => bundle(get$a(obj, key));\n    const optionDefaultedAccess = (obj, key, fallback, bundle) => {\n      const opt = get$a(obj, key).map(val => val === true ? fallback(obj) : val);\n      return bundle(opt);\n    };\n    const extractField = (field, path, obj, key, prop) => {\n      const bundle = av => prop.extract(path.concat([key]), av);\n      const bundleAsOption = optValue => optValue.fold(() => SimpleResult.svalue(Optional.none()), ov => {\n        const result = prop.extract(path.concat([key]), ov);\n        return SimpleResult.map(result, Optional.some);\n      });\n      switch (field.tag) {\n      case 'required':\n        return requiredAccess(path, obj, key, bundle);\n      case 'defaultedThunk':\n        return fallbackAccess(obj, key, field.process, bundle);\n      case 'option':\n        return optionAccess(obj, key, bundleAsOption);\n      case 'defaultedOptionThunk':\n        return optionDefaultedAccess(obj, key, field.process, bundleAsOption);\n      case 'mergeWithThunk': {\n          return fallbackAccess(obj, key, constant({}), v => {\n            const result = deepMerge(field.process(obj), v);\n            return bundle(result);\n          });\n        }\n      }\n    };\n    const extractFields = (path, obj, fields) => {\n      const success = {};\n      const errors = [];\n      for (const field of fields) {\n        fold(field, (key, newKey, presence, prop) => {\n          const result = extractField(presence, path, obj, key, prop);\n          SimpleResult.fold(result, err => {\n            errors.push(...err);\n          }, res => {\n            success[newKey] = res;\n          });\n        }, (newKey, instantiator) => {\n          success[newKey] = instantiator(obj);\n        });\n      }\n      return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);\n    };\n    const objOf = values => {\n      const extract = (path, o) => extractFields(path, o, values);\n      const toString = () => {\n        const fieldStrings = map$3(values, value => fold(value, (key, _okey, _presence, prop) => key + ' -> ' + prop.toString(), (newKey, _instantiator) => 'state(' + newKey + ')'));\n        return 'obj{\\n' + fieldStrings.join('\\n') + '}';\n      };\n      return {\n        extract,\n        toString\n      };\n    };\n    const arrOf = prop => {\n      const extract = (path, array) => {\n        const results = map$3(array, (a, i) => prop.extract(path.concat(['[' + i + ']']), a));\n        return ResultCombine.consolidateArr(results);\n      };\n      const toString = () => 'array(' + prop.toString() + ')';\n      return {\n        extract,\n        toString\n      };\n    };\n\n    const valueOf = validator => value(v => validator(v).fold(SimpleResult.serror, SimpleResult.svalue));\n    const extractValue = (label, prop, obj) => {\n      const res = prop.extract([label], obj);\n      return SimpleResult.mapError(res, errs => ({\n        input: obj,\n        errors: errs\n      }));\n    };\n    const asRaw = (label, prop, obj) => SimpleResult.toResult(extractValue(label, prop, obj));\n    const formatError = errInfo => {\n      return 'Errors: \\n' + formatErrors(errInfo.errors).join('\\n') + '\\n\\nInput object: ' + formatObj(errInfo.input);\n    };\n    const choose = (key, branches) => choose$1(key, map$2(branches, objOf));\n\n    const anyValue = constant(anyValue$1);\n    const typedValue = (validator, expectedType) => value(a => {\n      const actualType = typeof a;\n      return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${ expectedType } but got: ${ actualType }`);\n    });\n    const number = typedValue(isNumber, 'number');\n    const string = typedValue(isString, 'string');\n    const boolean = typedValue(isBoolean, 'boolean');\n    const functionProcessor = typedValue(isFunction, 'function');\n\n    const field = field$1;\n    const customField = customField$1;\n    const validateEnum = values => valueOf(value => contains$2(values, value) ? Result.value(value) : Result.error(`Unsupported value: \"${ value }\", choose one of \"${ values.join(', ') }\".`));\n    const requiredOf = (key, schema) => field(key, key, required(), schema);\n    const requiredString = key => requiredOf(key, string);\n    const requiredFunction = key => requiredOf(key, functionProcessor);\n    const requiredArrayOf = (key, schema) => field(key, key, required(), arrOf(schema));\n    const optionOf = (key, schema) => field(key, key, asOption(), schema);\n    const optionString = key => optionOf(key, string);\n    const optionFunction = key => optionOf(key, functionProcessor);\n    const defaulted = (key, fallback) => field(key, key, defaulted$1(fallback), anyValue());\n    const defaultedOf = (key, fallback, schema) => field(key, key, defaulted$1(fallback), schema);\n    const defaultedNumber = (key, fallback) => defaultedOf(key, fallback, number);\n    const defaultedString = (key, fallback) => defaultedOf(key, fallback, string);\n    const defaultedStringEnum = (key, fallback, values) => defaultedOf(key, fallback, validateEnum(values));\n    const defaultedBoolean = (key, fallback) => defaultedOf(key, fallback, boolean);\n    const defaultedFunction = (key, fallback) => defaultedOf(key, fallback, functionProcessor);\n    const defaultedArrayOf = (key, fallback, schema) => defaultedOf(key, fallback, arrOf(schema));\n\n    const type = requiredString('type');\n    const fetch = requiredFunction('fetch');\n    const onAction = requiredFunction('onAction');\n    const onSetup = defaultedFunction('onSetup', () => noop);\n    const optionalText = optionString('text');\n    const optionalIcon = optionString('icon');\n    const optionalTooltip = optionString('tooltip');\n    const optionalLabel = optionString('label');\n    const active = defaultedBoolean('active', false);\n    const enabled = defaultedBoolean('enabled', true);\n    const primary = defaultedBoolean('primary', false);\n    const defaultedColumns = num => defaulted('columns', num);\n    const defaultedType = type => defaultedString('type', type);\n\n    const autocompleterSchema = objOf([\n      type,\n      requiredString('ch'),\n      defaultedNumber('minChars', 1),\n      defaultedColumns(1),\n      defaultedNumber('maxResults', 10),\n      optionFunction('matches'),\n      fetch,\n      onAction,\n      defaultedArrayOf('highlightOn', [], string)\n    ]);\n    const createAutocompleter = spec => asRaw('Autocompleter', autocompleterSchema, spec);\n\n    const baseToolbarButtonFields = [\n      enabled,\n      optionalTooltip,\n      optionalIcon,\n      optionalText,\n      onSetup\n    ];\n\n    const baseToolbarToggleButtonFields = [active].concat(baseToolbarButtonFields);\n\n    const contextBarFields = [\n      defaultedFunction('predicate', never),\n      defaultedStringEnum('scope', 'node', [\n        'node',\n        'editor'\n      ]),\n      defaultedStringEnum('position', 'selection', [\n        'node',\n        'selection',\n        'line'\n      ])\n    ];\n\n    const contextButtonFields = baseToolbarButtonFields.concat([\n      defaultedType('contextformbutton'),\n      primary,\n      onAction,\n      customField('original', identity)\n    ]);\n    const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([\n      defaultedType('contextformbutton'),\n      primary,\n      onAction,\n      customField('original', identity)\n    ]);\n    const launchButtonFields = baseToolbarButtonFields.concat([defaultedType('contextformbutton')]);\n    const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType('contextformtogglebutton')]);\n    const toggleOrNormal = choose('type', {\n      contextformbutton: contextButtonFields,\n      contextformtogglebutton: contextToggleButtonFields\n    });\n    objOf([\n      defaultedType('contextform'),\n      defaultedFunction('initValue', constant('')),\n      optionalLabel,\n      requiredArrayOf('commands', toggleOrNormal),\n      optionOf('launch', choose('type', {\n        contextformbutton: launchButtonFields,\n        contextformtogglebutton: launchToggleButtonFields\n      }))\n    ].concat(contextBarFields));\n\n    const register$2 = editor => {\n      const popups = editor.ui.registry.getAll().popups;\n      const dataset = map$2(popups, popup => createAutocompleter(popup).fold(err => {\n        throw new Error(formatError(err));\n      }, identity));\n      const triggerChars = stringArray(mapToArray(dataset, v => v.ch));\n      const datasetValues = values(dataset);\n      const lookupByChar = ch => filter$6(datasetValues, dv => dv.ch === ch);\n      return {\n        dataset,\n        triggerChars,\n        lookupByChar\n      };\n    };\n\n    const setupEditorInput = (editor, api) => {\n      const update = last$1(api.load, 50);\n      editor.on('keypress compositionend', e => {\n        if (e.which === 27) {\n          return;\n        }\n        update.throttle();\n      });\n      editor.on('keydown', e => {\n        const keyCode = e.which;\n        if (keyCode === 8) {\n          update.throttle();\n        } else if (keyCode === 27) {\n          api.cancelIfNecessary();\n        }\n      });\n      editor.on('remove', update.cancel);\n    };\n    const setup$j = editor => {\n      const activeAutocompleter = value$2();\n      const uiActive = Cell(false);\n      const isActive = activeAutocompleter.isSet;\n      const cancelIfNecessary = () => {\n        if (isActive()) {\n          removeAutocompleterDecoration(editor);\n          fireAutocompleterEnd(editor);\n          uiActive.set(false);\n          activeAutocompleter.clear();\n        }\n      };\n      const commenceIfNecessary = context => {\n        if (!isActive()) {\n          addAutocompleterDecoration(editor, context.range);\n          activeAutocompleter.set({\n            triggerChar: context.triggerChar,\n            matchLength: context.text.length\n          });\n        }\n      };\n      const getAutocompleters = cached(() => register$2(editor));\n      const doLookup = fetchOptions => activeAutocompleter.get().map(ac => getContext(editor.dom, editor.selection.getRng(), ac.triggerChar).bind(newContext => lookupWithContext(editor, getAutocompleters, newContext, fetchOptions))).getOrThunk(() => lookup(editor, getAutocompleters));\n      const load = fetchOptions => {\n        doLookup(fetchOptions).fold(cancelIfNecessary, lookupInfo => {\n          commenceIfNecessary(lookupInfo.context);\n          lookupInfo.lookupData.then(lookupData => {\n            activeAutocompleter.get().map(ac => {\n              const context = lookupInfo.context;\n              if (ac.triggerChar === context.triggerChar) {\n                if (context.text.length - ac.matchLength >= 10) {\n                  cancelIfNecessary();\n                } else {\n                  activeAutocompleter.set({\n                    ...ac,\n                    matchLength: context.text.length\n                  });\n                  if (uiActive.get()) {\n                    fireAutocompleterUpdate(editor, { lookupData });\n                  } else {\n                    uiActive.set(true);\n                    fireAutocompleterStart(editor, { lookupData });\n                  }\n                }\n              }\n            });\n          });\n        });\n      };\n      editor.addCommand('mceAutocompleterReload', (_ui, value) => {\n        const fetchOptions = isObject(value) ? value.fetchOptions : {};\n        load(fetchOptions);\n      });\n      editor.addCommand('mceAutocompleterClose', cancelIfNecessary);\n      setupEditorInput(editor, {\n        cancelIfNecessary,\n        load\n      });\n    };\n\n    const createAndFireInputEvent = eventType => (editor, inputType, specifics = {}) => {\n      const target = editor.getBody();\n      const overrides = {\n        bubbles: true,\n        composed: true,\n        data: null,\n        isComposing: false,\n        detail: 0,\n        view: null,\n        target,\n        currentTarget: target,\n        eventPhase: Event.AT_TARGET,\n        originalTarget: target,\n        explicitOriginalTarget: target,\n        isTrusted: false,\n        srcElement: target,\n        cancelable: false,\n        preventDefault: noop,\n        inputType\n      };\n      const input = clone$3(new InputEvent(eventType));\n      return editor.dispatch(eventType, {\n        ...input,\n        ...overrides,\n        ...specifics\n      });\n    };\n    const fireFakeInputEvent = createAndFireInputEvent('input');\n    const fireFakeBeforeInputEvent = createAndFireInputEvent('beforeinput');\n\n    const executeKeydownOverride$3 = (editor, caret, evt) => {\n      const inputType = evt.keyCode === VK.BACKSPACE ? 'deleteContentBackward' : 'deleteContentForward';\n      executeWithDelayedAction([\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete, editor)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$5, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$5, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$6, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$6, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$3, editor, caret, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$3, editor, caret, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$9, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$9, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$4, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$4, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$1, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$1, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$7, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$7, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$8, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$8, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$2, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$2, editor, true)\n        }\n      ], evt).each(applyAction => {\n        evt.preventDefault();\n        const beforeInput = fireFakeBeforeInputEvent(editor, inputType);\n        if (!beforeInput.isDefaultPrevented()) {\n          applyAction();\n          fireFakeInputEvent(editor, inputType);\n        }\n      });\n    };\n    const executeKeyupOverride = (editor, evt) => {\n      execute([\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(paddEmptyElement, editor)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(paddEmptyElement, editor)\n        }\n      ], evt);\n    };\n    const setup$i = (editor, caret) => {\n      editor.on('keydown', evt => {\n        if (evt.isDefaultPrevented() === false) {\n          executeKeydownOverride$3(editor, caret, evt);\n        }\n      });\n      editor.on('keyup', evt => {\n        if (evt.isDefaultPrevented() === false) {\n          executeKeyupOverride(editor, evt);\n        }\n      });\n    };\n\n    const firstNonWhiteSpaceNodeSibling = node => {\n      while (node) {\n        if (node.nodeType === 1 || node.nodeType === 3 && node.data && /[\\r\\n\\s]/.test(node.data)) {\n          return node;\n        }\n        node = node.nextSibling;\n      }\n    };\n    const moveToCaretPosition = (editor, root) => {\n      let node, lastNode = root;\n      const dom = editor.dom;\n      const moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();\n      if (!root) {\n        return;\n      }\n      if (/^(LI|DT|DD)$/.test(root.nodeName)) {\n        const firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);\n        if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {\n          root.insertBefore(dom.doc.createTextNode(nbsp), root.firstChild);\n        }\n      }\n      const rng = dom.createRng();\n      root.normalize();\n      if (root.hasChildNodes()) {\n        const walker = new DomTreeWalker(root, root);\n        while (node = walker.current()) {\n          if (isText$8(node)) {\n            rng.setStart(node, 0);\n            rng.setEnd(node, 0);\n            break;\n          }\n          if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {\n            rng.setStartBefore(node);\n            rng.setEndBefore(node);\n            break;\n          }\n          lastNode = node;\n          node = walker.next();\n        }\n        if (!node) {\n          rng.setStart(lastNode, 0);\n          rng.setEnd(lastNode, 0);\n        }\n      } else {\n        if (isBr$5(root)) {\n          if (root.nextSibling && dom.isBlock(root.nextSibling)) {\n            rng.setStartBefore(root);\n            rng.setEndBefore(root);\n          } else {\n            rng.setStartAfter(root);\n            rng.setEndAfter(root);\n          }\n        } else {\n          rng.setStart(root, 0);\n          rng.setEnd(root, 0);\n        }\n      }\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, rng);\n    };\n    const getEditableRoot$1 = (dom, node) => {\n      const root = dom.getRoot();\n      let parent, editableRoot;\n      parent = node;\n      while (parent !== root && dom.getContentEditable(parent) !== 'false') {\n        if (dom.getContentEditable(parent) === 'true') {\n          editableRoot = parent;\n        }\n        parent = parent.parentNode;\n      }\n      return parent !== root ? editableRoot : root;\n    };\n    const getParentBlock$1 = editor => {\n      return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));\n    };\n    const getParentBlockName = editor => {\n      return getParentBlock$1(editor).fold(constant(''), parentBlock => {\n        return parentBlock.nodeName.toUpperCase();\n      });\n    };\n    const isListItemParentBlock = editor => {\n      return getParentBlock$1(editor).filter(elm => {\n        return isListItem(SugarElement.fromDom(elm));\n      }).isSome();\n    };\n\n    const hasFirstChild = (elm, name) => {\n      return elm.firstChild && elm.firstChild.nodeName === name;\n    };\n    const isFirstChild = elm => {\n      var _a;\n      return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;\n    };\n    const hasParent = (elm, parentName) => {\n      return elm && elm.parentNode && elm.parentNode.nodeName === parentName;\n    };\n    const isListBlock = elm => {\n      return elm && /^(OL|UL|LI)$/.test(elm.nodeName);\n    };\n    const isNestedList = elm => {\n      return isListBlock(elm) && isListBlock(elm.parentNode);\n    };\n    const getContainerBlock = containerBlock => {\n      const containerBlockParent = containerBlock.parentNode;\n      if (/^(LI|DT|DD)$/.test(containerBlockParent.nodeName)) {\n        return containerBlockParent;\n      }\n      return containerBlock;\n    };\n    const isFirstOrLastLi = (containerBlock, parentBlock, first) => {\n      let node = containerBlock[first ? 'firstChild' : 'lastChild'];\n      while (node) {\n        if (isElement$6(node)) {\n          break;\n        }\n        node = node[first ? 'nextSibling' : 'previousSibling'];\n      }\n      return node === parentBlock;\n    };\n    const insert$3 = (editor, createNewBlock, containerBlock, parentBlock, newBlockName) => {\n      const dom = editor.dom;\n      const rng = editor.selection.getRng();\n      if (containerBlock === editor.getBody()) {\n        return;\n      }\n      if (isNestedList(containerBlock)) {\n        newBlockName = 'LI';\n      }\n      let newBlock = createNewBlock(newBlockName);\n      if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {\n        if (hasParent(containerBlock, 'LI')) {\n          const containerBlockParent = getContainerBlock(containerBlock);\n          dom.insertAfter(newBlock, containerBlockParent);\n          if (isFirstChild(containerBlock)) {\n            dom.remove(containerBlockParent);\n          } else {\n            dom.remove(containerBlock);\n          }\n        } else {\n          dom.replace(newBlock, containerBlock);\n        }\n      } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {\n        if (hasParent(containerBlock, 'LI')) {\n          dom.insertAfter(newBlock, getContainerBlock(containerBlock));\n          newBlock.appendChild(dom.doc.createTextNode(' '));\n          newBlock.appendChild(containerBlock);\n        } else {\n          containerBlock.parentNode.insertBefore(newBlock, containerBlock);\n        }\n        dom.remove(parentBlock);\n      } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {\n        dom.insertAfter(newBlock, getContainerBlock(containerBlock));\n        dom.remove(parentBlock);\n      } else {\n        containerBlock = getContainerBlock(containerBlock);\n        const tmpRng = rng.cloneRange();\n        tmpRng.setStartAfter(parentBlock);\n        tmpRng.setEndAfter(containerBlock);\n        const fragment = tmpRng.extractContents();\n        if (newBlockName === 'LI' && hasFirstChild(fragment, 'LI')) {\n          newBlock = fragment.firstChild;\n          dom.insertAfter(fragment, containerBlock);\n        } else {\n          dom.insertAfter(fragment, containerBlock);\n          dom.insertAfter(newBlock, containerBlock);\n        }\n        dom.remove(parentBlock);\n      }\n      moveToCaretPosition(editor, newBlock);\n    };\n\n    const trimZwsp = fragment => {\n      each$g(descendants$1(SugarElement.fromDom(fragment), isText$9), text => {\n        const rawNode = text.dom;\n        rawNode.nodeValue = trim$1(rawNode.nodeValue);\n      });\n    };\n    const isEmptyAnchor = (dom, elm) => {\n      return elm && elm.nodeName === 'A' && dom.isEmpty(elm);\n    };\n    const isTableCell = node => {\n      return node && /^(TD|TH|CAPTION)$/.test(node.nodeName);\n    };\n    const emptyBlock = elm => {\n      elm.innerHTML = '<br data-mce-bogus=\"1\">';\n    };\n    const containerAndSiblingName = (container, nodeName) => {\n      return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;\n    };\n    const canSplitBlock = (dom, node) => {\n      return node && dom.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom.getContentEditable(node) !== 'true';\n    };\n    const trimInlineElementsOnLeftSideOfBlock = (dom, nonEmptyElementsMap, block) => {\n      let node = block;\n      const firstChilds = [];\n      let i;\n      if (!node) {\n        return;\n      }\n      while (node = node.firstChild) {\n        if (dom.isBlock(node)) {\n          return;\n        }\n        if (isElement$6(node) && !nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\n          firstChilds.push(node);\n        }\n      }\n      i = firstChilds.length;\n      while (i--) {\n        node = firstChilds[i];\n        if (!node.hasChildNodes() || node.firstChild === node.lastChild && node.firstChild.nodeValue === '') {\n          dom.remove(node);\n        } else {\n          if (isEmptyAnchor(dom, node)) {\n            dom.remove(node);\n          }\n        }\n      }\n    };\n    const normalizeZwspOffset = (start, container, offset) => {\n      if (isText$8(container) === false) {\n        return offset;\n      } else if (start) {\n        return offset === 1 && container.data.charAt(offset - 1) === ZWSP$1 ? 0 : offset;\n      } else {\n        return offset === container.data.length - 1 && container.data.charAt(offset) === ZWSP$1 ? container.data.length : offset;\n      }\n    };\n    const includeZwspInRange = rng => {\n      const newRng = rng.cloneRange();\n      newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));\n      newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));\n      return newRng;\n    };\n    const trimLeadingLineBreaks = node => {\n      do {\n        if (isText$8(node)) {\n          node.nodeValue = node.nodeValue.replace(/^[\\r\\n]+/, '');\n        }\n        node = node.firstChild;\n      } while (node);\n    };\n    const getEditableRoot = (dom, node) => {\n      const root = dom.getRoot();\n      let parent, editableRoot;\n      parent = node;\n      while (parent !== root && dom.getContentEditable(parent) !== 'false') {\n        if (dom.getContentEditable(parent) === 'true') {\n          editableRoot = parent;\n        }\n        parent = parent.parentNode;\n      }\n      return parent !== root ? editableRoot : root;\n    };\n    const applyAttributes = (editor, node, forcedRootBlockAttrs) => {\n      const dom = editor.dom;\n      Optional.from(forcedRootBlockAttrs.style).map(dom.parseStyle).each(attrStyles => {\n        const currentStyles = getAllRaw(SugarElement.fromDom(node));\n        const newStyles = {\n          ...currentStyles,\n          ...attrStyles\n        };\n        dom.setStyles(node, newStyles);\n      });\n      const attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map(attrClasses => attrClasses.split(/\\s+/));\n      const currentClassesOpt = Optional.from(node.className).map(currentClasses => filter$6(currentClasses.split(/\\s+/), clazz => clazz !== ''));\n      lift2(attrClassesOpt, currentClassesOpt, (attrClasses, currentClasses) => {\n        const filteredClasses = filter$6(currentClasses, clazz => !contains$2(attrClasses, clazz));\n        const newClasses = [\n          ...attrClasses,\n          ...filteredClasses\n        ];\n        dom.setAttrib(node, 'class', newClasses.join(' '));\n      });\n      const appliedAttrs = [\n        'style',\n        'class'\n      ];\n      const remainingAttrs = filter$5(forcedRootBlockAttrs, (_, attrs) => !contains$2(appliedAttrs, attrs));\n      dom.setAttribs(node, remainingAttrs);\n    };\n    const setForcedBlockAttrs = (editor, node) => {\n      const forcedRootBlockName = getForcedRootBlock(editor);\n      if (forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {\n        const forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);\n        applyAttributes(editor, node, forcedRootBlockAttrs);\n      }\n    };\n    const wrapSelfAndSiblingsInDefaultBlock = (editor, newBlockName, rng, container, offset) => {\n      let newBlock, parentBlock, startNode, node, next, rootBlockName;\n      const dom = editor.dom, editableRoot = getEditableRoot(dom, container);\n      parentBlock = dom.getParent(container, dom.isBlock);\n      if (!parentBlock || !canSplitBlock(dom, parentBlock)) {\n        parentBlock = parentBlock || editableRoot;\n        if (parentBlock === editor.getBody() || isTableCell(parentBlock)) {\n          rootBlockName = parentBlock.nodeName.toLowerCase();\n        } else {\n          rootBlockName = parentBlock.parentNode.nodeName.toLowerCase();\n        }\n        if (!parentBlock.hasChildNodes()) {\n          newBlock = dom.create(newBlockName);\n          setForcedBlockAttrs(editor, newBlock);\n          parentBlock.appendChild(newBlock);\n          rng.setStart(newBlock, 0);\n          rng.setEnd(newBlock, 0);\n          return newBlock;\n        }\n        node = container;\n        while (node.parentNode !== parentBlock) {\n          node = node.parentNode;\n        }\n        while (node && !dom.isBlock(node)) {\n          startNode = node;\n          node = node.previousSibling;\n        }\n        if (startNode && editor.schema.isValidChild(rootBlockName, newBlockName.toLowerCase())) {\n          newBlock = dom.create(newBlockName);\n          setForcedBlockAttrs(editor, newBlock);\n          startNode.parentNode.insertBefore(newBlock, startNode);\n          node = startNode;\n          while (node && !dom.isBlock(node)) {\n            next = node.nextSibling;\n            newBlock.appendChild(node);\n            node = next;\n          }\n          rng.setStart(container, offset);\n          rng.setEnd(container, offset);\n        }\n      }\n      return container;\n    };\n    const addBrToBlockIfNeeded = (dom, block) => {\n      block.normalize();\n      const lastChild = block.lastChild;\n      if (!lastChild || /^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true))) {\n        dom.add(block, 'br');\n      }\n    };\n    const insert$2 = (editor, evt) => {\n      let tmpRng, container, offset, parentBlock;\n      let newBlock, fragment, containerBlock, parentBlockName, isAfterLastNodeInContainer;\n      const dom = editor.dom;\n      const schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();\n      const rng = editor.selection.getRng();\n      const newBlockName = getForcedRootBlock(editor);\n      const createNewBlock = name => {\n        let node = container, block, clonedNode, caretNode;\n        const textInlineElements = schema.getTextInlineElements();\n        if (name || parentBlockName === 'TABLE' || parentBlockName === 'HR') {\n          block = dom.create(name || newBlockName);\n        } else {\n          block = parentBlock.cloneNode(false);\n        }\n        caretNode = block;\n        if (shouldKeepStyles(editor) === false) {\n          dom.setAttrib(block, 'style', null);\n          dom.setAttrib(block, 'class', null);\n        } else {\n          do {\n            if (textInlineElements[node.nodeName]) {\n              if (isCaretNode(node) || isBookmarkNode$1(node)) {\n                continue;\n              }\n              clonedNode = node.cloneNode(false);\n              dom.setAttrib(clonedNode, 'id', '');\n              if (block.hasChildNodes()) {\n                clonedNode.appendChild(block.firstChild);\n                block.appendChild(clonedNode);\n              } else {\n                caretNode = clonedNode;\n                block.appendChild(clonedNode);\n              }\n            }\n          } while ((node = node.parentNode) && node !== editableRoot);\n        }\n        setForcedBlockAttrs(editor, block);\n        emptyBlock(caretNode);\n        return block;\n      };\n      const isCaretAtStartOrEndOfBlock = start => {\n        let node, name;\n        const normalizedOffset = normalizeZwspOffset(start, container, offset);\n        if (isText$8(container) && (start ? normalizedOffset > 0 : normalizedOffset < container.nodeValue.length)) {\n          return false;\n        }\n        if (container.parentNode === parentBlock && isAfterLastNodeInContainer && !start) {\n          return true;\n        }\n        if (start && isElement$6(container) && container === parentBlock.firstChild) {\n          return true;\n        }\n        if (containerAndSiblingName(container, 'TABLE') || containerAndSiblingName(container, 'HR')) {\n          return isAfterLastNodeInContainer && !start || !isAfterLastNodeInContainer && start;\n        }\n        const walker = new DomTreeWalker(container, parentBlock);\n        if (isText$8(container)) {\n          if (start && normalizedOffset === 0) {\n            walker.prev();\n          } else if (!start && normalizedOffset === container.nodeValue.length) {\n            walker.next();\n          }\n        }\n        while (node = walker.current()) {\n          if (isElement$6(node)) {\n            if (!node.getAttribute('data-mce-bogus')) {\n              name = node.nodeName.toLowerCase();\n              if (nonEmptyElementsMap[name] && name !== 'br') {\n                return false;\n              }\n            }\n          } else if (isText$8(node) && !isWhitespaceText(node.nodeValue)) {\n            return false;\n          }\n          if (start) {\n            walker.prev();\n          } else {\n            walker.next();\n          }\n        }\n        return true;\n      };\n      const insertNewBlockAfter = () => {\n        if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== 'HGROUP') {\n          newBlock = createNewBlock(newBlockName);\n        } else {\n          newBlock = createNewBlock();\n        }\n        if (shouldEndContainerOnEmptyBlock(editor) && canSplitBlock(dom, containerBlock) && dom.isEmpty(parentBlock)) {\n          newBlock = dom.split(containerBlock, parentBlock);\n        } else {\n          dom.insertAfter(newBlock, parentBlock);\n        }\n        moveToCaretPosition(editor, newBlock);\n      };\n      normalize$2(dom, rng).each(normRng => {\n        rng.setStart(normRng.startContainer, normRng.startOffset);\n        rng.setEnd(normRng.endContainer, normRng.endOffset);\n      });\n      container = rng.startContainer;\n      offset = rng.startOffset;\n      const shiftKey = !!(evt && evt.shiftKey);\n      const ctrlKey = !!(evt && evt.ctrlKey);\n      if (isElement$6(container) && container.hasChildNodes()) {\n        isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n        if (isAfterLastNodeInContainer && isText$8(container)) {\n          offset = container.nodeValue.length;\n        } else {\n          offset = 0;\n        }\n      }\n      const editableRoot = getEditableRoot(dom, container);\n      if (!editableRoot) {\n        return;\n      }\n      if (!shiftKey) {\n        container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);\n      }\n      parentBlock = dom.getParent(container, dom.isBlock);\n      containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n      parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';\n      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\n      if (containerBlockName === 'LI' && !ctrlKey) {\n        parentBlock = containerBlock;\n        containerBlock = containerBlock.parentNode;\n        parentBlockName = containerBlockName;\n      }\n      if (/^(LI|DT|DD)$/.test(parentBlockName)) {\n        if (dom.isEmpty(parentBlock)) {\n          insert$3(editor, createNewBlock, containerBlock, parentBlock, newBlockName);\n          return;\n        }\n      }\n      if (parentBlock === editor.getBody()) {\n        return;\n      }\n      if (isCaretContainerBlock$1(parentBlock)) {\n        newBlock = showCaretContainerBlock(parentBlock);\n        if (dom.isEmpty(parentBlock)) {\n          emptyBlock(parentBlock);\n        }\n        setForcedBlockAttrs(editor, newBlock);\n        moveToCaretPosition(editor, newBlock);\n      } else if (isCaretAtStartOrEndOfBlock()) {\n        insertNewBlockAfter();\n      } else if (isCaretAtStartOrEndOfBlock(true)) {\n        newBlock = parentBlock.parentNode.insertBefore(createNewBlock(), parentBlock);\n        moveToCaretPosition(editor, containerAndSiblingName(parentBlock, 'HR') ? newBlock : parentBlock);\n      } else {\n        tmpRng = includeZwspInRange(rng).cloneRange();\n        tmpRng.setEndAfter(parentBlock);\n        fragment = tmpRng.extractContents();\n        trimZwsp(fragment);\n        trimLeadingLineBreaks(fragment);\n        newBlock = fragment.firstChild;\n        dom.insertAfter(fragment, parentBlock);\n        trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);\n        addBrToBlockIfNeeded(dom, parentBlock);\n        if (dom.isEmpty(parentBlock)) {\n          emptyBlock(parentBlock);\n        }\n        newBlock.normalize();\n        if (dom.isEmpty(newBlock)) {\n          dom.remove(newBlock);\n          insertNewBlockAfter();\n        } else {\n          setForcedBlockAttrs(editor, newBlock);\n          moveToCaretPosition(editor, newBlock);\n        }\n      }\n      dom.setAttrib(newBlock, 'id', '');\n      editor.dispatch('NewBlock', { newBlock });\n    };\n\n    const hasRightSideContent = (schema, container, parentBlock) => {\n      const walker = new DomTreeWalker(container, parentBlock);\n      let node;\n      const nonEmptyElementsMap = schema.getNonEmptyElements();\n      while (node = walker.next()) {\n        if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || node.length > 0) {\n          return true;\n        }\n      }\n    };\n    const moveSelectionToBr = (editor, brElm, extraBr) => {\n      const rng = editor.dom.createRng();\n      if (!extraBr) {\n        rng.setStartAfter(brElm);\n        rng.setEndAfter(brElm);\n      } else {\n        rng.setStartBefore(brElm);\n        rng.setEndBefore(brElm);\n      }\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, rng);\n    };\n    const insertBrAtCaret = (editor, evt) => {\n      const selection = editor.selection;\n      const dom = editor.dom;\n      const rng = selection.getRng();\n      let brElm;\n      let extraBr;\n      normalize$2(dom, rng).each(normRng => {\n        rng.setStart(normRng.startContainer, normRng.startOffset);\n        rng.setEnd(normRng.endContainer, normRng.endOffset);\n      });\n      let offset = rng.startOffset;\n      let container = rng.startContainer;\n      if (container.nodeType === 1 && container.hasChildNodes()) {\n        const isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n        if (isAfterLastNodeInContainer && container.nodeType === 3) {\n          offset = container.nodeValue.length;\n        } else {\n          offset = 0;\n        }\n      }\n      let parentBlock = dom.getParent(container, dom.isBlock);\n      const containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\n      const isControlKey = !!(evt && evt.ctrlKey);\n      if (containerBlockName === 'LI' && !isControlKey) {\n        parentBlock = containerBlock;\n      }\n      if (container && container.nodeType === 3 && offset >= container.nodeValue.length) {\n        if (!hasRightSideContent(editor.schema, container, parentBlock)) {\n          brElm = dom.create('br');\n          rng.insertNode(brElm);\n          rng.setStartAfter(brElm);\n          rng.setEndAfter(brElm);\n          extraBr = true;\n        }\n      }\n      brElm = dom.create('br');\n      rangeInsertNode(dom, rng, brElm);\n      moveSelectionToBr(editor, brElm, extraBr);\n      editor.undoManager.add();\n    };\n    const insertBrBefore = (editor, inline) => {\n      const br = SugarElement.fromTag('br');\n      before$3(SugarElement.fromDom(inline), br);\n      editor.undoManager.add();\n    };\n    const insertBrAfter = (editor, inline) => {\n      if (!hasBrAfter(editor.getBody(), inline)) {\n        after$4(SugarElement.fromDom(inline), SugarElement.fromTag('br'));\n      }\n      const br = SugarElement.fromTag('br');\n      after$4(SugarElement.fromDom(inline), br);\n      moveSelectionToBr(editor, br.dom, false);\n      editor.undoManager.add();\n    };\n    const isBeforeBr = pos => {\n      return isBr$5(pos.getNode());\n    };\n    const hasBrAfter = (rootNode, startNode) => {\n      if (isBeforeBr(CaretPosition.after(startNode))) {\n        return true;\n      } else {\n        return nextPosition(rootNode, CaretPosition.after(startNode)).map(pos => {\n          return isBr$5(pos.getNode());\n        }).getOr(false);\n      }\n    };\n    const isAnchorLink = elm => {\n      return elm && elm.nodeName === 'A' && 'href' in elm;\n    };\n    const isInsideAnchor = location => {\n      return location.fold(never, isAnchorLink, isAnchorLink, never);\n    };\n    const readInlineAnchorLocation = editor => {\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const position = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);\n    };\n    const insertBrOutsideAnchor = (editor, location) => {\n      location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);\n    };\n    const insert$1 = (editor, evt) => {\n      const anchorLocation = readInlineAnchorLocation(editor);\n      if (anchorLocation.isSome()) {\n        anchorLocation.each(curry(insertBrOutsideAnchor, editor));\n      } else {\n        insertBrAtCaret(editor, evt);\n      }\n    };\n\n    const matchesSelector = (editor, selector) => {\n      return getParentBlock$1(editor).filter(parentBlock => {\n        return selector.length > 0 && is$1(SugarElement.fromDom(parentBlock), selector);\n      }).isSome();\n    };\n    const shouldInsertBr = editor => {\n      return matchesSelector(editor, getBrNewLineSelector(editor));\n    };\n    const shouldBlockNewLine$1 = editor => {\n      return matchesSelector(editor, getNoNewLineSelector(editor));\n    };\n\n    const newLineAction = Adt.generate([\n      { br: [] },\n      { block: [] },\n      { none: [] }\n    ]);\n    const shouldBlockNewLine = (editor, _shiftKey) => {\n      return shouldBlockNewLine$1(editor);\n    };\n    const inListBlock = requiredState => {\n      return (editor, _shiftKey) => {\n        return isListItemParentBlock(editor) === requiredState;\n      };\n    };\n    const inBlock = (blockName, requiredState) => (editor, _shiftKey) => {\n      const state = getParentBlockName(editor) === blockName.toUpperCase();\n      return state === requiredState;\n    };\n    const inPreBlock = requiredState => inBlock('pre', requiredState);\n    const inSummaryBlock = () => inBlock('summary', true);\n    const shouldPutBrInPre = requiredState => {\n      return (editor, _shiftKey) => {\n        return shouldPutBrInPre$1(editor) === requiredState;\n      };\n    };\n    const inBrContext = (editor, _shiftKey) => {\n      return shouldInsertBr(editor);\n    };\n    const hasShiftKey = (_editor, shiftKey) => {\n      return shiftKey;\n    };\n    const canInsertIntoEditableRoot = editor => {\n      const forcedRootBlock = getForcedRootBlock(editor);\n      const rootEditable = getEditableRoot$1(editor.dom, editor.selection.getStart());\n      return rootEditable && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock);\n    };\n    const match = (predicates, action) => {\n      return (editor, shiftKey) => {\n        const isMatch = foldl(predicates, (res, p) => {\n          return res && p(editor, shiftKey);\n        }, true);\n        return isMatch ? Optional.some(action) : Optional.none();\n      };\n    };\n    const getAction = (editor, evt) => {\n      return evaluateUntil([\n        match([shouldBlockNewLine], newLineAction.none()),\n        match([inSummaryBlock()], newLineAction.br()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(false),\n          hasShiftKey\n        ], newLineAction.br()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(false)\n        ], newLineAction.block()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(true),\n          hasShiftKey\n        ], newLineAction.block()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(true)\n        ], newLineAction.br()),\n        match([\n          inListBlock(true),\n          hasShiftKey\n        ], newLineAction.br()),\n        match([inListBlock(true)], newLineAction.block()),\n        match([inBrContext], newLineAction.br()),\n        match([hasShiftKey], newLineAction.br()),\n        match([canInsertIntoEditableRoot], newLineAction.block())\n      ], [\n        editor,\n        !!(evt && evt.shiftKey)\n      ]).getOr(newLineAction.none());\n    };\n\n    const insert = (editor, evt) => {\n      getAction(editor, evt).fold(() => {\n        if (isNonNullable(evt)) {\n          const event = fireFakeBeforeInputEvent(editor, 'insertLineBreak');\n          if (event.isDefaultPrevented()) {\n            return;\n          }\n        }\n        insert$1(editor, evt);\n        if (isNonNullable(evt)) {\n          fireFakeInputEvent(editor, 'insertLineBreak');\n        }\n      }, () => {\n        if (isNonNullable(evt)) {\n          const event = fireFakeBeforeInputEvent(editor, 'insertParagraph');\n          if (event.isDefaultPrevented()) {\n            return;\n          }\n        }\n        insert$2(editor, evt);\n        if (isNonNullable(evt)) {\n          fireFakeInputEvent(editor, 'insertParagraph');\n        }\n      }, noop);\n    };\n\n    const handleEnterKeyEvent = (editor, event) => {\n      if (event.isDefaultPrevented()) {\n        return;\n      }\n      event.preventDefault();\n      endTypingLevelIgnoreLocks(editor.undoManager);\n      editor.undoManager.transact(() => {\n        if (editor.selection.isCollapsed() === false) {\n          execDeleteCommand(editor);\n        }\n        insert(editor, event);\n      });\n    };\n    const setup$h = editor => {\n      editor.on('keydown', event => {\n        if (event.keyCode === VK.ENTER) {\n          handleEnterKeyEvent(editor, event);\n        }\n      });\n    };\n\n    const executeKeydownOverride$2 = (editor, caret, evt) => {\n      execute([\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint$1, editor, true)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint$1, editor, false)\n        },\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint, editor, true)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint, editor, false)\n        },\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint$2, editor, true, caret)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint$2, editor, false, caret)\n        }\n      ], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$g = (editor, caret) => {\n      editor.on('keydown', evt => {\n        if (evt.isDefaultPrevented() === false) {\n          executeKeydownOverride$2(editor, caret, evt);\n        }\n      });\n    };\n\n    const setup$f = editor => {\n      editor.on('input', e => {\n        if (e.isComposing === false) {\n          normalizeNbspsInEditor(editor);\n        }\n      });\n    };\n\n    const platform = detect$2();\n    const executeKeyupAction = (editor, caret, evt) => {\n      execute([\n        {\n          keyCode: VK.PAGE_UP,\n          action: action(moveToLineEndPoint$2, editor, false, caret)\n        },\n        {\n          keyCode: VK.PAGE_DOWN,\n          action: action(moveToLineEndPoint$2, editor, true, caret)\n        }\n      ], evt);\n    };\n    const stopImmediatePropagation = e => e.stopImmediatePropagation();\n    const isPageUpDown = evt => evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;\n    const setNodeChangeBlocker = (blocked, editor, block) => {\n      if (block && !blocked.get()) {\n        editor.on('NodeChange', stopImmediatePropagation, true);\n      } else if (!block && blocked.get()) {\n        editor.off('NodeChange', stopImmediatePropagation);\n      }\n      blocked.set(block);\n    };\n    const setup$e = (editor, caret) => {\n      if (platform.os.isMacOS()) {\n        return;\n      }\n      const blocked = Cell(false);\n      editor.on('keydown', evt => {\n        if (isPageUpDown(evt)) {\n          setNodeChangeBlocker(blocked, editor, true);\n        }\n      });\n      editor.on('keyup', evt => {\n        if (evt.isDefaultPrevented() === false) {\n          executeKeyupAction(editor, caret, evt);\n        }\n        if (isPageUpDown(evt) && blocked.get()) {\n          setNodeChangeBlocker(blocked, editor, false);\n          editor.nodeChanged();\n        }\n      });\n    };\n\n    const insertTextAtPosition = (text, pos) => {\n      const container = pos.container();\n      const offset = pos.offset();\n      if (isText$8(container)) {\n        container.insertData(offset, text);\n        return Optional.some(CaretPosition(container, offset + text.length));\n      } else {\n        return getElementFromPosition(pos).map(elm => {\n          const textNode = SugarElement.fromText(text);\n          if (pos.isAtEnd()) {\n            after$4(elm, textNode);\n          } else {\n            before$3(elm, textNode);\n          }\n          return CaretPosition(textNode.dom, text.length);\n        });\n      }\n    };\n    const insertNbspAtPosition = curry(insertTextAtPosition, nbsp);\n    const insertSpaceAtPosition = curry(insertTextAtPosition, ' ');\n\n    const locationToCaretPosition = root => location => location.fold(element => prevPosition(root.dom, CaretPosition.before(element)), element => firstPositionIn(element), element => lastPositionIn(element), element => nextPosition(root.dom, CaretPosition.after(element)));\n    const insertInlineBoundarySpaceOrNbsp = (root, pos) => checkPos => needsToHaveNbsp(root, checkPos) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);\n    const setSelection = editor => pos => {\n      editor.selection.setRng(pos.toRange());\n      editor.nodeChanged();\n      return true;\n    };\n    const insertSpaceOrNbspAtSelection = editor => {\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      const root = SugarElement.fromDom(editor.getBody());\n      if (editor.selection.isCollapsed()) {\n        const isInlineTarget$1 = curry(isInlineTarget, editor);\n        const caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());\n        return readLocation(isInlineTarget$1, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).map(checkPos => () => insertInlineBoundarySpaceOrNbsp(root, pos)(checkPos).each(setSelection(editor)));\n      } else {\n        return Optional.none();\n      }\n    };\n\n    const executeKeydownOverride$1 = (editor, evt) => {\n      executeWithDelayedAction([{\n          keyCode: VK.SPACEBAR,\n          action: action(insertSpaceOrNbspAtSelection, editor)\n        }], evt).each(applyAction => {\n        evt.preventDefault();\n        const event = fireFakeBeforeInputEvent(editor, 'insertText', { data: ' ' });\n        if (!event.isDefaultPrevented()) {\n          applyAction();\n          fireFakeInputEvent(editor, 'insertText', { data: ' ' });\n        }\n      });\n    };\n    const setup$d = editor => {\n      editor.on('keydown', evt => {\n        if (evt.isDefaultPrevented() === false) {\n          executeKeydownOverride$1(editor, evt);\n        }\n      });\n    };\n\n    const tableTabNavigation = editor => {\n      if (hasTableTabNavigation(editor)) {\n        return [\n          {\n            keyCode: VK.TAB,\n            action: action(handleTab, editor, true)\n          },\n          {\n            keyCode: VK.TAB,\n            shiftKey: true,\n            action: action(handleTab, editor, false)\n          }\n        ];\n      } else {\n        return [];\n      }\n    };\n    const executeKeydownOverride = (editor, evt) => {\n      execute([...tableTabNavigation(editor)], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$c = editor => {\n      editor.on('keydown', evt => {\n        if (evt.isDefaultPrevented() === false) {\n          executeKeydownOverride(editor, evt);\n        }\n      });\n    };\n\n    const setup$b = editor => {\n      editor.addShortcut('Meta+P', '', 'mcePrint');\n      setup$j(editor);\n      if (isRtc(editor)) {\n        return Cell(null);\n      } else {\n        const caret = setupSelectedState(editor);\n        setup$l(editor);\n        setup$k(editor, caret);\n        setup$i(editor, caret);\n        setup$h(editor);\n        setup$d(editor);\n        setup$f(editor);\n        setup$c(editor);\n        setup$g(editor, caret);\n        setup$e(editor, caret);\n        return caret;\n      }\n    };\n\n    class NodeChange {\n      constructor(editor) {\n        this.lastPath = [];\n        this.editor = editor;\n        let lastRng;\n        const self = this;\n        if (!('onselectionchange' in editor.getDoc())) {\n          editor.on('NodeChange click mouseup keyup focus', e => {\n            const nativeRng = editor.selection.getRng();\n            const fakeRng = {\n              startContainer: nativeRng.startContainer,\n              startOffset: nativeRng.startOffset,\n              endContainer: nativeRng.endContainer,\n              endOffset: nativeRng.endOffset\n            };\n            if (e.type === 'nodechange' || !isEq$4(fakeRng, lastRng)) {\n              editor.dispatch('SelectionChange');\n            }\n            lastRng = fakeRng;\n          });\n        }\n        editor.on('contextmenu', () => {\n          editor.dispatch('SelectionChange');\n        });\n        editor.on('SelectionChange', () => {\n          const startElm = editor.selection.getStart(true);\n          if (!startElm) {\n            return;\n          }\n          if (hasAnyRanges(editor) && !self.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {\n            editor.nodeChanged({ selectionChange: true });\n          }\n        });\n        editor.on('mouseup', e => {\n          if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {\n            if (editor.selection.getNode().nodeName === 'IMG') {\n              Delay.setEditorTimeout(editor, () => {\n                editor.nodeChanged();\n              });\n            } else {\n              editor.nodeChanged();\n            }\n          }\n        });\n      }\n      nodeChanged(args) {\n        const selection = this.editor.selection;\n        let node, parents, root;\n        if (this.editor.initialized && selection && !shouldDisableNodeChange(this.editor) && !this.editor.mode.isReadOnly()) {\n          root = this.editor.getBody();\n          node = selection.getStart(true) || root;\n          if (node.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(node, root)) {\n            node = root;\n          }\n          parents = [];\n          this.editor.dom.getParent(node, node => {\n            if (node === root) {\n              return true;\n            }\n            parents.push(node);\n          });\n          args = args || {};\n          args.element = node;\n          args.parents = parents;\n          this.editor.dispatch('NodeChange', args);\n        }\n      }\n      isSameElementPath(startElm) {\n        let i;\n        const editor = this.editor;\n        const currentPath = reverse(editor.dom.getParents(startElm, always, editor.getBody()));\n        if (currentPath.length === this.lastPath.length) {\n          for (i = currentPath.length; i >= 0; i--) {\n            if (currentPath[i] !== this.lastPath[i]) {\n              break;\n            }\n          }\n          if (i === -1) {\n            this.lastPath = currentPath;\n            return true;\n          }\n        }\n        this.lastPath = currentPath;\n        return false;\n      }\n    }\n\n    const internalMimeType = 'x-tinymce/html';\n    const internalHtmlMime = constant(internalMimeType);\n    const internalMark = '<!-- ' + internalMimeType + ' -->';\n    const mark = html => internalMark + html;\n    const unmark = html => html.replace(internalMark, '');\n    const isMarked = html => html.indexOf(internalMark) !== -1;\n\n    const isPlainText = text => {\n      return !/<(?:\\/?(?!(?:div|p|br|span)>)\\w+|(?:(?!(?:span style=\"white-space:\\s?pre;?\">)|br\\s?\\/>))\\w+\\s[^>]+)>/i.test(text);\n    };\n    const openContainer = (rootTag, rootAttrs) => {\n      let tag = '<' + rootTag;\n      const attrs = mapToArray(rootAttrs, (value, key) => key + '=\"' + Entities.encodeAllRaw(value) + '\"');\n      if (attrs.length) {\n        tag += ' ' + attrs.join(' ');\n      }\n      return tag + '>';\n    };\n    const toBlockElements = (text, rootTag, rootAttrs) => {\n      const blocks = text.split(/\\n\\n/);\n      const tagOpen = openContainer(rootTag, rootAttrs);\n      const tagClose = '</' + rootTag + '>';\n      const paragraphs = map$3(blocks, p => {\n        return p.split(/\\n/).join('<br />');\n      });\n      const stitch = p => {\n        return tagOpen + p + tagClose;\n      };\n      return paragraphs.length === 1 ? paragraphs[0] : map$3(paragraphs, stitch).join('');\n    };\n\n    const pasteBinDefaultContent = '%MCEPASTEBIN%';\n    const create$6 = (editor, lastRngCell) => {\n      const {dom, selection} = editor;\n      const body = editor.getBody();\n      lastRngCell.set(selection.getRng());\n      const pasteBinElm = dom.add(editor.getBody(), 'div', {\n        'id': 'mcepastebin',\n        'class': 'mce-pastebin',\n        'contentEditable': true,\n        'data-mce-bogus': 'all',\n        'style': 'position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0'\n      }, pasteBinDefaultContent);\n      if (Env.browser.isFirefox()) {\n        dom.setStyle(pasteBinElm, 'left', dom.getStyle(body, 'direction', true) === 'rtl' ? 65535 : -65535);\n      }\n      dom.bind(pasteBinElm, 'beforedeactivate focusin focusout', e => {\n        e.stopPropagation();\n      });\n      pasteBinElm.focus();\n      selection.select(pasteBinElm, true);\n    };\n    const remove = (editor, lastRngCell) => {\n      const dom = editor.dom;\n      if (getEl(editor)) {\n        let pasteBinClone;\n        const lastRng = lastRngCell.get();\n        while (pasteBinClone = getEl(editor)) {\n          dom.remove(pasteBinClone);\n          dom.unbind(pasteBinClone);\n        }\n        if (lastRng) {\n          editor.selection.setRng(lastRng);\n        }\n      }\n      lastRngCell.set(null);\n    };\n    const getEl = editor => editor.dom.get('mcepastebin');\n    const isPasteBin = elm => elm && elm.id === 'mcepastebin';\n    const getHtml = editor => {\n      const dom = editor.dom;\n      const copyAndRemove = (toElm, fromElm) => {\n        toElm.appendChild(fromElm);\n        dom.remove(fromElm, true);\n      };\n      const [pasteBinElm, ...pasteBinClones] = filter$6(editor.getBody().childNodes, isPasteBin);\n      each$g(pasteBinClones, pasteBinClone => {\n        copyAndRemove(pasteBinElm, pasteBinClone);\n      });\n      const dirtyWrappers = dom.select('div[id=mcepastebin]', pasteBinElm);\n      for (let i = dirtyWrappers.length - 1; i >= 0; i--) {\n        const cleanWrapper = dom.create('div');\n        pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i]);\n        copyAndRemove(cleanWrapper, dirtyWrappers[i]);\n      }\n      return pasteBinElm ? pasteBinElm.innerHTML : '';\n    };\n    const isDefaultPasteBinContent = content => content === pasteBinDefaultContent;\n    const PasteBin = editor => {\n      const lastRng = Cell(null);\n      return {\n        create: () => create$6(editor, lastRng),\n        remove: () => remove(editor, lastRng),\n        getEl: () => getEl(editor),\n        getHtml: () => getHtml(editor),\n        getLastRng: lastRng.get\n      };\n    };\n\n    const filter = (content, items) => {\n      Tools.each(items, v => {\n        if (is$4(v, RegExp)) {\n          content = content.replace(v, '');\n        } else {\n          content = content.replace(v[0], v[1]);\n        }\n      });\n      return content;\n    };\n    const innerText = html => {\n      const schema = Schema();\n      const domParser = DomParser({}, schema);\n      let text = '';\n      const voidElements = schema.getVoidElements();\n      const ignoreElements = Tools.makeMap('script noscript style textarea video audio iframe object', ' ');\n      const blockElements = schema.getBlockElements();\n      const walk = node => {\n        const name = node.name, currentNode = node;\n        if (name === 'br') {\n          text += '\\n';\n          return;\n        }\n        if (name === 'wbr') {\n          return;\n        }\n        if (voidElements[name]) {\n          text += ' ';\n        }\n        if (ignoreElements[name]) {\n          text += ' ';\n          return;\n        }\n        if (node.type === 3) {\n          text += node.value;\n        }\n        if (!(node.name in schema.getVoidElements())) {\n          if (node = node.firstChild) {\n            do {\n              walk(node);\n            } while (node = node.next);\n          }\n        }\n        if (blockElements[name] && currentNode.next) {\n          text += '\\n';\n          if (name === 'p') {\n            text += '\\n';\n          }\n        }\n      };\n      html = filter(html, [/<!\\[[^\\]]+\\]>/g]);\n      walk(domParser.parse(html));\n      return text;\n    };\n    const trimHtml = html => {\n      const trimSpaces = (all, s1, s2) => {\n        if (!s1 && !s2) {\n          return ' ';\n        }\n        return nbsp;\n      };\n      html = filter(html, [\n        /^[\\s\\S]*<body[^>]*>\\s*|\\s*<\\/body[^>]*>[\\s\\S]*$/ig,\n        /<!--StartFragment-->|<!--EndFragment-->/g,\n        [\n          /( ?)<span class=\"Apple-converted-space\">\\u00a0<\\/span>( ?)/g,\n          trimSpaces\n        ],\n        /<br class=\"Apple-interchange-newline\">/g,\n        /<br>$/i\n      ]);\n      return html;\n    };\n    const createIdGenerator = prefix => {\n      let count = 0;\n      return () => {\n        return prefix + count++;\n      };\n    };\n    const getImageMimeType = ext => {\n      const lowerExt = ext.toLowerCase();\n      const mimeOverrides = {\n        jpg: 'jpeg',\n        jpe: 'jpeg',\n        jfi: 'jpeg',\n        jif: 'jpeg',\n        jfif: 'jpeg',\n        pjpeg: 'jpeg',\n        pjp: 'jpeg',\n        svg: 'svg+xml'\n      };\n      return Tools.hasOwn(mimeOverrides, lowerExt) ? 'image/' + mimeOverrides[lowerExt] : 'image/' + lowerExt;\n    };\n\n    const preProcess = (editor, html) => {\n      const parser = DomParser({}, editor.schema);\n      parser.addNodeFilter('meta', nodes => {\n        Tools.each(nodes, node => {\n          node.remove();\n        });\n      });\n      const fragment = parser.parse(html, {\n        forced_root_block: false,\n        isRootContent: true\n      });\n      return HtmlSerializer({ validate: true }, editor.schema).serialize(fragment);\n    };\n    const processResult = (content, cancelled) => ({\n      content,\n      cancelled\n    });\n    const postProcessFilter = (editor, html, internal) => {\n      const tempBody = editor.dom.create('div', { style: 'display:none' }, html);\n      const postProcessArgs = firePastePostProcess(editor, tempBody, internal);\n      return processResult(postProcessArgs.node.innerHTML, postProcessArgs.isDefaultPrevented());\n    };\n    const filterContent = (editor, content, internal) => {\n      const preProcessArgs = firePastePreProcess(editor, content, internal);\n      const filteredContent = preProcess(editor, preProcessArgs.content);\n      if (editor.hasEventListeners('PastePostProcess') && !preProcessArgs.isDefaultPrevented()) {\n        return postProcessFilter(editor, filteredContent, internal);\n      } else {\n        return processResult(filteredContent, preProcessArgs.isDefaultPrevented());\n      }\n    };\n    const process = (editor, html, internal) => {\n      return filterContent(editor, html, internal);\n    };\n\n    const pasteHtml$1 = (editor, html) => {\n      editor.insertContent(html, {\n        merge: shouldPasteMergeFormats(editor),\n        paste: true\n      });\n      return true;\n    };\n    const isAbsoluteUrl = url => /^https?:\\/\\/[\\w\\?\\-\\/+=.&%@~#]+$/i.test(url);\n    const isImageUrl = (editor, url) => {\n      return isAbsoluteUrl(url) && exists(getAllowedImageFileTypes(editor), type => endsWith(url.toLowerCase(), `.${ type.toLowerCase() }`));\n    };\n    const createImage = (editor, url, pasteHtmlFn) => {\n      editor.undoManager.extra(() => {\n        pasteHtmlFn(editor, url);\n      }, () => {\n        editor.insertContent('<img src=\"' + url + '\">');\n      });\n      return true;\n    };\n    const createLink = (editor, url, pasteHtmlFn) => {\n      editor.undoManager.extra(() => {\n        pasteHtmlFn(editor, url);\n      }, () => {\n        editor.execCommand('mceInsertLink', false, url);\n      });\n      return true;\n    };\n    const linkSelection = (editor, html, pasteHtmlFn) => !editor.selection.isCollapsed() && isAbsoluteUrl(html) ? createLink(editor, html, pasteHtmlFn) : false;\n    const insertImage = (editor, html, pasteHtmlFn) => isImageUrl(editor, html) ? createImage(editor, html, pasteHtmlFn) : false;\n    const smartInsertContent = (editor, html) => {\n      Tools.each([\n        linkSelection,\n        insertImage,\n        pasteHtml$1\n      ], action => {\n        return action(editor, html, pasteHtml$1) !== true;\n      });\n    };\n    const insertContent = (editor, html, pasteAsText) => {\n      if (pasteAsText || !isSmartPasteEnabled(editor)) {\n        pasteHtml$1(editor, html);\n      } else {\n        smartInsertContent(editor, html);\n      }\n    };\n\n    const uniqueId = createIdGenerator('mceclip');\n    const doPaste = (editor, content, internal, pasteAsText) => {\n      const args = process(editor, content, internal);\n      if (args.cancelled === false) {\n        insertContent(editor, args.content, pasteAsText);\n      }\n    };\n    const pasteHtml = (editor, html, internalFlag) => {\n      const internal = internalFlag ? internalFlag : isMarked(html);\n      doPaste(editor, unmark(html), internal, false);\n    };\n    const pasteText = (editor, text) => {\n      const encodedText = editor.dom.encode(text).replace(/\\r\\n/g, '\\n');\n      const normalizedText = normalize$4(encodedText, getPasteTabSpaces(editor));\n      const html = toBlockElements(normalizedText, getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));\n      doPaste(editor, html, false, true);\n    };\n    const getDataTransferItems = dataTransfer => {\n      const items = {};\n      if (dataTransfer && dataTransfer.types) {\n        for (let i = 0; i < dataTransfer.types.length; i++) {\n          const contentType = dataTransfer.types[i];\n          try {\n            items[contentType] = dataTransfer.getData(contentType);\n          } catch (ex) {\n            items[contentType] = '';\n          }\n        }\n      }\n      return items;\n    };\n    const hasContentType = (clipboardContent, mimeType) => mimeType in clipboardContent && clipboardContent[mimeType].length > 0;\n    const hasHtmlOrText = content => hasContentType(content, 'text/html') || hasContentType(content, 'text/plain');\n    const extractFilename = (editor, str) => {\n      const m = str.match(/([\\s\\S]+?)(?:\\.[a-z0-9.]+)$/i);\n      return isNonNullable(m) ? editor.dom.encode(m[1]) : null;\n    };\n    const createBlobInfo = (editor, blobCache, file, base64) => {\n      const id = uniqueId();\n      const useFileName = shouldReuseFileName(editor) && isNonNullable(file.name);\n      const name = useFileName ? extractFilename(editor, file.name) : id;\n      const filename = useFileName ? file.name : undefined;\n      const blobInfo = blobCache.create(id, file, base64, name, filename);\n      blobCache.add(blobInfo);\n      return blobInfo;\n    };\n    const pasteImage = (editor, imageItem) => {\n      const {\n        data: base64,\n        type\n      } = parseDataUri$1(imageItem.uri);\n      const file = imageItem.file;\n      const blobCache = editor.editorUpload.blobCache;\n      const existingBlobInfo = blobCache.getByData(base64, type);\n      const blobInfo = existingBlobInfo !== null && existingBlobInfo !== void 0 ? existingBlobInfo : createBlobInfo(editor, blobCache, file, base64);\n      pasteHtml(editor, `<img src=\"${ blobInfo.blobUri() }\">`, false);\n    };\n    const isClipboardEvent = event => event.type === 'paste';\n    const readFilesAsDataUris = items => Promise.all(map$3(items, file => {\n      return blobToDataUri(file).then(uri => ({\n        file,\n        uri\n      }));\n    }));\n    const isImage = editor => {\n      const allowedExtensions = getAllowedImageFileTypes(editor);\n      return file => startsWith(file.type, 'image/') && exists(allowedExtensions, extension => {\n        return getImageMimeType(extension) === file.type;\n      });\n    };\n    const getImagesFromDataTransfer = (editor, dataTransfer) => {\n      const items = dataTransfer.items ? bind$3(from(dataTransfer.items), item => {\n        return item.kind === 'file' ? [item.getAsFile()] : [];\n      }) : [];\n      const files = dataTransfer.files ? from(dataTransfer.files) : [];\n      return filter$6(items.length > 0 ? items : files, isImage(editor));\n    };\n    const pasteImageData = (editor, e, rng) => {\n      const dataTransfer = isClipboardEvent(e) ? e.clipboardData : e.dataTransfer;\n      if (shouldPasteDataImages(editor) && dataTransfer) {\n        const images = getImagesFromDataTransfer(editor, dataTransfer);\n        if (images.length > 0) {\n          e.preventDefault();\n          readFilesAsDataUris(images).then(fileResults => {\n            if (rng) {\n              editor.selection.setRng(rng);\n            }\n            each$g(fileResults, result => {\n              pasteImage(editor, result);\n            });\n          });\n          return true;\n        }\n      }\n      return false;\n    };\n    const isBrokenAndroidClipboardEvent = e => {\n      var _a, _b;\n      return Env.os.isAndroid() && ((_b = (_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.length) === 0;\n    };\n    const isKeyboardPasteEvent = e => VK.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45;\n    const insertClipboardContent = (editor, clipboardContent, html, plainTextMode) => {\n      let content = trimHtml(html);\n      const isInternal = hasContentType(clipboardContent, internalHtmlMime()) || isMarked(html);\n      const isPlainTextHtml = !isInternal && isPlainText(content);\n      const isAbsoluteUrl$1 = isAbsoluteUrl(content);\n      if (isDefaultPasteBinContent(content) || !content.length || isPlainTextHtml && !isAbsoluteUrl$1) {\n        plainTextMode = true;\n      }\n      if (plainTextMode || isAbsoluteUrl$1) {\n        if (hasContentType(clipboardContent, 'text/plain') && isPlainTextHtml) {\n          content = clipboardContent['text/plain'];\n        } else {\n          content = innerText(content);\n        }\n      }\n      if (isDefaultPasteBinContent(content)) {\n        return;\n      }\n      if (plainTextMode) {\n        pasteText(editor, content);\n      } else {\n        pasteHtml(editor, content, isInternal);\n      }\n    };\n    const registerEventHandlers = (editor, pasteBin, pasteFormat) => {\n      let keyboardPastePlainTextState;\n      const getLastRng = () => pasteBin.getLastRng() || editor.selection.getRng();\n      editor.on('keydown', e => {\n        if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {\n          keyboardPastePlainTextState = e.shiftKey && e.keyCode === 86;\n        }\n      });\n      editor.on('paste', e => {\n        if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {\n          return;\n        }\n        const plainTextMode = pasteFormat.get() === 'text' || keyboardPastePlainTextState;\n        keyboardPastePlainTextState = false;\n        const clipboardContent = getDataTransferItems(e.clipboardData);\n        if (!hasHtmlOrText(clipboardContent) && pasteImageData(editor, e, getLastRng())) {\n          return;\n        }\n        if (hasContentType(clipboardContent, 'text/html')) {\n          e.preventDefault();\n          insertClipboardContent(editor, clipboardContent, clipboardContent['text/html'], plainTextMode);\n        } else {\n          pasteBin.create();\n          Delay.setEditorTimeout(editor, () => {\n            const html = pasteBin.getHtml();\n            pasteBin.remove();\n            insertClipboardContent(editor, clipboardContent, html, plainTextMode);\n          }, 0);\n        }\n      });\n    };\n    const registerDataImageFilter = editor => {\n      const isWebKitFakeUrl = src => startsWith(src, 'webkit-fake-url');\n      const isDataUri = src => startsWith(src, 'data:');\n      const isPasteInsert = args => {\n        var _a;\n        return ((_a = args.data) === null || _a === void 0 ? void 0 : _a.paste) === true;\n      };\n      editor.parser.addNodeFilter('img', (nodes, name, args) => {\n        if (!shouldPasteDataImages(editor) && isPasteInsert(args)) {\n          for (const node of nodes) {\n            const src = node.attr('src');\n            if (isString(src) && !node.attr('data-mce-object') && src !== Env.transparentSrc) {\n              if (isWebKitFakeUrl(src)) {\n                node.remove();\n              } else if (!shouldAllowHtmlDataUrls(editor) && isDataUri(src)) {\n                node.remove();\n              }\n            }\n          }\n        }\n      });\n    };\n    const registerEventsAndFilters = (editor, pasteBin, pasteFormat) => {\n      registerEventHandlers(editor, pasteBin, pasteFormat);\n      registerDataImageFilter(editor);\n    };\n\n    const togglePlainTextPaste = (editor, pasteFormat) => {\n      if (pasteFormat.get() === 'text') {\n        pasteFormat.set('html');\n        firePastePlainTextToggle(editor, false);\n      } else {\n        pasteFormat.set('text');\n        firePastePlainTextToggle(editor, true);\n      }\n      editor.focus();\n    };\n    const register$1 = (editor, pasteFormat) => {\n      editor.addCommand('mceTogglePlainTextPaste', () => {\n        togglePlainTextPaste(editor, pasteFormat);\n      });\n      editor.addCommand('mceInsertClipboardContent', (ui, value) => {\n        if (value.html) {\n          pasteHtml(editor, value.html, value.internal);\n        }\n        if (value.text) {\n          pasteText(editor, value.text);\n        }\n      });\n    };\n\n    const setHtml5Clipboard = (clipboardData, html, text) => {\n      try {\n        clipboardData.clearData();\n        clipboardData.setData('text/html', html);\n        clipboardData.setData('text/plain', text);\n        clipboardData.setData(internalHtmlMime(), html);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    };\n    const setClipboardData = (evt, data, fallback, done) => {\n      if (setHtml5Clipboard(evt.clipboardData, data.html, data.text)) {\n        evt.preventDefault();\n        done();\n      } else {\n        fallback(data.html, done);\n      }\n    };\n    const fallback = editor => (html, done) => {\n      const {dom, selection} = editor;\n      const outer = dom.create('div', {\n        'contenteditable': 'false',\n        'data-mce-bogus': 'all'\n      });\n      const inner = dom.create('div', { contenteditable: 'true' }, html);\n      dom.setStyles(outer, {\n        position: 'fixed',\n        top: '0',\n        left: '-3000px',\n        width: '1000px',\n        overflow: 'hidden'\n      });\n      outer.appendChild(inner);\n      dom.add(editor.getBody(), outer);\n      const range = selection.getRng();\n      inner.focus();\n      const offscreenRange = dom.createRng();\n      offscreenRange.selectNodeContents(inner);\n      selection.setRng(offscreenRange);\n      Delay.setEditorTimeout(editor, () => {\n        selection.setRng(range);\n        dom.remove(outer);\n        done();\n      }, 0);\n    };\n    const getData = editor => ({\n      html: mark(editor.selection.getContent({ contextual: true })),\n      text: editor.selection.getContent({ format: 'text' })\n    });\n    const isTableSelection = editor => !!editor.dom.getParent(editor.selection.getStart(), 'td[data-mce-selected],th[data-mce-selected]', editor.getBody());\n    const hasSelectedContent = editor => !editor.selection.isCollapsed() || isTableSelection(editor);\n    const cut = editor => evt => {\n      if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {\n        setClipboardData(evt, getData(editor), fallback(editor), () => {\n          if (Env.browser.isChromium() || Env.browser.isFirefox()) {\n            const rng = editor.selection.getRng();\n            Delay.setEditorTimeout(editor, () => {\n              editor.selection.setRng(rng);\n              editor.execCommand('Delete');\n            }, 0);\n          } else {\n            editor.execCommand('Delete');\n          }\n        });\n      }\n    };\n    const copy = editor => evt => {\n      if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {\n        setClipboardData(evt, getData(editor), fallback(editor), noop);\n      }\n    };\n    const register = editor => {\n      editor.on('cut', cut(editor));\n      editor.on('copy', copy(editor));\n    };\n\n    const getCaretRangeFromEvent = (editor, e) => {\n      var _a, _b;\n      return RangeUtils.getCaretRangeFromPoint((_a = e.clientX) !== null && _a !== void 0 ? _a : 0, (_b = e.clientY) !== null && _b !== void 0 ? _b : 0, editor.getDoc());\n    };\n    const isPlainTextFileUrl = content => {\n      const plainTextContent = content['text/plain'];\n      return plainTextContent ? plainTextContent.indexOf('file://') === 0 : false;\n    };\n    const setFocusedRange = (editor, rng) => {\n      editor.focus();\n      if (rng) {\n        editor.selection.setRng(rng);\n      }\n    };\n    const hasImage = dataTransfer => exists(dataTransfer.files, file => /^image\\//.test(file.type));\n    const setup$a = (editor, draggingInternallyState) => {\n      if (shouldPasteBlockDrop(editor)) {\n        editor.on('dragend dragover draggesture dragdrop drop drag', e => {\n          e.preventDefault();\n          e.stopPropagation();\n        });\n      }\n      if (!shouldPasteDataImages(editor)) {\n        editor.on('drop', e => {\n          const dataTransfer = e.dataTransfer;\n          if (dataTransfer && hasImage(dataTransfer)) {\n            e.preventDefault();\n          }\n        });\n      }\n      editor.on('drop', e => {\n        if (e.isDefaultPrevented() || draggingInternallyState.get()) {\n          return;\n        }\n        const rng = getCaretRangeFromEvent(editor, e);\n        if (isNullable(rng)) {\n          return;\n        }\n        const dropContent = getDataTransferItems(e.dataTransfer);\n        const internal = hasContentType(dropContent, internalHtmlMime());\n        if ((!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && pasteImageData(editor, e, rng)) {\n          return;\n        }\n        const internalContent = dropContent[internalHtmlMime()];\n        const content = internalContent || dropContent['text/html'] || dropContent['text/plain'];\n        if (content) {\n          e.preventDefault();\n          Delay.setEditorTimeout(editor, () => {\n            editor.undoManager.transact(() => {\n              if (internalContent) {\n                editor.execCommand('Delete');\n              }\n              setFocusedRange(editor, rng);\n              const trimmedContent = trimHtml(content);\n              if (dropContent['text/html']) {\n                pasteHtml(editor, trimmedContent, internal);\n              } else {\n                pasteText(editor, trimmedContent);\n              }\n            });\n          });\n        }\n      });\n      editor.on('dragstart', _e => {\n        draggingInternallyState.set(true);\n      });\n      editor.on('dragover dragend', e => {\n        if (shouldPasteDataImages(editor) && draggingInternallyState.get() === false) {\n          e.preventDefault();\n          setFocusedRange(editor, getCaretRangeFromEvent(editor, e));\n        }\n        if (e.type === 'dragend') {\n          draggingInternallyState.set(false);\n        }\n      });\n    };\n\n    const setup$9 = editor => {\n      const processEvent = f => e => {\n        f(editor, e);\n      };\n      const preProcess = getPastePreProcess(editor);\n      if (isFunction(preProcess)) {\n        editor.on('PastePreProcess', processEvent(preProcess));\n      }\n      const postProcess = getPastePostProcess(editor);\n      if (isFunction(postProcess)) {\n        editor.on('PastePostProcess', processEvent(postProcess));\n      }\n    };\n\n    const addPreProcessFilter = (editor, filterFunc) => {\n      editor.on('PastePreProcess', e => {\n        e.content = filterFunc(editor, e.content, e.internal);\n      });\n    };\n    const rgbRegExp = /rgb\\s*\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)/gi;\n    const rgbToHex = value => Tools.trim(value).replace(rgbRegExp, rgbaToHexString).toLowerCase();\n    const removeWebKitStyles = (editor, content, internal) => {\n      const webKitStylesOption = getPasteWebkitStyles(editor);\n      if (internal || webKitStylesOption === 'all' || !shouldPasteRemoveWebKitStyles(editor)) {\n        return content;\n      }\n      const webKitStyles = webKitStylesOption ? webKitStylesOption.split(/[, ]/) : [];\n      if (webKitStyles && webKitStylesOption !== 'none') {\n        const dom = editor.dom, node = editor.selection.getNode();\n        content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, (all, before, value, after) => {\n          const inputStyles = dom.parseStyle(dom.decode(value));\n          const outputStyles = {};\n          for (let i = 0; i < webKitStyles.length; i++) {\n            const inputValue = inputStyles[webKitStyles[i]];\n            let compareInput = inputValue;\n            let currentValue = dom.getStyle(node, webKitStyles[i], true);\n            if (/color/.test(webKitStyles[i])) {\n              compareInput = rgbToHex(compareInput);\n              currentValue = rgbToHex(currentValue);\n            }\n            if (currentValue !== compareInput) {\n              outputStyles[webKitStyles[i]] = inputValue;\n            }\n          }\n          const outputStyle = dom.serializeStyle(outputStyles, 'span');\n          if (outputStyle) {\n            return before + ' style=\"' + outputStyle + '\"' + after;\n          }\n          return before + after;\n        });\n      } else {\n        content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, '$1$3');\n      }\n      content = content.replace(/(<[^>]+) data-mce-style=\"([^\"]+)\"([^>]*>)/gi, (all, before, value, after) => {\n        return before + ' style=\"' + value + '\"' + after;\n      });\n      return content;\n    };\n    const setup$8 = editor => {\n      if (Env.browser.isChromium() || Env.browser.isSafari()) {\n        addPreProcessFilter(editor, removeWebKitStyles);\n      }\n    };\n\n    const setup$7 = editor => {\n      const draggingInternallyState = Cell(false);\n      const pasteFormat = Cell(isPasteAsTextEnabled(editor) ? 'text' : 'html');\n      const pasteBin = PasteBin(editor);\n      setup$8(editor);\n      register$1(editor, pasteFormat);\n      setup$9(editor);\n      editor.on('PreInit', () => {\n        register(editor);\n        setup$a(editor, draggingInternallyState);\n        registerEventsAndFilters(editor, pasteBin, pasteFormat);\n      });\n    };\n\n    const preventSummaryToggle = editor => {\n      editor.on('click', e => {\n        if (editor.dom.getParent(e.target, 'details')) {\n          e.preventDefault();\n        }\n      });\n    };\n    const filterDetails = editor => {\n      editor.parser.addNodeFilter('details', elms => {\n        each$g(elms, details => {\n          details.attr('data-mce-open', details.attr('open'));\n          details.attr('open', 'open');\n        });\n      });\n      editor.serializer.addNodeFilter('details', elms => {\n        each$g(elms, details => {\n          const open = details.attr('data-mce-open');\n          details.attr('open', isString(open) ? open : null);\n          details.attr('data-mce-open', null);\n        });\n      });\n    };\n    const setup$6 = editor => {\n      preventSummaryToggle(editor);\n      filterDetails(editor);\n    };\n\n    const isTextBlockNode = node => isElement$6(node) && isTextBlock$2(SugarElement.fromDom(node));\n    const normalizeSelection = editor => {\n      const rng = editor.selection.getRng();\n      const startPos = CaretPosition.fromRangeStart(rng);\n      const endPos = CaretPosition.fromRangeEnd(rng);\n      if (CaretPosition.isElementPosition(startPos)) {\n        const container = startPos.container();\n        if (isTextBlockNode(container)) {\n          firstPositionIn(container).each(pos => rng.setStart(pos.container(), pos.offset()));\n        }\n      }\n      if (CaretPosition.isElementPosition(endPos)) {\n        const container = startPos.container();\n        if (isTextBlockNode(container)) {\n          lastPositionIn(container).each(pos => rng.setEnd(pos.container(), pos.offset()));\n        }\n      }\n      editor.selection.setRng(normalize(rng));\n    };\n    const setup$5 = editor => {\n      editor.on('click', e => {\n        if (e.detail >= 3) {\n          normalizeSelection(editor);\n        }\n      });\n    };\n\n    var FakeCaretPosition;\n    (function (FakeCaretPosition) {\n      FakeCaretPosition['Before'] = 'before';\n      FakeCaretPosition['After'] = 'after';\n    }(FakeCaretPosition || (FakeCaretPosition = {})));\n    const distanceToRectLeft = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\n    const distanceToRectRight = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\n    const isInsideY = (clientY, clientRect) => clientY >= clientRect.top && clientY <= clientRect.bottom;\n    const collidesY = (r1, r2) => r1.top < r2.bottom && r1.bottom > r2.top;\n    const isOverlapping = (r1, r2) => {\n      const overlap = overlapY(r1, r2) / Math.min(r1.height, r2.height);\n      return collidesY(r1, r2) && overlap > 0.5;\n    };\n    const splitRectsPerAxis = (rects, y) => {\n      const intersectingRects = filter$6(rects, rect => isInsideY(y, rect));\n      return boundingClientRectFromRects(intersectingRects).fold(() => [\n        [],\n        rects\n      ], boundingRect => {\n        const {\n          pass: horizontal,\n          fail: vertical\n        } = partition$2(rects, rect => isOverlapping(rect, boundingRect));\n        return [\n          horizontal,\n          vertical\n        ];\n      });\n    };\n    const clientInfo = (rect, clientX) => {\n      return {\n        node: rect.node,\n        position: distanceToRectLeft(rect, clientX) < distanceToRectRight(rect, clientX) ? FakeCaretPosition.Before : FakeCaretPosition.After\n      };\n    };\n    const horizontalDistance = (rect, x, _y) => x > rect.left && x < rect.right ? 0 : Math.min(Math.abs(rect.left - x), Math.abs(rect.right - x));\n    const closestChildCaretCandidateNodeRect = (children, clientX, clientY) => {\n      const caretCandidateRect = rect => {\n        if (isCaretCandidate$3(rect.node)) {\n          return Optional.some(rect);\n        } else if (isElement$6(rect.node)) {\n          return closestChildCaretCandidateNodeRect(from(rect.node.childNodes), clientX, clientY);\n        } else {\n          return Optional.none();\n        }\n      };\n      const getClosestTextNode = (rects, distance) => {\n        if (rects.length >= 2) {\n          const r1 = caretCandidateRect(rects[0]).getOr(rects[0]);\n          const r2 = caretCandidateRect(rects[1]).getOr(rects[1]);\n          const deltaDistance = Math.abs(distance(r1, clientX, clientY) - distance(r2, clientX, clientY));\n          if (deltaDistance < 2) {\n            if (isText$8(r1.node)) {\n              return Optional.some(r1);\n            } else if (isText$8(r2.node)) {\n              return Optional.some(r2);\n            }\n          }\n        }\n        return Optional.none();\n      };\n      const findClosestCaretCandidateNodeRect = (rects, distance) => {\n        const sortedRects = sort(rects, (r1, r2) => distance(r1, clientX, clientY) - distance(r2, clientX, clientY));\n        return getClosestTextNode(sortedRects, distance).orThunk(() => findMap(sortedRects, caretCandidateRect));\n      };\n      const [horizontalRects, verticalRects] = splitRectsPerAxis(getClientRects(children), clientY);\n      const {\n        pass: above,\n        fail: below\n      } = partition$2(verticalRects, rect => rect.top < clientY);\n      return findClosestCaretCandidateNodeRect(horizontalRects, horizontalDistance).orThunk(() => findClosestCaretCandidateNodeRect(below, distanceToRectEdgeFromXY)).orThunk(() => findClosestCaretCandidateNodeRect(above, distanceToRectEdgeFromXY));\n    };\n    const traverseUp = (rootElm, scope, clientX, clientY) => {\n      const helper = (scope, prevScope) => {\n        return prevScope.fold(() => closestChildCaretCandidateNodeRect(from(scope.dom.childNodes), clientX, clientY), prevScope => {\n          const uncheckedChildren = filter$6(from(scope.dom.childNodes), node => node !== prevScope.dom);\n          return closestChildCaretCandidateNodeRect(uncheckedChildren, clientX, clientY);\n        }).orThunk(() => {\n          const parent = eq(scope, rootElm) ? Optional.none() : parentElement(scope);\n          return parent.bind(newScope => helper(newScope, Optional.some(scope)));\n        });\n      };\n      return helper(scope, Optional.none());\n    };\n    const closestCaretCandidateNodeRect = (root, clientX, clientY) => {\n      const rootElm = SugarElement.fromDom(root);\n      const ownerDoc = documentOrOwner(rootElm);\n      const elementAtPoint = SugarElement.fromPoint(ownerDoc, clientX, clientY).filter(elm => contains(rootElm, elm));\n      const element = elementAtPoint.getOr(rootElm);\n      return traverseUp(rootElm, element, clientX, clientY);\n    };\n    const closestFakeCaretCandidate = (root, clientX, clientY) => closestCaretCandidateNodeRect(root, clientX, clientY).filter(rect => isFakeCaretTarget(rect.node)).map(rect => clientInfo(rect, clientX));\n\n    const getAbsolutePosition = elm => {\n      const clientRect = elm.getBoundingClientRect();\n      const doc = elm.ownerDocument;\n      const docElem = doc.documentElement;\n      const win = doc.defaultView;\n      return {\n        top: clientRect.top + win.pageYOffset - docElem.clientTop,\n        left: clientRect.left + win.pageXOffset - docElem.clientLeft\n      };\n    };\n    const getBodyPosition = editor => editor.inline ? getAbsolutePosition(editor.getBody()) : {\n      left: 0,\n      top: 0\n    };\n    const getScrollPosition = editor => {\n      const body = editor.getBody();\n      return editor.inline ? {\n        left: body.scrollLeft,\n        top: body.scrollTop\n      } : {\n        left: 0,\n        top: 0\n      };\n    };\n    const getBodyScroll = editor => {\n      const body = editor.getBody(), docElm = editor.getDoc().documentElement;\n      const inlineScroll = {\n        left: body.scrollLeft,\n        top: body.scrollTop\n      };\n      const iframeScroll = {\n        left: body.scrollLeft || docElm.scrollLeft,\n        top: body.scrollTop || docElm.scrollTop\n      };\n      return editor.inline ? inlineScroll : iframeScroll;\n    };\n    const getMousePosition = (editor, event) => {\n      if (event.target.ownerDocument !== editor.getDoc()) {\n        const iframePosition = getAbsolutePosition(editor.getContentAreaContainer());\n        const scrollPosition = getBodyScroll(editor);\n        return {\n          left: event.pageX - iframePosition.left + scrollPosition.left,\n          top: event.pageY - iframePosition.top + scrollPosition.top\n        };\n      }\n      return {\n        left: event.pageX,\n        top: event.pageY\n      };\n    };\n    const calculatePosition = (bodyPosition, scrollPosition, mousePosition) => ({\n      pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,\n      pageY: mousePosition.top - bodyPosition.top + scrollPosition.top\n    });\n    const calc = (editor, event) => calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));\n\n    const isContentEditableFalse$1 = isContentEditableFalse$a, isContentEditableTrue = isContentEditableTrue$4;\n    const isDraggable = (rootElm, elm) => isContentEditableFalse$1(elm) && elm !== rootElm;\n    const isValidDropTarget = (editor, targetElement, dragElement) => {\n      if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {\n        return false;\n      }\n      return !isContentEditableFalse$1(targetElement);\n    };\n    const cloneElement = elm => {\n      const cloneElm = elm.cloneNode(true);\n      cloneElm.removeAttribute('data-mce-selected');\n      return cloneElm;\n    };\n    const createGhost = (editor, elm, width, height) => {\n      const dom = editor.dom;\n      const clonedElm = elm.cloneNode(true);\n      dom.setStyles(clonedElm, {\n        width,\n        height\n      });\n      dom.setAttrib(clonedElm, 'data-mce-selected', null);\n      const ghostElm = dom.create('div', {\n        'class': 'mce-drag-container',\n        'data-mce-bogus': 'all',\n        'unselectable': 'on',\n        'contenteditable': 'false'\n      });\n      dom.setStyles(ghostElm, {\n        position: 'absolute',\n        opacity: 0.5,\n        overflow: 'hidden',\n        border: 0,\n        padding: 0,\n        margin: 0,\n        width,\n        height\n      });\n      dom.setStyles(clonedElm, {\n        margin: 0,\n        boxSizing: 'border-box'\n      });\n      ghostElm.appendChild(clonedElm);\n      return ghostElm;\n    };\n    const appendGhostToBody = (ghostElm, bodyElm) => {\n      if (ghostElm.parentNode !== bodyElm) {\n        bodyElm.appendChild(ghostElm);\n      }\n    };\n    const moveGhost = (ghostElm, position, width, height, maxX, maxY) => {\n      let overflowX = 0, overflowY = 0;\n      ghostElm.style.left = position.pageX + 'px';\n      ghostElm.style.top = position.pageY + 'px';\n      if (position.pageX + width > maxX) {\n        overflowX = position.pageX + width - maxX;\n      }\n      if (position.pageY + height > maxY) {\n        overflowY = position.pageY + height - maxY;\n      }\n      ghostElm.style.width = width - overflowX + 'px';\n      ghostElm.style.height = height - overflowY + 'px';\n    };\n    const removeElement = elm => {\n      if (elm && elm.parentNode) {\n        elm.parentNode.removeChild(elm);\n      }\n    };\n    const isLeftMouseButtonPressed = e => e.button === 0;\n    const applyRelPos = (state, position) => ({\n      pageX: position.pageX - state.relX,\n      pageY: position.pageY + 5\n    });\n    const start = (state, editor) => e => {\n      if (isLeftMouseButtonPressed(e)) {\n        const ceElm = find$2(editor.dom.getParents(e.target), or(isContentEditableFalse$1, isContentEditableTrue)).getOr(null);\n        if (isDraggable(editor.getBody(), ceElm)) {\n          const elmPos = editor.dom.getPos(ceElm);\n          const bodyElm = editor.getBody();\n          const docElm = editor.getDoc().documentElement;\n          state.set({\n            element: ceElm,\n            dragging: false,\n            screenX: e.screenX,\n            screenY: e.screenY,\n            maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,\n            maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,\n            relX: e.pageX - elmPos.x,\n            relY: e.pageY - elmPos.y,\n            width: ceElm.offsetWidth,\n            height: ceElm.offsetHeight,\n            ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight)\n          });\n        }\n      }\n    };\n    const move = (state, editor) => {\n      const throttledPlaceCaretAt = first$1((clientX, clientY) => {\n        editor._selectionOverrides.hideFakeCaret();\n        editor.selection.placeCaretAt(clientX, clientY);\n      }, 0);\n      editor.on('remove', throttledPlaceCaretAt.cancel);\n      return e => state.on(state => {\n        const movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));\n        if (!state.dragging && movement > 10) {\n          const args = editor.dispatch('dragstart', { target: state.element });\n          if (args.isDefaultPrevented()) {\n            return;\n          }\n          state.dragging = true;\n          editor.focus();\n        }\n        if (state.dragging) {\n          const targetPos = applyRelPos(state, calc(editor, e));\n          appendGhostToBody(state.ghost, editor.getBody());\n          moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY);\n          throttledPlaceCaretAt.throttle(e.clientX, e.clientY);\n        }\n      });\n    };\n    const getRawTarget = selection => {\n      const rng = selection.getSel().getRangeAt(0);\n      const startContainer = rng.startContainer;\n      return startContainer.nodeType === 3 ? startContainer.parentNode : startContainer;\n    };\n    const drop = (state, editor) => e => {\n      state.on(state => {\n        if (state.dragging) {\n          if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {\n            const targetClone = cloneElement(state.element);\n            const args = editor.dispatch('drop', {\n              clientX: e.clientX,\n              clientY: e.clientY\n            });\n            if (!args.isDefaultPrevented()) {\n              editor.undoManager.transact(() => {\n                removeElement(state.element);\n                editor.insertContent(editor.dom.getOuterHTML(targetClone));\n                editor._selectionOverrides.hideFakeCaret();\n              });\n            }\n          }\n          editor.dispatch('dragend');\n        }\n      });\n      removeDragState(state);\n    };\n    const stop = (state, editor) => () => {\n      state.on(state => {\n        if (state.dragging) {\n          editor.dispatch('dragend');\n        }\n      });\n      removeDragState(state);\n    };\n    const removeDragState = state => {\n      state.on(state => {\n        removeElement(state.ghost);\n      });\n      state.clear();\n    };\n    const bindFakeDragEvents = editor => {\n      const state = value$2();\n      const pageDom = DOMUtils.DOM;\n      const rootDocument = document;\n      const dragStartHandler = start(state, editor);\n      const dragHandler = move(state, editor);\n      const dropHandler = drop(state, editor);\n      const dragEndHandler = stop(state, editor);\n      editor.on('mousedown', dragStartHandler);\n      editor.on('mousemove', dragHandler);\n      editor.on('mouseup', dropHandler);\n      pageDom.bind(rootDocument, 'mousemove', dragHandler);\n      pageDom.bind(rootDocument, 'mouseup', dragEndHandler);\n      editor.on('remove', () => {\n        pageDom.unbind(rootDocument, 'mousemove', dragHandler);\n        pageDom.unbind(rootDocument, 'mouseup', dragEndHandler);\n      });\n      editor.on('keydown', e => {\n        if (e.keyCode === VK.ESC) {\n          dragEndHandler();\n        }\n      });\n    };\n    const blockUnsupportedFileDrop = editor => {\n      const preventFileDrop = e => {\n        if (!e.isDefaultPrevented()) {\n          const dataTransfer = e.dataTransfer;\n          if (dataTransfer && (contains$2(dataTransfer.types, 'Files') || dataTransfer.files.length > 0)) {\n            e.preventDefault();\n            if (e.type === 'drop') {\n              displayError(editor, 'Dropped file type is not supported');\n            }\n          }\n        }\n      };\n      const preventFileDropIfUIElement = e => {\n        if (isUIElement(editor, e.target)) {\n          preventFileDrop(e);\n        }\n      };\n      const setup = () => {\n        const pageDom = DOMUtils.DOM;\n        const dom = editor.dom;\n        const doc = document;\n        const editorRoot = editor.inline ? editor.getBody() : editor.getDoc();\n        const eventNames = [\n          'drop',\n          'dragover'\n        ];\n        each$g(eventNames, name => {\n          pageDom.bind(doc, name, preventFileDropIfUIElement);\n          dom.bind(editorRoot, name, preventFileDrop);\n        });\n        editor.on('remove', () => {\n          each$g(eventNames, name => {\n            pageDom.unbind(doc, name, preventFileDropIfUIElement);\n            dom.unbind(editorRoot, name, preventFileDrop);\n          });\n        });\n      };\n      editor.on('init', () => {\n        Delay.setEditorTimeout(editor, setup, 0);\n      });\n    };\n    const init$2 = editor => {\n      bindFakeDragEvents(editor);\n      if (shouldBlockUnsupportedDrop(editor)) {\n        blockUnsupportedFileDrop(editor);\n      }\n    };\n\n    const setup$4 = editor => {\n      const renderFocusCaret = first$1(() => {\n        if (!editor.removed && editor.getBody().contains(document.activeElement)) {\n          const rng = editor.selection.getRng();\n          if (rng.collapsed) {\n            const caretRange = renderRangeCaret(editor, rng, false);\n            editor.selection.setRng(caretRange);\n          }\n        }\n      }, 0);\n      editor.on('focus', () => {\n        renderFocusCaret.throttle();\n      });\n      editor.on('blur', () => {\n        renderFocusCaret.cancel();\n      });\n    };\n\n    const setup$3 = editor => {\n      editor.on('init', () => {\n        editor.on('focusin', e => {\n          const target = e.target;\n          if (isMedia$2(target)) {\n            const ceRoot = getContentEditableRoot$1(editor.getBody(), target);\n            const node = isContentEditableFalse$a(ceRoot) ? ceRoot : target;\n            if (editor.selection.getNode() !== node) {\n              selectNode(editor, node).each(rng => editor.selection.setRng(rng));\n            }\n          }\n        });\n      });\n    };\n\n    const isContentEditableFalse = isContentEditableFalse$a;\n    const getContentEditableRoot = (editor, node) => getContentEditableRoot$1(editor.getBody(), node);\n    const SelectionOverrides = editor => {\n      const selection = editor.selection, dom = editor.dom;\n      const isBlock = dom.isBlock;\n      const rootNode = editor.getBody();\n      const fakeCaret = FakeCaret(editor, rootNode, isBlock, () => hasFocus(editor));\n      const realSelectionId = 'sel-' + dom.uniqueId();\n      const elementSelectionAttr = 'data-mce-selected';\n      let selectedElement;\n      const isFakeSelectionElement = node => dom.hasClass(node, 'mce-offscreen-selection');\n      const isFakeSelectionTargetElement = node => node !== rootNode && (isContentEditableFalse(node) || isMedia$2(node)) && dom.isChildOf(node, rootNode);\n      const setRange = range => {\n        if (range) {\n          selection.setRng(range);\n        }\n      };\n      const showCaret = (direction, node, before, scrollIntoView = true) => {\n        const e = editor.dispatch('ShowCaret', {\n          target: node,\n          direction,\n          before\n        });\n        if (e.isDefaultPrevented()) {\n          return null;\n        }\n        if (scrollIntoView) {\n          selection.scrollIntoView(node, direction === -1);\n        }\n        return fakeCaret.show(before, node);\n      };\n      const showBlockCaretContainer = blockCaretContainer => {\n        if (blockCaretContainer.hasAttribute('data-mce-caret')) {\n          showCaretContainerBlock(blockCaretContainer);\n          selection.scrollIntoView(blockCaretContainer);\n        }\n      };\n      const registerEvents = () => {\n        editor.on('click', e => {\n          const contentEditableRoot = getContentEditableRoot(editor, e.target);\n          if (contentEditableRoot) {\n            if (isContentEditableFalse(contentEditableRoot)) {\n              e.preventDefault();\n              editor.focus();\n            }\n          }\n        });\n        editor.on('blur NewBlock', removeElementSelection);\n        editor.on('ResizeWindow FullscreenStateChanged', fakeCaret.reposition);\n        editor.on('tap', e => {\n          const targetElm = e.target;\n          const contentEditableRoot = getContentEditableRoot(editor, targetElm);\n          if (isContentEditableFalse(contentEditableRoot)) {\n            e.preventDefault();\n            selectNode(editor, contentEditableRoot).each(setElementSelection);\n          } else if (isFakeSelectionTargetElement(targetElm)) {\n            selectNode(editor, targetElm).each(setElementSelection);\n          }\n        }, true);\n        editor.on('mousedown', e => {\n          const targetElm = e.target;\n          if (targetElm !== rootNode && targetElm.nodeName !== 'HTML' && !dom.isChildOf(targetElm, rootNode)) {\n            return;\n          }\n          if (isXYInContentArea(editor, e.clientX, e.clientY) === false) {\n            return;\n          }\n          removeElementSelection();\n          hideFakeCaret();\n          const closestContentEditable = getContentEditableRoot(editor, targetElm);\n          if (isContentEditableFalse(closestContentEditable)) {\n            e.preventDefault();\n            selectNode(editor, closestContentEditable).each(setElementSelection);\n          } else {\n            closestFakeCaretCandidate(rootNode, e.clientX, e.clientY).each(caretInfo => {\n              e.preventDefault();\n              const range = showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);\n              setRange(range);\n              if (isElement$6(closestContentEditable)) {\n                closestContentEditable.focus();\n              } else {\n                editor.getBody().focus();\n              }\n            });\n          }\n        });\n        editor.on('keypress', e => {\n          if (VK.modifierPressed(e)) {\n            return;\n          }\n          if (isContentEditableFalse(selection.getNode())) {\n            e.preventDefault();\n          }\n        });\n        editor.on('GetSelectionRange', e => {\n          let rng = e.range;\n          if (selectedElement) {\n            if (!selectedElement.parentNode) {\n              selectedElement = null;\n              return;\n            }\n            rng = rng.cloneRange();\n            rng.selectNode(selectedElement);\n            e.range = rng;\n          }\n        });\n        editor.on('SetSelectionRange', e => {\n          e.range = normalizeVoidElementSelection(e.range);\n          const rng = setElementSelection(e.range, e.forward);\n          if (rng) {\n            e.range = rng;\n          }\n        });\n        const isPasteBin = node => node.id === 'mcepastebin';\n        editor.on('AfterSetSelectionRange', e => {\n          const rng = e.range;\n          const parentNode = rng.startContainer.parentNode;\n          if (!isRangeInCaretContainer(rng) && !isPasteBin(parentNode)) {\n            hideFakeCaret();\n          }\n          if (!isFakeSelectionElement(parentNode)) {\n            removeElementSelection();\n          }\n        });\n        init$2(editor);\n        setup$4(editor);\n        setup$3(editor);\n      };\n      const isWithinCaretContainer = node => isCaretContainer$2(node) || startsWithCaretContainer$1(node) || endsWithCaretContainer$1(node);\n      const isRangeInCaretContainer = rng => isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);\n      const normalizeVoidElementSelection = rng => {\n        const voidElements = editor.schema.getVoidElements();\n        const newRng = dom.createRng();\n        const startContainer = rng.startContainer;\n        const startOffset = rng.startOffset;\n        const endContainer = rng.endContainer;\n        const endOffset = rng.endOffset;\n        if (has$2(voidElements, startContainer.nodeName.toLowerCase())) {\n          if (startOffset === 0) {\n            newRng.setStartBefore(startContainer);\n          } else {\n            newRng.setStartAfter(startContainer);\n          }\n        } else {\n          newRng.setStart(startContainer, startOffset);\n        }\n        if (has$2(voidElements, endContainer.nodeName.toLowerCase())) {\n          if (endOffset === 0) {\n            newRng.setEndBefore(endContainer);\n          } else {\n            newRng.setEndAfter(endContainer);\n          }\n        } else {\n          newRng.setEnd(endContainer, endOffset);\n        }\n        return newRng;\n      };\n      const setupOffscreenSelection = (node, targetClone) => {\n        const body = SugarElement.fromDom(editor.getBody());\n        const doc = editor.getDoc();\n        const realSelectionContainer = descendant(body, '#' + realSelectionId).getOrThunk(() => {\n          const newContainer = SugarElement.fromHtml('<div data-mce-bogus=\"all\" class=\"mce-offscreen-selection\"></div>', doc);\n          set$2(newContainer, 'id', realSelectionId);\n          append$1(body, newContainer);\n          return newContainer;\n        });\n        const newRange = dom.createRng();\n        empty(realSelectionContainer);\n        append(realSelectionContainer, [\n          SugarElement.fromText(nbsp, doc),\n          SugarElement.fromDom(targetClone),\n          SugarElement.fromText(nbsp, doc)\n        ]);\n        newRange.setStart(realSelectionContainer.dom.firstChild, 1);\n        newRange.setEnd(realSelectionContainer.dom.lastChild, 0);\n        setAll(realSelectionContainer, { top: dom.getPos(node, editor.getBody()).y + 'px' });\n        focus$1(realSelectionContainer);\n        const sel = selection.getSel();\n        sel.removeAllRanges();\n        sel.addRange(newRange);\n        return newRange;\n      };\n      const selectElement = elm => {\n        const targetClone = elm.cloneNode(true);\n        const e = editor.dispatch('ObjectSelected', {\n          target: elm,\n          targetClone\n        });\n        if (e.isDefaultPrevented()) {\n          return null;\n        }\n        const range = setupOffscreenSelection(elm, e.targetClone);\n        const nodeElm = SugarElement.fromDom(elm);\n        each$g(descendants(SugarElement.fromDom(editor.getBody()), '*[data-mce-selected]'), elm => {\n          if (!eq(nodeElm, elm)) {\n            remove$a(elm, elementSelectionAttr);\n          }\n        });\n        if (!dom.getAttrib(elm, elementSelectionAttr)) {\n          elm.setAttribute(elementSelectionAttr, '1');\n        }\n        selectedElement = elm;\n        hideFakeCaret();\n        return range;\n      };\n      const setElementSelection = (range, forward) => {\n        if (!range) {\n          return null;\n        }\n        if (range.collapsed) {\n          if (!isRangeInCaretContainer(range)) {\n            const dir = forward ? 1 : -1;\n            const caretPosition = getNormalizedRangeEndPoint(dir, rootNode, range);\n            const beforeNode = caretPosition.getNode(!forward);\n            if (isFakeCaretTarget(beforeNode)) {\n              return showCaret(dir, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);\n            }\n            const afterNode = caretPosition.getNode(forward);\n            if (isFakeCaretTarget(afterNode)) {\n              return showCaret(dir, afterNode, forward ? false : !caretPosition.isAtEnd(), false);\n            }\n          }\n          return null;\n        }\n        let startContainer = range.startContainer;\n        let startOffset = range.startOffset;\n        const endOffset = range.endOffset;\n        if (startContainer.nodeType === 3 && startOffset === 0 && isContentEditableFalse(startContainer.parentNode)) {\n          startContainer = startContainer.parentNode;\n          startOffset = dom.nodeIndex(startContainer);\n          startContainer = startContainer.parentNode;\n        }\n        if (startContainer.nodeType !== 1) {\n          return null;\n        }\n        if (endOffset === startOffset + 1 && startContainer === range.endContainer) {\n          const node = startContainer.childNodes[startOffset];\n          if (isFakeSelectionTargetElement(node)) {\n            return selectElement(node);\n          }\n        }\n        return null;\n      };\n      const removeElementSelection = () => {\n        if (selectedElement) {\n          selectedElement.removeAttribute(elementSelectionAttr);\n        }\n        descendant(SugarElement.fromDom(editor.getBody()), '#' + realSelectionId).each(remove$5);\n        selectedElement = null;\n      };\n      const destroy = () => {\n        fakeCaret.destroy();\n        selectedElement = null;\n      };\n      const hideFakeCaret = () => {\n        fakeCaret.hide();\n      };\n      if (!isRtc(editor)) {\n        registerEvents();\n      }\n      return {\n        showCaret,\n        showBlockCaretContainer,\n        hideFakeCaret,\n        destroy\n      };\n    };\n\n    const generatePath = (root, node, offset) => {\n      if (isText$8(node) && (offset < 0 || offset > node.data.length)) {\n        return [];\n      }\n      const p = [offset];\n      let current = node;\n      while (current !== root && current.parentNode) {\n        const parent = current.parentNode;\n        for (let i = 0; i < parent.childNodes.length; i++) {\n          if (parent.childNodes[i] === current) {\n            p.push(i);\n            break;\n          }\n        }\n        current = parent;\n      }\n      return current === root ? p.reverse() : [];\n    };\n    const generatePathRange = (root, startNode, startOffset, endNode, endOffset) => {\n      const start = generatePath(root, startNode, startOffset);\n      const end = generatePath(root, endNode, endOffset);\n      return {\n        start,\n        end\n      };\n    };\n    const resolvePath = (root, path) => {\n      const nodePath = path.slice();\n      const offset = nodePath.pop();\n      const resolvedNode = foldl(nodePath, (optNode, index) => optNode.bind(node => Optional.from(node.childNodes[index])), Optional.some(root));\n      return resolvedNode.bind(node => {\n        if (isText$8(node) && (offset < 0 || offset > node.data.length)) {\n          return Optional.none();\n        } else {\n          return Optional.some({\n            node,\n            offset\n          });\n        }\n      });\n    };\n    const resolvePathRange = (root, range) => resolvePath(root, range.start).bind(({\n      node: startNode,\n      offset: startOffset\n    }) => resolvePath(root, range.end).map(({\n      node: endNode,\n      offset: endOffset\n    }) => {\n      const rng = document.createRange();\n      rng.setStart(startNode, startOffset);\n      rng.setEnd(endNode, endOffset);\n      return rng;\n    }));\n    const generatePathRangeFromRange = (root, range) => generatePathRange(root, range.startContainer, range.startOffset, range.endContainer, range.endOffset);\n\n    const cleanEmptyNodes = (dom, node, isRoot) => {\n      if (node && dom.isEmpty(node) && !isRoot(node)) {\n        const parent = node.parentNode;\n        dom.remove(node);\n        cleanEmptyNodes(dom, parent, isRoot);\n      }\n    };\n    const deleteRng = (dom, rng, isRoot, clean = true) => {\n      const startParent = rng.startContainer.parentNode;\n      const endParent = rng.endContainer.parentNode;\n      rng.deleteContents();\n      if (clean && !isRoot(rng.startContainer)) {\n        if (isText$8(rng.startContainer) && rng.startContainer.data.length === 0) {\n          dom.remove(rng.startContainer);\n        }\n        if (isText$8(rng.endContainer) && rng.endContainer.data.length === 0) {\n          dom.remove(rng.endContainer);\n        }\n        cleanEmptyNodes(dom, startParent, isRoot);\n        if (startParent !== endParent) {\n          cleanEmptyNodes(dom, endParent, isRoot);\n        }\n      }\n    };\n    const getParentBlock = (editor, rng) => Optional.from(editor.dom.getParent(rng.startContainer, editor.dom.isBlock));\n\n    const stripPattern = (dom, block, pattern) => {\n      const firstTextNode = textAfter(block, 0, block);\n      firstTextNode.each(spot => {\n        const node = spot.container;\n        scanRight(node, pattern.start.length, block).each(end => {\n          const rng = dom.createRng();\n          rng.setStart(node, 0);\n          rng.setEnd(end.container, end.offset);\n          deleteRng(dom, rng, e => e === block);\n        });\n      });\n    };\n    const applyPattern$1 = (editor, match) => {\n      const dom = editor.dom;\n      const pattern = match.pattern;\n      const rng = resolvePathRange(dom.getRoot(), match.range).getOrDie('Unable to resolve path range');\n      const isBlockFormatName = (name, formatter) => {\n        const formatSet = formatter.get(name);\n        return isArray$1(formatSet) && head(formatSet).exists(format => has$2(format, 'block'));\n      };\n      getParentBlock(editor, rng).each(block => {\n        if (pattern.type === 'block-format') {\n          if (isBlockFormatName(pattern.format, editor.formatter)) {\n            editor.undoManager.transact(() => {\n              stripPattern(editor.dom, block, pattern);\n              editor.formatter.apply(pattern.format);\n            });\n          }\n        } else if (pattern.type === 'block-command') {\n          editor.undoManager.transact(() => {\n            stripPattern(editor.dom, block, pattern);\n            editor.execCommand(pattern.cmd, false, pattern.value);\n          });\n        }\n      });\n      return true;\n    };\n    const findPattern$1 = (patterns, text) => {\n      const nuText = text.replace(nbsp, ' ');\n      return find$2(patterns, pattern => text.indexOf(pattern.start) === 0 || nuText.indexOf(pattern.start) === 0);\n    };\n    const findPatterns$1 = (editor, patterns) => {\n      const dom = editor.dom;\n      const rng = editor.selection.getRng();\n      return getParentBlock(editor, rng).filter(block => {\n        const forcedRootBlock = getForcedRootBlock(editor);\n        const matchesForcedRootBlock = dom.is(block, forcedRootBlock);\n        return block !== null && matchesForcedRootBlock;\n      }).bind(block => {\n        const blockText = block.textContent;\n        const matchedPattern = findPattern$1(patterns, blockText);\n        return matchedPattern.map(pattern => {\n          if (Tools.trim(blockText).length === pattern.start.length) {\n            return [];\n          }\n          return [{\n              pattern,\n              range: generatePathRange(dom.getRoot(), block, 0, block, 0)\n            }];\n        });\n      }).getOr([]);\n    };\n    const applyMatches$1 = (editor, matches) => {\n      if (matches.length === 0) {\n        return;\n      }\n      const bookmark = editor.selection.getBookmark();\n      each$g(matches, match => applyPattern$1(editor, match));\n      editor.selection.moveToBookmark(bookmark);\n    };\n\n    const newMarker = (dom, id) => dom.create('span', {\n      'data-mce-type': 'bookmark',\n      id\n    });\n    const rangeFromMarker = (dom, marker) => {\n      const rng = dom.createRng();\n      rng.setStartAfter(marker.start);\n      rng.setEndBefore(marker.end);\n      return rng;\n    };\n    const createMarker = (dom, markerPrefix, pathRange) => {\n      const rng = resolvePathRange(dom.getRoot(), pathRange).getOrDie('Unable to resolve path range');\n      const startNode = rng.startContainer;\n      const endNode = rng.endContainer;\n      const textEnd = rng.endOffset === 0 ? endNode : endNode.splitText(rng.endOffset);\n      const textStart = rng.startOffset === 0 ? startNode : startNode.splitText(rng.startOffset);\n      return {\n        prefix: markerPrefix,\n        end: textEnd.parentNode.insertBefore(newMarker(dom, markerPrefix + '-end'), textEnd),\n        start: textStart.parentNode.insertBefore(newMarker(dom, markerPrefix + '-start'), textStart)\n      };\n    };\n    const removeMarker = (dom, marker, isRoot) => {\n      cleanEmptyNodes(dom, dom.get(marker.prefix + '-end'), isRoot);\n      cleanEmptyNodes(dom, dom.get(marker.prefix + '-start'), isRoot);\n    };\n\n    const isReplacementPattern = pattern => pattern.start.length === 0;\n    const matchesPattern = patternContent => (element, offset) => {\n      const text = element.data;\n      const searchText = text.substring(0, offset);\n      const startEndIndex = searchText.lastIndexOf(patternContent.charAt(patternContent.length - 1));\n      const startIndex = searchText.lastIndexOf(patternContent);\n      if (startIndex !== -1) {\n        return startIndex + patternContent.length;\n      } else if (startEndIndex !== -1) {\n        return startEndIndex + 1;\n      } else {\n        return -1;\n      }\n    };\n    const findPatternStartFromSpot = (dom, pattern, block, spot) => {\n      const startPattern = pattern.start;\n      const startSpot = repeatLeft(dom, spot.container, spot.offset, matchesPattern(startPattern), block);\n      return startSpot.bind(spot => {\n        if (spot.offset >= startPattern.length) {\n          const rng = dom.createRng();\n          rng.setStart(spot.container, spot.offset - startPattern.length);\n          rng.setEnd(spot.container, spot.offset);\n          return Optional.some(rng);\n        } else {\n          const offset = spot.offset - startPattern.length;\n          return scanLeft(spot.container, offset, block).map(nextSpot => {\n            const rng = dom.createRng();\n            rng.setStart(nextSpot.container, nextSpot.offset);\n            rng.setEnd(spot.container, spot.offset);\n            return rng;\n          }).filter(rng => rng.toString() === startPattern).orThunk(() => findPatternStartFromSpot(dom, pattern, block, point(spot.container, 0)));\n        }\n      });\n    };\n    const findPatternStart = (dom, pattern, node, offset, block, requireGap = false) => {\n      if (pattern.start.length === 0 && !requireGap) {\n        const rng = dom.createRng();\n        rng.setStart(node, offset);\n        rng.setEnd(node, offset);\n        return Optional.some(rng);\n      }\n      return textBefore(node, offset, block).bind(spot => {\n        const start = findPatternStartFromSpot(dom, pattern, block, spot);\n        return start.bind(startRange => {\n          if (requireGap) {\n            if (startRange.endContainer === spot.container && startRange.endOffset === spot.offset) {\n              return Optional.none();\n            } else if (spot.offset === 0 && startRange.endContainer.textContent.length === startRange.endOffset) {\n              return Optional.none();\n            }\n          }\n          return Optional.some(startRange);\n        });\n      });\n    };\n    const findPattern = (editor, block, details) => {\n      const dom = editor.dom;\n      const root = dom.getRoot();\n      const pattern = details.pattern;\n      const endNode = details.position.container;\n      const endOffset = details.position.offset;\n      return scanLeft(endNode, endOffset - details.pattern.end.length, block).bind(spot => {\n        const endPathRng = generatePathRange(root, spot.container, spot.offset, endNode, endOffset);\n        if (isReplacementPattern(pattern)) {\n          return Optional.some({\n            matches: [{\n                pattern,\n                startRng: endPathRng,\n                endRng: endPathRng\n              }],\n            position: spot\n          });\n        } else {\n          const resultsOpt = findPatternsRec(editor, details.remainingPatterns, spot.container, spot.offset, block);\n          const results = resultsOpt.getOr({\n            matches: [],\n            position: spot\n          });\n          const pos = results.position;\n          const start = findPatternStart(dom, pattern, pos.container, pos.offset, block, resultsOpt.isNone());\n          return start.map(startRng => {\n            const startPathRng = generatePathRangeFromRange(root, startRng);\n            return {\n              matches: results.matches.concat([{\n                  pattern,\n                  startRng: startPathRng,\n                  endRng: endPathRng\n                }]),\n              position: point(startRng.startContainer, startRng.startOffset)\n            };\n          });\n        }\n      });\n    };\n    const findPatternsRec = (editor, patterns, node, offset, block) => {\n      const dom = editor.dom;\n      return textBefore(node, offset, dom.getRoot()).bind(endSpot => {\n        const rng = dom.createRng();\n        rng.setStart(block, 0);\n        rng.setEnd(node, offset);\n        const text = rng.toString();\n        for (let i = 0; i < patterns.length; i++) {\n          const pattern = patterns[i];\n          if (!endsWith(text, pattern.end)) {\n            continue;\n          }\n          const patternsWithoutCurrent = patterns.slice();\n          patternsWithoutCurrent.splice(i, 1);\n          const result = findPattern(editor, block, {\n            pattern,\n            remainingPatterns: patternsWithoutCurrent,\n            position: endSpot\n          });\n          if (result.isSome()) {\n            return result;\n          }\n        }\n        return Optional.none();\n      });\n    };\n    const applyPattern = (editor, pattern, patternRange) => {\n      editor.selection.setRng(patternRange);\n      if (pattern.type === 'inline-format') {\n        each$g(pattern.format, format => {\n          editor.formatter.apply(format);\n        });\n      } else {\n        editor.execCommand(pattern.cmd, false, pattern.value);\n      }\n    };\n    const applyReplacementPattern = (editor, pattern, marker, isRoot) => {\n      const markerRange = rangeFromMarker(editor.dom, marker);\n      deleteRng(editor.dom, markerRange, isRoot);\n      applyPattern(editor, pattern, markerRange);\n    };\n    const applyPatternWithContent = (editor, pattern, startMarker, endMarker, isRoot) => {\n      const dom = editor.dom;\n      const markerEndRange = rangeFromMarker(dom, endMarker);\n      const markerStartRange = rangeFromMarker(dom, startMarker);\n      deleteRng(dom, markerStartRange, isRoot);\n      deleteRng(dom, markerEndRange, isRoot);\n      const patternMarker = {\n        prefix: startMarker.prefix,\n        start: startMarker.end,\n        end: endMarker.start\n      };\n      const patternRange = rangeFromMarker(dom, patternMarker);\n      applyPattern(editor, pattern, patternRange);\n    };\n    const addMarkers = (dom, matches) => {\n      const markerPrefix = generate$1('mce_textpattern');\n      const matchesWithEnds = foldr(matches, (acc, match) => {\n        const endMarker = createMarker(dom, markerPrefix + `_end${ acc.length }`, match.endRng);\n        return acc.concat([{\n            ...match,\n            endMarker\n          }]);\n      }, []);\n      return foldr(matchesWithEnds, (acc, match) => {\n        const idx = matchesWithEnds.length - acc.length - 1;\n        const startMarker = isReplacementPattern(match.pattern) ? match.endMarker : createMarker(dom, markerPrefix + `_start${ idx }`, match.startRng);\n        return acc.concat([{\n            ...match,\n            startMarker\n          }]);\n      }, []);\n    };\n    const findPatterns = (editor, patterns, space) => {\n      const rng = editor.selection.getRng();\n      if (rng.collapsed === false) {\n        return [];\n      }\n      return getParentBlock(editor, rng).bind(block => {\n        const offset = Math.max(0, rng.startOffset - (space ? 1 : 0));\n        return findPatternsRec(editor, patterns, rng.startContainer, offset, block);\n      }).fold(() => [], result => result.matches);\n    };\n    const applyMatches = (editor, matches) => {\n      if (matches.length === 0) {\n        return;\n      }\n      const dom = editor.dom;\n      const bookmark = editor.selection.getBookmark();\n      const matchesWithMarkers = addMarkers(dom, matches);\n      each$g(matchesWithMarkers, match => {\n        const block = dom.getParent(match.startMarker.start, dom.isBlock);\n        const isRoot = node => node === block;\n        if (isReplacementPattern(match.pattern)) {\n          applyReplacementPattern(editor, match.pattern, match.endMarker, isRoot);\n        } else {\n          applyPatternWithContent(editor, match.pattern, match.startMarker, match.endMarker, isRoot);\n        }\n        removeMarker(dom, match.endMarker, isRoot);\n        removeMarker(dom, match.startMarker, isRoot);\n      });\n      editor.selection.moveToBookmark(bookmark);\n    };\n\n    const hasPatterns = patternSet => patternSet.inlinePatterns.length > 0 || patternSet.blockPatterns.length > 0;\n    const handleEnter = (editor, patternSet) => {\n      if (!editor.selection.isCollapsed() || !hasPatterns(patternSet)) {\n        return false;\n      }\n      const inlineMatches = findPatterns(editor, patternSet.inlinePatterns, false);\n      const blockMatches = findPatterns$1(editor, patternSet.blockPatterns);\n      if (blockMatches.length > 0 || inlineMatches.length > 0) {\n        editor.undoManager.add();\n        editor.undoManager.extra(() => {\n          editor.execCommand('mceInsertNewLine');\n        }, () => {\n          editor.insertContent(zeroWidth);\n          applyMatches(editor, inlineMatches);\n          applyMatches$1(editor, blockMatches);\n          const range = editor.selection.getRng();\n          const spot = textBefore(range.startContainer, range.startOffset, editor.dom.getRoot());\n          editor.execCommand('mceInsertNewLine');\n          spot.each(s => {\n            const node = s.container;\n            if (node.data.charAt(s.offset - 1) === zeroWidth) {\n              node.deleteData(s.offset - 1, 1);\n              cleanEmptyNodes(editor.dom, node.parentNode, e => e === editor.dom.getRoot());\n            }\n          });\n        });\n        return true;\n      }\n      return false;\n    };\n    const handleInlineKey = (editor, inlinePatterns) => {\n      if (inlinePatterns.length > 0) {\n        const inlineMatches = findPatterns(editor, inlinePatterns, true);\n        if (inlineMatches.length > 0) {\n          editor.undoManager.transact(() => {\n            applyMatches(editor, inlineMatches);\n          });\n        }\n      }\n    };\n    const checkKeyEvent = (codes, event, predicate) => {\n      for (let i = 0; i < codes.length; i++) {\n        if (predicate(codes[i], event)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const checkKeyCode = (codes, event) => checkKeyEvent(codes, event, (code, event) => {\n      return code === event.keyCode && VK.modifierPressed(event) === false;\n    });\n    const checkCharCode = (chars, event) => checkKeyEvent(chars, event, (chr, event) => {\n      return chr.charCodeAt(0) === event.charCode;\n    });\n\n    const setup$2 = editor => {\n      const charCodes = [\n        ',',\n        '.',\n        ';',\n        ':',\n        '!',\n        '?'\n      ];\n      const keyCodes = [32];\n      const getPatternSet = () => createPatternSet(getTextPatterns(editor));\n      const getInlinePatterns$1 = () => getInlinePatterns(getTextPatterns(editor));\n      editor.on('keydown', e => {\n        if (e.keyCode === 13 && !VK.modifierPressed(e)) {\n          if (handleEnter(editor, getPatternSet())) {\n            e.preventDefault();\n          }\n        }\n      }, true);\n      editor.on('keyup', e => {\n        if (checkKeyCode(keyCodes, e)) {\n          handleInlineKey(editor, getInlinePatterns$1());\n        }\n      });\n      editor.on('keypress', e => {\n        if (checkCharCode(charCodes, e)) {\n          Delay.setEditorTimeout(editor, () => {\n            handleInlineKey(editor, getInlinePatterns$1());\n          });\n        }\n      });\n    };\n\n    const setup$1 = editor => {\n      setup$2(editor);\n    };\n\n    const Quirks = editor => {\n      const each = Tools.each;\n      const BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection, parser = editor.parser;\n      const browser = Env.browser;\n      const isGecko = browser.isFirefox();\n      const isWebKit = browser.isChromium() || browser.isSafari();\n      const isiOS = Env.deviceType.isiPhone() || Env.deviceType.isiPad();\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      const setEditorCommandState = (cmd, state) => {\n        try {\n          editor.getDoc().execCommand(cmd, false, state);\n        } catch (ex) {\n        }\n      };\n      const isDefaultPrevented = e => {\n        return e.isDefaultPrevented();\n      };\n      const emptyEditorWhenDeleting = () => {\n        const serializeRng = rng => {\n          const body = dom.create('body');\n          const contents = rng.cloneContents();\n          body.appendChild(contents);\n          return selection.serializer.serialize(body, { format: 'html' });\n        };\n        const allContentsSelected = rng => {\n          const selection = serializeRng(rng);\n          const allRng = dom.createRng();\n          allRng.selectNode(editor.getBody());\n          const allSelection = serializeRng(allRng);\n          return selection === allSelection;\n        };\n        editor.on('keydown', e => {\n          const keyCode = e.keyCode;\n          let isCollapsed, body;\n          if (!isDefaultPrevented(e) && (keyCode === DELETE || keyCode === BACKSPACE)) {\n            isCollapsed = editor.selection.isCollapsed();\n            body = editor.getBody();\n            if (isCollapsed && !dom.isEmpty(body)) {\n              return;\n            }\n            if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {\n              return;\n            }\n            e.preventDefault();\n            editor.setContent('');\n            if (body.firstChild && dom.isBlock(body.firstChild)) {\n              editor.selection.setCursorLocation(body.firstChild, 0);\n            } else {\n              editor.selection.setCursorLocation(body, 0);\n            }\n            editor.nodeChanged();\n          }\n        });\n      };\n      const selectAll = () => {\n        editor.shortcuts.add('meta+a', null, 'SelectAll');\n      };\n      const documentElementEditingFocus = () => {\n        if (!editor.inline) {\n          dom.bind(editor.getDoc(), 'mousedown mouseup', e => {\n            let rng;\n            if (e.target === editor.getDoc().documentElement) {\n              rng = selection.getRng();\n              editor.getBody().focus();\n              if (e.type === 'mousedown') {\n                if (isCaretContainer$2(rng.startContainer)) {\n                  return;\n                }\n                selection.placeCaretAt(e.clientX, e.clientY);\n              } else {\n                selection.setRng(rng);\n              }\n            }\n          });\n        }\n      };\n      const removeHrOnBackspace = () => {\n        editor.on('keydown', e => {\n          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n            if (!editor.getBody().getElementsByTagName('hr').length) {\n              return;\n            }\n            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\n              const node = selection.getNode();\n              const previousSibling = node.previousSibling;\n              if (node.nodeName === 'HR') {\n                dom.remove(node);\n                e.preventDefault();\n                return;\n              }\n              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'hr') {\n                dom.remove(previousSibling);\n                e.preventDefault();\n              }\n            }\n          }\n        });\n      };\n      const focusBody = () => {\n        if (!Range.prototype.getClientRects) {\n          editor.on('mousedown', e => {\n            if (!isDefaultPrevented(e) && e.target.nodeName === 'HTML') {\n              const body = editor.getBody();\n              body.blur();\n              Delay.setEditorTimeout(editor, () => {\n                body.focus();\n              });\n            }\n          });\n        }\n      };\n      const selectControlElements = () => {\n        const visualAidsAnchorClass = getVisualAidsAnchorClass(editor);\n        editor.on('click', e => {\n          const target = e.target;\n          if (/^(IMG|HR)$/.test(target.nodeName) && dom.getContentEditableParent(target) !== 'false') {\n            e.preventDefault();\n            editor.selection.select(target);\n            editor.nodeChanged();\n          }\n          if (target.nodeName === 'A' && dom.hasClass(target, visualAidsAnchorClass) && target.childNodes.length === 0) {\n            e.preventDefault();\n            selection.select(target);\n          }\n        });\n      };\n      const removeStylesWhenDeletingAcrossBlockElements = () => {\n        const getAttributeApplyFunction = () => {\n          const template = dom.getAttribs(selection.getStart().cloneNode(false));\n          return () => {\n            const target = selection.getStart();\n            if (target !== editor.getBody()) {\n              dom.setAttrib(target, 'style', null);\n              each(template, attr => {\n                target.setAttributeNode(attr.cloneNode(true));\n              });\n            }\n          };\n        };\n        const isSelectionAcrossElements = () => {\n          return !selection.isCollapsed() && dom.getParent(selection.getStart(), dom.isBlock) !== dom.getParent(selection.getEnd(), dom.isBlock);\n        };\n        editor.on('keypress', e => {\n          let applyAttributes;\n          if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {\n            applyAttributes = getAttributeApplyFunction();\n            editor.getDoc().execCommand('delete', false, null);\n            applyAttributes();\n            e.preventDefault();\n            return false;\n          }\n        });\n        dom.bind(editor.getDoc(), 'cut', e => {\n          let applyAttributes;\n          if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {\n            applyAttributes = getAttributeApplyFunction();\n            Delay.setEditorTimeout(editor, () => {\n              applyAttributes();\n            });\n          }\n        });\n      };\n      const disableBackspaceIntoATable = () => {\n        editor.on('keydown', e => {\n          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\n              const previousSibling = selection.getNode().previousSibling;\n              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'table') {\n                e.preventDefault();\n                return false;\n              }\n            }\n          }\n        });\n      };\n      const removeBlockQuoteOnBackSpace = () => {\n        editor.on('keydown', e => {\n          let rng, parent;\n          if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {\n            return;\n          }\n          rng = selection.getRng();\n          const container = rng.startContainer;\n          const offset = rng.startOffset;\n          const root = dom.getRoot();\n          parent = container;\n          if (!rng.collapsed || offset !== 0) {\n            return;\n          }\n          while (parent && parent.parentNode && parent.parentNode.firstChild === parent && parent.parentNode !== root) {\n            parent = parent.parentNode;\n          }\n          if (parent.tagName === 'BLOCKQUOTE') {\n            editor.formatter.toggle('blockquote', null, parent);\n            rng = dom.createRng();\n            rng.setStart(container, 0);\n            rng.setEnd(container, 0);\n            selection.setRng(rng);\n          }\n        });\n      };\n      const setGeckoEditingOptions = () => {\n        const setOpts = () => {\n          setEditorCommandState('StyleWithCSS', false);\n          setEditorCommandState('enableInlineTableEditing', false);\n          if (!getObjectResizing(editor)) {\n            setEditorCommandState('enableObjectResizing', false);\n          }\n        };\n        if (!isReadOnly$1(editor)) {\n          editor.on('BeforeExecCommand mousedown', setOpts);\n        }\n      };\n      const addBrAfterLastLinks = () => {\n        const fixLinks = () => {\n          each(dom.select('a'), node => {\n            let parentNode = node.parentNode;\n            const root = dom.getRoot();\n            if (parentNode.lastChild === node) {\n              while (parentNode && !dom.isBlock(parentNode)) {\n                if (parentNode.parentNode.lastChild !== parentNode || parentNode === root) {\n                  return;\n                }\n                parentNode = parentNode.parentNode;\n              }\n              dom.add(parentNode, 'br', { 'data-mce-bogus': 1 });\n            }\n          });\n        };\n        editor.on('SetContent ExecCommand', e => {\n          if (e.type === 'setcontent' || e.command === 'mceInsertLink') {\n            fixLinks();\n          }\n        });\n      };\n      const setDefaultBlockType = () => {\n        editor.on('init', () => {\n          setEditorCommandState('DefaultParagraphSeparator', getForcedRootBlock(editor));\n        });\n      };\n      const normalizeSelection = () => {\n        editor.on('keyup focusin mouseup', e => {\n          if (!VK.modifierPressed(e)) {\n            selection.normalize();\n          }\n        }, true);\n      };\n      const showBrokenImageIcon = () => {\n        editor.contentStyles.push('img:-moz-broken {' + '-moz-force-broken-image-icon:1;' + 'min-width:24px;' + 'min-height:24px' + '}');\n      };\n      const restoreFocusOnKeyDown = () => {\n        if (!editor.inline) {\n          editor.on('keydown', () => {\n            if (document.activeElement === document.body) {\n              editor.getWin().focus();\n            }\n          });\n        }\n      };\n      const bodyHeight = () => {\n        if (!editor.inline) {\n          editor.contentStyles.push('body {min-height: 150px}');\n          editor.on('click', e => {\n            let rng;\n            if (e.target.nodeName === 'HTML') {\n              rng = editor.selection.getRng();\n              editor.getBody().focus();\n              editor.selection.setRng(rng);\n              editor.selection.normalize();\n              editor.nodeChanged();\n            }\n          });\n        }\n      };\n      const blockCmdArrowNavigation = () => {\n        if (isMac) {\n          editor.on('keydown', e => {\n            if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {\n              e.preventDefault();\n              const selection = editor.selection.getSel();\n              selection.modify('move', e.keyCode === 37 ? 'backward' : 'forward', 'lineboundary');\n            }\n          });\n        }\n      };\n      const tapLinksAndImages = () => {\n        editor.on('click', e => {\n          let elm = e.target;\n          do {\n            if (elm.tagName === 'A') {\n              e.preventDefault();\n              return;\n            }\n          } while (elm = elm.parentNode);\n        });\n        editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');\n      };\n      const blockFormSubmitInsideEditor = () => {\n        editor.on('init', () => {\n          editor.dom.bind(editor.getBody(), 'submit', e => {\n            e.preventDefault();\n          });\n        });\n      };\n      const removeAppleInterchangeBrs = () => {\n        parser.addNodeFilter('br', nodes => {\n          let i = nodes.length;\n          while (i--) {\n            if (nodes[i].attr('class') === 'Apple-interchange-newline') {\n              nodes[i].remove();\n            }\n          }\n        });\n      };\n      const refreshContentEditable = noop;\n      const isHidden = () => {\n        if (!isGecko || editor.removed) {\n          return false;\n        }\n        const sel = editor.selection.getSel();\n        return !sel || !sel.rangeCount || sel.rangeCount === 0;\n      };\n      const setupRtc = () => {\n        if (isWebKit) {\n          documentElementEditingFocus();\n          selectControlElements();\n          blockFormSubmitInsideEditor();\n          selectAll();\n          if (isiOS) {\n            restoreFocusOnKeyDown();\n            bodyHeight();\n            tapLinksAndImages();\n          }\n        }\n        if (isGecko) {\n          focusBody();\n          setGeckoEditingOptions();\n          showBrokenImageIcon();\n          blockCmdArrowNavigation();\n        }\n      };\n      const setup = () => {\n        removeBlockQuoteOnBackSpace();\n        emptyEditorWhenDeleting();\n        if (!Env.windowsPhone) {\n          normalizeSelection();\n        }\n        if (isWebKit) {\n          documentElementEditingFocus();\n          selectControlElements();\n          setDefaultBlockType();\n          blockFormSubmitInsideEditor();\n          disableBackspaceIntoATable();\n          removeAppleInterchangeBrs();\n          if (isiOS) {\n            restoreFocusOnKeyDown();\n            bodyHeight();\n            tapLinksAndImages();\n          } else {\n            selectAll();\n          }\n        }\n        if (isGecko) {\n          removeHrOnBackspace();\n          focusBody();\n          removeStylesWhenDeletingAcrossBlockElements();\n          setGeckoEditingOptions();\n          addBrAfterLastLinks();\n          showBrokenImageIcon();\n          blockCmdArrowNavigation();\n          disableBackspaceIntoATable();\n        }\n      };\n      if (isRtc(editor)) {\n        setupRtc();\n      } else {\n        setup();\n      }\n      return {\n        refreshContentEditable,\n        isHidden\n      };\n    };\n\n    const DOM$6 = DOMUtils.DOM;\n    const appendStyle = (editor, text) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const container = getStyleContainer(getRootNode(body));\n      const style = SugarElement.fromTag('style');\n      set$2(style, 'type', 'text/css');\n      append$1(style, SugarElement.fromText(text));\n      append$1(container, style);\n      editor.on('remove', () => {\n        remove$5(style);\n      });\n    };\n    const getRootName = editor => editor.inline ? editor.getElement().nodeName.toLowerCase() : undefined;\n    const removeUndefined = obj => filter$5(obj, v => isUndefined(v) === false);\n    const mkParserSettings = editor => {\n      const getOption = editor.options.get;\n      const blobCache = editor.editorUpload.blobCache;\n      return removeUndefined({\n        allow_conditional_comments: getOption('allow_conditional_comments'),\n        allow_html_data_urls: getOption('allow_html_data_urls'),\n        allow_svg_data_urls: getOption('allow_svg_data_urls'),\n        allow_html_in_named_anchor: getOption('allow_html_in_named_anchor'),\n        allow_script_urls: getOption('allow_script_urls'),\n        allow_unsafe_link_target: getOption('allow_unsafe_link_target'),\n        convert_fonts_to_spans: getOption('convert_fonts_to_spans'),\n        fix_list_elements: getOption('fix_list_elements'),\n        font_size_legacy_values: getOption('font_size_legacy_values'),\n        forced_root_block: getOption('forced_root_block'),\n        forced_root_block_attrs: getOption('forced_root_block_attrs'),\n        preserve_cdata: getOption('preserve_cdata'),\n        remove_trailing_brs: getOption('remove_trailing_brs'),\n        inline_styles: getOption('inline_styles'),\n        root_name: getRootName(editor),\n        validate: true,\n        blob_cache: blobCache,\n        document: editor.getDoc()\n      });\n    };\n    const mkSchemaSettings = editor => {\n      const getOption = editor.options.get;\n      return removeUndefined({\n        custom_elements: getOption('custom_elements'),\n        extended_valid_elements: getOption('extended_valid_elements'),\n        invalid_elements: getOption('invalid_elements'),\n        invalid_styles: getOption('invalid_styles'),\n        schema: getOption('schema'),\n        valid_children: getOption('valid_children'),\n        valid_classes: getOption('valid_classes'),\n        valid_elements: getOption('valid_elements'),\n        valid_styles: getOption('valid_styles'),\n        verify_html: getOption('verify_html')\n      });\n    };\n    const mkSerializerSettings = editor => {\n      const getOption = editor.options.get;\n      return {\n        ...mkParserSettings(editor),\n        ...mkSchemaSettings(editor),\n        ...removeUndefined({\n          url_converter: getOption('url_converter'),\n          url_converter_scope: getOption('url_converter_scope'),\n          element_format: getOption('element_format'),\n          entities: getOption('entities'),\n          entity_encoding: getOption('entity_encoding'),\n          indent: getOption('indent'),\n          indent_after: getOption('indent_after'),\n          indent_before: getOption('indent_before')\n        })\n      };\n    };\n    const createParser = editor => {\n      const parser = DomParser(mkParserSettings(editor), editor.schema);\n      parser.addAttributeFilter('src,href,style,tabindex', (nodes, name) => {\n        let i = nodes.length, node, value;\n        const dom = editor.dom;\n        const internalName = 'data-mce-' + name;\n        while (i--) {\n          node = nodes[i];\n          value = node.attr(name);\n          if (value && !node.attr(internalName)) {\n            if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {\n              continue;\n            }\n            if (name === 'style') {\n              value = dom.serializeStyle(dom.parseStyle(value), node.name);\n              if (!value.length) {\n                value = null;\n              }\n              node.attr(internalName, value);\n              node.attr(name, value);\n            } else if (name === 'tabindex') {\n              node.attr(internalName, value);\n              node.attr(name, null);\n            } else {\n              node.attr(internalName, editor.convertURL(value, name, node.name));\n            }\n          }\n        }\n      });\n      parser.addNodeFilter('script', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          const type = node.attr('type') || 'no/type';\n          if (type.indexOf('mce-') !== 0) {\n            node.attr('type', 'mce-' + type);\n          }\n        }\n      });\n      if (editor.options.get('preserve_cdata')) {\n        parser.addNodeFilter('#cdata', nodes => {\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            node.type = 8;\n            node.name = '#comment';\n            node.value = '[CDATA[' + editor.dom.encode(node.value) + ']]';\n          }\n        });\n      }\n      parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', nodes => {\n        let i = nodes.length;\n        const nonEmptyElements = editor.schema.getNonEmptyElements();\n        while (i--) {\n          const node = nodes[i];\n          if (node.isEmpty(nonEmptyElements) && node.getAll('br').length === 0) {\n            node.append(new AstNode('br', 1));\n          }\n        }\n      });\n      return parser;\n    };\n    const autoFocus = editor => {\n      const autoFocus = getAutoFocus(editor);\n      if (autoFocus) {\n        Delay.setEditorTimeout(editor, () => {\n          let focusEditor;\n          if (autoFocus === true) {\n            focusEditor = editor;\n          } else {\n            focusEditor = editor.editorManager.get(autoFocus);\n          }\n          if (!focusEditor.destroyed) {\n            focusEditor.focus();\n          }\n        }, 100);\n      }\n    };\n    const moveSelectionToFirstCaretPosition = editor => {\n      const root = editor.dom.getRoot();\n      if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {\n        firstPositionIn(root).each(pos => {\n          const node = pos.getNode();\n          const caretPos = isTable$3(node) ? firstPositionIn(node).getOr(pos) : pos;\n          editor.selection.setRng(caretPos.toRange());\n        });\n      }\n    };\n    const initEditor = editor => {\n      editor.bindPendingEventDelegates();\n      editor.initialized = true;\n      fireInit(editor);\n      editor.focus(true);\n      moveSelectionToFirstCaretPosition(editor);\n      editor.nodeChanged({ initial: true });\n      const initInstanceCallback = getInitInstanceCallback(editor);\n      if (isFunction(initInstanceCallback)) {\n        initInstanceCallback.call(editor, editor);\n      }\n      autoFocus(editor);\n    };\n    const getStyleSheetLoader$1 = editor => editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;\n    const makeStylesheetLoadingPromises = (editor, css, framedFonts) => {\n      const promises = [getStyleSheetLoader$1(editor).loadAll(css)];\n      if (editor.inline) {\n        return promises;\n      } else {\n        return promises.concat([editor.ui.styleSheetLoader.loadAll(framedFonts)]);\n      }\n    };\n    const loadContentCss = editor => {\n      const styleSheetLoader = getStyleSheetLoader$1(editor);\n      const fontCss = getFontCss(editor);\n      const css = editor.contentCSS;\n      const removeCss = () => {\n        styleSheetLoader.unloadAll(css);\n        if (!editor.inline) {\n          editor.ui.styleSheetLoader.unloadAll(fontCss);\n        }\n      };\n      const loaded = () => {\n        if (editor.removed) {\n          removeCss();\n        } else {\n          editor.on('remove', removeCss);\n        }\n      };\n      if (editor.contentStyles.length > 0) {\n        let contentCssText = '';\n        Tools.each(editor.contentStyles, style => {\n          contentCssText += style + '\\r\\n';\n        });\n        editor.dom.addStyle(contentCssText);\n      }\n      const allStylesheets = Promise.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);\n      const contentStyle = getContentStyle(editor);\n      if (contentStyle) {\n        appendStyle(editor, contentStyle);\n      }\n      return allStylesheets;\n    };\n    const preInit = editor => {\n      const doc = editor.getDoc(), body = editor.getBody();\n      firePreInit(editor);\n      if (!shouldBrowserSpellcheck(editor)) {\n        doc.body.spellcheck = false;\n        DOM$6.setAttrib(body, 'spellcheck', 'false');\n      }\n      editor.quirks = Quirks(editor);\n      firePostRender(editor);\n      const directionality = getDirectionality(editor);\n      if (directionality !== undefined) {\n        body.dir = directionality;\n      }\n      const protect = getProtect(editor);\n      if (protect) {\n        editor.on('BeforeSetContent', e => {\n          Tools.each(protect, pattern => {\n            e.content = e.content.replace(pattern, str => {\n              return '<!--mce:protected ' + escape(str) + '-->';\n            });\n          });\n        });\n      }\n      editor.on('SetContent', () => {\n        editor.addVisual(editor.getBody());\n      });\n      editor.on('compositionstart compositionend', e => {\n        editor.composing = e.type === 'compositionstart';\n      });\n    };\n    const loadInitialContent = editor => {\n      if (!isRtc(editor)) {\n        editor.load({\n          initial: true,\n          format: 'html'\n        });\n      }\n      editor.startContent = editor.getContent({ format: 'raw' });\n    };\n    const initEditorWithInitialContent = editor => {\n      if (editor.removed !== true) {\n        loadInitialContent(editor);\n        initEditor(editor);\n      }\n    };\n    const contentBodyLoaded = editor => {\n      const targetElm = editor.getElement();\n      let doc = editor.getDoc();\n      if (editor.inline) {\n        DOM$6.addClass(targetElm, 'mce-content-body');\n        editor.contentDocument = doc = document;\n        editor.contentWindow = window;\n        editor.bodyElement = targetElm;\n        editor.contentAreaContainer = targetElm;\n      }\n      const body = editor.getBody();\n      body.disabled = true;\n      editor.readonly = isReadOnly$1(editor);\n      if (!editor.readonly) {\n        if (editor.inline && DOM$6.getStyle(body, 'position', true) === 'static') {\n          body.style.position = 'relative';\n        }\n        body.contentEditable = 'true';\n      }\n      body.disabled = false;\n      editor.editorUpload = EditorUpload(editor);\n      editor.schema = Schema(mkSchemaSettings(editor));\n      editor.dom = DOMUtils(doc, {\n        keep_values: true,\n        url_converter: editor.convertURL,\n        url_converter_scope: editor,\n        update_styles: true,\n        root_element: editor.inline ? editor.getBody() : null,\n        collect: () => editor.inline,\n        schema: editor.schema,\n        contentCssCors: shouldUseContentCssCors(editor),\n        referrerPolicy: getReferrerPolicy(editor),\n        onSetAttrib: e => {\n          editor.dispatch('SetAttrib', e);\n        }\n      });\n      editor.parser = createParser(editor);\n      editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);\n      editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);\n      editor.annotator = Annotator(editor);\n      editor.formatter = Formatter(editor);\n      editor.undoManager = UndoManager(editor);\n      editor._nodeChangeDispatcher = new NodeChange(editor);\n      editor._selectionOverrides = SelectionOverrides(editor);\n      setup$o(editor);\n      setup$6(editor);\n      setup$m(editor);\n      if (!isRtc(editor)) {\n        setup$5(editor);\n        setup$1(editor);\n      }\n      const caret = setup$b(editor);\n      setup$p(editor, caret);\n      setup$n(editor);\n      setup$q(editor);\n      setup$7(editor);\n      const setupRtcThunk = setup$s(editor);\n      preInit(editor);\n      setupRtcThunk.fold(() => {\n        loadContentCss(editor).then(() => initEditorWithInitialContent(editor));\n      }, setupRtc => {\n        editor.setProgressState(true);\n        loadContentCss(editor).then(() => {\n          setupRtc().then(_rtcMode => {\n            editor.setProgressState(false);\n            initEditorWithInitialContent(editor);\n            bindEvents(editor);\n          }, err => {\n            editor.notificationManager.open({\n              type: 'error',\n              text: String(err)\n            });\n            initEditorWithInitialContent(editor);\n            bindEvents(editor);\n          });\n        });\n      });\n    };\n    const initContentBody = (editor, skipWrite) => {\n      if (!editor.inline) {\n        editor.getElement().style.visibility = editor.orgVisibility;\n      }\n      if (!skipWrite && !editor.inline) {\n        const iframe = editor.iframeElement;\n        const binder = bind$1(SugarElement.fromDom(iframe), 'load', () => {\n          binder.unbind();\n          editor.contentDocument = iframe.contentDocument;\n          contentBodyLoaded(editor);\n        });\n        iframe.srcdoc = editor.iframeHTML;\n      } else {\n        contentBodyLoaded(editor);\n      }\n    };\n\n    const DOM$5 = DOMUtils.DOM;\n    const createIframeElement = (id, title, customAttrs, tabindex) => {\n      const iframe = SugarElement.fromTag('iframe');\n      tabindex.each(t => set$2(iframe, 'tabindex', t));\n      setAll$1(iframe, customAttrs);\n      setAll$1(iframe, {\n        id: id + '_ifr',\n        frameBorder: '0',\n        allowTransparency: 'true',\n        title\n      });\n      add$2(iframe, 'tox-edit-area__iframe');\n      return iframe;\n    };\n    const getIframeHtml = editor => {\n      let iframeHTML = getDocType(editor) + '<html><head>';\n      if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {\n        iframeHTML += '<base href=\"' + editor.documentBaseURI.getURI() + '\" />';\n      }\n      iframeHTML += '<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />';\n      const bodyId = getBodyId(editor);\n      const bodyClass = getBodyClass(editor);\n      const translatedAriaText = editor.translate(getIframeAriaText(editor));\n      if (getContentSecurityPolicy(editor)) {\n        iframeHTML += '<meta http-equiv=\"Content-Security-Policy\" content=\"' + getContentSecurityPolicy(editor) + '\" />';\n      }\n      iframeHTML += '</head>' + `<body id=\"${ bodyId }\" class=\"mce-content-body ${ bodyClass }\" data-id=\"${ editor.id }\" aria-label=\"${ translatedAriaText }\">` + '<br>' + '</body></html>';\n      return iframeHTML;\n    };\n    const createIframe = (editor, boxInfo) => {\n      const iframeTitle = editor.translate('Rich Text Area');\n      const tabindex = getOpt(SugarElement.fromDom(editor.getElement()), 'tabindex').bind(toInt);\n      const ifr = createIframeElement(editor.id, iframeTitle, getIframeAttrs(editor), tabindex).dom;\n      ifr.onload = () => {\n        ifr.onload = null;\n        editor.dispatch('load');\n      };\n      editor.contentAreaContainer = boxInfo.iframeContainer;\n      editor.iframeElement = ifr;\n      editor.iframeHTML = getIframeHtml(editor);\n      DOM$5.add(boxInfo.iframeContainer, ifr);\n    };\n    const init$1 = (editor, boxInfo) => {\n      createIframe(editor, boxInfo);\n      if (boxInfo.editorContainer) {\n        DOM$5.get(boxInfo.editorContainer).style.display = editor.orgDisplay;\n        editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);\n      }\n      editor.getElement().style.display = 'none';\n      DOM$5.setAttrib(editor.id, 'aria-hidden', 'true');\n      initContentBody(editor);\n    };\n\n    const DOM$4 = DOMUtils.DOM;\n    const initPlugin = (editor, initializedPlugins, plugin) => {\n      const Plugin = PluginManager.get(plugin);\n      const pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\\/$/, '');\n      plugin = Tools.trim(plugin);\n      if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {\n        if (editor.plugins[plugin]) {\n          return;\n        }\n        try {\n          const pluginInstance = Plugin(editor, pluginUrl) || {};\n          editor.plugins[plugin] = pluginInstance;\n          if (isFunction(pluginInstance.init)) {\n            pluginInstance.init(editor, pluginUrl);\n            initializedPlugins.push(plugin);\n          }\n        } catch (e) {\n          pluginInitError(editor, plugin, e);\n        }\n      }\n    };\n    const trimLegacyPrefix = name => {\n      return name.replace(/^\\-/, '');\n    };\n    const initPlugins = editor => {\n      const initializedPlugins = [];\n      each$g(getPlugins(editor), name => {\n        initPlugin(editor, initializedPlugins, trimLegacyPrefix(name));\n      });\n    };\n    const initIcons = editor => {\n      const iconPackName = Tools.trim(getIconPackName(editor));\n      const currentIcons = editor.ui.registry.getAll().icons;\n      const loadIcons = {\n        ...IconManager.get('default').icons,\n        ...IconManager.get(iconPackName).icons\n      };\n      each$f(loadIcons, (svgData, icon) => {\n        if (!has$2(currentIcons, icon)) {\n          editor.ui.registry.addIcon(icon, svgData);\n        }\n      });\n    };\n    const initTheme = editor => {\n      const theme = getTheme(editor);\n      if (isString(theme)) {\n        const Theme = ThemeManager.get(theme);\n        editor.theme = Theme(editor, ThemeManager.urls[theme]) || {};\n        if (isFunction(editor.theme.init)) {\n          editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\\/$/, ''));\n        }\n      } else {\n        editor.theme = {};\n      }\n    };\n    const initModel = editor => {\n      const model = getModel(editor);\n      const Model = ModelManager.get(model);\n      editor.model = Model(editor, ModelManager.urls[model]);\n    };\n    const renderFromLoadedTheme = editor => {\n      return editor.theme.renderUI();\n    };\n    const renderFromThemeFunc = editor => {\n      const elm = editor.getElement();\n      const theme = getTheme(editor);\n      const info = theme(editor, elm);\n      if (info.editorContainer.nodeType) {\n        info.editorContainer.id = info.editorContainer.id || editor.id + '_parent';\n      }\n      if (info.iframeContainer && info.iframeContainer.nodeType) {\n        info.iframeContainer.id = info.iframeContainer.id || editor.id + '_iframecontainer';\n      }\n      info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;\n      return info;\n    };\n    const createThemeFalseResult = element => {\n      return {\n        editorContainer: element,\n        iframeContainer: element,\n        api: {}\n      };\n    };\n    const renderThemeFalseIframe = targetElement => {\n      const iframeContainer = DOM$4.create('div');\n      DOM$4.insertAfter(iframeContainer, targetElement);\n      return createThemeFalseResult(iframeContainer);\n    };\n    const renderThemeFalse = editor => {\n      const targetElement = editor.getElement();\n      return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);\n    };\n    const renderThemeUi = editor => {\n      const elm = editor.getElement();\n      editor.orgDisplay = elm.style.display;\n      if (isString(getTheme(editor))) {\n        return renderFromLoadedTheme(editor);\n      } else if (isFunction(getTheme(editor))) {\n        return renderFromThemeFunc(editor);\n      } else {\n        return renderThemeFalse(editor);\n      }\n    };\n    const augmentEditorUiApi = (editor, api) => {\n      const uiApiFacade = {\n        show: Optional.from(api.show).getOr(noop),\n        hide: Optional.from(api.hide).getOr(noop),\n        isEnabled: Optional.from(api.isEnabled).getOr(always),\n        setEnabled: state => {\n          if (!editor.mode.isReadOnly()) {\n            Optional.from(api.setEnabled).each(f => f(state));\n          }\n        }\n      };\n      editor.ui = {\n        ...editor.ui,\n        ...uiApiFacade\n      };\n    };\n    const init = editor => {\n      editor.dispatch('ScriptsLoaded');\n      initIcons(editor);\n      initTheme(editor);\n      initModel(editor);\n      initPlugins(editor);\n      const renderInfo = renderThemeUi(editor);\n      augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));\n      const boxInfo = {\n        editorContainer: renderInfo.editorContainer,\n        iframeContainer: renderInfo.iframeContainer\n      };\n      editor.editorContainer = boxInfo.editorContainer ? boxInfo.editorContainer : null;\n      appendContentCssFromSettings(editor);\n      if (editor.inline) {\n        return initContentBody(editor);\n      } else {\n        return init$1(editor, boxInfo);\n      }\n    };\n\n    const DOM$3 = DOMUtils.DOM;\n    const hasSkipLoadPrefix = name => name.charAt(0) === '-';\n    const loadLanguage = (scriptLoader, editor) => {\n      const languageCode = getLanguageCode(editor);\n      const languageUrl = getLanguageUrl(editor);\n      if (I18n.hasCode(languageCode) === false && languageCode !== 'en') {\n        const url = isNotEmpty(languageUrl) ? languageUrl : `${ editor.editorManager.baseURL }/langs/${ languageCode }.js`;\n        scriptLoader.add(url).catch(() => {\n          languageLoadError(editor, url, languageCode);\n        });\n      }\n    };\n    const loadTheme = (editor, suffix) => {\n      const theme = getTheme(editor);\n      if (isString(theme) && !hasSkipLoadPrefix(theme) && !has$2(ThemeManager.urls, theme)) {\n        const themeUrl = getThemeUrl(editor);\n        const url = themeUrl ? editor.documentBaseURI.toAbsolute(themeUrl) : `themes/${ theme }/theme${ suffix }.js`;\n        ThemeManager.load(theme, url).catch(() => {\n          themeLoadError(editor, url, theme);\n        });\n      }\n    };\n    const loadModel = (editor, suffix) => {\n      const model = getModel(editor);\n      if (model !== 'plugin' && !has$2(ModelManager.urls, model)) {\n        const modelUrl = getModelUrl(editor);\n        const url = isString(modelUrl) ? editor.documentBaseURI.toAbsolute(modelUrl) : `models/${ model }/model${ suffix }.js`;\n        ModelManager.load(model, url).catch(() => {\n          modelLoadError(editor, url, model);\n        });\n      }\n    };\n    const getIconsUrlMetaFromUrl = editor => Optional.from(getIconsUrl(editor)).filter(isNotEmpty).map(url => ({\n      url,\n      name: Optional.none()\n    }));\n    const getIconsUrlMetaFromName = (editor, name, suffix) => Optional.from(name).filter(name => isNotEmpty(name) && !IconManager.has(name)).map(name => ({\n      url: `${ editor.editorManager.baseURL }/icons/${ name }/icons${ suffix }.js`,\n      name: Optional.some(name)\n    }));\n    const loadIcons = (scriptLoader, editor, suffix) => {\n      const defaultIconsUrl = getIconsUrlMetaFromName(editor, 'default', suffix);\n      const customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(() => getIconsUrlMetaFromName(editor, getIconPackName(editor), ''));\n      each$g(cat([\n        defaultIconsUrl,\n        customIconsUrl\n      ]), urlMeta => {\n        scriptLoader.add(urlMeta.url).catch(() => {\n          iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());\n        });\n      });\n    };\n    const loadPlugins = (editor, suffix) => {\n      const loadPlugin = (name, url) => {\n        PluginManager.load(name, url).catch(() => {\n          pluginLoadError(editor, url, name);\n        });\n      };\n      each$f(getExternalPlugins$1(editor), (url, name) => {\n        loadPlugin(name, url);\n        editor.options.set('plugins', getPlugins(editor).concat(name));\n      });\n      each$g(getPlugins(editor), plugin => {\n        plugin = Tools.trim(plugin);\n        if (plugin && !PluginManager.urls[plugin] && !hasSkipLoadPrefix(plugin)) {\n          loadPlugin(plugin, `plugins/${ plugin }/plugin${ suffix }.js`);\n        }\n      });\n    };\n    const isThemeLoaded = editor => {\n      const theme = getTheme(editor);\n      return !isString(theme) || isNonNullable(ThemeManager.get(theme));\n    };\n    const isModelLoaded = editor => {\n      const model = getModel(editor);\n      return isNonNullable(ModelManager.get(model));\n    };\n    const loadScripts = (editor, suffix) => {\n      const scriptLoader = ScriptLoader.ScriptLoader;\n      const initEditor = () => {\n        if (!editor.removed && isThemeLoaded(editor) && isModelLoaded(editor)) {\n          init(editor);\n        }\n      };\n      loadTheme(editor, suffix);\n      loadModel(editor, suffix);\n      loadLanguage(scriptLoader, editor);\n      loadIcons(scriptLoader, editor, suffix);\n      loadPlugins(editor, suffix);\n      scriptLoader.loadQueue().then(initEditor, initEditor);\n    };\n    const getStyleSheetLoader = (element, editor) => instance.forElement(element, {\n      contentCssCors: hasContentCssCors(editor),\n      referrerPolicy: getReferrerPolicy(editor)\n    });\n    const render = editor => {\n      const id = editor.id;\n      I18n.setCode(getLanguageCode(editor));\n      const readyHandler = () => {\n        DOM$3.unbind(window, 'ready', readyHandler);\n        editor.render();\n      };\n      if (!EventUtils.Event.domLoaded) {\n        DOM$3.bind(window, 'ready', readyHandler);\n        return;\n      }\n      if (!editor.getElement()) {\n        return;\n      }\n      const element = SugarElement.fromDom(editor.getElement());\n      const snapshot = clone$4(element);\n      editor.on('remove', () => {\n        eachr(element.dom.attributes, attr => remove$a(element, attr.name));\n        setAll$1(element, snapshot);\n      });\n      editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);\n      if (!isInline(editor)) {\n        editor.orgVisibility = editor.getElement().style.visibility;\n        editor.getElement().style.visibility = 'hidden';\n      } else {\n        editor.inline = true;\n      }\n      const form = editor.getElement().form || DOM$3.getParent(id, 'form');\n      if (form) {\n        editor.formElement = form;\n        if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {\n          DOM$3.insertAfter(DOM$3.create('input', {\n            type: 'hidden',\n            name: id\n          }), id);\n          editor.hasHiddenInput = true;\n        }\n        editor.formEventDelegate = e => {\n          editor.dispatch(e.type, e);\n        };\n        DOM$3.bind(form, 'submit reset', editor.formEventDelegate);\n        editor.on('reset', () => {\n          editor.resetContent();\n        });\n        if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {\n          form._mceOldSubmit = form.submit;\n          form.submit = () => {\n            editor.editorManager.triggerSave();\n            editor.setDirty(false);\n            return form._mceOldSubmit(form);\n          };\n        }\n      }\n      editor.windowManager = WindowManager(editor);\n      editor.notificationManager = NotificationManager(editor);\n      if (isEncodingXml(editor)) {\n        editor.on('GetContent', e => {\n          if (e.save) {\n            e.content = DOM$3.encode(e.content);\n          }\n        });\n      }\n      if (shouldAddFormSubmitTrigger(editor)) {\n        editor.on('submit', () => {\n          if (editor.initialized) {\n            editor.save();\n          }\n        });\n      }\n      if (shouldAddUnloadTrigger(editor)) {\n        editor._beforeUnload = () => {\n          if (editor.initialized && !editor.destroyed && !editor.isHidden()) {\n            editor.save({\n              format: 'raw',\n              no_events: true,\n              set_dirty: false\n            });\n          }\n        };\n        editor.editorManager.on('BeforeUnload', editor._beforeUnload);\n      }\n      editor.editorManager.add(editor);\n      loadScripts(editor, editor.suffix);\n    };\n\n    const sectionResult = (sections, settings) => ({\n      sections: constant(sections),\n      options: constant(settings)\n    });\n    const deviceDetection = detect$2().deviceType;\n    const isPhone = deviceDetection.isPhone();\n    const isTablet = deviceDetection.isTablet();\n    const normalizePlugins = plugins => {\n      if (isNullable(plugins)) {\n        return [];\n      } else {\n        const pluginNames = isArray$1(plugins) ? plugins : plugins.split(/[ ,]/);\n        const trimmedPlugins = map$3(pluginNames, trim$3);\n        return filter$6(trimmedPlugins, isNotEmpty);\n      }\n    };\n    const extractSections = (keys, options) => {\n      const result = bifilter(options, (value, key) => {\n        return contains$2(keys, key);\n      });\n      return sectionResult(result.t, result.f);\n    };\n    const getSection = (sectionResult, name, defaults = {}) => {\n      const sections = sectionResult.sections();\n      const sectionOptions = get$a(sections, name).getOr({});\n      return Tools.extend({}, defaults, sectionOptions);\n    };\n    const hasSection = (sectionResult, name) => {\n      return has$2(sectionResult.sections(), name);\n    };\n    const getSectionConfig = (sectionResult, name) => {\n      return hasSection(sectionResult, name) ? sectionResult.sections()[name] : {};\n    };\n    const getMobileOverrideOptions = (mobileOptions, isPhone) => {\n      const defaultMobileOptions = {\n        table_grid: false,\n        object_resizing: false,\n        resize: false,\n        toolbar_mode: get$a(mobileOptions, 'toolbar_mode').getOr('scrolling'),\n        toolbar_sticky: false\n      };\n      const defaultPhoneOptions = { menubar: false };\n      return {\n        ...defaultMobileOptions,\n        ...isPhone ? defaultPhoneOptions : {}\n      };\n    };\n    const getExternalPlugins = (overrideOptions, options) => {\n      var _a;\n      const userDefinedExternalPlugins = (_a = options.external_plugins) !== null && _a !== void 0 ? _a : {};\n      if (overrideOptions && overrideOptions.external_plugins) {\n        return Tools.extend({}, overrideOptions.external_plugins, userDefinedExternalPlugins);\n      } else {\n        return userDefinedExternalPlugins;\n      }\n    };\n    const combinePlugins = (forcedPlugins, plugins) => {\n      return [].concat(normalizePlugins(forcedPlugins)).concat(normalizePlugins(plugins));\n    };\n    const getPlatformPlugins = (isMobileDevice, sectionResult, desktopPlugins, mobilePlugins) => {\n      if (isMobileDevice && hasSection(sectionResult, 'mobile')) {\n        return mobilePlugins;\n      } else {\n        return desktopPlugins;\n      }\n    };\n    const processPlugins = (isMobileDevice, sectionResult, defaultOverrideOptions, options) => {\n      const forcedPlugins = normalizePlugins(defaultOverrideOptions.forced_plugins);\n      const desktopPlugins = normalizePlugins(options.plugins);\n      const mobileConfig = getSectionConfig(sectionResult, 'mobile');\n      const mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;\n      const platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult, desktopPlugins, mobilePlugins);\n      const combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);\n      return Tools.extend(options, {\n        forced_plugins: forcedPlugins,\n        plugins: combinedPlugins\n      });\n    };\n    const isOnMobile = (isMobileDevice, sectionResult) => {\n      return isMobileDevice && hasSection(sectionResult, 'mobile');\n    };\n    const combineOptions = (isMobileDevice, isPhone, defaultOptions, defaultOverrideOptions, options) => {\n      var _a;\n      const deviceOverrideOptions = isMobileDevice ? { mobile: getMobileOverrideOptions((_a = options.mobile) !== null && _a !== void 0 ? _a : {}, isPhone) } : {};\n      const sectionResult = extractSections(['mobile'], deepMerge(deviceOverrideOptions, options));\n      const extendedOptions = Tools.extend(defaultOptions, defaultOverrideOptions, sectionResult.options(), isOnMobile(isMobileDevice, sectionResult) ? getSection(sectionResult, 'mobile') : {}, { external_plugins: getExternalPlugins(defaultOverrideOptions, sectionResult.options()) });\n      return processPlugins(isMobileDevice, sectionResult, defaultOverrideOptions, extendedOptions);\n    };\n    const normalizeOptions = (defaultOverrideOptions, options) => combineOptions(isPhone || isTablet, isPhone, options, defaultOverrideOptions, options);\n\n    const addVisual = (editor, elm) => addVisual$1(editor, elm);\n\n    const registerExecCommands$3 = editor => {\n      const toggleFormat = (name, value) => {\n        editor.formatter.toggle(name, value);\n        editor.nodeChanged();\n      };\n      const toggleAlign = align => () => {\n        each$g('left,center,right,justify'.split(','), name => {\n          if (align !== name) {\n            editor.formatter.remove('align' + name);\n          }\n        });\n        if (align !== 'none') {\n          toggleFormat('align' + align);\n        }\n      };\n      editor.editorCommands.addCommands({\n        JustifyLeft: toggleAlign('left'),\n        JustifyCenter: toggleAlign('center'),\n        JustifyRight: toggleAlign('right'),\n        JustifyFull: toggleAlign('justify'),\n        JustifyNone: toggleAlign('none')\n      });\n    };\n    const registerQueryStateCommands$1 = editor => {\n      const alignStates = name => () => {\n        const selection = editor.selection;\n        const nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();\n        return exists(nodes, node => isNonNullable(editor.formatter.matchNode(node, name)));\n      };\n      editor.editorCommands.addCommands({\n        JustifyLeft: alignStates('alignleft'),\n        JustifyCenter: alignStates('aligncenter'),\n        JustifyRight: alignStates('alignright'),\n        JustifyFull: alignStates('alignjustify')\n      }, 'state');\n    };\n    const registerCommands$a = editor => {\n      registerExecCommands$3(editor);\n      registerQueryStateCommands$1(editor);\n    };\n\n    const registerCommands$9 = editor => {\n      editor.editorCommands.addCommands({\n        'Cut,Copy,Paste': command => {\n          const doc = editor.getDoc();\n          let failed;\n          try {\n            doc.execCommand(command);\n          } catch (ex) {\n            failed = true;\n          }\n          if (command === 'paste' && !doc.queryCommandEnabled(command)) {\n            failed = true;\n          }\n          if (failed || !doc.queryCommandSupported(command)) {\n            let msg = editor.translate(`Your browser doesn't support direct access to the clipboard. ` + 'Please use the Ctrl+X/C/V keyboard shortcuts instead.');\n            if (Env.os.isMacOS() || Env.os.isiOS()) {\n              msg = msg.replace(/Ctrl\\+/g, '\\u2318+');\n            }\n            editor.notificationManager.open({\n              text: msg,\n              type: 'error'\n            });\n          }\n        }\n      });\n    };\n\n    const trimOrPadLeftRight = (dom, rng, html) => {\n      const root = SugarElement.fromDom(dom.getRoot());\n      if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng))) {\n        html = html.replace(/^ /, '&nbsp;');\n      } else {\n        html = html.replace(/^&nbsp;/, ' ');\n      }\n      if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng))) {\n        html = html.replace(/(&nbsp;| )(<br( \\/)>)?$/, '&nbsp;');\n      } else {\n        html = html.replace(/&nbsp;(<br( \\/)?>)?$/, ' ');\n      }\n      return html;\n    };\n\n    const processValue$1 = value => {\n      if (typeof value !== 'string') {\n        const details = Tools.extend({\n          paste: value.paste,\n          data: { paste: value.paste }\n        }, value);\n        return {\n          content: value.content,\n          details\n        };\n      }\n      return {\n        content: value,\n        details: {}\n      };\n    };\n    const trimOrPad = (editor, value) => {\n      const selection = editor.selection;\n      const dom = editor.dom;\n      if (/^ | $/.test(value)) {\n        return trimOrPadLeftRight(dom, selection.getRng(), value);\n      } else {\n        return value;\n      }\n    };\n    const insertAtCaret = (editor, value) => {\n      const {content, details} = processValue$1(value);\n      preProcessSetContent(editor, {\n        content: trimOrPad(editor, content),\n        format: 'html',\n        set: false,\n        selection: true,\n        paste: details.paste\n      }).each(args => {\n        const insertedContent = insertContent$1(editor, args.content, details);\n        postProcessSetContent(editor, insertedContent, args);\n        editor.addVisual();\n      });\n    };\n\n    const registerCommands$8 = editor => {\n      editor.editorCommands.addCommands({\n        mceCleanup: () => {\n          const bm = editor.selection.getBookmark();\n          editor.setContent(editor.getContent());\n          editor.selection.moveToBookmark(bm);\n        },\n        insertImage: (_command, _ui, value) => {\n          insertAtCaret(editor, editor.dom.createHTML('img', { src: value }));\n        },\n        insertHorizontalRule: () => {\n          editor.execCommand('mceInsertContent', false, '<hr>');\n        },\n        insertText: (_command, _ui, value) => {\n          insertAtCaret(editor, editor.dom.encode(value));\n        },\n        insertHTML: (_command, _ui, value) => {\n          insertAtCaret(editor, value);\n        },\n        mceInsertContent: (_command, _ui, value) => {\n          insertAtCaret(editor, value);\n        },\n        mceSetContent: (_command, _ui, value) => {\n          editor.setContent(value);\n        },\n        mceReplaceContent: (_command, _ui, value) => {\n          editor.execCommand('mceInsertContent', false, value.replace(/\\{\\$selection\\}/g, editor.selection.getContent({ format: 'text' })));\n        },\n        mceNewDocument: () => {\n          editor.setContent('');\n        }\n      });\n    };\n\n    const legacyPropNames = {\n      'font-size': 'size',\n      'font-family': 'face'\n    };\n    const getSpecifiedFontProp = (propName, rootElm, elm) => {\n      const getProperty = elm => getRaw$1(elm, propName).orThunk(() => {\n        if (name(elm) === 'font') {\n          return get$a(legacyPropNames, propName).bind(legacyPropName => getOpt(elm, legacyPropName));\n        } else {\n          return Optional.none();\n        }\n      });\n      const isRoot = elm => eq(SugarElement.fromDom(rootElm), elm);\n      return closest$2(SugarElement.fromDom(elm), elm => getProperty(elm), isRoot);\n    };\n    const normalizeFontFamily = fontFamily => fontFamily.replace(/[\\'\\\"\\\\]/g, '').replace(/,\\s+/g, ',');\n    const getComputedFontProp = (propName, elm) => Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));\n    const getFontProp = propName => (rootElm, elm) => Optional.from(elm).map(SugarElement.fromDom).filter(isElement$7).bind(element => getSpecifiedFontProp(propName, rootElm, element.dom).or(getComputedFontProp(propName, element.dom))).getOr('');\n    const getFontSize = getFontProp('font-size');\n    const getFontFamily = compose(normalizeFontFamily, getFontProp('font-family'));\n\n    const findFirstCaretElement = editor => firstPositionIn(editor.getBody()).map(caret => {\n      const container = caret.container();\n      return isText$8(container) ? container.parentNode : container;\n    });\n    const getCaretElement = editor => Optional.from(editor.selection.getRng()).bind(rng => {\n      const root = editor.getBody();\n      const atStartOfNode = rng.startContainer === root && rng.startOffset === 0;\n      return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));\n    });\n    const bindRange = (editor, binder) => getCaretElement(editor).orThunk(curry(findFirstCaretElement, editor)).map(SugarElement.fromDom).filter(isElement$7).bind(binder);\n    const mapRange = (editor, mapper) => bindRange(editor, compose1(Optional.some, mapper));\n\n    const fromFontSizeNumber = (editor, value) => {\n      if (/^[0-9.]+$/.test(value)) {\n        const fontSizeNumber = parseInt(value, 10);\n        if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {\n          const fontSizes = getFontStyleValues(editor);\n          const fontClasses = getFontSizeClasses(editor);\n          if (fontClasses) {\n            return fontClasses[fontSizeNumber - 1] || value;\n          } else {\n            return fontSizes[fontSizeNumber - 1] || value;\n          }\n        } else {\n          return value;\n        }\n      } else {\n        return value;\n      }\n    };\n    const normalizeFontNames = font => {\n      const fonts = font.split(/\\s*,\\s*/);\n      return map$3(fonts, font => {\n        if (font.indexOf(' ') !== -1 && !(startsWith(font, '\"') || startsWith(font, `'`))) {\n          return `'${ font }'`;\n        } else {\n          return font;\n        }\n      }).join(',');\n    };\n    const fontNameAction = (editor, value) => {\n      const font = fromFontSizeNumber(editor, value);\n      editor.formatter.toggle('fontname', { value: normalizeFontNames(font) });\n      editor.nodeChanged();\n    };\n    const fontNameQuery = editor => mapRange(editor, elm => getFontFamily(editor.getBody(), elm.dom)).getOr('');\n    const fontSizeAction = (editor, value) => {\n      editor.formatter.toggle('fontsize', { value: fromFontSizeNumber(editor, value) });\n      editor.nodeChanged();\n    };\n    const fontSizeQuery = editor => mapRange(editor, elm => getFontSize(editor.getBody(), elm.dom)).getOr('');\n\n    const lineHeightQuery = editor => mapRange(editor, elm => {\n      const root = SugarElement.fromDom(editor.getBody());\n      const specifiedStyle = closest$2(elm, elm => getRaw$1(elm, 'line-height'), curry(eq, root));\n      const computedStyle = () => {\n        const lineHeight = parseFloat(get$7(elm, 'line-height'));\n        const fontSize = parseFloat(get$7(elm, 'font-size'));\n        return String(lineHeight / fontSize);\n      };\n      return specifiedStyle.getOrThunk(computedStyle);\n    }).getOr('');\n    const lineHeightAction = (editor, lineHeight) => {\n      editor.formatter.toggle('lineheight', { value: String(lineHeight) });\n      editor.nodeChanged();\n    };\n\n    const registerExecCommands$2 = editor => {\n      const toggleFormat = (name, value) => {\n        editor.formatter.toggle(name, value);\n        editor.nodeChanged();\n      };\n      editor.editorCommands.addCommands({\n        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => {\n          toggleFormat(command);\n        },\n        'ForeColor,HiliteColor': (command, _ui, value) => {\n          toggleFormat(command, { value });\n        },\n        'BackColor': (_command, _ui, value) => {\n          toggleFormat('hilitecolor', { value });\n        },\n        'FontName': (_command, _ui, value) => {\n          fontNameAction(editor, value);\n        },\n        'FontSize': (_command, _ui, value) => {\n          fontSizeAction(editor, value);\n        },\n        'LineHeight': (_command, _ui, value) => {\n          lineHeightAction(editor, value);\n        },\n        'Lang': (command, _ui, lang) => {\n          toggleFormat(command, {\n            value: lang.code,\n            customValue: lang.customCode\n          });\n        },\n        'RemoveFormat': command => {\n          editor.formatter.remove(command);\n        },\n        'mceBlockQuote': () => {\n          toggleFormat('blockquote');\n        },\n        'FormatBlock': (_command, _ui, value) => {\n          toggleFormat(isString(value) ? value : 'p');\n        },\n        'mceToggleFormat': (_command, _ui, value) => {\n          toggleFormat(value);\n        }\n      });\n    };\n    const registerQueryValueCommands = editor => {\n      const isFormatMatch = name => editor.formatter.match(name);\n      editor.editorCommands.addCommands({\n        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => isFormatMatch(command),\n        'mceBlockQuote': () => isFormatMatch('blockquote')\n      }, 'state');\n      editor.editorCommands.addQueryValueHandler('FontName', () => fontNameQuery(editor));\n      editor.editorCommands.addQueryValueHandler('FontSize', () => fontSizeQuery(editor));\n      editor.editorCommands.addQueryValueHandler('LineHeight', () => lineHeightQuery(editor));\n    };\n    const registerCommands$7 = editor => {\n      registerExecCommands$2(editor);\n      registerQueryValueCommands(editor);\n    };\n\n    const registerCommands$6 = editor => {\n      editor.editorCommands.addCommands({\n        mceAddUndoLevel: () => {\n          editor.undoManager.add();\n        },\n        mceEndUndoLevel: () => {\n          editor.undoManager.add();\n        },\n        Undo: () => {\n          editor.undoManager.undo();\n        },\n        Redo: () => {\n          editor.undoManager.redo();\n        }\n      });\n    };\n\n    const registerCommands$5 = editor => {\n      editor.editorCommands.addCommands({\n        Indent: () => {\n          indent(editor);\n        },\n        Outdent: () => {\n          outdent(editor);\n        }\n      });\n      editor.editorCommands.addCommands({ Outdent: () => canOutdent(editor) }, 'state');\n    };\n\n    const registerCommands$4 = editor => {\n      const applyLinkToSelection = (_command, _ui, value) => {\n        const linkDetails = isString(value) ? { href: value } : value;\n        const anchor = editor.dom.getParent(editor.selection.getNode(), 'a');\n        if (isObject(linkDetails) && isString(linkDetails.href)) {\n          linkDetails.href = linkDetails.href.replace(/ /g, '%20');\n          if (!anchor || !linkDetails.href) {\n            editor.formatter.remove('link');\n          }\n          if (linkDetails.href) {\n            editor.formatter.apply('link', linkDetails, anchor);\n          }\n        }\n      };\n      editor.editorCommands.addCommands({\n        unlink: () => {\n          if (editor.selection.isCollapsed()) {\n            const elm = editor.dom.getParent(editor.selection.getStart(), 'a');\n            if (elm) {\n              editor.dom.remove(elm, true);\n            }\n            return;\n          }\n          editor.formatter.remove('link');\n        },\n        mceInsertLink: applyLinkToSelection,\n        createLink: applyLinkToSelection\n      });\n    };\n\n    const registerExecCommands$1 = editor => {\n      editor.editorCommands.addCommands({\n        'InsertUnorderedList,InsertOrderedList': command => {\n          editor.getDoc().execCommand(command);\n          const listElm = editor.dom.getParent(editor.selection.getNode(), 'ol,ul');\n          if (listElm) {\n            const listParent = listElm.parentNode;\n            if (/^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {\n              const bm = editor.selection.getBookmark();\n              editor.dom.split(listParent, listElm);\n              editor.selection.moveToBookmark(bm);\n            }\n          }\n        }\n      });\n    };\n    const registerQueryStateCommands = editor => {\n      editor.editorCommands.addCommands({\n        'InsertUnorderedList,InsertOrderedList': command => {\n          const list = editor.dom.getParent(editor.selection.getNode(), 'ul,ol');\n          return list && (command === 'insertunorderedlist' && list.tagName === 'UL' || command === 'insertorderedlist' && list.tagName === 'OL');\n        }\n      }, 'state');\n    };\n    const registerCommands$3 = editor => {\n      registerExecCommands$1(editor);\n      registerQueryStateCommands(editor);\n    };\n\n    const registerCommands$2 = editor => {\n      editor.editorCommands.addCommands({\n        insertParagraph: () => {\n          insert(editor);\n        },\n        mceInsertNewLine: (_command, _ui, value) => {\n          insert(editor, value);\n        },\n        InsertLineBreak: (_command, _ui, value) => {\n          insert$1(editor, value);\n        }\n      });\n    };\n\n    const registerCommands$1 = editor => {\n      editor.editorCommands.addCommands({\n        mceSelectNodeDepth: (_command, _ui, value) => {\n          let counter = 0;\n          editor.dom.getParent(editor.selection.getNode(), node => {\n            if (node.nodeType === 1 && counter++ === value) {\n              editor.selection.select(node);\n              return false;\n            }\n          }, editor.getBody());\n        },\n        mceSelectNode: (_command, _ui, value) => {\n          editor.selection.select(value);\n        },\n        selectAll: () => {\n          const editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue$4);\n          if (editingHost) {\n            const rng = editor.dom.createRng();\n            rng.selectNodeContents(editingHost);\n            editor.selection.setRng(rng);\n          }\n        }\n      });\n    };\n\n    const registerExecCommands = editor => {\n      editor.editorCommands.addCommands({\n        mceRemoveNode: (_command, _ui, value) => {\n          const node = value !== null && value !== void 0 ? value : editor.selection.getNode();\n          if (node !== editor.getBody()) {\n            const bm = editor.selection.getBookmark();\n            editor.dom.remove(node, true);\n            editor.selection.moveToBookmark(bm);\n          }\n        },\n        mcePrint: () => {\n          editor.getWin().print();\n        },\n        mceFocus: (_command, _ui, value) => {\n          focus(editor, value);\n        },\n        mceToggleVisualAid: () => {\n          editor.hasVisual = !editor.hasVisual;\n          editor.addVisual();\n        }\n      });\n    };\n    const registerCommands = editor => {\n      registerCommands$a(editor);\n      registerCommands$9(editor);\n      registerCommands$6(editor);\n      registerCommands$1(editor);\n      registerCommands$8(editor);\n      registerCommands$4(editor);\n      registerCommands$5(editor);\n      registerCommands$2(editor);\n      registerCommands$3(editor);\n      registerCommands$7(editor);\n      registerExecCommands(editor);\n    };\n\n    class EditorCommands {\n      constructor(editor) {\n        this.commands = {\n          state: {},\n          exec: {},\n          value: {}\n        };\n        this.editor = editor;\n      }\n      execCommand(command, ui, value, args) {\n        const editor = this.editor;\n        const lowerCaseCommand = command.toLowerCase();\n        const skipFocus = args === null || args === void 0 ? void 0 : args.skip_focus;\n        if (editor.removed) {\n          return false;\n        }\n        if (lowerCaseCommand !== 'mcefocus') {\n          if (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(lowerCaseCommand) && !skipFocus) {\n            editor.focus();\n          } else {\n            restore(editor);\n          }\n        }\n        const eventArgs = editor.dispatch('BeforeExecCommand', {\n          command,\n          ui,\n          value\n        });\n        if (eventArgs.isDefaultPrevented()) {\n          return false;\n        }\n        const func = this.commands.exec[lowerCaseCommand];\n        if (isFunction(func)) {\n          func(lowerCaseCommand, ui, value);\n          editor.dispatch('ExecCommand', {\n            command,\n            ui,\n            value\n          });\n          return true;\n        }\n        return false;\n      }\n      queryCommandState(command) {\n        if (this.editor.quirks.isHidden() || this.editor.removed) {\n          return false;\n        }\n        const lowerCaseCommand = command.toLowerCase();\n        const func = this.commands.state[lowerCaseCommand];\n        if (isFunction(func)) {\n          return func(lowerCaseCommand);\n        }\n        return false;\n      }\n      queryCommandValue(command) {\n        if (this.editor.quirks.isHidden() || this.editor.removed) {\n          return '';\n        }\n        const lowerCaseCommand = command.toLowerCase();\n        const func = this.commands.value[lowerCaseCommand];\n        if (isFunction(func)) {\n          return func(lowerCaseCommand);\n        }\n        return '';\n      }\n      addCommands(commandList, type = 'exec') {\n        const commands = this.commands;\n        each$f(commandList, (callback, command) => {\n          each$g(command.toLowerCase().split(','), command => {\n            commands[type][command] = callback;\n          });\n        });\n      }\n      addCommand(command, callback, scope) {\n        const lowerCaseCommand = command.toLowerCase();\n        this.commands.exec[lowerCaseCommand] = (_command, ui, value) => callback.call(scope !== null && scope !== void 0 ? scope : this.editor, ui, value);\n      }\n      queryCommandSupported(command) {\n        const lowerCaseCommand = command.toLowerCase();\n        if (this.commands.exec[lowerCaseCommand]) {\n          return true;\n        }\n        return false;\n      }\n      addQueryStateHandler(command, callback, scope) {\n        this.commands.state[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\n      }\n      addQueryValueHandler(command, callback, scope) {\n        this.commands.value[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\n      }\n    }\n\n    const internalContentEditableAttr = 'data-mce-contenteditable';\n    const toggleClass = (elm, cls, state) => {\n      if (has(elm, cls) && state === false) {\n        remove$7(elm, cls);\n      } else if (state) {\n        add$2(elm, cls);\n      }\n    };\n    const setEditorCommandState = (editor, cmd, state) => {\n      try {\n        editor.getDoc().execCommand(cmd, false, String(state));\n      } catch (ex) {\n      }\n    };\n    const setContentEditable = (elm, state) => {\n      elm.dom.contentEditable = state ? 'true' : 'false';\n    };\n    const switchOffContentEditableTrue = elm => {\n      each$g(descendants(elm, '*[contenteditable=\"true\"]'), elm => {\n        set$2(elm, internalContentEditableAttr, 'true');\n        setContentEditable(elm, false);\n      });\n    };\n    const switchOnContentEditableTrue = elm => {\n      each$g(descendants(elm, `*[${ internalContentEditableAttr }=\"true\"]`), elm => {\n        remove$a(elm, internalContentEditableAttr);\n        setContentEditable(elm, true);\n      });\n    };\n    const removeFakeSelection = editor => {\n      Optional.from(editor.selection.getNode()).each(elm => {\n        elm.removeAttribute('data-mce-selected');\n      });\n    };\n    const restoreFakeSelection = editor => {\n      editor.selection.setRng(editor.selection.getRng());\n    };\n    const toggleReadOnly = (editor, state) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      toggleClass(body, 'mce-content-readonly', state);\n      if (state) {\n        editor.selection.controlSelection.hideResizeRect();\n        editor._selectionOverrides.hideFakeCaret();\n        removeFakeSelection(editor);\n        editor.readonly = true;\n        setContentEditable(body, false);\n        switchOffContentEditableTrue(body);\n      } else {\n        editor.readonly = false;\n        setContentEditable(body, true);\n        switchOnContentEditableTrue(body);\n        setEditorCommandState(editor, 'StyleWithCSS', false);\n        setEditorCommandState(editor, 'enableInlineTableEditing', false);\n        setEditorCommandState(editor, 'enableObjectResizing', false);\n        if (hasEditorOrUiFocus(editor)) {\n          editor.focus();\n        }\n        restoreFakeSelection(editor);\n        editor.nodeChanged();\n      }\n    };\n    const isReadOnly = editor => editor.readonly;\n    const registerFilters = editor => {\n      editor.parser.addAttributeFilter('contenteditable', nodes => {\n        if (isReadOnly(editor)) {\n          each$g(nodes, node => {\n            node.attr(internalContentEditableAttr, node.attr('contenteditable'));\n            node.attr('contenteditable', 'false');\n          });\n        }\n      });\n      editor.serializer.addAttributeFilter(internalContentEditableAttr, nodes => {\n        if (isReadOnly(editor)) {\n          each$g(nodes, node => {\n            node.attr('contenteditable', node.attr(internalContentEditableAttr));\n          });\n        }\n      });\n      editor.serializer.addTempAttr(internalContentEditableAttr);\n    };\n    const registerReadOnlyContentFilters = editor => {\n      if (editor.serializer) {\n        registerFilters(editor);\n      } else {\n        editor.on('PreInit', () => {\n          registerFilters(editor);\n        });\n      }\n    };\n    const isClickEvent = e => e.type === 'click';\n    const getAnchorHrefOpt = (editor, elm) => {\n      const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\n      return closest$3(elm, 'a', isRoot).bind(a => getOpt(a, 'href'));\n    };\n    const processReadonlyEvents = (editor, e) => {\n      if (isClickEvent(e) && !VK.metaKeyPressed(e)) {\n        const elm = SugarElement.fromDom(e.target);\n        getAnchorHrefOpt(editor, elm).each(href => {\n          e.preventDefault();\n          if (/^#/.test(href)) {\n            const targetEl = editor.dom.select(`${ href },[name=\"${ removeLeading(href, '#') }\"]`);\n            if (targetEl.length) {\n              editor.selection.scrollIntoView(targetEl[0], true);\n            }\n          } else {\n            window.open(href, '_blank', 'rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes');\n          }\n        });\n      }\n    };\n    const registerReadOnlySelectionBlockers = editor => {\n      editor.on('ShowCaret', e => {\n        if (isReadOnly(editor)) {\n          e.preventDefault();\n        }\n      });\n      editor.on('ObjectSelected', e => {\n        if (isReadOnly(editor)) {\n          e.preventDefault();\n        }\n      });\n    };\n\n    const nativeEvents = Tools.makeMap('focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange ' + 'mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover ' + 'draggesture dragdrop drop drag submit ' + 'compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel', ' ');\n    class EventDispatcher {\n      constructor(settings) {\n        this.bindings = {};\n        this.settings = settings || {};\n        this.scope = this.settings.scope || this;\n        this.toggleEvent = this.settings.toggleEvent || never;\n      }\n      static isNative(name) {\n        return !!nativeEvents[name.toLowerCase()];\n      }\n      fire(name, args) {\n        return this.dispatch(name, args);\n      }\n      dispatch(name, args) {\n        const lcName = name.toLowerCase();\n        const event = normalize$3(lcName, args !== null && args !== void 0 ? args : {}, this.scope);\n        if (this.settings.beforeFire) {\n          this.settings.beforeFire(event);\n        }\n        const handlers = this.bindings[lcName];\n        if (handlers) {\n          for (let i = 0, l = handlers.length; i < l; i++) {\n            const callback = handlers[i];\n            if (callback.removed) {\n              continue;\n            }\n            if (callback.once) {\n              this.off(lcName, callback.func);\n            }\n            if (event.isImmediatePropagationStopped()) {\n              return event;\n            }\n            if (callback.func.call(this.scope, event) === false) {\n              event.preventDefault();\n              return event;\n            }\n          }\n        }\n        return event;\n      }\n      on(name, callback, prepend, extra) {\n        if (callback === false) {\n          callback = never;\n        }\n        if (callback) {\n          const wrappedCallback = {\n            func: callback,\n            removed: false\n          };\n          if (extra) {\n            Tools.extend(wrappedCallback, extra);\n          }\n          const names = name.toLowerCase().split(' ');\n          let i = names.length;\n          while (i--) {\n            const currentName = names[i];\n            let handlers = this.bindings[currentName];\n            if (!handlers) {\n              handlers = [];\n              this.toggleEvent(currentName, true);\n            }\n            if (prepend) {\n              handlers = [\n                wrappedCallback,\n                ...handlers\n              ];\n            } else {\n              handlers = [\n                ...handlers,\n                wrappedCallback\n              ];\n            }\n            this.bindings[currentName] = handlers;\n          }\n        }\n        return this;\n      }\n      off(name, callback) {\n        if (name) {\n          const names = name.toLowerCase().split(' ');\n          let i = names.length;\n          while (i--) {\n            const currentName = names[i];\n            let handlers = this.bindings[currentName];\n            if (!currentName) {\n              each$f(this.bindings, (_value, bindingName) => {\n                this.toggleEvent(bindingName, false);\n                delete this.bindings[bindingName];\n              });\n              return this;\n            }\n            if (handlers) {\n              if (!callback) {\n                handlers.length = 0;\n              } else {\n                const filteredHandlers = partition$2(handlers, handler => handler.func === callback);\n                handlers = filteredHandlers.fail;\n                this.bindings[currentName] = handlers;\n                each$g(filteredHandlers.pass, handler => {\n                  handler.removed = true;\n                });\n              }\n              if (!handlers.length) {\n                this.toggleEvent(name, false);\n                delete this.bindings[currentName];\n              }\n            }\n          }\n        } else {\n          each$f(this.bindings, (_value, name) => {\n            this.toggleEvent(name, false);\n          });\n          this.bindings = {};\n        }\n        return this;\n      }\n      once(name, callback, prepend) {\n        return this.on(name, callback, prepend, { once: true });\n      }\n      has(name) {\n        name = name.toLowerCase();\n        return !(!this.bindings[name] || this.bindings[name].length === 0);\n      }\n    }\n\n    const getEventDispatcher = obj => {\n      if (!obj._eventDispatcher) {\n        obj._eventDispatcher = new EventDispatcher({\n          scope: obj,\n          toggleEvent: (name, state) => {\n            if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {\n              obj.toggleNativeEvent(name, state);\n            }\n          }\n        });\n      }\n      return obj._eventDispatcher;\n    };\n    const Observable = {\n      fire(name, args, bubble) {\n        return this.dispatch(name, args, bubble);\n      },\n      dispatch(name, args, bubble) {\n        const self = this;\n        if (self.removed && name !== 'remove' && name !== 'detach') {\n          return normalize$3(name.toLowerCase(), args !== null && args !== void 0 ? args : {}, self);\n        }\n        const dispatcherArgs = getEventDispatcher(self).dispatch(name, args);\n        if (bubble !== false && self.parent) {\n          let parent = self.parent();\n          while (parent && !dispatcherArgs.isPropagationStopped()) {\n            parent.dispatch(name, dispatcherArgs, false);\n            parent = parent.parent();\n          }\n        }\n        return dispatcherArgs;\n      },\n      on(name, callback, prepend) {\n        return getEventDispatcher(this).on(name, callback, prepend);\n      },\n      off(name, callback) {\n        return getEventDispatcher(this).off(name, callback);\n      },\n      once(name, callback) {\n        return getEventDispatcher(this).once(name, callback);\n      },\n      hasEventListeners(name) {\n        return getEventDispatcher(this).has(name);\n      }\n    };\n\n    const DOM$2 = DOMUtils.DOM;\n    let customEventRootDelegates;\n    const getEventTarget = (editor, eventName) => {\n      if (eventName === 'selectionchange') {\n        return editor.getDoc();\n      }\n      if (!editor.inline && /^mouse|touch|click|contextmenu|drop|dragover|dragend/.test(eventName)) {\n        return editor.getDoc().documentElement;\n      }\n      const eventRoot = getEventRoot(editor);\n      if (eventRoot) {\n        if (!editor.eventRoot) {\n          editor.eventRoot = DOM$2.select(eventRoot)[0];\n        }\n        return editor.eventRoot;\n      }\n      return editor.getBody();\n    };\n    const isListening = editor => !editor.hidden && !isReadOnly(editor);\n    const fireEvent = (editor, eventName, e) => {\n      if (isListening(editor)) {\n        editor.dispatch(eventName, e);\n      } else if (isReadOnly(editor)) {\n        processReadonlyEvents(editor, e);\n      }\n    };\n    const bindEventDelegate = (editor, eventName) => {\n      let delegate;\n      if (!editor.delegates) {\n        editor.delegates = {};\n      }\n      if (editor.delegates[eventName] || editor.removed) {\n        return;\n      }\n      const eventRootElm = getEventTarget(editor, eventName);\n      if (getEventRoot(editor)) {\n        if (!customEventRootDelegates) {\n          customEventRootDelegates = {};\n          editor.editorManager.on('removeEditor', () => {\n            if (!editor.editorManager.activeEditor) {\n              if (customEventRootDelegates) {\n                each$f(customEventRootDelegates, (_value, name) => {\n                  editor.dom.unbind(getEventTarget(editor, name));\n                });\n                customEventRootDelegates = null;\n              }\n            }\n          });\n        }\n        if (customEventRootDelegates[eventName]) {\n          return;\n        }\n        delegate = e => {\n          const target = e.target;\n          const editors = editor.editorManager.get();\n          let i = editors.length;\n          while (i--) {\n            const body = editors[i].getBody();\n            if (body === target || DOM$2.isChildOf(target, body)) {\n              fireEvent(editors[i], eventName, e);\n            }\n          }\n        };\n        customEventRootDelegates[eventName] = delegate;\n        DOM$2.bind(eventRootElm, eventName, delegate);\n      } else {\n        delegate = e => {\n          fireEvent(editor, eventName, e);\n        };\n        DOM$2.bind(eventRootElm, eventName, delegate);\n        editor.delegates[eventName] = delegate;\n      }\n    };\n    const EditorObservable = {\n      ...Observable,\n      bindPendingEventDelegates() {\n        const self = this;\n        Tools.each(self._pendingNativeEvents, name => {\n          bindEventDelegate(self, name);\n        });\n      },\n      toggleNativeEvent(name, state) {\n        const self = this;\n        if (name === 'focus' || name === 'blur') {\n          return;\n        }\n        if (self.removed) {\n          return;\n        }\n        if (state) {\n          if (self.initialized) {\n            bindEventDelegate(self, name);\n          } else {\n            if (!self._pendingNativeEvents) {\n              self._pendingNativeEvents = [name];\n            } else {\n              self._pendingNativeEvents.push(name);\n            }\n          }\n        } else if (self.initialized) {\n          self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);\n          delete self.delegates[name];\n        }\n      },\n      unbindAllNativeEvents() {\n        const self = this;\n        const body = self.getBody();\n        const dom = self.dom;\n        if (self.delegates) {\n          each$f(self.delegates, (value, name) => {\n            self.dom.unbind(getEventTarget(self, name), name, value);\n          });\n          delete self.delegates;\n        }\n        if (!self.inline && body && dom) {\n          body.onload = null;\n          dom.unbind(self.getWin());\n          dom.unbind(self.getDoc());\n        }\n        if (dom) {\n          dom.unbind(body);\n          dom.unbind(self.getContainer());\n        }\n      }\n    };\n\n    const stringListProcessor = value => {\n      if (isString(value)) {\n        return {\n          value: value.split(/[ ,]/),\n          valid: true\n        };\n      } else if (isArrayOf(value, isString)) {\n        return {\n          value,\n          valid: true\n        };\n      } else {\n        return {\n          valid: false,\n          message: `The value must be a string[] or a comma/space separated string.`\n        };\n      }\n    };\n    const getBuiltInProcessor = type => {\n      const validator = (() => {\n        switch (type) {\n        case 'array':\n          return isArray$1;\n        case 'boolean':\n          return isBoolean;\n        case 'function':\n          return isFunction;\n        case 'number':\n          return isNumber;\n        case 'object':\n          return isObject;\n        case 'string':\n          return isString;\n        case 'string[]':\n          return stringListProcessor;\n        case 'object[]':\n          return val => isArrayOf(val, isObject);\n        case 'regexp':\n          return val => is$4(val, RegExp);\n        }\n      })();\n      return value => processValue(value, validator, `The value must be a ${ type }.`);\n    };\n    const isBuiltInSpec = spec => isString(spec.processor);\n    const getErrorMessage = (message, result) => {\n      const additionalText = isEmpty$3(result.message) ? '' : `. ${ result.message }`;\n      return message + additionalText;\n    };\n    const isValidResult = result => result.valid;\n    const processValue = (value, processor, message = '') => {\n      const result = processor(value);\n      if (isBoolean(result)) {\n        return result ? {\n          value: value,\n          valid: true\n        } : {\n          valid: false,\n          message\n        };\n      } else {\n        return result;\n      }\n    };\n    const processDefaultValue = (name, defaultValue, processor) => {\n      if (!isUndefined(defaultValue)) {\n        const result = processValue(defaultValue, processor);\n        if (isValidResult(result)) {\n          return result.value;\n        } else {\n          console.error(getErrorMessage(`Invalid default value passed for the \"${ name }\" option`, result));\n        }\n      }\n      return undefined;\n    };\n    const create$5 = (editor, initialOptions) => {\n      const registry = {};\n      const values = {};\n      const setValue = (name, value, processor) => {\n        const result = processValue(value, processor);\n        if (isValidResult(result)) {\n          values[name] = result.value;\n          return true;\n        } else {\n          console.warn(getErrorMessage(`Invalid value passed for the ${ name } option`, result));\n          return false;\n        }\n      };\n      const register = (name, spec) => {\n        const processor = isBuiltInSpec(spec) ? getBuiltInProcessor(spec.processor) : spec.processor;\n        const defaultValue = processDefaultValue(name, spec.default, processor);\n        registry[name] = {\n          ...spec,\n          default: defaultValue,\n          processor\n        };\n        const initValue = get$a(values, name).orThunk(() => get$a(initialOptions, name));\n        initValue.each(value => setValue(name, value, processor));\n      };\n      const isRegistered = name => has$2(registry, name);\n      const get = name => get$a(values, name).orThunk(() => get$a(registry, name).map(spec => spec.default)).getOrUndefined();\n      const set = (name, value) => {\n        if (!isRegistered(name)) {\n          console.warn(`\"${ name }\" is not a registered option. Ensure the option has been registered before setting a value.`);\n          return false;\n        } else {\n          const spec = registry[name];\n          if (spec.immutable) {\n            console.error(`\"${ name }\" is an immutable option and cannot be updated`);\n            return false;\n          } else {\n            return setValue(name, value, spec.processor);\n          }\n        }\n      };\n      const unset = name => {\n        const registered = isRegistered(name);\n        if (registered) {\n          delete values[name];\n        }\n        return registered;\n      };\n      const isSet = name => has$2(values, name);\n      return {\n        register,\n        isRegistered,\n        get,\n        set,\n        unset,\n        isSet\n      };\n    };\n\n    const defaultModes = [\n      'design',\n      'readonly'\n    ];\n    const switchToMode = (editor, activeMode, availableModes, mode) => {\n      const oldMode = availableModes[activeMode.get()];\n      const newMode = availableModes[mode];\n      try {\n        newMode.activate();\n      } catch (e) {\n        console.error(`problem while activating editor mode ${ mode }:`, e);\n        return;\n      }\n      oldMode.deactivate();\n      if (oldMode.editorReadOnly !== newMode.editorReadOnly) {\n        toggleReadOnly(editor, newMode.editorReadOnly);\n      }\n      activeMode.set(mode);\n      fireSwitchMode(editor, mode);\n    };\n    const setMode = (editor, availableModes, activeMode, mode) => {\n      if (mode === activeMode.get()) {\n        return;\n      } else if (!has$2(availableModes, mode)) {\n        throw new Error(`Editor mode '${ mode }' is invalid`);\n      }\n      if (editor.initialized) {\n        switchToMode(editor, activeMode, availableModes, mode);\n      } else {\n        editor.on('init', () => switchToMode(editor, activeMode, availableModes, mode));\n      }\n    };\n    const registerMode = (availableModes, mode, api) => {\n      if (contains$2(defaultModes, mode)) {\n        throw new Error(`Cannot override default mode ${ mode }`);\n      }\n      return {\n        ...availableModes,\n        [mode]: {\n          ...api,\n          deactivate: () => {\n            try {\n              api.deactivate();\n            } catch (e) {\n              console.error(`problem while deactivating editor mode ${ mode }:`, e);\n            }\n          }\n        }\n      };\n    };\n\n    const create$4 = editor => {\n      const activeMode = Cell('design');\n      const availableModes = Cell({\n        design: {\n          activate: noop,\n          deactivate: noop,\n          editorReadOnly: false\n        },\n        readonly: {\n          activate: noop,\n          deactivate: noop,\n          editorReadOnly: true\n        }\n      });\n      registerReadOnlyContentFilters(editor);\n      registerReadOnlySelectionBlockers(editor);\n      return {\n        isReadOnly: () => isReadOnly(editor),\n        set: mode => setMode(editor, availableModes.get(), activeMode, mode),\n        get: () => activeMode.get(),\n        register: (mode, api) => {\n          availableModes.set(registerMode(availableModes.get(), mode, api));\n        }\n      };\n    };\n\n    const each$2 = Tools.each, explode = Tools.explode;\n    const keyCodeLookup = {\n      f1: 112,\n      f2: 113,\n      f3: 114,\n      f4: 115,\n      f5: 116,\n      f6: 117,\n      f7: 118,\n      f8: 119,\n      f9: 120,\n      f10: 121,\n      f11: 122,\n      f12: 123\n    };\n    const modifierNames = Tools.makeMap('alt,ctrl,shift,meta,access');\n    const parseShortcut = pattern => {\n      let key;\n      const shortcut = {};\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      each$2(explode(pattern.toLowerCase(), '+'), value => {\n        if (value in modifierNames) {\n          shortcut[value] = true;\n        } else {\n          if (/^[0-9]{2,}$/.test(value)) {\n            shortcut.keyCode = parseInt(value, 10);\n          } else {\n            shortcut.charCode = value.charCodeAt(0);\n            shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);\n          }\n        }\n      });\n      const id = [shortcut.keyCode];\n      for (key in modifierNames) {\n        if (shortcut[key]) {\n          id.push(key);\n        } else {\n          shortcut[key] = false;\n        }\n      }\n      shortcut.id = id.join(',');\n      if (shortcut.access) {\n        shortcut.alt = true;\n        if (isMac) {\n          shortcut.ctrl = true;\n        } else {\n          shortcut.shift = true;\n        }\n      }\n      if (shortcut.meta) {\n        if (isMac) {\n          shortcut.meta = true;\n        } else {\n          shortcut.ctrl = true;\n          shortcut.meta = false;\n        }\n      }\n      return shortcut;\n    };\n    class Shortcuts {\n      constructor(editor) {\n        this.shortcuts = {};\n        this.pendingPatterns = [];\n        this.editor = editor;\n        const self = this;\n        editor.on('keyup keypress keydown', e => {\n          if ((self.hasModifier(e) || self.isFunctionKey(e)) && !e.isDefaultPrevented()) {\n            each$2(self.shortcuts, shortcut => {\n              if (self.matchShortcut(e, shortcut)) {\n                self.pendingPatterns = shortcut.subpatterns.slice(0);\n                if (e.type === 'keydown') {\n                  self.executeShortcutAction(shortcut);\n                }\n                return true;\n              }\n            });\n            if (self.matchShortcut(e, self.pendingPatterns[0])) {\n              if (self.pendingPatterns.length === 1) {\n                if (e.type === 'keydown') {\n                  self.executeShortcutAction(self.pendingPatterns[0]);\n                }\n              }\n              self.pendingPatterns.shift();\n            }\n          }\n        });\n      }\n      add(pattern, desc, cmdFunc, scope) {\n        const self = this;\n        const func = self.normalizeCommandFunc(cmdFunc);\n        each$2(explode(Tools.trim(pattern)), pattern => {\n          const shortcut = self.createShortcut(pattern, desc, func, scope);\n          self.shortcuts[shortcut.id] = shortcut;\n        });\n        return true;\n      }\n      remove(pattern) {\n        const shortcut = this.createShortcut(pattern);\n        if (this.shortcuts[shortcut.id]) {\n          delete this.shortcuts[shortcut.id];\n          return true;\n        }\n        return false;\n      }\n      normalizeCommandFunc(cmdFunc) {\n        const self = this;\n        const cmd = cmdFunc;\n        if (typeof cmd === 'string') {\n          return () => {\n            self.editor.execCommand(cmd, false, null);\n          };\n        } else if (Tools.isArray(cmd)) {\n          return () => {\n            self.editor.execCommand(cmd[0], cmd[1], cmd[2]);\n          };\n        } else {\n          return cmd;\n        }\n      }\n      createShortcut(pattern, desc, cmdFunc, scope) {\n        const shortcuts = Tools.map(explode(pattern, '>'), parseShortcut);\n        shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {\n          func: cmdFunc,\n          scope: scope || this.editor\n        });\n        return Tools.extend(shortcuts[0], {\n          desc: this.editor.translate(desc),\n          subpatterns: shortcuts.slice(1)\n        });\n      }\n      hasModifier(e) {\n        return e.altKey || e.ctrlKey || e.metaKey;\n      }\n      isFunctionKey(e) {\n        return e.type === 'keydown' && e.keyCode >= 112 && e.keyCode <= 123;\n      }\n      matchShortcut(e, shortcut) {\n        if (!shortcut) {\n          return false;\n        }\n        if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {\n          return false;\n        }\n        if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {\n          return false;\n        }\n        if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {\n          e.preventDefault();\n          return true;\n        }\n        return false;\n      }\n      executeShortcutAction(shortcut) {\n        return shortcut.func ? shortcut.func.call(shortcut.scope) : null;\n      }\n    }\n\n    const create$3 = () => {\n      const buttons = {};\n      const menuItems = {};\n      const popups = {};\n      const icons = {};\n      const contextMenus = {};\n      const contextToolbars = {};\n      const sidebars = {};\n      const add = (collection, type) => (name, spec) => collection[name.toLowerCase()] = {\n        ...spec,\n        type\n      };\n      const addIcon = (name, svgData) => icons[name.toLowerCase()] = svgData;\n      return {\n        addButton: add(buttons, 'button'),\n        addGroupToolbarButton: add(buttons, 'grouptoolbarbutton'),\n        addToggleButton: add(buttons, 'togglebutton'),\n        addMenuButton: add(buttons, 'menubutton'),\n        addSplitButton: add(buttons, 'splitbutton'),\n        addMenuItem: add(menuItems, 'menuitem'),\n        addNestedMenuItem: add(menuItems, 'nestedmenuitem'),\n        addToggleMenuItem: add(menuItems, 'togglemenuitem'),\n        addAutocompleter: add(popups, 'autocompleter'),\n        addContextMenu: add(contextMenus, 'contextmenu'),\n        addContextToolbar: add(contextToolbars, 'contexttoolbar'),\n        addContextForm: add(contextToolbars, 'contextform'),\n        addSidebar: add(sidebars, 'sidebar'),\n        addIcon,\n        getAll: () => ({\n          buttons,\n          menuItems,\n          icons,\n          popups,\n          contextMenus,\n          contextToolbars,\n          sidebars\n        })\n      };\n    };\n\n    const registry = () => {\n      const bridge = create$3();\n      return {\n        addAutocompleter: bridge.addAutocompleter,\n        addButton: bridge.addButton,\n        addContextForm: bridge.addContextForm,\n        addContextMenu: bridge.addContextMenu,\n        addContextToolbar: bridge.addContextToolbar,\n        addIcon: bridge.addIcon,\n        addMenuButton: bridge.addMenuButton,\n        addMenuItem: bridge.addMenuItem,\n        addNestedMenuItem: bridge.addNestedMenuItem,\n        addSidebar: bridge.addSidebar,\n        addSplitButton: bridge.addSplitButton,\n        addToggleButton: bridge.addToggleButton,\n        addGroupToolbarButton: bridge.addGroupToolbarButton,\n        addToggleMenuItem: bridge.addToggleMenuItem,\n        getAll: bridge.getAll\n      };\n    };\n\n    const DOM$1 = DOMUtils.DOM;\n    const extend = Tools.extend, each$1 = Tools.each;\n    class Editor {\n      constructor(id, options, editorManager) {\n        this.plugins = {};\n        this.contentCSS = [];\n        this.contentStyles = [];\n        this.loadedCSS = {};\n        this.isNotDirty = false;\n        this.editorManager = editorManager;\n        this.documentBaseUrl = editorManager.documentBaseURL;\n        extend(this, EditorObservable);\n        const self = this;\n        this.id = id;\n        this.hidden = false;\n        const normalizedOptions = normalizeOptions(editorManager.defaultOptions, options);\n        this.options = create$5(self, normalizedOptions);\n        register$7(self);\n        const getOption = this.options.get;\n        if (getOption('deprecation_warnings')) {\n          logWarnings(options, normalizedOptions);\n        }\n        const suffix = getOption('suffix');\n        if (suffix) {\n          editorManager.suffix = suffix;\n        }\n        this.suffix = editorManager.suffix;\n        const baseUrl = getOption('base_url');\n        if (baseUrl) {\n          editorManager._setBaseUrl(baseUrl);\n        }\n        this.baseUri = editorManager.baseURI;\n        const referrerPolicy = getReferrerPolicy(self);\n        if (referrerPolicy) {\n          ScriptLoader.ScriptLoader._setReferrerPolicy(referrerPolicy);\n          DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(referrerPolicy);\n        }\n        AddOnManager.languageLoad = getOption('language_load');\n        AddOnManager.baseURL = editorManager.baseURL;\n        this.setDirty(false);\n        this.documentBaseURI = new URI(getDocumentBaseUrl(self), { base_uri: this.baseUri });\n        this.baseURI = this.baseUri;\n        this.inline = isInline(self);\n        this.shortcuts = new Shortcuts(this);\n        this.editorCommands = new EditorCommands(this);\n        registerCommands(this);\n        const cacheSuffix = getOption('cache_suffix');\n        if (cacheSuffix) {\n          Env.cacheSuffix = cacheSuffix.replace(/^[\\?\\&]+/, '');\n        }\n        this.ui = {\n          registry: registry(),\n          styleSheetLoader: undefined,\n          show: noop,\n          hide: noop,\n          setEnabled: noop,\n          isEnabled: always\n        };\n        this.mode = create$4(self);\n        editorManager.dispatch('SetupEditor', { editor: this });\n        const setupCallback = getSetupCallback(self);\n        if (isFunction(setupCallback)) {\n          setupCallback.call(self, self);\n        }\n      }\n      render() {\n        render(this);\n      }\n      focus(skipFocus) {\n        this.execCommand('mceFocus', false, skipFocus);\n      }\n      hasFocus() {\n        return hasFocus(this);\n      }\n      translate(text) {\n        return I18n.translate(text);\n      }\n      getParam(name, defaultVal, type) {\n        const options = this.options;\n        if (!options.isRegistered(name)) {\n          if (isNonNullable(type)) {\n            options.register(name, {\n              processor: type,\n              default: defaultVal\n            });\n          } else {\n            options.register(name, {\n              processor: always,\n              default: defaultVal\n            });\n          }\n        }\n        return !options.isSet(name) && !isUndefined(defaultVal) ? defaultVal : options.get(name);\n      }\n      hasPlugin(name, loaded) {\n        const hasPlugin = contains$2(getPlugins(this), name);\n        if (hasPlugin) {\n          return loaded ? PluginManager.get(name) !== undefined : true;\n        } else {\n          return false;\n        }\n      }\n      nodeChanged(args) {\n        this._nodeChangeDispatcher.nodeChanged(args);\n      }\n      addCommand(name, callback, scope) {\n        this.editorCommands.addCommand(name, callback, scope);\n      }\n      addQueryStateHandler(name, callback, scope) {\n        this.editorCommands.addQueryStateHandler(name, callback, scope);\n      }\n      addQueryValueHandler(name, callback, scope) {\n        this.editorCommands.addQueryValueHandler(name, callback, scope);\n      }\n      addShortcut(pattern, desc, cmdFunc, scope) {\n        this.shortcuts.add(pattern, desc, cmdFunc, scope);\n      }\n      execCommand(cmd, ui, value, args) {\n        return this.editorCommands.execCommand(cmd, ui, value, args);\n      }\n      queryCommandState(cmd) {\n        return this.editorCommands.queryCommandState(cmd);\n      }\n      queryCommandValue(cmd) {\n        return this.editorCommands.queryCommandValue(cmd);\n      }\n      queryCommandSupported(cmd) {\n        return this.editorCommands.queryCommandSupported(cmd);\n      }\n      show() {\n        const self = this;\n        if (self.hidden) {\n          self.hidden = false;\n          if (self.inline) {\n            self.getBody().contentEditable = 'true';\n          } else {\n            DOM$1.show(self.getContainer());\n            DOM$1.hide(self.id);\n          }\n          self.load();\n          self.dispatch('show');\n        }\n      }\n      hide() {\n        const self = this;\n        if (!self.hidden) {\n          self.save();\n          if (self.inline) {\n            self.getBody().contentEditable = 'false';\n            if (self === self.editorManager.focusedEditor) {\n              self.editorManager.focusedEditor = null;\n            }\n          } else {\n            DOM$1.hide(self.getContainer());\n            DOM$1.setStyle(self.id, 'display', self.orgDisplay);\n          }\n          self.hidden = true;\n          self.dispatch('hide');\n        }\n      }\n      isHidden() {\n        return this.hidden;\n      }\n      setProgressState(state, time) {\n        this.dispatch('ProgressState', {\n          state,\n          time\n        });\n      }\n      load(args) {\n        const self = this;\n        let elm = self.getElement(), html;\n        if (self.removed) {\n          return '';\n        }\n        if (elm) {\n          args = args || {};\n          args.load = true;\n          const value = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;\n          html = self.setContent(value, args);\n          args.element = elm;\n          if (!args.no_events) {\n            self.dispatch('LoadContent', args);\n          }\n          args.element = elm = null;\n          return html;\n        }\n      }\n      save(args) {\n        const self = this;\n        let elm = self.getElement(), html, form;\n        if (!elm || !self.initialized || self.removed) {\n          return;\n        }\n        args = args || {};\n        args.save = true;\n        args.element = elm;\n        html = args.content = self.getContent(args);\n        if (!args.no_events) {\n          self.dispatch('SaveContent', args);\n        }\n        if (args.format === 'raw') {\n          self.dispatch('RawSaveContent', args);\n        }\n        html = args.content;\n        if (!isTextareaOrInput(elm)) {\n          if (args.is_removing || !self.inline) {\n            elm.innerHTML = html;\n          }\n          if (form = DOM$1.getParent(self.id, 'form')) {\n            each$1(form.elements, elm => {\n              if (elm.name === self.id) {\n                elm.value = html;\n                return false;\n              }\n            });\n          }\n        } else {\n          elm.value = html;\n        }\n        args.element = elm = null;\n        if (args.set_dirty !== false) {\n          self.setDirty(false);\n        }\n        return html;\n      }\n      setContent(content, args) {\n        return setContent(this, content, args);\n      }\n      getContent(args) {\n        return getContent(this, args);\n      }\n      insertContent(content, args) {\n        if (args) {\n          content = extend({ content }, args);\n        }\n        this.execCommand('mceInsertContent', false, content);\n      }\n      resetContent(initialContent) {\n        if (initialContent === undefined) {\n          setContent(this, this.startContent, { format: 'raw' });\n        } else {\n          setContent(this, initialContent);\n        }\n        this.undoManager.reset();\n        this.setDirty(false);\n        this.nodeChanged();\n      }\n      isDirty() {\n        return !this.isNotDirty;\n      }\n      setDirty(state) {\n        const oldState = !this.isNotDirty;\n        this.isNotDirty = !state;\n        if (state && state !== oldState) {\n          this.dispatch('dirty');\n        }\n      }\n      getContainer() {\n        const self = this;\n        if (!self.container) {\n          self.container = DOM$1.get(self.editorContainer || self.id + '_parent');\n        }\n        return self.container;\n      }\n      getContentAreaContainer() {\n        return this.contentAreaContainer;\n      }\n      getElement() {\n        if (!this.targetElm) {\n          this.targetElm = DOM$1.get(this.id);\n        }\n        return this.targetElm;\n      }\n      getWin() {\n        const self = this;\n        let elm;\n        if (!self.contentWindow) {\n          elm = self.iframeElement;\n          if (elm) {\n            self.contentWindow = elm.contentWindow;\n          }\n        }\n        return self.contentWindow;\n      }\n      getDoc() {\n        const self = this;\n        let win;\n        if (!self.contentDocument) {\n          win = self.getWin();\n          if (win) {\n            self.contentDocument = win.document;\n          }\n        }\n        return self.contentDocument;\n      }\n      getBody() {\n        const doc = this.getDoc();\n        return this.bodyElement || (doc ? doc.body : null);\n      }\n      convertURL(url, name, elm) {\n        const self = this, getOption = self.options.get;\n        const urlConverterCallback = getUrlConverterCallback(self);\n        if (isFunction(urlConverterCallback)) {\n          return urlConverterCallback.call(self, url, elm, true, name);\n        }\n        if (!getOption('convert_urls') || elm && elm.nodeName === 'LINK' || url.indexOf('file:') === 0 || url.length === 0) {\n          return url;\n        }\n        if (getOption('relative_urls')) {\n          return self.documentBaseURI.toRelative(url);\n        }\n        url = self.documentBaseURI.toAbsolute(url, getOption('remove_script_host'));\n        return url;\n      }\n      addVisual(elm) {\n        addVisual(this, elm);\n      }\n      remove() {\n        remove$1(this);\n      }\n      destroy(automatic) {\n        destroy(this, automatic);\n      }\n      uploadImages() {\n        return this.editorUpload.uploadImages();\n      }\n      _scanForImages() {\n        return this.editorUpload.scanForImages();\n      }\n    }\n\n    const DOM = DOMUtils.DOM;\n    const each = Tools.each;\n    let boundGlobalEvents = false;\n    let beforeUnloadDelegate;\n    let editors = [];\n    const globalEventDelegate = e => {\n      const type = e.type;\n      each(EditorManager.get(), editor => {\n        switch (type) {\n        case 'scroll':\n          editor.dispatch('ScrollWindow', e);\n          break;\n        case 'resize':\n          editor.dispatch('ResizeWindow', e);\n          break;\n        }\n      });\n    };\n    const toggleGlobalEvents = state => {\n      if (state !== boundGlobalEvents) {\n        const DOM = DOMUtils.DOM;\n        if (state) {\n          DOM.bind(window, 'resize', globalEventDelegate);\n          DOM.bind(window, 'scroll', globalEventDelegate);\n        } else {\n          DOM.unbind(window, 'resize', globalEventDelegate);\n          DOM.unbind(window, 'scroll', globalEventDelegate);\n        }\n        boundGlobalEvents = state;\n      }\n    };\n    const removeEditorFromList = targetEditor => {\n      const oldEditors = editors;\n      editors = filter$6(editors, editor => {\n        return targetEditor !== editor;\n      });\n      if (EditorManager.activeEditor === targetEditor) {\n        EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;\n      }\n      if (EditorManager.focusedEditor === targetEditor) {\n        EditorManager.focusedEditor = null;\n      }\n      return oldEditors.length !== editors.length;\n    };\n    const purgeDestroyedEditor = editor => {\n      if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {\n        removeEditorFromList(editor);\n        editor.unbindAllNativeEvents();\n        editor.destroy(true);\n        editor.removed = true;\n        editor = null;\n      }\n      return editor;\n    };\n    const isQuirksMode = document.compatMode !== 'CSS1Compat';\n    const EditorManager = {\n      ...Observable,\n      baseURI: null,\n      baseURL: null,\n      defaultOptions: {},\n      documentBaseURL: null,\n      suffix: null,\n      majorVersion: '6',\n      minorVersion: '0.2',\n      releaseDate: '2022-04-27',\n      i18n: I18n,\n      activeEditor: null,\n      focusedEditor: null,\n      setup() {\n        const self = this;\n        let baseURL, documentBaseURL, suffix = '';\n        documentBaseURL = URI.getDocumentBaseUrl(document.location);\n        if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(documentBaseURL)) {\n          documentBaseURL = documentBaseURL.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\n          if (!/[\\/\\\\]$/.test(documentBaseURL)) {\n            documentBaseURL += '/';\n          }\n        }\n        const preInit = window.tinymce || window.tinyMCEPreInit;\n        if (preInit) {\n          baseURL = preInit.base || preInit.baseURL;\n          suffix = preInit.suffix;\n        } else {\n          const scripts = document.getElementsByTagName('script');\n          for (let i = 0; i < scripts.length; i++) {\n            const src = scripts[i].src || '';\n            if (src === '') {\n              continue;\n            }\n            const srcScript = src.substring(src.lastIndexOf('/'));\n            if (/tinymce(\\.full|\\.jquery|)(\\.min|\\.dev|)\\.js/.test(src)) {\n              if (srcScript.indexOf('.min') !== -1) {\n                suffix = '.min';\n              }\n              baseURL = src.substring(0, src.lastIndexOf('/'));\n              break;\n            }\n          }\n          if (!baseURL && document.currentScript) {\n            const src = document.currentScript.src;\n            if (src.indexOf('.min') !== -1) {\n              suffix = '.min';\n            }\n            baseURL = src.substring(0, src.lastIndexOf('/'));\n          }\n        }\n        self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);\n        self.documentBaseURL = documentBaseURL;\n        self.baseURI = new URI(self.baseURL);\n        self.suffix = suffix;\n        setup$v(self);\n      },\n      overrideDefaults(defaultOptions) {\n        const baseUrl = defaultOptions.base_url;\n        if (baseUrl) {\n          this._setBaseUrl(baseUrl);\n        }\n        const suffix = defaultOptions.suffix;\n        if (defaultOptions.suffix) {\n          this.suffix = suffix;\n        }\n        this.defaultOptions = defaultOptions;\n        const pluginBaseUrls = defaultOptions.plugin_base_urls;\n        if (pluginBaseUrls !== undefined) {\n          each$f(pluginBaseUrls, (pluginBaseUrl, pluginName) => {\n            AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;\n          });\n        }\n      },\n      init(options) {\n        const self = this;\n        let result;\n        const invalidInlineTargets = Tools.makeMap('area base basefont br col frame hr img input isindex link meta param embed source wbr track ' + 'colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu', ' ');\n        const isInvalidInlineTarget = (options, elm) => options.inline && elm.tagName.toLowerCase() in invalidInlineTargets;\n        const createId = elm => {\n          let id = elm.id;\n          if (!id) {\n            id = get$a(elm, 'name').filter(name => !DOM.get(name)).getOrThunk(DOM.uniqueId);\n            elm.setAttribute('id', id);\n          }\n          return id;\n        };\n        const execCallback = name => {\n          const callback = options[name];\n          if (!callback) {\n            return;\n          }\n          return callback.apply(self, []);\n        };\n        const findTargets = options => {\n          if (Env.browser.isIE() || Env.browser.isEdge()) {\n            initError('TinyMCE does not support the browser you are using. For a list of supported' + ' browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers');\n            return [];\n          } else if (isQuirksMode) {\n            initError('Failed to initialize the editor as the document is not in standards mode. ' + 'TinyMCE requires standards mode.');\n            return [];\n          } else if (isString(options.selector)) {\n            return DOM.select(options.selector);\n          } else if (isNonNullable(options.target)) {\n            return [options.target];\n          } else {\n            return [];\n          }\n        };\n        let provideResults = editors => {\n          result = editors;\n        };\n        const initEditors = () => {\n          let initCount = 0;\n          const editors = [];\n          let targets;\n          const createEditor = (id, options, targetElm) => {\n            const editor = new Editor(id, options, self);\n            editors.push(editor);\n            editor.on('init', () => {\n              if (++initCount === targets.length) {\n                provideResults(editors);\n              }\n            });\n            editor.targetElm = editor.targetElm || targetElm;\n            editor.render();\n          };\n          DOM.unbind(window, 'ready', initEditors);\n          execCallback('onpageload');\n          targets = unique$1(findTargets(options));\n          Tools.each(targets, elm => {\n            purgeDestroyedEditor(self.get(elm.id));\n          });\n          targets = Tools.grep(targets, elm => {\n            return !self.get(elm.id);\n          });\n          if (targets.length === 0) {\n            provideResults([]);\n          } else {\n            each(targets, elm => {\n              if (isInvalidInlineTarget(options, elm)) {\n                initError('Could not initialize inline editor on invalid inline target element', elm);\n              } else {\n                createEditor(createId(elm), options, elm);\n              }\n            });\n          }\n        };\n        DOM.bind(window, 'ready', initEditors);\n        return new Promise(resolve => {\n          if (result) {\n            resolve(result);\n          } else {\n            provideResults = editors => {\n              resolve(editors);\n            };\n          }\n        });\n      },\n      get(id) {\n        if (arguments.length === 0) {\n          return editors.slice(0);\n        } else if (isString(id)) {\n          return find$2(editors, editor => {\n            return editor.id === id;\n          }).getOr(null);\n        } else if (isNumber(id)) {\n          return editors[id] ? editors[id] : null;\n        } else {\n          return null;\n        }\n      },\n      add(editor) {\n        const self = this;\n        const existingEditor = self.get(editor.id);\n        if (existingEditor === editor) {\n          return editor;\n        }\n        if (existingEditor === null) {\n          editors.push(editor);\n        }\n        toggleGlobalEvents(true);\n        self.activeEditor = editor;\n        self.dispatch('AddEditor', { editor });\n        if (!beforeUnloadDelegate) {\n          beforeUnloadDelegate = e => {\n            const event = self.dispatch('BeforeUnload');\n            if (event.returnValue) {\n              e.preventDefault();\n              e.returnValue = event.returnValue;\n              return event.returnValue;\n            }\n          };\n          window.addEventListener('beforeunload', beforeUnloadDelegate);\n        }\n        return editor;\n      },\n      createEditor(id, options) {\n        return this.add(new Editor(id, options, this));\n      },\n      remove(selector) {\n        const self = this;\n        let i, editor;\n        if (!selector) {\n          for (i = editors.length - 1; i >= 0; i--) {\n            self.remove(editors[i]);\n          }\n          return;\n        }\n        if (isString(selector)) {\n          each(DOM.select(selector), elm => {\n            editor = self.get(elm.id);\n            if (editor) {\n              self.remove(editor);\n            }\n          });\n          return;\n        }\n        editor = selector;\n        if (isNull(self.get(editor.id))) {\n          return null;\n        }\n        if (removeEditorFromList(editor)) {\n          self.dispatch('RemoveEditor', { editor });\n        }\n        if (editors.length === 0) {\n          window.removeEventListener('beforeunload', beforeUnloadDelegate);\n        }\n        editor.remove();\n        toggleGlobalEvents(editors.length > 0);\n        return editor;\n      },\n      execCommand(cmd, ui, value) {\n        var _a;\n        const self = this;\n        const editorId = isObject(value) ? (_a = value.id) !== null && _a !== void 0 ? _a : value.index : value;\n        switch (cmd) {\n        case 'mceAddEditor': {\n            if (!self.get(editorId)) {\n              const editorOptions = value.options;\n              new Editor(editorId, editorOptions, self).render();\n            }\n            return true;\n          }\n        case 'mceRemoveEditor': {\n            const editor = self.get(editorId);\n            if (editor) {\n              editor.remove();\n            }\n            return true;\n          }\n        case 'mceToggleEditor': {\n            const editor = self.get(editorId);\n            if (!editor) {\n              self.execCommand('mceAddEditor', false, value);\n              return true;\n            }\n            if (editor.isHidden()) {\n              editor.show();\n            } else {\n              editor.hide();\n            }\n            return true;\n          }\n        }\n        if (self.activeEditor) {\n          return self.activeEditor.execCommand(cmd, ui, value);\n        }\n        return false;\n      },\n      triggerSave: () => {\n        each(editors, editor => {\n          editor.save();\n        });\n      },\n      addI18n: (code, items) => {\n        I18n.add(code, items);\n      },\n      translate: text => {\n        return I18n.translate(text);\n      },\n      setActive(editor) {\n        const activeEditor = this.activeEditor;\n        if (this.activeEditor !== editor) {\n          if (activeEditor) {\n            activeEditor.dispatch('deactivate', { relatedTarget: editor });\n          }\n          editor.dispatch('activate', { relatedTarget: activeEditor });\n        }\n        this.activeEditor = editor;\n      },\n      _setBaseUrl(baseUrl) {\n        this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\\/+$/, ''));\n        this.baseURI = new URI(this.baseURL);\n      }\n    };\n    EditorManager.setup();\n\n    const setup = () => {\n      const dataValue = value$2();\n      const FakeClipboardItem = items => ({\n        items,\n        types: keys(items),\n        getType: type => get$a(items, type).getOrUndefined()\n      });\n      const write = data => {\n        dataValue.set(data);\n      };\n      const read = () => dataValue.get().getOrUndefined();\n      const clear = dataValue.clear;\n      return {\n        FakeClipboardItem,\n        write,\n        read,\n        clear\n      };\n    };\n    const FakeClipboard = setup();\n\n    const min = Math.min, max = Math.max, round = Math.round;\n    const relativePosition = (rect, targetRect, rel) => {\n      let x = targetRect.x;\n      let y = targetRect.y;\n      const w = rect.w;\n      const h = rect.h;\n      const targetW = targetRect.w;\n      const targetH = targetRect.h;\n      const relChars = (rel || '').split('');\n      if (relChars[0] === 'b') {\n        y += targetH;\n      }\n      if (relChars[1] === 'r') {\n        x += targetW;\n      }\n      if (relChars[0] === 'c') {\n        y += round(targetH / 2);\n      }\n      if (relChars[1] === 'c') {\n        x += round(targetW / 2);\n      }\n      if (relChars[3] === 'b') {\n        y -= h;\n      }\n      if (relChars[4] === 'r') {\n        x -= w;\n      }\n      if (relChars[3] === 'c') {\n        y -= round(h / 2);\n      }\n      if (relChars[4] === 'c') {\n        x -= round(w / 2);\n      }\n      return create$2(x, y, w, h);\n    };\n    const findBestRelativePosition = (rect, targetRect, constrainRect, rels) => {\n      let pos, i;\n      for (i = 0; i < rels.length; i++) {\n        pos = relativePosition(rect, targetRect, rels[i]);\n        if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {\n          return rels[i];\n        }\n      }\n      return null;\n    };\n    const inflate = (rect, w, h) => {\n      return create$2(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);\n    };\n    const intersect = (rect, cropRect) => {\n      const x1 = max(rect.x, cropRect.x);\n      const y1 = max(rect.y, cropRect.y);\n      const x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);\n      const y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);\n      if (x2 - x1 < 0 || y2 - y1 < 0) {\n        return null;\n      }\n      return create$2(x1, y1, x2 - x1, y2 - y1);\n    };\n    const clamp = (rect, clampRect, fixedSize) => {\n      let x1 = rect.x;\n      let y1 = rect.y;\n      let x2 = rect.x + rect.w;\n      let y2 = rect.y + rect.h;\n      const cx2 = clampRect.x + clampRect.w;\n      const cy2 = clampRect.y + clampRect.h;\n      const underflowX1 = max(0, clampRect.x - x1);\n      const underflowY1 = max(0, clampRect.y - y1);\n      const overflowX2 = max(0, x2 - cx2);\n      const overflowY2 = max(0, y2 - cy2);\n      x1 += underflowX1;\n      y1 += underflowY1;\n      if (fixedSize) {\n        x2 += underflowX1;\n        y2 += underflowY1;\n        x1 -= overflowX2;\n        y1 -= overflowY2;\n      }\n      x2 -= overflowX2;\n      y2 -= overflowY2;\n      return create$2(x1, y1, x2 - x1, y2 - y1);\n    };\n    const create$2 = (x, y, w, h) => {\n      return {\n        x,\n        y,\n        w,\n        h\n      };\n    };\n    const fromClientRect = clientRect => {\n      return create$2(clientRect.left, clientRect.top, clientRect.width, clientRect.height);\n    };\n    const Rect = {\n      inflate,\n      relativePosition,\n      findBestRelativePosition,\n      intersect,\n      clamp,\n      create: create$2,\n      fromClientRect\n    };\n\n    const awaiter = (resolveCb, rejectCb, timeout = 1000) => {\n      let done = false;\n      let timer = null;\n      const complete = completer => (...args) => {\n        if (!done) {\n          done = true;\n          if (timer !== null) {\n            clearTimeout(timer);\n            timer = null;\n          }\n          completer.apply(null, args);\n        }\n      };\n      const resolve = complete(resolveCb);\n      const reject = complete(rejectCb);\n      const start = (...args) => {\n        if (!done && timer === null) {\n          timer = setTimeout(() => reject.apply(null, args), timeout);\n        }\n      };\n      return {\n        start,\n        resolve,\n        reject\n      };\n    };\n    const create$1 = () => {\n      const tasks = {};\n      const resultFns = {};\n      const load = (id, url) => {\n        const loadErrMsg = `Script at URL \"${ url }\" failed to load`;\n        const runErrMsg = `Script at URL \"${ url }\" did not call \\`tinymce.Resource.add('${ id }', data)\\` within 1 second`;\n        if (tasks[id] !== undefined) {\n          return tasks[id];\n        } else {\n          const task = new Promise((resolve, reject) => {\n            const waiter = awaiter(resolve, reject);\n            resultFns[id] = waiter.resolve;\n            ScriptLoader.ScriptLoader.loadScript(url).then(() => waiter.start(runErrMsg), () => waiter.reject(loadErrMsg));\n          });\n          tasks[id] = task;\n          return task;\n        }\n      };\n      const add = (id, data) => {\n        if (resultFns[id] !== undefined) {\n          resultFns[id](data);\n          delete resultFns[id];\n        }\n        tasks[id] = Promise.resolve(data);\n      };\n      const unload = id => {\n        delete tasks[id];\n      };\n      return {\n        load,\n        add,\n        unload\n      };\n    };\n    const Resource = create$1();\n\n    const create = () => (() => {\n      let data = {};\n      let keys = [];\n      const storage = {\n        getItem: key => {\n          const item = data[key];\n          return item ? item : null;\n        },\n        setItem: (key, value) => {\n          keys.push(key);\n          data[key] = String(value);\n        },\n        key: index => {\n          return keys[index];\n        },\n        removeItem: key => {\n          keys = keys.filter(k => k === key);\n          delete data[key];\n        },\n        clear: () => {\n          keys = [];\n          data = {};\n        },\n        length: 0\n      };\n      Object.defineProperty(storage, 'length', {\n        get: () => keys.length,\n        configurable: false,\n        enumerable: false\n      });\n      return storage;\n    })();\n\n    let localStorage;\n    try {\n      const test = '__storage_test__';\n      localStorage = window.localStorage;\n      localStorage.setItem(test, test);\n      localStorage.removeItem(test);\n    } catch (e) {\n      localStorage = create();\n    }\n    var LocalStorage = localStorage;\n\n    const publicApi = {\n      geom: { Rect },\n      util: {\n        Delay,\n        Tools,\n        VK,\n        URI,\n        EventDispatcher,\n        Observable,\n        I18n,\n        LocalStorage,\n        ImageUploader\n      },\n      dom: {\n        EventUtils,\n        TreeWalker: DomTreeWalker,\n        TextSeeker,\n        DOMUtils,\n        ScriptLoader,\n        RangeUtils,\n        Serializer: DomSerializer,\n        StyleSheetLoader,\n        ControlSelection,\n        BookmarkManager,\n        Selection: EditorSelection,\n        Event: EventUtils.Event\n      },\n      html: {\n        Styles,\n        Entities,\n        Node: AstNode,\n        Schema,\n        DomParser,\n        Writer,\n        Serializer: HtmlSerializer\n      },\n      Env,\n      AddOnManager,\n      Annotator,\n      Formatter,\n      UndoManager,\n      EditorCommands,\n      WindowManager,\n      NotificationManager,\n      EditorObservable,\n      Shortcuts,\n      Editor,\n      FocusManager,\n      EditorManager,\n      DOM: DOMUtils.DOM,\n      ScriptLoader: ScriptLoader.ScriptLoader,\n      PluginManager,\n      ThemeManager,\n      ModelManager,\n      IconManager,\n      Resource,\n      FakeClipboard,\n      trim: Tools.trim,\n      isArray: Tools.isArray,\n      is: Tools.is,\n      toArray: Tools.toArray,\n      makeMap: Tools.makeMap,\n      each: Tools.each,\n      map: Tools.map,\n      grep: Tools.grep,\n      inArray: Tools.inArray,\n      extend: Tools.extend,\n      walk: Tools.walk,\n      resolve: Tools.resolve,\n      explode: Tools.explode,\n      _addCacheSuffix: Tools._addCacheSuffix\n    };\n    const tinymce = Tools.extend(EditorManager, publicApi);\n\n    const exportToModuleLoaders = tinymce => {\n      if (typeof module === 'object') {\n        try {\n          module.exports = tinymce;\n        } catch (_) {\n        }\n      }\n    };\n    const exportToWindowGlobal = tinymce => {\n      window.tinymce = tinymce;\n      window.tinyMCE = tinymce;\n    };\n    exportToWindowGlobal(tinymce);\n    exportToModuleLoaders(tinymce);\n\n})();\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}